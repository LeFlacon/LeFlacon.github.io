<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>1212 无向图最小生成树</title>
      <link href="/2018/08/21/1212%20%E6%97%A0%E5%90%91%E5%9B%BE%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2018/08/21/1212%20%E6%97%A0%E5%90%91%E5%9B%BE%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      <content type="html"><![CDATA[<h1 id="1212-无向图最小生成树"><a href="#1212-无向图最小生成树" class="headerlink" title="1212 无向图最小生成树"></a>1212 无向图最小生成树</h1><p>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 </p><p>N个点M条边的无向连通图，每条边有一个权值，求该图的最小生成树。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：2个数N,M中间用空格分隔，N为点的数量，M为边的数量。（2 &lt;= N &lt;= 1000, 1 &lt;= M &lt;= 50000)<br>第2 - M + 1行：每行3个数S E W，分别表示M条边的2个顶点及权值。(1 &lt;= S, E &lt;= N，1 &lt;= W &lt;= 10000)</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出最小生成树的所有边的权值之和。</p><h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">9 14</span><br><span class="line">1 2 4</span><br><span class="line">2 3 8</span><br><span class="line">3 4 7</span><br><span class="line">4 5 9</span><br><span class="line">5 6 10</span><br><span class="line">6 7 2</span><br><span class="line">7 8 1</span><br><span class="line">8 9 7</span><br><span class="line">2 8 11</span><br><span class="line">3 9 2</span><br><span class="line">7 9 6</span><br><span class="line">3 6 4</span><br><span class="line">4 6 14</span><br><span class="line">1 8 8</span><br></pre></td></tr></table></figure><p>Output示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">37</span><br></pre></td></tr></table></figure><hr><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>水一发最小生成树模版</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">const int N=1005;</span><br><span class="line">struct Edge&#123;</span><br><span class="line">int u,v;</span><br><span class="line">int cap;</span><br><span class="line">&#125;Edge[N*N];</span><br><span class="line">int n,ans,cnt;</span><br><span class="line">int fa[N];</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">if(x!=fa[x])fa[x]=find(fa[x]);</span><br><span class="line">return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">int a=find(x),b=find(y);</span><br><span class="line">if(a==b)return;</span><br><span class="line">else&#123;</span><br><span class="line">fa[a]=b;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">bool cmp(struct Edge a,struct Edge b)&#123;</span><br><span class="line">return a.cap&lt;b.cap;</span><br><span class="line">&#125;</span><br><span class="line">void kruskal()&#123;</span><br><span class="line">sort(Edge,Edge+cnt,cmp);</span><br><span class="line">for(int i=0;i&lt;cnt;i++)&#123;</span><br><span class="line">int fx=find(Edge[i].u),fy=find(Edge[i].v);</span><br><span class="line">if(fx==fy)continue;</span><br><span class="line">ans+=Edge[i].cap;</span><br><span class="line">join(fx,fy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int s,e,w;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;n,&amp;cnt);</span><br><span class="line">for(int i=1;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">for(int i=0;i&lt;cnt;i++)&#123;</span><br><span class="line">scanf(&quot;%d%d%d&quot;,&amp;s,&amp;e,&amp;w);</span><br><span class="line">Edge[i].u=s;</span><br><span class="line">Edge[i].v=e;</span><br><span class="line">Edge[i].cap=w;</span><br><span class="line">&#125;</span><br><span class="line">ans=0;</span><br><span class="line">kruskal();</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 51nod基础题 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>1242 斐波那契数列的第N项（矩阵快速幂）</title>
      <link href="/2018/08/21/1242%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9A%84%E7%AC%ACN%E9%A1%B9%EF%BC%88%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%89/"/>
      <url>/2018/08/21/1242%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9A%84%E7%AC%ACN%E9%A1%B9%EF%BC%88%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="1242-斐波那契数列的第N项（矩阵快速幂）"><a href="#1242-斐波那契数列的第N项（矩阵快速幂）" class="headerlink" title="1242 斐波那契数列的第N项（矩阵快速幂）"></a>1242 斐波那契数列的第N项（矩阵快速幂）</h2><p>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 </p><p>斐波那契数列的定义如下：</p><p>F(0) = 0<br>F(1) = 1<br>F(n) = F(n - 1) + F(n - 2) (n &gt;= 2)  </p><p>(1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, …)  </p><p>给出n，求F(n)，由于结果很大，输出F(n) % 1000000009的结果即可。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入1个数n(1 &lt;= n &lt;= 10^18)。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出F(n) % 1000000009的结果。</p><h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><p><code>11</code></p><h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><p><code>89</code></p><hr><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>矩阵快速幂</p><p>F(n) = F(n - 1) + F(n - 2)</p><p>递推式如下。。macdown打不出数学公式。。就这样吧。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">( F(n)  ) = ( 1 1 )*( F(n-1) )</span><br><span class="line">  F(n-1)      1 0     F(n-2)</span><br></pre></td></tr></table></figure><p>下面这种存矩阵的方法是在大牛博客看到的 先学为敬(=ﾟωﾟ)ﾉ</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">#define LL long long</span><br><span class="line">typedef vector&lt;LL&gt;row;</span><br><span class="line">typedef vector&lt;row&gt;mat;</span><br><span class="line">const LL p=1000000009;</span><br><span class="line">mat mul(mat a,mat b)&#123;</span><br><span class="line">mat c(a.size(),row(b[0].size()));//c的行数列数分别是a的行数，b的列数</span><br><span class="line">for(int i=0;i&lt;a.size();i++)&#123;</span><br><span class="line">for(int j=0;j&lt;b.size();j++)&#123;</span><br><span class="line">for(int k=0;k&lt;b[0].size();k++)</span><br><span class="line">c[i][j]=(c[i][j]+a[i][k]*b[k][j])%p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return c;</span><br><span class="line">&#125;</span><br><span class="line">mat qpow(mat a,LL x)&#123;</span><br><span class="line">mat b(a.size(),row(a.size()));</span><br><span class="line">for(int i=0;i&lt;a.size();i++)b[i][i]=1;</span><br><span class="line">while(x&gt;0)&#123;</span><br><span class="line">if(x&amp;1)b=mul(b,a);</span><br><span class="line">a=mul(a,a);</span><br><span class="line">x&gt;&gt;=1;</span><br><span class="line">&#125;</span><br><span class="line">return b;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">    mat a(2,row(2));</span><br><span class="line">    a[0][0]=1;a[0][1]=1;a[1][0]=1;a[1][1]=0;</span><br><span class="line">    a=qpow(a,n);</span><br><span class="line">    printf(&quot;%lld\n&quot;,a[1][0]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 51nod基础题 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>cf 487 C. A Mist of Florescence（构造）</title>
      <link href="/2018/08/20/cf%20#487%20C.%20A%20Mist%20of%20Florescence%EF%BC%88%E6%9E%84%E9%80%A0%EF%BC%89/"/>
      <url>/2018/08/20/cf%20#487%20C.%20A%20Mist%20of%20Florescence%EF%BC%88%E6%9E%84%E9%80%A0%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="cf-487-C-A-Mist-of-Florescence（构造）"><a href="#cf-487-C-A-Mist-of-Florescence（构造）" class="headerlink" title="cf 487 C. A Mist of Florescence（构造）"></a>cf 487 C. A Mist of Florescence（构造）</h1><p><a href="http://codeforces.com/contest/989/problem/C" target="_blank" rel="noopener">http://codeforces.com/contest/989/problem/C</a></p><p>As the boat drifts down the river, a wood full of blossoms shows up on the riverfront.<br>“I’ve been here once,” Mino exclaims with delight, “it’s breathtakingly amazing.”</p><p>“What is it like?”</p><p>“Look, Kanno, you’ve got your paintbrush, and I’ve got my words. Have a try, shall we?”</p><p>There are four kinds of flowers in the wood, Amaranths, Begonias, Centaureas and Dianthuses.</p><p>The wood can be represented by a rectangular grid of<br>n<br> rows and<br>m<br> columns. In each cell of the grid, there is exactly one type of flowers.</p><p>According to Mino, the numbers of connected components formed by each kind of flowers are<br>a<br>,<br>b<br>,<br>c<br> and<br>d<br> respectively. Two cells are considered in the same connected component if and only if a path exists between them that moves between cells sharing common edges and passes only through cells containing the same flowers.</p><p>You are to help Kanno depict such a grid of flowers, with<br>n<br> and<br>m<br> arbitrarily chosen under the constraints given below. It can be shown that at least one solution exists under the constraints of this problem.</p><p>Note that you can choose arbitrary<br>n<br> and<br>m<br> under the constraints below, they are not given in the input.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first and only line of input contains four space-separated integers<br>a<br>,<br>b<br>,<br>c<br> and<br>d<br> (<br>1<br>≤<br>a<br>,<br>b<br>,<br>c<br>,<br>d<br>≤<br>100<br>) — the required number of connected components of Amaranths, Begonias, Centaureas and Dianthuses, respectively.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>In the first line, output two space-separated integers<br>n<br> and<br>m<br> (<br>1<br>≤<br>n<br>,<br>m<br>≤<br>50<br>) — the number of rows and the number of columns in the grid respectively.</p><p>Then output<br>n<br> lines each consisting of<br>m<br> consecutive English letters, representing one row of the grid. Each letter should be among ‘A’, ‘B’, ‘C’ and ‘D’, representing Amaranths, Begonias, Centaureas and Dianthuses, respectively.</p><p>In case there are multiple solutions, print any. You can output each letter in either case (upper or lower).</p><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><p>input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 3 2 1</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 7</span><br><span class="line">DDDDDDD</span><br><span class="line">DABACAD</span><br><span class="line">DBABACD</span><br><span class="line">DDDDDDD</span><br></pre></td></tr></table></figure><p>input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">50 50 1 1</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 50</span><br><span class="line">CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC</span><br><span class="line">ABABABABABABABABABABABABABABABABABABABABABABABABAB</span><br><span class="line">BABABABABABABABABABABABABABABABABABABABABABABABABA</span><br><span class="line">DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD</span><br></pre></td></tr></table></figure><p>input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 6 4 5</span><br></pre></td></tr></table></figure><p>outputCopy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7 7</span><br><span class="line">DDDDDDD</span><br><span class="line">DDDBDBD</span><br><span class="line">DDCDCDD</span><br><span class="line">DBDADBD</span><br><span class="line">DDCDCDD</span><br><span class="line">DBDBDDD</span><br><span class="line">DDDDDDD</span><br></pre></td></tr></table></figure><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>In the first example, each cell of Amaranths, Begonias and Centaureas forms a connected component, while all the Dianthuses form one.<br><img src="http://codeforces.com/predownloaded/ba/48/ba48b131922fa242edffd37b1eb411f72779e8e3.png" alt=""></p><hr><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>四个类，abcd为每个类的连通块数</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>50*50，分成4块，每块分别先填满abcd，然后每个都减一，然后在a里跳着放b单格，b里放a，c里放d，d里放c，注意一下边界判断就行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">char s[55][55];</span><br><span class="line">int a,b,c,d,h,l;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">for(int i=1;i&lt;=25;i++)&#123;</span><br><span class="line">for(int j=1;j&lt;=25;j++)&#123;</span><br><span class="line">s[i][j]=&apos;A&apos;;</span><br><span class="line">s[i][j+25]=&apos;B&apos;;</span><br><span class="line">s[i+25][j]=&apos;C&apos;;</span><br><span class="line">s[i+25][j+25]=&apos;D&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a--;b--;c--;d--;</span><br><span class="line">h=2;l=27;</span><br><span class="line">while(a--)&#123;</span><br><span class="line">if(l&gt;50)h+=2,l=27;</span><br><span class="line">s[h][l]=&apos;A&apos;;</span><br><span class="line">l+=2;</span><br><span class="line">&#125; </span><br><span class="line">h=2;l=2;</span><br><span class="line">while(b--)&#123;</span><br><span class="line">if(l&gt;25)h+=2,l=2;</span><br><span class="line">s[h][l]=&apos;B&apos;;</span><br><span class="line">l+=2;</span><br><span class="line">&#125;</span><br><span class="line">h=27;l=27;</span><br><span class="line">while(c--)&#123;</span><br><span class="line">if(l&gt;50)h+=2,l=27;</span><br><span class="line">s[h][l]=&apos;C&apos;;</span><br><span class="line">l+=2;</span><br><span class="line">&#125;</span><br><span class="line">h=27;l=2;</span><br><span class="line">while(d--)&#123;</span><br><span class="line">if(l&gt;25)h+=2,l=2;</span><br><span class="line">s[h][l]=&apos;D&apos;;</span><br><span class="line">l+=2;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;&quot;50 50&quot;&lt;&lt;endl;</span><br><span class="line">for(int i=1;i&lt;=50;i++)&#123;</span><br><span class="line">for(int j=1;j&lt;=50;j++)cout&lt;&lt;s[i][j]; </span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 杂 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>麻婆豆腐（思维）</title>
      <link href="/2018/08/20/%E9%BA%BB%E5%A9%86%E8%B1%86%E8%85%90%EF%BC%88%E6%80%9D%E7%BB%B4%EF%BC%89/"/>
      <url>/2018/08/20/%E9%BA%BB%E5%A9%86%E8%B1%86%E8%85%90%EF%BC%88%E6%80%9D%E7%BB%B4%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="麻婆豆腐（思维）"><a href="#麻婆豆腐（思维）" class="headerlink" title="麻婆豆腐（思维）"></a>麻婆豆腐（思维）</h1><p><a href="https://www.nowcoder.com/acm/contest/128/B" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/128/B</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一次课间休息的时候,音无结弦看到立华奏一个人坐在座位上写作业,于是动了请她吃麻婆豆腐的念头。他迅速移动到她后面的座位,寻思着该怎么开口邀请,他摸了摸口袋,拍了拍脑袋,有了!<br>“奏~听说食堂里有种传闻中因为辣过头所以谁都不会点的麻婆豆腐,但是却惊人地好吃啊,这样,我们来做个题吧!如果你做出来了我就天天请你吃麻婆豆腐╰(￣▽￣)╮”<br>奏的笔停下了,她转过头来,还带了一张草稿纸,做好了做题的准备。音无懵了一下,心中暗暗窃喜,“麻婆豆腐果然是她的最爱啊!”<br>“咳咳…请听题!我手上有n枚硬币,第i枚正面朝上的概率是Pi。我现在每个硬币各抛一次,正面朝上看做1,背面朝上看做0,把所有硬币得到的数异或起来决定最后得到的数。问:有多少个子集合使得0和1的概率相等?”<br>不管音无给了怎样的数,奏都是一分钟不到就算出来了!不愧是前学生会长啊~<br>于是他们就去食堂吃麻婆豆腐了,现在,你也来算一下吧。  </p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><p>输入的第一行包含一个整数T，表示测试组数。<br>每个测试用例前面都有一个空白行。<br>每个测试用例由两行组成。<br>第一行包含硬币数量n。<br>第二行包含n个数表示：概率p1,…,pn。每个pi都给出6个小数位。</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><p>对于每个测试用例输出一个数：使得0和1的概率相等的子集合数量。</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2 </span><br><span class="line"></span><br><span class="line">3 </span><br><span class="line">0.500000  0.500000  0.500000 </span><br><span class="line"></span><br><span class="line">4 </span><br><span class="line">0.000001  0.000002  0.000003  0.000004</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>说明<br>在第一个测试样例中，每个子集显然都能使得0和1的概率相等。<br>在第二个测试样例中，所有子集都不能使得0和1的概率相等<br>备注:<br>n ≤ 60,T=500</p><hr><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>n枚硬币,第i枚正面朝上的概率是Pi。每个硬币各抛一次,正面朝上看做1,背面朝上看做0,把所有硬币得到的数异或起来决定最后得到的数。  求有多少个子集合使得0和1的概率相等?</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>答案为<code>2^n-2^(n-cnt)</code><br>其中cnt是pi中0.5的个数</p><p>因为只有pi=0.5，异或后的概率才可能相等，别的数都不行，证明如下：</p><p>设当前集合有m个元素，第一个元素为1的概率x，剩下m-1个元素异或和为1的概率为p，那么这个集合最后异或和为1的概率为<code>p*(1-x)+x*(1-p)=0.5</code>,解得x=0.5</p><p>注意1要写1LL，不然会WA</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">double c;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    int cnt=0;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">    scanf(&quot;%lf&quot;,&amp;c);</span><br><span class="line">    if(c==0.5)cnt++;</span><br><span class="line">&#125;</span><br><span class="line">LL ans=(1LL&lt;&lt;n)-(1LL&lt;&lt;(n-cnt));</span><br><span class="line">printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 杂 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Alice和Bob的Nim游戏（博弈，数列，矩阵快速幂）</title>
      <link href="/2018/08/20/Alice%E5%92%8CBob%E7%9A%84Nim%E6%B8%B8%E6%88%8F%EF%BC%88%E5%8D%9A%E5%BC%88%EF%BC%8C%E6%95%B0%E5%88%97%EF%BC%8C%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%89/"/>
      <url>/2018/08/20/Alice%E5%92%8CBob%E7%9A%84Nim%E6%B8%B8%E6%88%8F%EF%BC%88%E5%8D%9A%E5%BC%88%EF%BC%8C%E6%95%B0%E5%88%97%EF%BC%8C%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>Alice和Bob的Nim游戏（博弈，数列，矩阵快速幂）<br><a href="https://nanti.jisuanke.com/t/28447" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/28447</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>众所周知，Alice和Bob非常喜欢博弈，而且Alice永远是先手，Bob永远是后手。</p><p>Alice和Bob面前有3堆石子，Alice和Bob每次轮流拿某堆石子中的若干个石子（不可以是0个），拿到所有石子中最后一个石子的人获胜。这是一个只有3堆石子的Nim游戏。</p><p>Bob错误的认为，三堆石子的Nim游戏只需要少的两堆的石子数量加起来等于多的那一堆，后手就一定会胜利。所以，Bob把三堆石子的数量分别设为 {k，4k，5k}（k&gt;0）。</p><p>现在Alice想要知道，在k 小于 2^n 的时候，有多少种情况先手一定会获得胜利。</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>一个整数n(1≤n≤2×10^9)。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出先手胜利的可能情形数。答案对10^9+7取模。</p><p>输出时每行末尾的多余空格，不影响答案正确性</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p><a href="https://nanti.jisuanke.com/?kw=ACM%E8%AE%AD%E7%BB%83%E8%81%94%E7%9B%9F%E5%91%A8%E8%B5%9B" target="_blank" rel="noopener">ACM训练联盟周赛</a></p><hr><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>就是普通尼姆博弈，只要把k，4k，5k异或一下，为0先手就必胜，这题难在k可以是个巨无敌大的数，只好找规律了</p><p>先打个表</p><p>2，4，6，9，15，25，40，64，104，169…</p><p>本来发现的规律是后一个数是前两个数相加，然后前两个数相加减一，前两个数相加，前两个数相加加一，前两个数相加…以此类推，但是没搞出什么名堂来</p><p>然后当时看了这篇知道了这个数列和斐波那契有点关系<br><a href="https://zhidao.baidu.com/question/489289663.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/489289663.html</a></p><p>四个一组，推出了四个公式，其中用到的斐波那契数列用矩阵快速幂（网上找的模版。。）处理一下，公式具体见代码</p><p>最后那个四个乘以qpow(5,p-2,p)，本来公式是除以5的，但是因为除法对求余不分配就WA了，所以费马小定理一下，乘以5的逆元</p><p>最后官方题解里是这么写的：f(n) = f(n-1) + f(n-3) + f(n-4) + 2，也是矩阵快速幂处理一下</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">#define LL long long</span><br><span class="line">const int N=20000000;</span><br><span class="line">const LL p=1000000000+7;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct matrix &#123;</span><br><span class="line">LL m[2][2];</span><br><span class="line">&#125;ans;</span><br><span class="line">matrix base = &#123;1, 1, 1, 0&#125;; </span><br><span class="line">matrix multi(matrix a, matrix b) &#123;</span><br><span class="line">matrix tmp;</span><br><span class="line">for(int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">for(int j = 0; j &lt; 2; j++) &#123;</span><br><span class="line">tmp.m[i][j] = 0;</span><br><span class="line">for(int k = 0;  k &lt; 2; k++)</span><br><span class="line">tmp.m[i][j] = (tmp.m[i][j] + a.m[i][k] * b.m[k][j]) % p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return tmp;</span><br><span class="line">&#125;</span><br><span class="line">LL matrix_pow(matrix a, int n) &#123;</span><br><span class="line">ans.m[0][0] = ans.m[1][1] = 1;</span><br><span class="line">ans.m[0][1] = ans.m[1][0] = 0;</span><br><span class="line">while(n) &#123;</span><br><span class="line">if(n &amp; 1) ans = multi(ans, a);</span><br><span class="line">a = multi(a, a);</span><br><span class="line">n &gt;&gt;= 1;</span><br><span class="line">&#125;</span><br><span class="line">return ans.m[0][1];</span><br><span class="line">&#125;</span><br><span class="line">LL fi(LL x) &#123;</span><br><span class="line">return matrix_pow(base, x);</span><br><span class="line">&#125; </span><br><span class="line">LL qpow(LL a,LL b,LL p)&#123;</span><br><span class="line">    LL anss=1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            anss=(anss*a)%p;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        b/=2;</span><br><span class="line">        a=a*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return anss;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    LL n,res=0;</span><br><span class="line">    LL z;</span><br><span class="line">    while(cin&gt;&gt;n)&#123;</span><br><span class="line">    if(n==1||n==2)&#123;</span><br><span class="line">    cout&lt;&lt;0&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">else if(n==3)&#123;</span><br><span class="line">cout&lt;&lt;2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">else if(n==4)&#123;</span><br><span class="line">cout&lt;&lt;7&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">LL nn=n;</span><br><span class="line">n+=2;</span><br><span class="line">if(n%4==0)&#123;</span><br><span class="line">z=((4*fi(n)+3*fi(n-1)+2)*qpow(5,p-2,p))%p;</span><br><span class="line">&#125;</span><br><span class="line">else if(n%4==1)&#123;</span><br><span class="line">z=((3*fi(n+1)+fi(n)+1)*qpow(5,p-2,p))%p;</span><br><span class="line">&#125;</span><br><span class="line">else if(n%4==2)&#123;</span><br><span class="line">z=((4*fi(n)+3*fi(n-1)-2)*qpow(5,p-2,p))%p;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">z=((3*fi(n+1)+fi(n)-1)*qpow(5,p-2,p))%p;</span><br><span class="line">&#125;</span><br><span class="line">res=(qpow(2,nn,p)-z%p+p)%p;</span><br><span class="line">cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 博弈论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Pawns（博弈，思维）</title>
      <link href="/2018/08/20/Pawns%EF%BC%88%E5%8D%9A%E5%BC%88%EF%BC%8C%E6%80%9D%E7%BB%B4%EF%BC%89/"/>
      <url>/2018/08/20/Pawns%EF%BC%88%E5%8D%9A%E5%BC%88%EF%BC%8C%E6%80%9D%E7%BB%B4%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="Pawns（博弈，思维）"><a href="#Pawns（博弈，思维）" class="headerlink" title="Pawns（博弈，思维）"></a>Pawns（博弈，思维）</h1><p><a href="https://nanti.jisuanke.com/t/28205" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/28205</a></p><p>Carl and Nathan are completely bored with the game of chess; it’s too easy! They have come up with their own game, which is surely a greater test of one’s intelligence.This game is played on a board with n by m squares. At the start, white and black pawns are placed quasi-randomly over the board, with the following constraint: in every column there is one white pawn and one black pawn, with the white pawn on some square below the black one.</p><p>Each player in turn makes a move with one of his pawns. A pawn is only allowed to move one square forward, provided that this square is empty. “Forward” means in the direction of the opponent, so white pawns move up and black pawns move down. In addition, a pawn on the first rank – that is, a white pawn on the bottom row, or a black pawn on the top row – may also move two squares forward, provided that both squares are empty. Unlike normal chess, the pawns are never taken from the board and never change column.</p><p><img src="https://res.jisuanke.com/img/upload/20180703/f32e80b481a421fcf94d5ed040138bbc778728d7.png" alt=""></p><p>For example, in the position above, White (the player using the white pieces) has eight moves: one with each of the pawns on b1, d2, f5 and h2, and two with both the pawn on c1 and the pawn on g1. The pawns on a6 and e1 cannot move.</p><p>Eventually and inevitably, the pawns will meet up in every column, leaving neither player able to move. The game is then finished, and the winner is the player who made the last move.</p><p>As usual, White gets the first move. With optimal play, who would win for a given startingposition?</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>On the first line one positive number: the number of test cases, at most 100. After that per test case:</p><p>one line with two space-separated integers n and m (3≤n≤20 and 1≤m≤20):the number of rows and columns of the board, respectively.<br>n lines with m characters, describing the position on the board at the start of the game:<br>‘W’ is a white pawn.<br>‘B’ is a black pawn.<br>‘.’ is an empty square.Each column contains exactly one ‘W’ and one ‘B’, with the ‘W’ being below the ‘B’.<br>In every test case, the starting position will be such that White has at least one move.  </p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>Per test case:</p><p>one line with the string “White wins” if White can win with optimal play, or “Black wins” if Black has a winning strategy.</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">8 8</span><br><span class="line">.....BB.</span><br><span class="line">B.......</span><br><span class="line">W......B</span><br><span class="line">...B.W..</span><br><span class="line">..B.....</span><br><span class="line">.B......</span><br><span class="line">...WB..W</span><br><span class="line">.WW.W.W.</span><br><span class="line">6 4</span><br><span class="line">....</span><br><span class="line">B..B</span><br><span class="line">....</span><br><span class="line">.B.W</span><br><span class="line">W.B.</span><br><span class="line">.WW.</span><br><span class="line">5 3</span><br><span class="line">...</span><br><span class="line">BBB</span><br><span class="line">...</span><br><span class="line">WW.</span><br><span class="line">..W</span><br><span class="line">4 6</span><br><span class="line">.BBB.B</span><br><span class="line">B...B.</span><br><span class="line">...W..</span><br><span class="line">WWW.WW</span><br><span class="line">7 7</span><br><span class="line">.B.B..B</span><br><span class="line">.......</span><br><span class="line">..B.B..</span><br><span class="line">B....B.</span><br><span class="line">.......</span><br><span class="line">...WW.W</span><br><span class="line">WWW..W.</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Black wins</span><br><span class="line">Black wins</span><br><span class="line">White wins</span><br><span class="line">White wins</span><br><span class="line">Black wins</span><br></pre></td></tr></table></figure><h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p>BAPC 2014 Preliminary</p><hr><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>两个人轮流下棋，给定一个棋局，B在W上，白色的棋子W向上移动，黑色的棋子B向下移动，每次可移动一格。底行上的W棋子或顶行上的B棋子可以向前移动两个方格，前提是两个方格都是空的。W先手，无法移动的一方输。</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>首先想到胜负和W，B之间可走步数的奇偶性有关，然后顶行和底行且可以走两步的棋子有改变奇偶性的能力。</p><p>先考虑一种特殊情况，某一列中B在顶行且W在底行，这对两个棋子来说是一样的，这种出现次数记为cd。</p><blockquote><p>1.n&gt;5时，只要一方走两步改变了奇偶性，另一方可以学对方的走法，把奇偶性变回来，所以后续不用考虑这几列的步数。</p><p>2.n=3时不会出现这种情况，不考虑。</p><p>3.特殊情况n=4和n=5，因为他们一方走两步之后，另一方就没有走两步的能力了，是要考虑的，在后面讨论。</p></blockquote><p>然后只有一方的棋子在顶行或者底行且该棋子可以走两步时：只要一方有改变奇偶性能力的棋子，另一方就会想要去优先破坏这种能力，比如：</p><p>B<br>。<br>。<code>W优先向上走三步，则B就没有破坏奇偶性的能力了，则cw+=3</code><br>。<br>。<br>W  </p><blockquote><p>cw为W破坏B的能力棋子所需要走的步数<br>cb为B破坏W的能力棋子所需要走的步数</p></blockquote><p>最后，对于那些没有棋子有机会走两步的列来说，双方都只能一步一步走，只要把可走步数累加即可。</p><p>综上所述，W的必胜情况：</p><blockquote><p>1.n=4，且cd为奇数</p><p>这种情况下，cd为奇数，W作为先手无论如何都掌握最后一个改变奇偶的决定权，所以w只要在最后一个机会时判断当前局势决定是否改变奇偶性即可。</p><p>2.cw &lt; cb</p><p>即B破坏W能力要走的步数多，那么W就有改变奇偶能力，W必胜。</p><p>3.cb = cw - 1或cb = cw且步数为奇<br>（这里的bushu指B在顶行且W在底行的情况不算的总步数）</p><p>cb = cw - 1时，因为W先走，下完（cb+cw）步之后，此时两人都刚好没有破坏奇偶性的能力，（cb+cw）为奇数，下一步轮到B下，剩余步数为（部分步数-cb-cw）为偶数，所以W必胜。<br>cb = cw时，同上，（cb+cw）为偶，下一步轮到W，剩余步数为奇，W必胜。</p></blockquote><p>最后考虑n=5的时候的特殊情况<br>比赛的时候这个情况我一直没想想清楚。。随便举个例子：</p><p>B 。。。B<br>。B 。。。<br>。。B 。。<br>。。。B 。<br>WWWWW</p><p>对于第一，五列那种双方都有能力的棋子来说，不管先手走一步还是两步，后手都可以走（3-i）步使这一列一人走一次然后作废，所以n=5时这种列也不考虑。<br>对于第二列，B要优先破坏W的能力。<br>对于第三，四列，只要数可走步数即可。  </p><p>因为剩下的策略都满足上面的n&gt;5时，所以n=5虽然有特殊，但是并不用考虑特殊策略。</p><hr><pre><code>#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;set&gt;using namespace std;const int N=40;char p[N][N];int main(){    int t,num=0;    scanf(&quot;%d&quot;, &amp;t);    while(t--){        int n,m;        int cw=0,cb=0,cd=0,bushu=0;        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        memset(p,0,sizeof(p));        for(int i=1;i&lt;=n;i++){            for(int j=1;j&lt;=m;j++){                cin&gt;&gt;p[i][j];            }        }        for(int i=1;i&lt;=m;i++){            int b,w;            for(int j=1;j&lt;=n;j++){                if(p[j][i]==&apos;B&apos;)b=j;                else if(p[j][i]==&apos;W&apos;)w=j;            }            if(b==1&amp;&amp;w==n&amp;&amp;n&gt;3)cd++;            else{                if(b==1&amp;&amp;w&gt;3)cw+=w-3;                else if(w==n&amp;&amp;b&lt;n-2)cb+=n-2-b;                bushu+=(w-b-1);            }         }        if((n==4&amp;&amp;cd%2==1)||(cw&lt;cb)||(((cb==cw-1)||(cb==cw))&amp;&amp;bushu%2==1))printf(&quot;White wins\n&quot;);        else printf(&quot;Black wins\n&quot;);    }    return 0;}</code></pre>]]></content>
      
      <categories>
          
          <category> 博弈论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hdu 1847 Good Luck in CET-4 Everybody!（巴什博弈）</title>
      <link href="/2018/08/20/hdu%201847%20Good%20Luck%20in%20CET-4%20Everybody!%EF%BC%88%E5%B7%B4%E4%BB%80%E5%8D%9A%E5%BC%88%EF%BC%89/"/>
      <url>/2018/08/20/hdu%201847%20Good%20Luck%20in%20CET-4%20Everybody!%EF%BC%88%E5%B7%B4%E4%BB%80%E5%8D%9A%E5%BC%88%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="hdu-1847-Good-Luck-in-CET-4-Everybody-（巴什博弈）"><a href="#hdu-1847-Good-Luck-in-CET-4-Everybody-（巴什博弈）" class="headerlink" title="hdu 1847 Good Luck in CET-4 Everybody!（巴什博弈）"></a>hdu 1847 Good Luck in CET-4 Everybody!（巴什博弈）</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1847" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1847</a></p><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>大学英语四级考试就要来临了，你是不是在紧张的复习？也许紧张得连短学期的ACM都没工夫练习了，反正我知道的Kiki和Cici都是如此。当然，作为在考场浸润了十几载的当代大学生，Kiki和Cici更懂得考前的放松，所谓“张弛有道”就是这个意思。这不，Kiki和Cici在每天晚上休息之前都要玩一会儿扑克牌以放松神经。</p><p>“升级”？“双扣”？“红五”？还是“斗地主”？</p><p>当然都不是！那多俗啊~</p><p>作为计算机学院的学生，Kiki和Cici打牌的时候可没忘记专业，她们打牌的规则是这样的：</p><p>1、  总共n张牌;<br>2、  双方轮流抓牌；<br>3、  每人每次抓牌的个数只能是2的幂次（即：1，2，4，8，16…）<br>4、  抓完牌，胜负结果也出来了：最后抓完牌的人为胜者；  </p><p>假设Kiki和Cici都是足够聪明（其实不用假设，哪有不聪明的学生~），并且每次都是Kiki先抓牌，请问谁能赢呢？</p><p>当然，打牌无论谁赢都问题不大，重要的是马上到来的CET-4能有好的状态。</p><p>Good luck in CET-4 everybody!</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入数据包含多个测试用例，每个测试用例占一行，包含一个整数n（1&lt;=n&lt;=1000）。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>如果Kiki能赢的话，请输出“Kiki”，否则请输出“Cici”，每个实例的输出占一行。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Kiki</span><br><span class="line">Cici</span><br></pre></td></tr></table></figure><hr><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>n张牌，每次可以取<code>2^i</code>张,最后取完的人胜</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>因为可以取到1，2，所以剩下取几都不重要了，因为所有数要么是三的倍数，要么是三的倍数多一，要么是三的倍数多二，又因为除了1，2剩下的数都是大于3的偶数，所以不管对手怎么取都无力回天了，不可能再把三的倍数抛给你 _ (: з 」∠) _</p><p>所以对手取完，只要你能一直留给他三的倍数，你就赢</p><p>综上所述，一开始是三的倍数的人必败</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    while(cin&gt;&gt;n)&#123;</span><br><span class="line">    if(n%3==0)cout&lt;&lt;&quot;Cici&quot;&lt;&lt;endl;</span><br><span class="line">else cout&lt;&lt;&quot;Kiki&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 博弈论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hdu 1404 Digital Deletions（sg函数暴力打表）</title>
      <link href="/2018/08/20/hdu%201404%20Digital%20Deletions%EF%BC%88sg%E5%87%BD%E6%95%B0%E6%9A%B4%E5%8A%9B%E6%89%93%E8%A1%A8%EF%BC%89/"/>
      <url>/2018/08/20/hdu%201404%20Digital%20Deletions%EF%BC%88sg%E5%87%BD%E6%95%B0%E6%9A%B4%E5%8A%9B%E6%89%93%E8%A1%A8%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="hdu-1404-Digital-Deletions（sg函数暴力打表）"><a href="#hdu-1404-Digital-Deletions（sg函数暴力打表）" class="headerlink" title="hdu 1404 Digital Deletions（sg函数暴力打表）"></a>hdu 1404 Digital Deletions（sg函数暴力打表）</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1404" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1404</a></p><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Digital deletions is a two-player game. The rule of the game is as following. </p><p>Begin by writing down a string of digits (numbers) that’s as long or as short as you like. The digits can be 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 and appear in any combinations that you like. You don’t have to use them all. Here is an example:</p><p><img src="http://acm.hdu.edu.cn/data/images/1404-1.gif" alt=""></p><p>On a turn a player may either:<br>Change any one of the digits to a value less than the number that it is. (No negative numbers are allowed.) For example, you could change a 5 into a 4, 3, 2, 1, or 0.<br>Erase a zero and all the digits to the right of it.</p><p>The player who removes the last digit wins.</p><p>The game that begins with the string of numbers above could proceed like this: </p><p><img src="http://acm.hdu.edu.cn/data/images/1404-2.gif" alt=""></p><p>Now, given a initial string, try to determine can the first player win if the two players play optimally both. </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input consists of several test cases. For each case, there is a string in one line.</p><p>The length of string will be in the range of [1,6]. The string contains only digit characters.</p><p>Proceed to the end of file.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Output Yes in a line if the first player can win the game, otherwise output No.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">00</span><br><span class="line">1</span><br><span class="line">20</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure><hr><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给一个长度在[1,6]的数字字符串</p><p>有两种操作：</p><p>1.把任何一个数字更改为小于其数字的值</p><p>2.删除0及其右侧的数字</p><p>删除最后一位的赢，问先手有无必胜策略</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>首先这个最多只有6位，有很多很多状态，所以是个sg函数的题，从最小的已知态往上推，根据sg函数的性质，能一步到达必败状态的都是必胜点，由此求得所有六位数状态的值</p><p>分析一下可以sg[1]是必败点，sg[1]=0,那么就从1开始向上拓展必胜态，具体操作见代码</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1000000;</span><br><span class="line">int sg[N];</span><br><span class="line">int wei(int n)&#123;</span><br><span class="line">if(n/100000)return 6;</span><br><span class="line">if(n/10000)return 5;</span><br><span class="line">if(n/1000)return 4;</span><br><span class="line">if(n/100)return 3;</span><br><span class="line">if(n/10)return 2;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">void extend(int n)&#123;</span><br><span class="line">//sg[n]=0先手必败，可以一步变为n的都是先手必胜</span><br><span class="line">int len=wei(n);</span><br><span class="line">for(int i=len;i&gt;0;i--)&#123;//每一位上加一个数</span><br><span class="line">int m=n;</span><br><span class="line">int base=1;</span><br><span class="line">for(int j=1;j&lt;i;j++)base*=10;</span><br><span class="line">int tmp=(m%(base*10))/base;</span><br><span class="line">for(int j=tmp;j&lt;9;j++)&#123;</span><br><span class="line">m+=base;</span><br><span class="line">sg[m]=1;</span><br><span class="line">&#125;</span><br><span class="line">if(len&lt;6)&#123;//长度小于6，可以在后面补0</span><br><span class="line">int m=n;</span><br><span class="line">int base=1;</span><br><span class="line">for(int i=len;i&lt;6;i++)&#123;</span><br><span class="line">m*=10;</span><br><span class="line">for(int b=0;b&lt;base;b++)sg[m+b]=1;</span><br><span class="line">base*=10;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">void work()&#123;</span><br><span class="line">memset(sg,0,sizeof(sg));</span><br><span class="line">sg[0]=1;</span><br><span class="line">for(int i=1;i&lt;N;i++)&#123;</span><br><span class="line">if(!sg[i])extend(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">char str[8];</span><br><span class="line">int n;</span><br><span class="line">work();</span><br><span class="line">while(scanf(&quot;%s&quot;,str)!=EOF)&#123;</span><br><span class="line">if(str[0]==&apos;0&apos;)&#123;</span><br><span class="line">printf(&quot;Yes\n&quot;);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">int len=strlen(str);</span><br><span class="line">n=0;</span><br><span class="line">for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">n*=10;</span><br><span class="line">n+=str[i]-&apos;0&apos;;</span><br><span class="line">&#125;</span><br><span class="line">if(sg[n])printf(&quot;Yes\n&quot;);</span><br><span class="line">else printf(&quot;No\n&quot;); </span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 博弈论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hdu 1527 取石子游戏（威佐夫博弈）</title>
      <link href="/2018/08/20/hdu%201527%20%E5%8F%96%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F%EF%BC%88%E5%A8%81%E4%BD%90%E5%A4%AB%E5%8D%9A%E5%BC%88%EF%BC%89/"/>
      <url>/2018/08/20/hdu%201527%20%E5%8F%96%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F%EF%BC%88%E5%A8%81%E4%BD%90%E5%A4%AB%E5%8D%9A%E5%BC%88%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="hdu-1527-取石子游戏（威佐夫博弈）"><a href="#hdu-1527-取石子游戏（威佐夫博弈）" class="headerlink" title="hdu 1527 取石子游戏（威佐夫博弈）"></a>hdu 1527 取石子游戏（威佐夫博弈）</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1527" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1527</a></p><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入包含若干行，表示若干种石子的初始情况，其中每一行包含两个非负整数a和b，表示两堆石子的数目，a和b都不大于1,000,000,000。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出对应也有若干行，每行包含一个数字1或0，如果最后你是胜者，则为1，反之，则为0。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">8 4</span><br><span class="line">4 7</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><hr><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>威佐夫博弈裸题，在hdu 2177那篇有介绍威佐夫博弈</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int a,b;</span><br><span class="line">while(scanf(&quot;%d%d&quot;,&amp;a,&amp;b)!=EOF)&#123;</span><br><span class="line">if(a&gt;b)&#123;</span><br><span class="line">int temp=a;a=b;b=temp;</span><br><span class="line">&#125;</span><br><span class="line">if((int)((sqrt(5)+1)*(b-a)/2)==a)printf(&quot;0\n&quot;);</span><br><span class="line">else printf(&quot;1\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 博弈论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hdu 1564 Play a game</title>
      <link href="/2018/08/20/hdu%201564%20Play%20a%20game/"/>
      <url>/2018/08/20/hdu%201564%20Play%20a%20game/</url>
      <content type="html"><![CDATA[<h1 id="hdu-1564-Play-a-game"><a href="#hdu-1564-Play-a-game" class="headerlink" title="hdu 1564 Play a game"></a>hdu 1564 Play a game</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1564" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1564</a></p><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>New Year is Coming!<br>ailyanlu is very happy today! and he is playing a chessboard game with 8600.<br>The size of the chessboard is n*n. A stone is placed in a corner square. They play alternatively with 8600 having the first move. Each time, player is allowed to move the stone to an unvisited neighbor square horizontally or vertically. The one who can’t make a move will lose the game. If both play perfectly, who will win the game?</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input is a sequence of positive integers each in a separate line.<br>The integers are between 1 and 10000, inclusive,(means 1 &lt;= n &lt;= 10000) indicating the size of the chessboard. The end of the input is indicated by a zero.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Output the winner (“8600” or “ailyanlu”) for each input line except the last zero.<br>No other characters should be inserted in the output.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8600</span><br></pre></td></tr></table></figure><hr><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给一个<code>n*n</code>的网格，一个石头从角落出发，每次水平或垂直移动到相邻的没有访问过的格子上，谁不能走谁输</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>蛮水的题。。</p><p>n=1先手必败，n=2先手必胜，n=3先手必败，n=4先手必胜…</p><p>这些自己模拟一下大概就能发现规律了：n为奇数时后手胜，n为偶数先手胜</p><p>当然这也是可以解释的，就是把棋盘分成一个个<code>1*2</code>的部分，无论先手后手只要跟着对方走把对方那个补上完成一个个<code>1*2</code>，最后就赢了，所以就是看剩下的<code>n*n-1</code>个格子能否恰好凑成一些<code>1*2</code>的小块，<code>n*n-1</code>为偶数就可以，那么后手必胜，如果<code>n*n-1</code>为奇数，多了一个，那么先手必胜</p><p>判断 <code>n*n-1</code> 的奇偶性，其实也是 <code>n</code>的奇偶性</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int n;</span><br><span class="line">while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)&#123;</span><br><span class="line">if(n&amp;1)printf(&quot;ailyanlu\n&quot;);</span><br><span class="line">else printf(&quot;8600\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 博弈论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hdu 1729 Stone Game（尼姆博弈，sg函数）</title>
      <link href="/2018/08/20/hdu%201729%20Stone%20Game%EF%BC%88%E5%B0%BC%E5%A7%86%E5%8D%9A%E5%BC%88%EF%BC%8Csg%E5%87%BD%E6%95%B0%EF%BC%89/"/>
      <url>/2018/08/20/hdu%201729%20Stone%20Game%EF%BC%88%E5%B0%BC%E5%A7%86%E5%8D%9A%E5%BC%88%EF%BC%8Csg%E5%87%BD%E6%95%B0%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="hdu-1729-Stone-Game（尼姆博弈，sg函数）"><a href="#hdu-1729-Stone-Game（尼姆博弈，sg函数）" class="headerlink" title="hdu 1729 Stone Game（尼姆博弈，sg函数）"></a>hdu 1729 Stone Game（尼姆博弈，sg函数）</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1729" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1729</a></p><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>This game is a two-player game and is played as follows:</p><ol><li>There are n boxes; each box has its size. The box can hold up to s stones if the size is s.</li><li>At the beginning of the game, there are some stones in these boxes.</li><li>The players take turns choosing a box and put a number of stones into the box. The number mustn’t be great than the square of the number of stones before the player adds the stones. For example, the player can add 1 to 9 stones if there are 3 stones in the box. Of course, the total number of stones mustn’t be great than the size of the box.<br>4.Who can’t add stones any more will loss the game.</li></ol><p>Give an Initial state of the game. You are supposed to find whether the first player will win the game if both of the players make the best strategy.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input file contains several test cases.<br>Each test case begins with an integer N, 0 &lt; N ≤ 50, the number of the boxes.<br>In the next N line there are two integer si, ci (0 ≤ ci ≤ si ≤ 1,000,000) on each line, as the size of the box is si and there are ci stones in the box.<br>N = 0 indicates the end of input and should not be processed.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, output the number of the case on the first line, then output “Yes” (without quotes) on the next line if the first player can win the game, otherwise output “No”.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2 0</span><br><span class="line">3 3</span><br><span class="line">6 2</span><br><span class="line">2</span><br><span class="line">6 3</span><br><span class="line">6 3</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Case 1:</span><br><span class="line">Yes</span><br><span class="line">Case 2:</span><br><span class="line">No</span><br></pre></td></tr></table></figure><hr><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>n个盒子，每个盒子容量si，里面有ci个石头，每次操作向盒子里面放石头，放的数量不能大于盒子中已有石头数量的平方，不能再放石头的人输</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>按题意是个组合游戏和，博弈好题</p><p><strong>平等组合游戏</strong></p><ul><li>两人游戏</li><li>有一个状态集，而且通常是有限的</li><li>规定哪些状态转移是允许的</li><li>所有规定对于两人来说是一样的</li><li>两人轮流走步</li><li>有一个终止状态，到达终止状态后游戏即告终止</li><li>游戏可以在有限步内终止</li></ul><p>严格的来定义P状态和N状态</p><ul><li>所有的终止状态都是P状态；</li><li>对于任何的N状态，肯定存在一种方式可以一步转到一个P状态；</li><li>对于任何的P状态，不管怎么走步，都只能转到N状态。</li></ul><p><strong>Sprague-Grundy函数</strong><br>解题模型：</p><ul><li>把原游戏分解成多个独立的子游戏，则原游戏的SG函数值是它的所有子游戏的SG函数值的异或<br>即<code>sg(G)=sg(G1)^sg(G2)^...^sg(Gn)</code></li><li>分别考虑每一个子游戏，计算其SG值</li></ul><p>求每个盒子的sg函数值，<code>get_sg(s,c)</code>，假设每次的取的范围是<code>1～q</code>，那么有<code>q*q+q&lt;s</code> ，同时又要使q尽量大，则有<code>(q+1)*(q+1)+(q+1)&gt;=s</code></p><p>所以先根据上限s找到这个q，然后和当前容量c比较判断是否合法，如果当前盒子里的c&gt;q，那么就可以一次性放满，这个盒子就没用了，反之如果不能一次性放满，就需要假设盒子容量是q，继续递归求上一步操作，<code>get_sg(q,c)</code>;</p><p>要是倒着想感觉绕的话，那就把需要求两次的正过来想╮(￣▽￣””)╭，当前宝石个数是c，但是 <code>c+c*c&lt;s</code>，放不满怎么办，那就先放x个，x是多少现在我还不知道（因为越往后面平方越大，所以实际上我倒着想才会得到最优的结果），那么现在的宝石个数变成了（c+x）个，我可以放<code>1～(c+x)*(c+x)</code>个，如果按最大值放的话，此时就是(c+x)*(c+x)+(c+x)个，如果这个值恰好大于等于s，那么问题就最优的解决了</p><p>然后求这几个sg值的Nim和即可</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int get_sg(int s,int c)&#123;</span><br><span class="line">int q=sqrt((double)s);</span><br><span class="line">while(q+q*q&gt;=s)&#123;</span><br><span class="line">q--;</span><br><span class="line">&#125;</span><br><span class="line">if(c&gt;q)return s-c;</span><br><span class="line">else return get_sg(q,c);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int n,cas=0;</span><br><span class="line">while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)&#123;</span><br><span class="line">int s,c;</span><br><span class="line">printf(&quot;Case %d:\n&quot;,++cas);</span><br><span class="line">int ans=0;</span><br><span class="line">while(n--)&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;s,&amp;c);</span><br><span class="line">ans^=get_sg(s,c);</span><br><span class="line">&#125;</span><br><span class="line">if(ans)puts(&quot;Yes&quot;);</span><br><span class="line">else puts(&quot;No&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 博弈论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hdu 1846 Brave Game（巴什博弈）</title>
      <link href="/2018/08/19/hdu%201846%20Brave%20Game%EF%BC%88%E5%B7%B4%E4%BB%80%E5%8D%9A%E5%BC%88%EF%BC%89/"/>
      <url>/2018/08/19/hdu%201846%20Brave%20Game%EF%BC%88%E5%B7%B4%E4%BB%80%E5%8D%9A%E5%BC%88%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="hdu-1846-Brave-Game（巴什博弈）"><a href="#hdu-1846-Brave-Game（巴什博弈）" class="headerlink" title="hdu 1846 Brave Game（巴什博弈）"></a>hdu 1846 Brave Game（巴什博弈）</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1846" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1846</a></p><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>十年前读大学的时候，中国每年都要从国外引进一些电影大片，其中有一部电影就叫《勇敢者的游戏》（英文名称：Zathura），一直到现在，我依然对于电影中的部分电脑特技印象深刻。<br>今天，大家选择上机考试，就是一种勇敢（brave）的选择；这个短学期，我们讲的是博弈（game）专题；所以，大家现在玩的也是“勇敢者的游戏”，这也是我命名这个题目的原因。<br>当然，除了“勇敢”，我还希望看到“诚信”，无论考试成绩如何，希望看到的都是一个真实的结果，我也相信大家一定能做到的~</p><p>各位勇敢者要玩的第一个游戏是什么呢？很简单，它是这样定义的：<br>1、  本游戏是一个二人游戏;<br>2、  有一堆石子一共有n个；<br>3、  两人轮流进行;<br>4、  每走一步可以取走1…m个石子；<br>5、  最先取光石子的一方为胜；   </p><p>如果游戏的双方使用的都是最优策略，请输出哪个人能赢。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入数据首先包含一个正整数C(C&lt;=100)，表示有C组测试数据。<br>每组测试数据占一行，包含两个整数n和m（1&lt;=n,m&lt;=1000），n和m的含义见题目描述。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>如果先走的人能赢，请输出“first”，否则请输出“second”，每个实例的输出占一行。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">23 2</span><br><span class="line">4 3</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first</span><br><span class="line">second</span><br></pre></td></tr></table></figure><hr><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><h4 id="巴什博弈："><a href="#巴什博弈：" class="headerlink" title="巴什博弈："></a>巴什博弈：</h4><p>只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。</p><p>若n=m+1，由于一次最多只能取m个，所以无论先手拿几个，后手都能够一次拿走剩下的，先手必败</p><p>所以必胜情况就是：n=（m+1）r+s，（r为任意自然数，s≤m),那么先手先拿走s个物品，然后如果后手拿走k（≤m)个，那么先手再拿走m+1-k个，凑成一组（m+1）就行，保证留给后手的永远是（m+1）的倍数，那么先手必胜</p><p>所以结论是n%(m+1)!=0,先手必胜，反之后手胜</p><p>感觉博弈里很多都是根据对方的动作凑成一组一组，蛮妙的</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        int m,n;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        if(n%(m+1)==0)cout&lt;&lt;&quot;second&quot;&lt;&lt;endl;</span><br><span class="line">        else cout&lt;&lt;&quot;first&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 博弈论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hdu 1849 Rabbit and Grass（尼姆博弈）</title>
      <link href="/2018/08/19/hdu%201849%20Rabbit%20and%20Grass%EF%BC%88%E5%B0%BC%E5%A7%86%E5%8D%9A%E5%BC%88%EF%BC%89/"/>
      <url>/2018/08/19/hdu%201849%20Rabbit%20and%20Grass%EF%BC%88%E5%B0%BC%E5%A7%86%E5%8D%9A%E5%BC%88%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="hdu-1849-Rabbit-and-Grass（尼姆博弈）"><a href="#hdu-1849-Rabbit-and-Grass（尼姆博弈）" class="headerlink" title="hdu 1849 Rabbit and Grass（尼姆博弈）"></a>hdu 1849 Rabbit and Grass（尼姆博弈）</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1849" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1849</a></p><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>大学时光是浪漫的，女生是浪漫的，圣诞更是浪漫的，但是Rabbit和Grass这两个大学女生在今年的圣诞节却表现得一点都不浪漫：不去逛商场，不去逛公园，不去和AC男约会，两个人竟然猫在寝食下棋……<br>说是下棋，其实只是一个简单的小游戏而已，游戏的规则是这样的：</p><p>1、棋盘包含1*n个方格，方格从左到右分别编号为0，1，2，…，n-1；</p><p>2、m个棋子放在棋盘的方格上，方格可以为空，也可以放多于一个的棋子；</p><p>3、双方轮流走棋；</p><p>4、每一步可以选择任意一个棋子向左移动到任意的位置（可以多个棋子位于同一个方格），当然，任何棋子不能超出棋盘边界；</p><p>5、如果所有的棋子都位于最左边（即编号为0的位置），则游戏结束，并且规定最后走棋的一方为胜者。</p><p>对于本题，你不需要考虑n的大小（我们可以假设在初始状态，棋子总是位于棋盘的适当位置）。下面的示意图即为一个1*15的棋盘，共有6个棋子，其中，编号8的位置有两个棋子。</p><p><img src="http://acm.hdu.edu.cn/data/images/C101-1004-1.JPG" alt=""></p><p>大家知道，虽然偶尔不够浪漫，但是Rabbit和Grass都是冰雪聪明的女生，如果每次都是Rabbit先走棋，请输出最后的结果。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入数据包含多组测试用例，每个测试用例占二行，首先一行包含一个整数m（0&lt;=m&lt;=1000），表示本测试用例的棋子数目，紧跟着的一行包含m个整数Ki(i=1…m; 0&lt;=Ki&lt;=1000)，分别表示m个棋子初始的位置，m=0则结束输入。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>如果Rabbit能赢的话，请输出“Rabbit Win!”，否则请输出“Grass Win!”，每个实例的输出占一行。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2 </span><br><span class="line">3 5</span><br><span class="line">3</span><br><span class="line">3 5 6</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rabbit Win!</span><br><span class="line">Grass Win!</span><br></pre></td></tr></table></figure><hr><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>尼姆博弈水题 </p><p>因为棋子最后都移动到最左，可以重合，所以一个棋子的可移动次数就是它的位置号也相当于尼姆博弈n堆石子中某一堆的石子数</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=200005;</span><br><span class="line">int main()&#123;</span><br><span class="line">int n;</span><br><span class="line">while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)&#123;</span><br><span class="line">int sum=0,c[N];</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;c[i]);</span><br><span class="line">sum^=c[i];</span><br><span class="line">&#125;</span><br><span class="line">if(sum==0)printf(&quot;Grass Win!\n&quot;);</span><br><span class="line">else&#123;</span><br><span class="line">printf(&quot;Rabbit Win!\n&quot;);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 博弈论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hdu 2176 取(m堆)石子游戏（尼姆博弈）</title>
      <link href="/2018/08/19/hdu%202176%20%E5%8F%96(m%E5%A0%86)%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F%EF%BC%88%E5%B0%BC%E5%A7%86%E5%8D%9A%E5%BC%88%EF%BC%89/"/>
      <url>/2018/08/19/hdu%202176%20%E5%8F%96(m%E5%A0%86)%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F%EF%BC%88%E5%B0%BC%E5%A7%86%E5%8D%9A%E5%BC%88%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="hdu-2176-取-m堆-石子游戏（尼姆博弈）"><a href="#hdu-2176-取-m堆-石子游戏（尼姆博弈）" class="headerlink" title="hdu 2176 取(m堆)石子游戏（尼姆博弈）"></a>hdu 2176 取(m堆)石子游戏（尼姆博弈）</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2176" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=2176</a></p><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>m堆石子,两人轮流取.只能在1堆中取.取完者胜.先取者负输出No.先取者胜输出Yes,然后输出怎样取子.例如5堆 5,7,8,9,10先取者胜,先取者第1次取时可以从有8个的那一堆取走7个剩下1个,也可以从有9个的中那一堆取走9个剩下0个,也可以从有10个的中那一堆取走7个剩下3个.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入有多组.每组第1行是m,m&lt;=200000. 后面m个非零正整数.m=0退出.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>先取者负输出No.先取者胜输出Yes,然后输出先取者第1次取子的所有方法.如果从有a个石子的堆中取若干个后剩下b个后会胜就输出a b.参看Sample Output.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">45 45</span><br><span class="line">3</span><br><span class="line">3 6 9</span><br><span class="line">5</span><br><span class="line">5 7 8 9 10</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">No</span><br><span class="line">Yes</span><br><span class="line">9 5</span><br><span class="line">Yes</span><br><span class="line">8 1</span><br><span class="line">9 0</span><br><span class="line">10 3</span><br></pre></td></tr></table></figure><hr><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><h4 id="尼姆博弈"><a href="#尼姆博弈" class="headerlink" title="尼姆博弈"></a>尼姆博弈</h4><p>这题判断胜负直接异或就行，若异或结果sum=0则先手败，其余先手必胜</p><p>胜要求输出第一步操作后剩余的石子数，若<code>c[i]^sum&lt;c[i]</code>则可行，取得个数为<code>c[i]-c[i]^sum</code>，输出剩余个数即为<code>c[i]^sum</code></p><p>以下我也忘了摘自哪里。。</p><blockquote><p>三堆的时候</p><p>用(a,b,c)表示某种局势，首先(0,0,0)显然是必败态，无论谁面对(0,0,0) ，都必然失败；第二种必败态是(0,n,n)，自己在某一堆拿走k（k ≤ n）个物品，不论k为多少，对方只要在另一堆拿走k个物品，最后自己都将面临(0,0,0)的局势，必败。仔细分析一下，(1,2,3)也是必败态，无论自己如何拿，接下来对手都可以把局势变为(0,n,n)的情形</p><p>任何奇异局势(a,b,c)都有a XOR b XOR c = 0</p><p>如果我们面对的是一个非必败态(a,b,c)，要如何变为必败态呢？<br>假设 a &lt; b &lt; c，我们只要将 c 变为a XOR b，即可。因为有如下的运算结果：</p><p>a XOR b XOR (a XOR b)=(a XOR a) XOR (b XOR b) = 0 XOR 0 = 0</p><p>要将c 变为a XOR b，只要对 c进行 c-(a XOR b)这样的运算即可</p><hr><p>定义两个状态，分别为N和P，N代表Next-position，可以理解为先手必胜状态，P代表Previous-position，可以理解为后手必胜状态（或为先手必败）<br>N/P两个状态的关系：<br>（1）无法进行局面转移的状态为P；<br>（2）只要有一种转移方式能将局面变为P，则当前状态为N；<br>（3）任何转移方式都只能使局面变为N，则当前状态为P。<br>（1）最后所有石堆中的石子都为0，此时无法再做任何操作，所以此时是P；<br>（2）在还剩一堆的情况下（无论个数，因为可以随意取），把这一堆都取完，留给对方 的肯定是0个石子，也就是P，所以当前肯定是N；<br>（3）还剩下两堆，且每堆个数为1，因为当前必须要取，而当取完后，通过（2）可知， 留给对方的局 面一定是N，所以当前肯定为P。</p><hr><p>对于Nim游戏的各个石堆（a1,a2,a3……an），当且仅当a1^a2^a3^……^an=0时它为P。</p><p>论证还是要根据N/P的三个状态关系来：</p><p>（1）无法移动的局面为所有石堆的石子数都为0，0^0^……^0=0，这个很简单；</p><p>（2）若当前的局面不为0，即a1^a2^a3^……^an=k，则必定有一个数ai改变ai的值为ai’（或者理解为改变当前某个石堆的状态），能使的a1^a2^a3^……^ai’^……^an=0,证明很简单，通过异或的性质，因为k的二进制最高位（从右往左）为1，可以得出一 定存在某个ai的最高位为1，此时<code>ai&#39;*k&lt;ai</code>，这个也很好理解，当前的最高位由1变为0 ，十进制时ai一定小于ai’。所以，我们可以将<code>ai=ai&#39;*k</code>，此时<code>a1^a2^a3^......^ai&#39;*k ^.......an=0</code>。</p><p>（3）若当前某个局面为P，即a1^a2^a3^……^an=0,一定不存在改变某 个ai，使之变为ai’，a1^a2^a3^…….^ai’^……^an=0,因为异或满足消去律，消去后得ai=ai’，由题目可得不能不取，即当前的ai值必须改变，所以此时ai一定不等于ai’。</p></blockquote><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=200005;</span><br><span class="line">//c1^c2^...^cn=k,然后c1^c2^...^cn^k=0,那么对那个数执行操作减去（cn-cn^k）,那个数变为cn^k </span><br><span class="line">int main()&#123;</span><br><span class="line">int n;</span><br><span class="line">while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)&#123;</span><br><span class="line">int sum=0,c[N];</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;c[i]);</span><br><span class="line">sum^=c[i];</span><br><span class="line">&#125;</span><br><span class="line">if(sum==0)printf(&quot;No\n&quot;);</span><br><span class="line">else&#123;</span><br><span class="line">printf(&quot;Yes\n&quot;);</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">if((c[i]^sum)&lt;c[i])printf(&quot;%d %d\n&quot;,c[i],(c[i]^sum));</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 博弈论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hdu 2177 取(2堆)石子游戏（威佐夫博弈）</title>
      <link href="/2018/08/19/hdu%202177%20%E5%8F%96(2%E5%A0%86)%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F%EF%BC%88%E5%A8%81%E4%BD%90%E5%A4%AB%E5%8D%9A%E5%BC%88%EF%BC%89/"/>
      <url>/2018/08/19/hdu%202177%20%E5%8F%96(2%E5%A0%86)%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F%EF%BC%88%E5%A8%81%E4%BD%90%E5%A4%AB%E5%8D%9A%E5%BC%88%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="hdu-2177-取-2堆-石子游戏（威佐夫博弈）"><a href="#hdu-2177-取-2堆-石子游戏（威佐夫博弈）" class="headerlink" title="hdu 2177 取(2堆)石子游戏（威佐夫博弈）"></a>hdu 2177 取(2堆)石子游戏（威佐夫博弈）</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2177" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=2177</a></p><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。如果你胜，你第1次怎样取子? </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入包含若干行，表示若干种石子的初始情况，其中每一行包含两个非负整数a和b，表示两堆石子的数目，a和b都不大于1,000,000，且a&lt;=b。a=b=0退出。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出也有若干行，如果最后你是败者，则为0，反之，输出1，并输出使你胜的你第1次取石子后剩下的两堆石子的数量x,y,x&lt;=y。如果在任意的一堆中取走石子能胜同时在两堆中同时取走相同数量的石子也能胜，先输出取走相同数量的石子的情况.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 2 </span><br><span class="line">5 8</span><br><span class="line">4 7</span><br><span class="line">2 2</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">4 7</span><br><span class="line">3 5</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0 0</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><hr><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><h4 id="威佐夫博弈"><a href="#威佐夫博弈" class="headerlink" title="威佐夫博弈"></a>威佐夫博弈</h4><p>给出一些明显的必败状态(也就是当你面对这些状态时，只要你的对手够聪明，不犯错，无论你怎么拿，你都是必输的)（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）、…… 、（ak，bk） (k = 0, 1, 2, 3,……)。并称这些必败状态为 <strong>“奇异局势”</strong></p><p>得到a0=b0=0,ak是未在前面出现过的最小自然数,而 bk= ak + k。然后公式化就得到了奇异局势的状态公式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ak = [ k * (1 + √5) / 2 ]   ( [x]表示对x取整 )</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bk = ak + k</span><br></pre></td></tr></table></figure><p>奇异局势有三个性质——</p><blockquote><p>性质1：每个自然数都包含在且只包含在一个奇异局势中。</p></blockquote><blockquote><p>性质2：对任意的奇异局势，任何合法的操作都会使其成为非奇异局势，也就是奇异局势的所有后继状态均为非奇异局势。</p></blockquote><blockquote><p>性质3：任何非奇异局势都可以通过某种合法操作得到奇异局势，即奇异局势的所有后继状态中存在奇异局势。</p></blockquote><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int a,b;</span><br><span class="line">double x=(1+sqrt(5.0))/2.0;//矩阵黄金分割数 </span><br><span class="line">while(scanf(&quot;%d%d&quot;,&amp;a,&amp;b)!=EOF&amp;&amp;(a+b))&#123;</span><br><span class="line">if(a&gt;b)&#123;</span><br><span class="line">int temp=a;a=b;b=temp;</span><br><span class="line">&#125;</span><br><span class="line">if((int)((b-a)*x)==a)printf(&quot;0\n&quot;);</span><br><span class="line">else&#123;</span><br><span class="line">int n,m;</span><br><span class="line">printf(&quot;1\n&quot;);</span><br><span class="line">for(int i=1;i&lt;=a;i++)&#123;//一起拿 </span><br><span class="line">n=a-i;</span><br><span class="line">m=b-i;</span><br><span class="line">if((int)((m-n)*x)==n)printf(&quot;%d %d\n&quot;,n,m);</span><br><span class="line">//不用退出循环也可，因为由奇异状态性质，只会有一个i满足 </span><br><span class="line">&#125;</span><br><span class="line">for(int i=b-1;i&gt;=0;i--)&#123;//从一个中拿，要从多的那堆中拿！ </span><br><span class="line">n=a;</span><br><span class="line">m=i;</span><br><span class="line">if(n&gt;m)&#123;</span><br><span class="line">int temp=n;n=m;m=temp;</span><br><span class="line">&#125;</span><br><span class="line">if((int)((m-n)*x)==n)printf(&quot;%d %d\n&quot;,n,m);</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 博弈论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>poj 1704 Georgia and Bob（尼姆博弈，阶梯博弈）</title>
      <link href="/2018/08/19/poj%201704%20Georgia%20and%20Bob%EF%BC%88%E5%B0%BC%E5%A7%86%E5%8D%9A%E5%BC%88%EF%BC%8C%E9%98%B6%E6%A2%AF%E5%8D%9A%E5%BC%88%EF%BC%89/"/>
      <url>/2018/08/19/poj%201704%20Georgia%20and%20Bob%EF%BC%88%E5%B0%BC%E5%A7%86%E5%8D%9A%E5%BC%88%EF%BC%8C%E9%98%B6%E6%A2%AF%E5%8D%9A%E5%BC%88%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="poj-1704-Georgia-and-Bob（尼姆博弈，阶梯博弈）"><a href="#poj-1704-Georgia-and-Bob（尼姆博弈，阶梯博弈）" class="headerlink" title="poj 1704 Georgia and Bob（尼姆博弈，阶梯博弈）"></a>poj 1704 Georgia and Bob（尼姆博弈，阶梯博弈）</h1><p><a href="http://poj.org/problem?id=1704" target="_blank" rel="noopener">http://poj.org/problem?id=1704</a></p><p>Georgia and Bob decide to play a self-invented game. They draw a row of grids on paper, number the grids from left to right by 1, 2, 3, …, and place N chessmen on different grids, as shown in the following figure for example:<br><img src="http://poj.org/images/1704_1.jpg" alt=""></p><p>Georgia and Bob move the chessmen in turn. Every time a player will choose a chessman, and move it to the left without going over any other chessmen or across the left edge. The player can freely choose number of steps the chessman moves, with the constraint that the chessman must be moved at least ONE step and one grid can at most contains ONE single chessman. The player who cannot make a move loses the game. </p><p>Georgia always plays first since “Lady first”. Suppose that Georgia and Bob both do their best in the game, i.e., if one of them knows a way to win the game, he or she will be able to carry it out. </p><p>Given the initial positions of the n chessmen, can you predict who will finally win the game? </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input contains a single integer T (1 &lt;= T &lt;= 20), the number of test cases. Then T cases follow. Each test case contains two lines. The first line consists of one integer N (1 &lt;= N &lt;= 1000), indicating the number of chessmen. The second line contains N different integers P1, P2 … Pn (1 &lt;= Pi &lt;= 10000), which are the initial positions of the n chessmen.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, prints a single line, “Georgia will win”, if Georgia will win the game; “Bob will win”, if Bob will win the game; otherwise ‘Not sure’.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">8</span><br><span class="line">1 5 6 7 9 12 14 17</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bob will win</span><br><span class="line">Georgia will win</span><br></pre></td></tr></table></figure><hr><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>从左到右有一排棋子，给出棋子初始位置，每次操作选择一个棋子向左移动，且不能跨过前面的棋子和最左边边缘，一个格子只能放一个棋子，无法移动的输</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>题面一看很玄乎，但是分析分析这其实就是个单单纯纯的尼姆博弈的模型啊</p><p>因为每个棋子不能越过前面的棋子，所以其实开始和结束棋子的顺序已经固定了都是一样的，他们最后移动多少步到哪个地方也都是安排好了的，所以最后肯定会变成<code>1...10...0（1表示有棋子，0表示空格）</code>的状态，所以其实就是相当于n堆取石子游戏，没堆的石子数相当于本题里两个棋子之间的距离，也就是后面棋子能直接移动的步数</p><p>这时可能会想到一个问题，如果移动后是<code>11100011</code>这样的情况呢？如果是这样的话，后手只要拿着那个跟先手移动的棋同一对棋，学着先手向左移动就好了，次数都一样，所以实际上转化成的石子数只和两个棋子的间隔有关，和具体的位置无关，最后都会在不影响胜负的情况下达到目标态</p><p>所以最后的具体写法是，先把棋子位置排序，从大到小两个两个一对，他们之间的间隔（r-l-1）就是每堆的石子数，这里如果最左边多了一个棋子，把它和位置1（即左边缘）凑成一对就可以</p><p>然后就是尼姆博弈异或一下没啥好说的啦～</p><p>查了一下原来这题有学名叫 <strong>阶梯博弈</strong></p><p>先mark一下 <a href="https://blog.csdn.net/a1799342217/article/details/78265265?locationNum=9&amp;fps=1" target="_blank" rel="noopener">阶梯博弈详解</a></p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int t,s[1005];</span><br><span class="line">scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">while(t--)&#123;</span><br><span class="line">int n;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;s[i]);</span><br><span class="line">sort(s,s+n);</span><br><span class="line">int ans;</span><br><span class="line">if(n&amp;1)&#123;</span><br><span class="line">ans=s[0]-1;</span><br><span class="line">for(int i=2;i&lt;n;i+=2)ans^=(s[i]-s[i-1]-1);</span><br><span class="line">if(ans==0)cout&lt;&lt;&quot;Bob will win&quot;&lt;&lt;endl;</span><br><span class="line">else cout&lt;&lt;&quot;Georgia will win&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">ans=s[1]-s[0]-1;</span><br><span class="line">for(int i=3;i&lt;n;i+=2)ans^=(s[i]-s[i-1]-1);</span><br><span class="line">if(ans==0)cout&lt;&lt;&quot;Bob will win&quot;&lt;&lt;endl;</span><br><span class="line">else cout&lt;&lt;&quot;Georgia will win&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 博弈论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>poj 1740 A New Stone Game（博弈论）</title>
      <link href="/2018/08/19/poj%201740%20A%20New%20Stone%20Game%EF%BC%88%E5%8D%9A%E5%BC%88%E8%AE%BA%EF%BC%89/"/>
      <url>/2018/08/19/poj%201740%20A%20New%20Stone%20Game%EF%BC%88%E5%8D%9A%E5%BC%88%E8%AE%BA%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="poj-1740-A-New-Stone-Game（博弈论）"><a href="#poj-1740-A-New-Stone-Game（博弈论）" class="headerlink" title="poj 1740 A New Stone Game（博弈论）"></a>poj 1740 A New Stone Game（博弈论）</h1><p><a href="http://poj.org/problem?id=1740" target="_blank" rel="noopener">http://poj.org/problem?id=1740</a></p><p>Alice and Bob decide to play a new stone game.At the beginning of the game they pick n(1&lt;=n&lt;=10) piles of stones in a line. Alice and Bob move the stones in turn.<br>At each step of the game,the player choose a pile,remove at least one stones,then freely move stones from this pile to any other pile that still has stones.<br>For example:n=4 and the piles have (3,1,4,2) stones.If the player chose the first pile and remove one.Then it can reach the follow states.<br>2 1 4 2<br>1 2 4 2（move one stone to Pile 2）<br>1 1 5 2（move one stone to Pile 3）<br>1 1 4 3（move one stone to Pile 4）<br>0 2 5 2（move one stone to Pile 2 and another one to Pile 3）<br>0 2 4 3（move one stone to Pile 2 and another one to Pile 4）<br>0 1 5 3（move one stone to Pile 3 and another one to Pile 4）<br>0 3 4 2（move two stones to Pile 2）<br>0 1 6 2（move two stones to Pile 3）<br>0 1 4 4（move two stones to Pile 4）<br>Alice always moves first. Suppose that both Alice and Bob do their best in the game.<br>You are to write a program to determine who will finally win the game. </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input contains several test cases. The first line of each test case contains an integer number n, denoting the number of piles. The following n integers describe the number of stones in each pile at the beginning of the game, you may assume the number of stones in each pile will not exceed 100.<br>The last test case is followed by one zero. </p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, if Alice win the game,output 1,otherwise output 0. </p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2 1 3</span><br><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><hr><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>有n堆石头，每次操作选择一堆，移除其中至少一块，然后可以取剩下的石子里的任意个移动到别的任意堆，无法操作的输</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>首先当n=1时先手必胜，全部移除就好了</p><p>n=2时，若a1=a2，则后手只要模仿先手的操作就可以，先手必败；同理若a1！=a2，则先手把两堆变成相等，然后后手必败</p><p>n=3时，先手一次操作把第三堆分给一二堆或丢掉，那么就又变成了之前两堆相等的状态，先手必胜</p><p>继续推下去，n=4，由于谁面临三堆就必胜，所以双方都想让对方取了那个第四堆然后自己面对三堆状态，而只有在四堆都是1的时候，才会不得不去取第四堆</p><p>经过上面分析，先手有极大优势，先手必败的情况只有这种： <strong>后手一直学先手的操作，而一开始注定了总操作数为偶，刚好让先手无路可走</strong> </p><p>这种情况对应的状态为：石头堆数为偶数，且有n/2对一样的数</p><p>判断n/2对是否相等只要排序再比较就可以</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int n;</span><br><span class="line">while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)&#123;</span><br><span class="line">int c[15];</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;c[i]);</span><br><span class="line">&#125;</span><br><span class="line">if(n&amp;1)&#123;</span><br><span class="line">printf(&quot;1\n&quot;);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">sort(c,c+n);</span><br><span class="line">int flag=0;</span><br><span class="line">for(int i=0;i&lt;n-1;i+=2)&#123;</span><br><span class="line">if(c[i]!=c[i+1])&#123;</span><br><span class="line">flag=1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag==0)printf(&quot;0\n&quot;);</span><br><span class="line">else printf(&quot;1\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 博弈论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Ponds（拓扑排序）</title>
      <link href="/2018/08/19/Ponds%EF%BC%88%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%89/"/>
      <url>/2018/08/19/Ponds%EF%BC%88%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="Ponds（拓扑排序）"><a href="#Ponds（拓扑排序）" class="headerlink" title="Ponds（拓扑排序）"></a>Ponds（拓扑排序）</h1><p><a href="https://nanti.jisuanke.com/t/29329" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/29329</a></p><p>Betty owns a lot of ponds, some of them are connected with other ponds by pipes, and there will not be more than one pipe between two ponds. Each pond has a value v.</p><p>Now Betty wants to remove some ponds because she does not have enough money. But each time when she removes a pond, she can only remove the ponds which are connected with less than two ponds, or the pond will explode.</p><p>Note that Betty should keep removing ponds until no more ponds can be removed. After that, please help her calculate the sum of the value for each connected component consisting of a odd number of ponds</p><h3 id="Input-Format"><a href="#Input-Format" class="headerlink" title="Input Format"></a>Input Format</h3><p>The first line of input will contain a number T(1≤T≤30) which is the number of test cases.</p><p>For each test case, the first line contains two number separated by a blank. One is the number p(1≤p≤10^4) which represents the number of ponds she owns, and the other is the number m(1≤m≤10^5) which represents the number of pipes.</p><p>The next line contains p numbers v1，···，vp, where vi(1≤vi≤10^8) indicating the value of pond i.</p><p>Each of the last m lines contain two numbers a and b, which indicates that pond a and pond b are connected by a pipe.</p><h3 id="Output-Format"><a href="#Output-Format" class="headerlink" title="Output Format"></a>Output Format</h3><p>For each test case, output the sum of the value of all connected components consisting of odd number of ponds after removing all the ponds connected with less than two pipes.</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">7 7</span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line">1 4</span><br><span class="line">1 5</span><br><span class="line">4 5</span><br><span class="line">2 3</span><br><span class="line">2 6</span><br><span class="line">3 6</span><br><span class="line">2 7</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure><h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p>ACM-ICPC 2015 Changchun Preliminary Contest</p><hr><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给一个无向图，池塘之间有管道相连，每个池塘有一个权值，现在要拆掉所有度数小于2的池塘，直至不能拆为止，最后求连通个数为奇数的池塘的权值和</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>删除一个度数为1的结点之后，这个点的边所通向的点的度数也要减一，就可能产生新的度数小于2的点，有点拓扑排序的意思，出现度数小于2的点就存入q，直到q为空，按照题意写就行</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N=1000005;</span><br><span class="line">int d[N],w[N],u[N],v[N],sum[N];</span><br><span class="line">LL ans;</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt;tu;</span><br><span class="line">bool vis[N];</span><br><span class="line">int fa[N];</span><br><span class="line">void init(int x)&#123;</span><br><span class="line">for(int i=1;i&lt;=x;i++)fa[i]=i;</span><br><span class="line">memset(d,0,sizeof(d));</span><br><span class="line">memset(vis,false,sizeof(vis));</span><br><span class="line">memset(sum,0,sizeof(sum));</span><br><span class="line">tu.resize(x+1);</span><br><span class="line">tu.clear();</span><br><span class="line">&#125;</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">    int tmp=x;</span><br><span class="line">    while(fa[tmp]!=tmp)tmp=fa[tmp]; </span><br><span class="line">    fa[x]=tmp;</span><br><span class="line">    return tmp;</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">    if(find(x)!=find(y))fa[find(x)]=fa[find(y)];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int t,n,m;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">while(t--)&#123;</span><br><span class="line">ans=0;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">init(n);</span><br><span class="line">for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;w[i]);</span><br><span class="line">for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;u[i],&amp;v[i]);</span><br><span class="line">d[u[i]]++;d[v[i]]++;</span><br><span class="line">tu[u[i]].push_back(v[i]);</span><br><span class="line">tu[v[i]].push_back(u[i]);</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;int&gt;q;</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">if(d[i]&lt;=1)&#123;</span><br><span class="line">vis[i]=true;</span><br><span class="line">q.push(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">while(!q.empty())&#123;</span><br><span class="line">int tmp=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">for(int i=0;i&lt;tu[tmp].size();i++)&#123;</span><br><span class="line">int nod=tu[tmp][i];</span><br><span class="line">d[nod]--;</span><br><span class="line">if(d[nod]&lt;=1&amp;&amp;vis[nod]==false)&#123;</span><br><span class="line">vis[nod]=true;</span><br><span class="line">q.push(nod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">if(vis[u[i]]==false&amp;&amp;vis[v[i]]==false)join(u[i],v[i]);</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">if(vis[i]==false)sum[find(i)]++;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">if(vis[i]==false&amp;&amp;sum[find(i)]&amp;1)ans+=w[i];</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%lld\n&quot;,ans);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Minimum Cut（读题。。）</title>
      <link href="/2018/08/19/Minimum%20Cut%EF%BC%88%E8%AF%BB%E9%A2%98%E3%80%82%E3%80%82%EF%BC%89/"/>
      <url>/2018/08/19/Minimum%20Cut%EF%BC%88%E8%AF%BB%E9%A2%98%E3%80%82%E3%80%82%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="Minimum-Cut（读题。。）"><a href="#Minimum-Cut（读题。。）" class="headerlink" title="Minimum Cut（读题。。）"></a>Minimum Cut（读题。。）</h1><p><a href="https://nanti.jisuanke.com/t/29122" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/29122</a></p><p>Given a simple unweighted graph GG (an undirected graph containing no loops nor multiple edges) with nn nodes and mm edges. Let T be a spanning tree of G. We say that a cut in G respects T if it cuts just one edges of T.</p><p>Since love needs good faith and hypocrisy return for only grief, you should find the minimum cut of graph G respecting the given spanning tree T.</p><h3 id="Input-Format"><a href="#Input-Format" class="headerlink" title="Input Format"></a>Input Format</h3><p>The input contains several test cases.</p><p>The first line of the input is a single integer t(1≤t≤5) which is the number of test cases. Then tt test cases follow.</p><p>Each test case contains several lines. The first line contains two integers n(2≤n≤20000) and m(n−1≤m≤200000). The following n-1n−1 lines describe the spanning tree T and each of them contains two integers uu and v corresponding to an edge. Next m−n+1 lines describe the undirected graph G and each of them contains two integers u and v corresponding to an edge which is not in the spanning tree T.</p><p>Output Format<br>For each test case, you should output the minimum cut of graph G respecting the given spanning tree T.</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Case #1: 2</span><br></pre></td></tr></table></figure><h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p>ACM-ICPC 2015 Shenyang Preliminary Contest</p><hr><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>先给一棵生成树，再在此基础上给图，删去树的一个边和图一些边使图不连通，求删去的最少边数</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>题目不难 读懂了就很水 但是真的是读了好久。。</p><p>要使图不连通且只能删树的一个边，就要找树上度数为1的点，然后加上图中和这个点相连的边，求最小的即可</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long </span><br><span class="line">const int N=20005;</span><br><span class="line">const int INF=0x3f3f3f3f;</span><br><span class="line">int d1[N],d2[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">int t;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">for(int i=1;i&lt;=t;i++)&#123;</span><br><span class="line">int n,m,ans=INF;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">memset(d1,0,sizeof(d1));</span><br><span class="line">memset(d2,0,sizeof(d2));</span><br><span class="line">int u,v;</span><br><span class="line">for(int i=0;i&lt;n-1;i++)&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">d1[u]++;d1[v]++;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=n-1;i&lt;m;i++)&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">d2[u]++;d2[v]++;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">if(d1[i]==1)ans=min(ans,1+d2[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;Case #%d: %d\n&quot;,i,ans);</span><br><span class="line">&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hdu 3371 Connect the Cities（最小生成树）</title>
      <link href="/2018/08/19/hdu%203371%20Connect%20the%20Cities%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89/"/>
      <url>/2018/08/19/hdu%203371%20Connect%20the%20Cities%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="hdu-3371-Connect-the-Cities（最小生成树）"><a href="#hdu-3371-Connect-the-Cities（最小生成树）" class="headerlink" title="hdu 3371 Connect the Cities（最小生成树）"></a>hdu 3371 Connect the Cities（最小生成树）</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3371" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=3371</a></p><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>In 2100, since the sea level rise, most of the cities disappear. Though some survived cities are still connected with others, but most of them become disconnected. The government wants to build some roads to connect all of these cities again, but they don’t want to take too much money.  </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains the number of test cases.<br>Each test case starts with three integers: n, m and k. n (3 &lt;= n &lt;=500) stands for the number of survived cities, m (0 &lt;= m &lt;= 25000) stands for the number of roads you can choose to connect the cities and k (0 &lt;= k &lt;= 100) stands for the number of still connected cities.</p><p>To make it easy, the cities are signed from 1 to n.<br>Then follow m lines, each contains three integers p, q and c (0 &lt;= c &lt;= 1000), means it takes c to connect p and q.</p><p>Then follow k lines, each line starts with an integer t (2 &lt;= t &lt;= n) stands for the number of this connected cities. Then t integers follow stands for the id of these cities.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each case, output the least money you need to take, if it’s impossible, just output -1.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">6 4 3</span><br><span class="line">1 4 2</span><br><span class="line">2 6 1</span><br><span class="line">2 3 5</span><br><span class="line">3 4 33</span><br><span class="line">2 1 2</span><br><span class="line">2 1 3</span><br><span class="line">3 4 5 6</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><hr><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>最小生成树</p><p>当时tle无数次 最后同一段代码看人品卡过去。。？什么操作？？</p><p>现在测了两次都是748ms</p><p>最后求gen的时候不要find(i)==i，直接fa[i]==i<br>k个那段读入的时候用while(num–)，或许真的while比for快一点？？</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=505;</span><br><span class="line">struct Edge&#123;</span><br><span class="line">int u,v;</span><br><span class="line">double cap;</span><br><span class="line">&#125;Edge[N*N];//边集 </span><br><span class="line">int m,ans; </span><br><span class="line">int fa[N];</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">if(x!=fa[x])fa[x]=find(fa[x]);</span><br><span class="line">return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">int a=find(x),b=find(y);</span><br><span class="line">if(a==b)return;</span><br><span class="line">else&#123;</span><br><span class="line">fa[a]=b;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">bool cmp(struct Edge a,struct Edge b)&#123;</span><br><span class="line">return a.cap&lt;b.cap;</span><br><span class="line">&#125;</span><br><span class="line">void kruskal()&#123;</span><br><span class="line">sort(Edge+1,Edge+m+1,cmp);//按边的最小代价排序 </span><br><span class="line">for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">int fx=find(Edge[i].u),fy=find(Edge[i].v);</span><br><span class="line">if(fx==fy)continue;</span><br><span class="line">ans+=Edge[i].cap;//u，v不在一棵树上，就加上这条边 </span><br><span class="line">join(fx,fy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int t;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">while(t--)&#123;</span><br><span class="line">int n,k;</span><br><span class="line">scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);</span><br><span class="line">for(int i=1;i&lt;=n;i++)fa[i]=i;;</span><br><span class="line">for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">int p,q,c;</span><br><span class="line">scanf(&quot;%d%d%d&quot;,&amp;p,&amp;q,&amp;c);</span><br><span class="line">Edge[i].u=p;</span><br><span class="line">Edge[i].v=q;</span><br><span class="line">Edge[i].cap=c;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=k;i++)&#123;</span><br><span class="line">int num,a,tmp;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;num,&amp;a);</span><br><span class="line">num--;tmp=a;</span><br><span class="line">while(num--)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;a);</span><br><span class="line">if(fa[tmp]!=fa[a])join(tmp,a);</span><br><span class="line">tmp=a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans=0;</span><br><span class="line">kruskal();</span><br><span class="line">int gen=0;</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">if(fa[i]==i)&#123;</span><br><span class="line">gen++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(gen==1)printf(&quot;%d\n&quot;,ans);</span><br><span class="line">else printf(&quot;-1\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hdu 1879 继续畅通工程（最小生成树）</title>
      <link href="/2018/08/19/hdu%201879%20%E7%BB%A7%E7%BB%AD%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89/"/>
      <url>/2018/08/19/hdu%201879%20%E7%BB%A7%E7%BB%AD%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>#hdu 1879 继续畅通工程（最小生成树）<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1879" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1879</a></p><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可）。现得到城镇道路统计表，表中列出了任意两城镇间修建道路的费用，以及该道路是否已经修通的状态。现请你编写程序，计算出全省畅通需要的最低成本。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>测试输入包含若干测试用例。每个测试用例的第1行给出村庄数目N ( 1&lt; N &lt; 100 )；随后的 N(N-1)/2 行对应村庄间道路的成本及修建状态，每行给4个正整数，分别是两个村庄的编号（从1编号到N），此两村庄间道路的成本，以及修建状态：1表示已建，0表示未建。</p><p>当N为0时输入结束。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>每个测试用例的输出占一行，输出全省畅通需要的最低成本。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 1 0</span><br><span class="line">1 3 2 0</span><br><span class="line">2 3 4 0</span><br><span class="line">3</span><br><span class="line">1 2 1 0</span><br><span class="line">1 3 2 0</span><br><span class="line">2 3 4 1</span><br><span class="line">3</span><br><span class="line">1 2 1 0</span><br><span class="line">1 3 2 1</span><br><span class="line">2 3 4 1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><hr><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>给出一些有的和没有的边</p><p>有的边直接join 没有的加入边集 跑一边kruskal</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=105;</span><br><span class="line">struct Edge&#123;</span><br><span class="line">int u,v;</span><br><span class="line">double cap;</span><br><span class="line">&#125;Edge[N*N];//边集 </span><br><span class="line">int n,num,cnt,ans; </span><br><span class="line">int fa[N];</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">if(x!=fa[x])fa[x]=find(fa[x]);</span><br><span class="line">return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">int a=find(x),b=find(y);</span><br><span class="line">if(a==b)return;</span><br><span class="line">else&#123;</span><br><span class="line">fa[a]=b;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">bool cmp(struct Edge a,struct Edge b)&#123;</span><br><span class="line">return a.cap&lt;b.cap;</span><br><span class="line">&#125;</span><br><span class="line">void kruskal()&#123;</span><br><span class="line">sort(Edge+1,Edge+cnt,cmp);//按边的最小代价排序 </span><br><span class="line">for(int i=1;i&lt;=cnt-1;i++)&#123;</span><br><span class="line">int fx=find(Edge[i].u),fy=find(Edge[i].v);</span><br><span class="line">if(fx==fy)continue;</span><br><span class="line">ans+=Edge[i].cap;//u，v不在一棵树上，就加上这条边 </span><br><span class="line">join(fx,fy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">while(scanf(&quot;%d&quot;,&amp;n))&#123;</span><br><span class="line">if(n==0)break;</span><br><span class="line">for(int i=1;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">num=n*(n-1)/2;</span><br><span class="line">cnt=1;</span><br><span class="line">for(int i=1;i&lt;=num;i++)&#123;</span><br><span class="line">int a,b,c,d;</span><br><span class="line">scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line">if(d==0)&#123;</span><br><span class="line">Edge[cnt].u=a;</span><br><span class="line">Edge[cnt].v=b;</span><br><span class="line">Edge[cnt].cap=c;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">else if(d==1)&#123;</span><br><span class="line">join(a,b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans=0;</span><br><span class="line">kruskal();</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hdu 1875 畅通工程再续（最小生成树）</title>
      <link href="/2018/08/19/hdu%201875%20%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%E5%86%8D%E7%BB%AD%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89/"/>
      <url>/2018/08/19/hdu%201875%20%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%E5%86%8D%E7%BB%AD%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="hdu-1875-畅通工程再续（最小生成树）"><a href="#hdu-1875-畅通工程再续（最小生成树）" class="headerlink" title="hdu 1875 畅通工程再续（最小生成树）"></a>hdu 1875 畅通工程再续（最小生成树）</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1875" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1875</a></p><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>相信大家都听说一个“百岛湖”的地方吧，百岛湖的居民生活在不同的小岛中，当他们想去其他的小岛时都要通过划小船来实现。现在政府决定大力发展百岛湖，发展首先要解决的问题当然是交通问题，政府决定实现百岛湖的全畅通！经过考察小组RPRush对百岛湖的情况充分了解后，决定在符合条件的小岛间建上桥，所谓符合条件，就是2个小岛之间的距离不能小于10米，也不能大于1000米。当然，为了节省资金，只要求实现任意2个小岛之间有路通即可。其中桥的价格为 100元/米。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入包括多组数据。输入首先包括一个整数T(T &lt;= 200)，代表有T组数据。<br>每组数据首先是一个整数C(C &lt;= 100),代表小岛的个数，接下来是C组坐标，代表每个小岛的坐标，这些坐标都是 0 &lt;= x, y &lt;= 1000的整数。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>每组输入数据输出一行，代表建桥的最小花费，结果保留一位小数。如果无法实现工程以达到全部畅通，输出”oh!”.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">10 10</span><br><span class="line">20 20</span><br><span class="line">3</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">1000 1000</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1414.2</span><br><span class="line">oh!</span><br></pre></td></tr></table></figure><hr><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>最小生成树 加了边的限制 只要在加边前判断一下边长是否合法就行</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=105;</span><br><span class="line">struct Edge&#123;</span><br><span class="line">int u,v;</span><br><span class="line">double cap;</span><br><span class="line">&#125;Edge[N*N];//边集 </span><br><span class="line">struct Node&#123;</span><br><span class="line">int x,y;</span><br><span class="line">&#125;Node[N];//点集 </span><br><span class="line">int n,num,ed,cnt;</span><br><span class="line">double ans; </span><br><span class="line">int fa[N];</span><br><span class="line">double distance_(int a,int b)&#123;</span><br><span class="line">return sqrt((Node[a].x-Node[b].x)*(Node[a].x-Node[b].x)+(Node[a].y-Node[b].y)*(Node[a].y-Node[b].y));</span><br><span class="line">&#125;</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">if(x!=fa[x])fa[x]=find(fa[x]);</span><br><span class="line">return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">int a=find(x),b=find(y);</span><br><span class="line">if(a==b)return;</span><br><span class="line">else&#123;</span><br><span class="line">fa[a]=b;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">bool cmp(struct Edge a,struct Edge b)&#123;</span><br><span class="line">return a.cap&lt;b.cap;</span><br><span class="line">&#125;</span><br><span class="line">void kruskal()&#123;</span><br><span class="line">sort(Edge,Edge+cnt,cmp);//按边的最小代价排序 </span><br><span class="line">for(int i=1;i&lt;=cnt-1;i++)&#123;</span><br><span class="line">int fx=find(Edge[i].u),fy=find(Edge[i].v);</span><br><span class="line">if(fx==fy)continue;</span><br><span class="line">ans+=Edge[i].cap;//u，v不在一棵树上，就加上这条边 </span><br><span class="line">join(fx,fy);</span><br><span class="line">ed++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int t;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">while(t--)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;Node[i].x,&amp;Node[i].y);</span><br><span class="line">fa[i]=i;</span><br><span class="line">&#125;</span><br><span class="line">cnt=1;</span><br><span class="line">ed=0;</span><br><span class="line">for(int i=1;i&lt;=n-1;i++)&#123;</span><br><span class="line">for(int j=i+1;j&lt;=n;j++)&#123;</span><br><span class="line">if(distance_(i,j)&gt;=10.0&amp;&amp;distance_(i,j)&lt;=1000.0)&#123;//生成边集的时候就把不要的排除了</span><br><span class="line">Edge[cnt].u=i;</span><br><span class="line">Edge[cnt].v=j;</span><br><span class="line">Edge[cnt].cap=distance_(i,j); </span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans=0;</span><br><span class="line">kruskal();</span><br><span class="line">if(ed==n-1)printf(&quot;%.1f\n&quot;,ans*100);</span><br><span class="line">else printf(&quot;oh!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hdu 1863 畅通工程（最小生成树）</title>
      <link href="/2018/08/19/hdu%201863%20%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89/"/>
      <url>/2018/08/19/hdu%201863%20%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="hdu-1863-畅通工程（最小生成树）"><a href="#hdu-1863-畅通工程（最小生成树）" class="headerlink" title="hdu 1863 畅通工程（最小生成树）"></a>hdu 1863 畅通工程（最小生成树）</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1863" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1863</a></p><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可）。经过调查评估，得到的统计表中列出了有可能建设公路的若干条道路的成本。现请你编写程序，计算出全省畅通需要的最低成本。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>测试输入包含若干测试用例。每个测试用例的第1行给出评估的道路条数 N、村庄数目M ( &lt; 100 )；随后的 N<br>行对应村庄间道路的成本，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间道路的成本（也是正整数）。为简单起见，村庄从1到M编号。当N为0时，全部输入结束，相应的结果不要输出。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对每个测试用例，在1行里输出全省畅通需要的最低成本。若统计数据不足以保证畅通，则输出“?”。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 1</span><br><span class="line">1 3 2</span><br><span class="line">2 3 4</span><br><span class="line">1 3</span><br><span class="line">2 3 2</span><br><span class="line">0 100</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">?</span><br></pre></td></tr></table></figure><hr><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>给出边 求最小生成树 </p><p>如果无法连通 输出“?”</p><p>因为要判断最后是否连通 所以用kruskal 最后只要先记录一个点的父亲 然后判断剩余点是否全部和它相同即可</p><p>不满足连通条件的情况：</p><ul><li>（点&lt;=边+1）的不行</li><li>最后所有结点不在一个根的不行</li></ul><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=105;</span><br><span class="line">struct Edge&#123;</span><br><span class="line">int u,v;</span><br><span class="line">int cap;</span><br><span class="line">&#125;Edge[N*N];//边集 </span><br><span class="line">int n,ans,num; </span><br><span class="line">int fa[N];</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">if(x!=fa[x])fa[x]=find(fa[x]);</span><br><span class="line">return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">int a=find(x),b=find(y);</span><br><span class="line">if(a==b)return;</span><br><span class="line">else&#123;</span><br><span class="line">fa[a]=b;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">bool cmp(struct Edge a,struct Edge b)&#123;</span><br><span class="line">return a.cap&lt;b.cap;</span><br><span class="line">&#125;</span><br><span class="line">void kruskal()&#123;</span><br><span class="line">sort(Edge,Edge+num,cmp);//按边的最小代价排序 </span><br><span class="line">for(int i=1;i&lt;=num;i++)&#123;</span><br><span class="line">int fx=find(Edge[i].u),fy=find(Edge[i].v);</span><br><span class="line">if(fx==fy)continue;</span><br><span class="line">ans+=Edge[i].cap;//u，v不在一棵树上，就加上这条边 </span><br><span class="line">join(fx,fy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">while(scanf(&quot;%d%d&quot;,&amp;num,&amp;n)!=EOF)&#123;</span><br><span class="line">if(num==0)&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">fa[i]=i;</span><br><span class="line">&#125;</span><br><span class="line">int p,q,w;</span><br><span class="line">for(int i=1;i&lt;=num;i++)&#123;</span><br><span class="line">scanf(&quot;%d%d%d&quot;,&amp;p,&amp;q,&amp;w);</span><br><span class="line">Edge[i].u=p;</span><br><span class="line">Edge[i].v=q;</span><br><span class="line">Edge[i].cap=w;</span><br><span class="line">&#125;</span><br><span class="line">ans=0;</span><br><span class="line">kruskal();</span><br><span class="line">int flag=1;</span><br><span class="line">for(int i=2;i&lt;=num;i++)&#123;</span><br><span class="line">if(find(i)!=find(1))&#123;</span><br><span class="line">flag=0;break;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">if(num&lt;n-1)printf(&quot;?\n&quot;);</span><br><span class="line">else if(flag==1)printf(&quot;%d\n&quot;,ans);</span><br><span class="line">else printf(&quot;?\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hdu 1301 Jungle Roads（最小生成树）</title>
      <link href="/2018/08/19/hdu%201301%20Jungle%20Roads%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89/"/>
      <url>/2018/08/19/hdu%201301%20Jungle%20Roads%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="hdu-1301-Jungle-Roads（最小生成树）"><a href="#hdu-1301-Jungle-Roads（最小生成树）" class="headerlink" title="hdu 1301 Jungle Roads（最小生成树）"></a>hdu 1301 Jungle Roads（最小生成树）</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1301" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1301</a></p><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p><img src="http://acm.hdu.edu.cn/data/images/1301-1.gif" alt=""></p><p>The Head Elder of the tropical island of Lagrishan has a problem. A burst of foreign aid money was spent on extra roads between villages some years ago. But the jungle overtakes roads relentlessly, so the large road network is too expensive to maintain. The Council of Elders must choose to stop maintaining some roads. The map above on the left shows all the roads in use now and the cost in aacms per month to maintain them. Of course there needs to be some way to get between all the villages on maintained roads, even if the route is not as short as before. The Chief Elder would like to tell the Council of Elders what would be the smallest amount they could spend in aacms per month to maintain roads that would connect all the villages. The villages are labeled A through I in the maps above. The map on the right shows the roads that could be maintained most cheaply, for 216 aacms per month. Your task is to write a program that will solve such problems. </p><p>The input consists of one to 100 data sets, followed by a final line containing only 0. Each data set starts with a line containing only a number n, which is the number of villages, 1 &lt; n &lt; 27, and the villages are labeled with the first n letters of the alphabet, capitalized. Each data set is completed with n-1 lines that start with village labels in alphabetical order. There is no line for the last village. Each line for a village starts with the village label followed by a number, k, of roads from this village to villages with labels later in the alphabet. If k is greater than 0, the line continues with data for each of the k roads. The data for each road is the village label for the other end of the road followed by the monthly maintenance cost in aacms for the road. Maintenance costs will be positive integers less than 100. All data fields in the row are separated by single blanks. The road network will always allow travel between all the villages. The network will never have more than 75 roads. No village will have more than 15 roads going to other villages (before or after in the alphabet). In the sample input below, the first data set goes with the map above. </p><p>The output is one integer per line for each data set: the minimum cost in aacms per month to maintain a road system that connect all the villages. Caution: A brute force solution that examines every possible set of roads will not finish within the one minute time limit. </p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">A 2 B 12 I 25</span><br><span class="line">B 3 C 10 H 40 I 8</span><br><span class="line">C 2 D 18 G 55</span><br><span class="line">D 1 E 44</span><br><span class="line">E 2 F 60 G 38</span><br><span class="line">F 0</span><br><span class="line">G 1 H 35</span><br><span class="line">H 1 I 35</span><br><span class="line">3</span><br><span class="line">A 2 B 10 C 40</span><br><span class="line">B 1 C 20</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">216</span><br><span class="line">30</span><br></pre></td></tr></table></figure><hr><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>一看图就是个最小生成树。。</p><p>注意回车要用getchar()搞掉</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=30;</span><br><span class="line">struct Edge&#123;</span><br><span class="line">int u,v;</span><br><span class="line">double cap;</span><br><span class="line">&#125;Edge[N*N];</span><br><span class="line">int n,ans,cnt; </span><br><span class="line">int fa[N];</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">if(x!=fa[x])fa[x]=find(fa[x]);</span><br><span class="line">return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">int a=find(x),b=find(y);</span><br><span class="line">if(a==b)return;</span><br><span class="line">else&#123;</span><br><span class="line">fa[a]=b;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">bool cmp(struct Edge a,struct Edge b)&#123;</span><br><span class="line">return a.cap&lt;b.cap;</span><br><span class="line">&#125;</span><br><span class="line">void kruskal()&#123;</span><br><span class="line">sort(Edge,Edge+cnt,cmp);</span><br><span class="line">for(int i=0;i&lt;cnt;i++)&#123;</span><br><span class="line">int fx=find(Edge[i].u),fy=find(Edge[i].v);</span><br><span class="line">if(fx==fy)continue;</span><br><span class="line">ans+=Edge[i].cap;</span><br><span class="line">join(fx,fy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">while(scanf(&quot;%d&quot;,&amp;n)!=EOF)&#123;</span><br><span class="line">if(n==0)break;</span><br><span class="line">for(int i=1;i&lt;N;i++)fa[i]=i;</span><br><span class="line">cnt=0;</span><br><span class="line">for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">char x,y;</span><br><span class="line">int xnum,c;</span><br><span class="line">getchar();</span><br><span class="line">scanf(&quot;%c %d&quot;,&amp;x,&amp;xnum);</span><br><span class="line">while(xnum--)&#123;</span><br><span class="line">getchar();</span><br><span class="line">scanf(&quot;%c %d&quot;,&amp;y,&amp;c);</span><br><span class="line">Edge[cnt].u=(int)(x-&apos;A&apos;+1);</span><br><span class="line">Edge[cnt].v=(int)(y-&apos;A&apos;+1);</span><br><span class="line">Edge[cnt].cap=c;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans=0;</span><br><span class="line">kruskal();</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hdu 1233 还是畅通工程（最小生成树）</title>
      <link href="/2018/08/19/hdu%201233%20%E8%BF%98%E6%98%AF%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89/"/>
      <url>/2018/08/19/hdu%201233%20%E8%BF%98%E6%98%AF%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>#hdu 1233 还是畅通工程（最小生成树）<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1233" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1233</a></p><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>某省调查乡村交通状况，得到的统计表中列出了任意两村庄间的距离。省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可），并要求铺设的公路总长度为最小。请计算最小的公路总长度。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>测试输入包含若干测试用例。每个测试用例的第1行给出村庄数目N ( &lt; 100 )；随后的N(N-1)/2行对应村庄间的距离，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间的距离。为简单起见，村庄从1到N编号。<br>当N为0时，输入结束，该用例不被处理。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对每个测试用例，在1行里输出最小的公路总长度。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 1</span><br><span class="line">1 3 2</span><br><span class="line">2 3 4</span><br><span class="line">4</span><br><span class="line">1 2 1</span><br><span class="line">1 3 4</span><br><span class="line">1 4 1</span><br><span class="line">2 3 3</span><br><span class="line">2 4 2</span><br><span class="line">3 4 5</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br></pre></td></tr></table></figure><hr><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>最小生成树 写的Kruskal</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=105;</span><br><span class="line">struct Edge&#123;</span><br><span class="line">int u,v;</span><br><span class="line">int cap;</span><br><span class="line">&#125;Edge[N*N];//边集 </span><br><span class="line">int n,ans,num; </span><br><span class="line">int fa[N];</span><br><span class="line">void init()&#123;</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">fa[i]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">if(x!=fa[x])fa[x]=find(fa[x]);</span><br><span class="line">return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">int a=find(x),b=find(y);</span><br><span class="line">if(a==b)return;</span><br><span class="line">else&#123;</span><br><span class="line">fa[a]=b;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">bool cmp(struct Edge a,struct Edge b)&#123;</span><br><span class="line">return a.cap&lt;b.cap;</span><br><span class="line">&#125;</span><br><span class="line">void kruskal()&#123;</span><br><span class="line">sort(Edge,Edge+num,cmp);//按边的最小代价排序 </span><br><span class="line">for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">int fx=find(Edge[i].u),fy=find(Edge[i].v);</span><br><span class="line">if(fx==fy)continue;</span><br><span class="line">ans+=Edge[i].cap;//u，v不在一棵树上，就加上这条边 </span><br><span class="line">join(fx,fy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">while(scanf(&quot;%d&quot;,&amp;n)!=EOF&amp;&amp;n)&#123;</span><br><span class="line">num=n*(n-1)/2;</span><br><span class="line">init();</span><br><span class="line">int p,q,w;</span><br><span class="line">for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">scanf(&quot;%d%d%d&quot;,&amp;p,&amp;q,&amp;w);</span><br><span class="line">Edge[i].u=p;</span><br><span class="line">Edge[i].v=q;</span><br><span class="line">Edge[i].cap=w;</span><br><span class="line">&#125;</span><br><span class="line">ans=0;</span><br><span class="line">kruskal();</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hdu 1162 Eddy&#39;s picture（最小生成树）</title>
      <link href="/2018/08/19/hdu%201162%20Eddy&#39;s%20picture%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89/"/>
      <url>/2018/08/19/hdu%201162%20Eddy&#39;s%20picture%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="hdu-1162-Eddy’s-picture（最小生成树）"><a href="#hdu-1162-Eddy’s-picture（最小生成树）" class="headerlink" title="hdu 1162 Eddy’s picture（最小生成树）"></a>hdu 1162 Eddy’s picture（最小生成树）</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1162" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1162</a></p><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Eddy begins to like painting pictures recently ,he is sure of himself to become a painter.Every day Eddy draws pictures in his small room, and he usually puts out his newest pictures to let his friends appreciate. but the result it can be imagined, the friends are not interested in his picture.Eddy feels very puzzled,in order to change all friends ‘s view to his technical of painting pictures ,so Eddy creates a problem for the his friends of you.<br>Problem descriptions as follows: Given you some coordinates pionts on a drawing paper, every point links with the ink with the straight line, causes all points finally to link in the same place. How many distants does your duty discover the shortest length which the ink draws?</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains 0 &lt; n &lt;= 100, the number of point. For each point, a line follows; each following line contains two real numbers indicating the (x,y) coordinates of the point. </p><p>Input contains multiple test cases. Process to the end of file.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Your program prints a single real number to two decimal places: the minimum total length of ink lines that can connect all the points. </p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1.0 1.0</span><br><span class="line">2.0 2.0</span><br><span class="line">2.0 4.0</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.41</span><br></pre></td></tr></table></figure><hr><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给n个点的坐标 求最小生成树</p><p>只要预处理一下边长就没别的了</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=105;</span><br><span class="line">struct Edge&#123;</span><br><span class="line">int u,v;</span><br><span class="line">double cap;</span><br><span class="line">&#125;Edge[N*N];</span><br><span class="line">struct Node&#123;</span><br><span class="line">float x,y;</span><br><span class="line">&#125;Node[N];</span><br><span class="line">int n,num,cnt;</span><br><span class="line">double ans; </span><br><span class="line">int fa[N];</span><br><span class="line">double distance_(int a,int b)&#123;</span><br><span class="line">return sqrt((Node[a].x-Node[b].x)*(Node[a].x-Node[b].x)+(Node[a].y-Node[b].y)*(Node[a].y-Node[b].y));</span><br><span class="line">&#125;</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">if(x!=fa[x])fa[x]=find(fa[x]);</span><br><span class="line">return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">int a=find(x),b=find(y);</span><br><span class="line">if(a==b)return;</span><br><span class="line">else&#123;</span><br><span class="line">fa[a]=b;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">bool cmp(struct Edge a,struct Edge b)&#123;</span><br><span class="line">return a.cap&lt;b.cap;</span><br><span class="line">&#125;</span><br><span class="line">void kruskal()&#123;</span><br><span class="line">sort(Edge,Edge+num+1,cmp);</span><br><span class="line">for(int i=0;i&lt;=num;i++)&#123;</span><br><span class="line">int fx=find(Edge[i].u),fy=find(Edge[i].v);</span><br><span class="line">if(fx==fy)continue;</span><br><span class="line">ans+=Edge[i].cap;</span><br><span class="line">join(fx,fy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">while(scanf(&quot;%d&quot;,&amp;n)!=EOF)&#123;</span><br><span class="line">if(n==0)&#123;</span><br><span class="line">printf(&quot;0\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">scanf(&quot;%f%f&quot;,&amp;Node[i].x,&amp;Node[i].y);</span><br><span class="line">fa[i]=i;</span><br><span class="line">&#125;</span><br><span class="line">cnt=0;</span><br><span class="line">num=n*(n-1)/2;</span><br><span class="line">for(int i=1;i&lt;=n-1;i++)&#123;</span><br><span class="line">for(int j=i+1;j&lt;=n;j++)&#123;</span><br><span class="line">Edge[cnt].u=i;</span><br><span class="line">Edge[cnt].v=j;</span><br><span class="line">Edge[cnt].cap=distance_(i,j); </span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans=0;</span><br><span class="line">kruskal();</span><br><span class="line">printf(&quot;%.2f\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hdu 1102 Constructing Roads(最小生成树)</title>
      <link href="/2018/08/19/hdu%201102%20Constructing%20Roads(%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91)/"/>
      <url>/2018/08/19/hdu%201102%20Constructing%20Roads(%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91)/</url>
      <content type="html"><![CDATA[<h1 id="hdu-1102-Constructing-Roads-最小生成树"><a href="#hdu-1102-Constructing-Roads-最小生成树" class="headerlink" title="hdu 1102 Constructing Roads(最小生成树)"></a>hdu 1102 Constructing Roads(最小生成树)</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1102" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1102</a><br>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)</p><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>There are N villages, which are numbered from 1 to N, and you should build some roads such that every two villages can connect to each other. We say two village A and B are connected, if and only if there is a road between A and B, or there exists a village C such that there is a road between A and C, and C and B are connected. </p><p>We know that there are already some roads between some villages and your job is the build some roads such that all the villages are connect and the length of all the roads built is minimum.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line is an integer N (3 &lt;= N &lt;= 100), which is the number of villages. Then come N lines, the i-th of which contains N integers, and the j-th of these N integers is the distance (the distance should be an integer within [1, 1000]) between village i and village j.</p><p>Then there is an integer Q (0 &lt;= Q &lt;= N * (N + 1) / 2). Then come Q lines, each line contains two integers a and b (1 &lt;= a &lt; b &lt;= N), which means the road between village a and village b has been built.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>You should output a line contains an integer, which is the length of all the roads to be built such that all the villages are connected, and this value is minimum. </p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">0 990 692</span><br><span class="line">990 0 179</span><br><span class="line">692 179 0</span><br><span class="line">1</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">179</span><br></pre></td></tr></table></figure><hr><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>裸的最小生成树的题 两种算法都放上 </p><p>prim加点 kruskal加边</p><p>现在整理以前的代码感觉以前写的好详细。。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p><code>Prim</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=105;</span><br><span class="line">const int INF=0x3f3f3f3f;</span><br><span class="line">int n,ans;</span><br><span class="line">int map_[N][N],dis[N],vis[N];</span><br><span class="line">void prim()&#123;</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">dis[i]=map_[1][i];</span><br><span class="line">vis[i]=0;</span><br><span class="line">&#125;</span><br><span class="line">dis[1]=0;</span><br><span class="line">vis[1]=1;</span><br><span class="line">int k,tmp;</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">tmp=INF;</span><br><span class="line">for(int j=1;j&lt;=n;j++)&#123;//在从i到j还没访问过的j中找出代价最小的 </span><br><span class="line">if(!vis[j]&amp;&amp;tmp&gt;dis[j])&#123;</span><br><span class="line">k=j;</span><br><span class="line">tmp=dis[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(tmp==INF)break;//没找到即全部访问过了，prim结束 </span><br><span class="line">vis[k]=1;//给k标记已访问 </span><br><span class="line">ans+=dis[k];</span><br><span class="line">for(int j=1;j&lt;=n;j++)&#123;//加入从k出发的最短路 </span><br><span class="line">if(!vis[j]&amp;&amp;dis[j]&gt;map_[k][j])&#123;</span><br><span class="line">dis[j]=map_[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">while(scanf(&quot;%d&quot;,&amp;n)!=EOF)&#123;</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;map_[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int q,a,b;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;q);</span><br><span class="line">while(q--)&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">map_[a][b]=map_[b][a]=0;</span><br><span class="line">&#125;</span><br><span class="line">ans=0;</span><br><span class="line">prim();</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Kruskal</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=105;</span><br><span class="line">struct Edge&#123;</span><br><span class="line">int u,v;</span><br><span class="line">int cap;</span><br><span class="line">&#125;Edge[N*N];</span><br><span class="line">int n,ans,cnt;//cnt为边数 </span><br><span class="line">int fa[N];</span><br><span class="line">void init()&#123;</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">fa[i]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">if(x!=fa[x])fa[x]=find(fa[x]);</span><br><span class="line">return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">int a=find(x),b=find(y);</span><br><span class="line">if(a==b)return;</span><br><span class="line">else&#123;</span><br><span class="line">fa[a]=b;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">bool cmp(struct Edge a,struct Edge b)&#123;</span><br><span class="line">return a.cap&lt;b.cap;</span><br><span class="line">&#125;</span><br><span class="line">void kruskal()&#123;</span><br><span class="line">sort(Edge,Edge+cnt,cmp);//按边的最小代价排序 </span><br><span class="line">for(int i=0;i&lt;cnt;i++)&#123;</span><br><span class="line">int fx=find(Edge[i].u),fy=find(Edge[i].v);</span><br><span class="line">if(fx==fy)continue;</span><br><span class="line">ans+=Edge[i].cap;//u，v不在一棵树上，就加上这条边 </span><br><span class="line">join(fx,fy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">while(scanf(&quot;%d&quot;,&amp;n)!=EOF)&#123;</span><br><span class="line">init();</span><br><span class="line">cnt=0;</span><br><span class="line">int w;</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;w);</span><br><span class="line">Edge[cnt].u=i;</span><br><span class="line">Edge[cnt].v=j;</span><br><span class="line">Edge[cnt].cap=w;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int q,u,v;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;q);</span><br><span class="line">while(q--)&#123;//建树 </span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">join(u,v);</span><br><span class="line">&#125;</span><br><span class="line">ans=0;</span><br><span class="line">kruskal();</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hdu 1198 Farm Irrigation（并查集）</title>
      <link href="/2018/08/18/hdu%201198%20Farm%20Irrigation%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89/"/>
      <url>/2018/08/18/hdu%201198%20Farm%20Irrigation%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="hdu-1198-Farm-Irrigation（并查集）"><a href="#hdu-1198-Farm-Irrigation（并查集）" class="headerlink" title="hdu 1198 Farm Irrigation（并查集）"></a>hdu 1198 Farm Irrigation（并查集）</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1198" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1198</a></p><p>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)</p><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Benny has a spacious farm land to irrigate. The farm land is a rectangle, and is divided into a lot of samll squares. Water pipes are placed in these squares. Different square has a different type of pipe. There are 11 types of pipes, which is marked from A to K, as Figure 1 shows.</p><p><img src="http://acm.hdu.edu.cn/data/images/1121-1.gif" alt=""></p><p>Benny has a map of his farm, which is an array of marks denoting the distribution of water pipes over the whole farm. For example, if he has a map </p><p>ADC<br>FJK<br>IHE   </p><p>then the water pipes are distributed like </p><p><img src="http://acm.hdu.edu.cn/data/images/1121-2.gif" alt=""></p><p>Several wellsprings are found in the center of some squares, so water can flow along the pipes from one square to another. If water flow crosses one square, the whole farm land in this square is irrigated and will have a good harvest in autumn. </p><p>Now Benny wants to know at least how many wellsprings should be found to have the whole farm land irrigated. Can you help him? </p><p>Note: In the above example, at least 3 wellsprings are needed, as those red points in Figure 2 show.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>There are several test cases! In each test case, the first line contains 2 integers M and N, then M lines follow. In each of these lines, there are N characters, in the range of ‘A’ to ‘K’, denoting the type of water pipe over the corresponding square. A negative M or N denotes the end of input, else you can assume 1 &lt;= M, N &lt;= 50.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, output in one line the least number of wellsprings needed.</p><p><strong>Sample Input</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2 2</span><br><span class="line">DK</span><br><span class="line">HF</span><br><span class="line">3 3</span><br><span class="line">ADC</span><br><span class="line">FJK</span><br><span class="line">IHE</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><p><strong>Sample Output</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><hr><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>一个并查集好题</p><p>水管连通本质上就是集合的合并，最后求有几个集合的问题，很容易想到并查集</p><p>只需要对每个地块与右方和下方的地块进行合并即可，合并之前先判断是否能连通，若能连通则合并，不能连通，则不能合并</p><p>每个地块的四个方向用数组的01来表示，用位运算来判断可连性</p><p>具体见代码注释</p><p>还有一种二进制的位运算写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const int type[11] = &#123;3,6,9,12,10,5,7,11,13,14,15&#125;; </span><br><span class="line"></span><br><span class="line">if(dir==1)&#123;</span><br><span class="line">    if(((type[ta]&gt;&gt;3) &amp; 1) &amp;&amp; ((type[tb]&gt;&gt;1) &amp; 1))mark = true;  </span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    if(((type[ta]&gt;&gt;2) &amp; 1) &amp;&amp; (type[tb] &amp; 1))mark = true;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=505;</span><br><span class="line">const int type[11][4]=&#123; &#123;1,1,0,0&#125;,&#123;0,1,1,0&#125;,&#123;1,0,0,1&#125;,&#123;0,0,1,1&#125;,&#123;0,1,0,1&#125;,&#123;1,0,1,0&#125;,&#123;1,1,1,0&#125;,&#123;1,1,0,1&#125;,&#123;1,0,1,1&#125;,&#123;0,1,1,1&#125;,&#123;1,1,1,1&#125; &#125;;</span><br><span class="line">int n,m,num,cnt; </span><br><span class="line">int fa[N*N+1];</span><br><span class="line">char f[N][N]; </span><br><span class="line">int find(int x)&#123;</span><br><span class="line">if(x!=fa[x])fa[x]=find(fa[x]);</span><br><span class="line">return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">void join(int x1,int y1,int x2,int y2,int dir)&#123;</span><br><span class="line">if(x2&gt;n||y2&gt;m)return;//超出地图不合并</span><br><span class="line">bool flag=false;//标记是否可连通 </span><br><span class="line">int t1,t2;</span><br><span class="line">t1=f[x1][y1]-&apos;A&apos;;</span><br><span class="line">t2=f[x2][y2]-&apos;A&apos;; </span><br><span class="line">if(dir==1)&#123;</span><br><span class="line">if(type[t1][3]&amp;&amp;type[t2][1])flag=true;//竖直方向 </span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">if(type[t1][2]&amp;&amp;type[t2][0])flag=true;//水平方向 </span><br><span class="line">&#125;</span><br><span class="line">if(flag)&#123;//合并 </span><br><span class="line">int a=find((x1-1)*m+y1),b=find((x2-1)*m+y2);</span><br><span class="line">if(a!=b)&#123;</span><br><span class="line">fa[b]=a;</span><br><span class="line">--cnt;//消去一个水井 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)&#123;</span><br><span class="line">if(n==-1&amp;&amp;m==-1)break;</span><br><span class="line">for(int i=1;i&lt;=n*m;i++)&#123;</span><br><span class="line">fa[i]=i;</span><br><span class="line">&#125;</span><br><span class="line">cnt=n*m;//初始化，假设所有田里都有水井 </span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">scanf(&quot;%s&quot;,f[i]+1);</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;//统一向右or下合并 </span><br><span class="line">for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">join(i,j,i+1,j,1);//竖直 </span><br><span class="line">join(i,j,i,j+1,0);//水平 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;,cnt);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hdu 1856 More is better（并查集）</title>
      <link href="/2018/08/18/hdu%201856%20More%20is%20better/"/>
      <url>/2018/08/18/hdu%201856%20More%20is%20better/</url>
      <content type="html"><![CDATA[<h1 id="hdu-1856-More-is-better（并查集）"><a href="#hdu-1856-More-is-better（并查集）" class="headerlink" title="hdu 1856 More is better（并查集）"></a>hdu 1856 More is better（并查集）</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1856" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1856</a></p><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Mr Wang wants some boys to help him with a project. Because the project is rather complex, the more boys come, the better it will be. Of course there are certain requirements.</p><p>Mr Wang selected a room big enough to hold the boys. The boy who are not been chosen has to leave the room immediately. There are 10000000 boys in the room numbered from 1 to 10000000 at the very beginning. After Mr Wang’s selection any two of them who are still in this room should be friends (direct or indirect), or there is only one boy left. Given all the direct friend-pairs, you should decide the best way.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input contains an integer n (0 &lt;= n &lt;= 100000) - the number of direct friend-pairs. The following n lines each contains a pair of numbers A and B separated by a single space that suggests A and B are direct friends. (A != B, 1 &lt;= A, B &lt;= 10000000) </p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>The output in one line contains exactly one integer equals to the maximum number of boys Mr Wang may keep. </p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br><span class="line">5 6</span><br><span class="line">1 6</span><br><span class="line">4</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br><span class="line">5 6</span><br><span class="line">7 8</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">2</span><br></pre></td></tr></table></figure><hr><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>一开始1e7个人，有n对朋友，a和b是朋友</p><p>最后剩下的人必须直接或间接是朋友 求剩下人数的最大值</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>求每个集合中元素的个数，然后求个数的最大值</p><p>求集合个数的方法:只需要在合并两个集合时处理一下，让这两个集合的元素个数也合并一下就行了</p><p>要注意的一个地方就是：当n=0时特判，没人是朋友，最多选一个人要输出1</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=100005;</span><br><span class="line">int fa[N],sum[N];</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">int tmp=x;</span><br><span class="line">while(tmp!=fa[tmp])tmp=fa[tmp];</span><br><span class="line">fa[x]=tmp;</span><br><span class="line">return tmp;</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">int a,b;</span><br><span class="line">a=find(x);b=find(y);</span><br><span class="line">if(a!=b)&#123;</span><br><span class="line">fa[a]=b;</span><br><span class="line">sum[b]+=sum[a];//合并集合中元素个数 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int n;</span><br><span class="line">while(scanf(&quot;%d&quot;,&amp;n)!=EOF)&#123;</span><br><span class="line">if(n==0)&#123;</span><br><span class="line">printf(&quot;1\n&quot;);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">fa[i]=i;</span><br><span class="line">sum[i]=1;//开始时数量的都为1 </span><br><span class="line">&#125;</span><br><span class="line">int num=0;</span><br><span class="line">while(n--)&#123;</span><br><span class="line">int a,b;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">num=a&gt;num?a:num;</span><br><span class="line">num=b&gt;num?b:num;</span><br><span class="line">join(a,b);</span><br><span class="line">&#125;</span><br><span class="line">int ans=0;</span><br><span class="line">for(int i=1;i&lt;=num;i++)&#123;</span><br><span class="line">ans=sum[i]&gt;ans?sum[i]:ans;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hdu 1232 畅通工程（并查集）</title>
      <link href="/2018/08/18/hdu%201232%20%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89/"/>
      <url>/2018/08/18/hdu%201232%20%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="hdu-1232-畅通工程（并查集）"><a href="#hdu-1232-畅通工程（并查集）" class="headerlink" title="hdu 1232 畅通工程（并查集）"></a>hdu 1232 畅通工程（并查集）</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1232" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1232</a></p><p>Time Limit: 4000/2000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)</p><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。 </p><p>注意:两个城市之间可以有多条道路相通,也就是说</p><p>3 3<br>1 2<br>1 2<br>2 1<br>这种输入也是合法的</p><p>当N为0时，输入结束，该用例不被处理。 </p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对每个测试用例，在1行里输出最少还需要建设的道路数目。 </p><p><strong>Sample Input</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">4 2</span><br><span class="line">1 3</span><br><span class="line">4 3</span><br><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">5 2</span><br><span class="line">1 2</span><br><span class="line">3 5</span><br><span class="line">999 0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>Sample Output</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">998</span><br></pre></td></tr></table></figure><hr><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>初始化时每个城镇都没有路，所以总共要连接的路的数量为n-1个，在增加路的过程中，先用并查集判断，如果两个城镇确实不在一个集合，这条路就有用，两个城镇归为一个集合中，要连接的路减一。如果两个城镇之前就已经在一个集合里，增加的这条路就无用，要连接的路不变</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=100005;</span><br><span class="line">int fa[N];</span><br><span class="line">int ed;</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">int tmp=x;</span><br><span class="line">while(tmp!=fa[tmp])tmp=fa[tmp];</span><br><span class="line">fa[x]=tmp;</span><br><span class="line">return tmp;</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">int a,b;</span><br><span class="line">a=find(x);b=find(y);</span><br><span class="line">if(a!=b)&#123;</span><br><span class="line">fa[a]=b;</span><br><span class="line">ed++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int m,n,a,b;</span><br><span class="line">while(1)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">if(n==0)break;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">ed=0;</span><br><span class="line">for(int i=1;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">while(m--)&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">join(a,b);</span><br><span class="line">&#125;</span><br><span class="line">int k=0,flag=1;</span><br><span class="line">int ans=n-1-ed;</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hdu 1272 小希的迷宫（并查集）</title>
      <link href="/2018/08/18/hdu%201272%20%E5%B0%8F%E5%B8%8C%E7%9A%84%E8%BF%B7%E5%AE%AB%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89/"/>
      <url>/2018/08/18/hdu%201272%20%E5%B0%8F%E5%B8%8C%E7%9A%84%E8%BF%B7%E5%AE%AB%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="hdu-1272-小希的迷宫（并查集）"><a href="#hdu-1272-小希的迷宫（并查集）" class="headerlink" title="hdu 1272 小希的迷宫（并查集）"></a>hdu 1272 小希的迷宫（并查集）</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1272" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1272</a><br>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)</p><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>上次Gardon的迷宫城堡小希玩了很久（见Problem B），现在她也想设计一个迷宫让Gardon来走。但是她设计迷宫的思路不一样，首先她认为所有的通道都应该是双向连通的，就是说如果有一个通道连通了房间A和B，那么既可以通过它从房间A走到房间B，也可以通过它从房间B走到房间A，为了提高难度，小希希望任意两个房间有且仅有一条路径可以相通（除非走了回头路）。小希现在把她的设计图给你，让你帮忙判断她的设计图是否符合她的设计思路。比如下面的例子，前两个是符合条件的，但是最后一个却有两种方法从5到达8。<br><img src="http://acm.hdu.edu.cn/data/images/C20-1007-1.jpg" alt=""></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入包含多组数据，每组数据是一个以0 0结尾的整数对列表，表示了一条通道连接的两个房间的编号。房间的编号至少为1，且不超过100000。每两组数据之间有一个空行。<br>整个文件以两个-1结尾。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于输入的每一组数据，输出仅包括一行。如果该迷宫符合小希的思路，那么输出”Yes”，否则输出”No”。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">6 8  5 3  5 2  6 4</span><br><span class="line">5 6  0 0</span><br><span class="line"></span><br><span class="line">8 1  7 3  6 2  8 9  7 5</span><br><span class="line">7 4  7 8  7 6  0 0</span><br><span class="line"></span><br><span class="line">3 8  6 8  6 4</span><br><span class="line">5 3  5 6  5 2  0 0</span><br><span class="line"></span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure><hr><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><ul><li>保证图是连通的，且连通分量为1</li><li>不存在环（包括自环）</li></ul><p>因为这是一个无向图，只要保证 顶点数 = 边数+1 ， 就可以说明是连通的</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line">const int N=100005;</span><br><span class="line">int fa[N];</span><br><span class="line">bool vis[N];</span><br><span class="line">bool circle;//判断是否成环</span><br><span class="line">int ed,v;//边数和顶点数 </span><br><span class="line">int find(int x)&#123;</span><br><span class="line">int tmp=x;</span><br><span class="line">while(tmp!=fa[tmp])tmp=fa[tmp];</span><br><span class="line">fa[x]=tmp;</span><br><span class="line">return tmp;</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">if(x==y)circle=true;</span><br><span class="line">int a,b;</span><br><span class="line">a=find(x);b=find(y);</span><br><span class="line">if(a!=b)&#123;</span><br><span class="line">fa[a]=b;</span><br><span class="line">ed++;//多一条边 </span><br><span class="line">&#125;</span><br><span class="line">else circle=true;//要join(x,y)，而a=b说明 x,y是同一祖先，再连起来就成环了 </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int a,b;</span><br><span class="line">while(1)&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">circle=false;</span><br><span class="line">ed=0;v=0; </span><br><span class="line">for(int i=1;i&lt;N;i++)fa[i]=i;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">if(a==0&amp;&amp;b==0)&#123;//空树特判 </span><br><span class="line">puts(&quot;Yes&quot;);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">if(a==-1&amp;&amp;b==-1)return 0;</span><br><span class="line">vis[a]=true;vis[b]=true;</span><br><span class="line">join(a,b);</span><br><span class="line">while(1)&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">if(a==0&amp;&amp;b==0)break;</span><br><span class="line">join(a,b);</span><br><span class="line">vis[a]=true;vis[b]=true;</span><br><span class="line">&#125;</span><br><span class="line">int k=0,flag=1;</span><br><span class="line">for(int i=1;i&lt;N;i++)&#123;</span><br><span class="line">if(vis[i])v++;</span><br><span class="line">&#125;</span><br><span class="line">if(!circle&amp;&amp;ed+1==v)puts(&quot;Yes&quot;);</span><br><span class="line">else puts(&quot;No&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hdu 1325 Is it a tree？（并查集）</title>
      <link href="/2018/08/18/hdu%201325%20Is%20it%20a%20tree%EF%BC%9F/"/>
      <url>/2018/08/18/hdu%201325%20Is%20it%20a%20tree%EF%BC%9F/</url>
      <content type="html"><![CDATA[<h1 id="hdu-1325-Is-it-a-tree？"><a href="#hdu-1325-Is-it-a-tree？" class="headerlink" title="hdu 1325 Is it a tree？"></a>hdu 1325 Is it a tree？</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1325" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1325</a><br><img src="/2018/08/18/hdu 1325 Is it a tree？/0.png" alt=""></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input will consist of a sequence of descriptions (test cases) followed by a pair of negative integers. Each test case will consist of a sequence of edge descriptions followed by a pair of zeroes Each edge description will consist of a pair of integers; the first integer identifies the node from which the edge begins, and the second integer identifies the node to which the edge is directed. Node numbers will always be greater than zero. </p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case display the line <code>Case k is a tree.&quot; or the line</code>Case k is not a tree.”, where k corresponds to the test case number (they are sequentially numbered starting with 1). </p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6 8 5 3 5 2 6 4</span><br><span class="line">5 6 0 0</span><br><span class="line">8 1 7 3 6 2 8 9 7 5</span><br><span class="line">7 4 7 8 7 6 0 0</span><br><span class="line">3 8 6 8 6 4</span><br><span class="line">5 3 5 6 5 2 0 0</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Case 1 is a tree.</span><br><span class="line">Case 2 is a tree.</span><br><span class="line">Case 3 is not a tree.</span><br></pre></td></tr></table></figure><hr><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>按题意判断是不是一棵树</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>类似hdu1272</p><ul><li>无环；   </li><li>除了根，所有的入度为1，根入度为0；   </li><li>这个结构只有一个根，空树也是树。  </li></ul><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line">const int N=100005;</span><br><span class="line">int fa[N];</span><br><span class="line">bool vis[N];</span><br><span class="line">bool circle;//判断是否成环</span><br><span class="line">int du[N];</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">int tmp=x;</span><br><span class="line">while(tmp!=fa[tmp])tmp=fa[tmp];</span><br><span class="line">fa[x]=tmp;</span><br><span class="line">return tmp;</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">du[y]++;</span><br><span class="line">if(x==y)circle=true;</span><br><span class="line">int a,b;</span><br><span class="line">a=find(x);b=find(y);</span><br><span class="line">if(a!=b)&#123;</span><br><span class="line">fa[a]=b;</span><br><span class="line">&#125;</span><br><span class="line">else circle=true;//要join(x,y)，而a=b说明 x,y是同一祖先，再连起来就成环了 </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int a,b;</span><br><span class="line">int cas=1; </span><br><span class="line">while(1)&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(du,0,sizeof(du));</span><br><span class="line">circle=false;</span><br><span class="line">for(int i=1;i&lt;N;i++)fa[i]=i;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">if(a==0&amp;&amp;b==0)&#123;//空树特判 </span><br><span class="line">printf(&quot;Case %d is a tree.\n&quot;,cas);</span><br><span class="line">cas++;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">if(a&lt;0&amp;&amp;b&lt;0)return 0;</span><br><span class="line">vis[a]=true;vis[b]=true;</span><br><span class="line">join(a,b);</span><br><span class="line">while(1)&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">if(a==0&amp;&amp;b==0)break;</span><br><span class="line">join(a,b);</span><br><span class="line">vis[a]=true;vis[b]=true;</span><br><span class="line">&#125;</span><br><span class="line">int gen=0,flag=0;</span><br><span class="line">for(int i=1;i&lt;N;i++)&#123;</span><br><span class="line">if(vis[i])&#123;</span><br><span class="line">if(du[i]&gt;1)&#123;</span><br><span class="line">flag=1;break;</span><br><span class="line">&#125;</span><br><span class="line">else if(du[i]==0)gen++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(!circle&amp;&amp;flag==0&amp;&amp;gen==1)printf(&quot;Case %d is a tree.\n&quot;,cas);</span><br><span class="line">else printf(&quot;Case %d is not a tree.\n&quot;,cas);</span><br><span class="line">cas++;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>poj 1182 食物链（并查集）</title>
      <link href="/2018/08/18/poj%201182%20%E9%A3%9F%E7%89%A9%E9%93%BE%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89/"/>
      <url>/2018/08/18/poj%201182%20%E9%A3%9F%E7%89%A9%E9%93%BE%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="poj-1182-食物链（并查集）"><a href="#poj-1182-食物链（并查集）" class="headerlink" title="poj 1182 食物链（并查集）"></a>poj 1182 食物链（并查集）</h1><p><a href="http://poj.org/problem?id=1182" target="_blank" rel="noopener">http://poj.org/problem?id=1182</a></p><p>Time Limit: 1000MS        Memory Limit: 10000K</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。<br>现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。<br>有人用两种说法对这N个动物所构成的食物链关系进行描述：<br>第一种说法是”1 X Y”，表示X和Y是同类。<br>第二种说法是”2 X Y”，表示X吃Y。<br>此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。<br>1）    当前的话与前面的某些真的话冲突，就是假话；<br>2）    当前的话中X或Y比N大，就是假话；<br>3）    当前的话表示X吃X，就是假话。<br>你的任务是根据给定的N（1 &lt;= N &lt;= 50,000）和K句话（0 &lt;= K &lt;= 100,000），输出假话的总数。 </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行是两个整数N和K，以一个空格分隔。<br>以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。<br>若D=1，则表示X和Y是同类。<br>若D=2，则表示X吃Y。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>只有一个整数，表示假话的数目。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">100 7</span><br><span class="line">1 101 1 </span><br><span class="line">2 1 2</span><br><span class="line">2 2 3 </span><br><span class="line">2 3 3 </span><br><span class="line">1 1 3 </span><br><span class="line">2 3 1 </span><br><span class="line">1 5 5</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><hr><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>分成三类 所以用 <strong>并查集+数组加倍</strong></p><p>不知道当时在哪看到的这种数组加倍的写法 反正巨好用</p><p>i (i+n) (i+2*n) 分别代表abc三个种类</p><p>如果a吃b 就分别把三种的a和b的下一个join起来</p><p>注意这题不合法的输入也要处理成假话</p><p>下面是网上找的带权并查集的写法 但是我还是喜欢数组加倍。。<br><a href="https://blog.csdn.net/sunmaoxiang/article/details/80959300" target="_blank" rel="noopener">https://blog.csdn.net/sunmaoxiang/article/details/80959300</a></p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=50005;</span><br><span class="line">int fa[N*3];</span><br><span class="line"></span><br><span class="line">int find(int x)&#123;</span><br><span class="line">return fa[x]==x?x:fa[x]=find(fa[x]);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">fa[find(x)]=find(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int n,k,ans=0;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;n,&amp;k);</span><br><span class="line">for(int i=0;i&lt;=3*n;i++)fa[i]=i;</span><br><span class="line">for(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">int a,b,d;</span><br><span class="line">scanf(&quot;%d%d%d&quot;,&amp;d,&amp;a,&amp;b);</span><br><span class="line">if(a&gt;n||b&gt;n||a&lt;1||b&lt;1)&#123;</span><br><span class="line">ans++;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">else if(d==1)&#123;</span><br><span class="line">if(find(a)==find(b+n)||find(a)==find(b+2*n))&#123;</span><br><span class="line">ans++;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">join(a,b);</span><br><span class="line">join(a+n,b+n);</span><br><span class="line">join(a+2*n,b+2*n);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">if(find(a)==find(b)||find(a)==find(b+2*n))&#123;</span><br><span class="line">ans++;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">join(a,b+n);</span><br><span class="line">join(a+n,b+2*n);</span><br><span class="line">join(a+2*n,b);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>poj 1988 Cube Stacking（并查集）</title>
      <link href="/2018/08/18/poj%201988%20Cube%20Stacking%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89/"/>
      <url>/2018/08/18/poj%201988%20Cube%20Stacking%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="poj-1988-Cube"><a href="#poj-1988-Cube" class="headerlink" title="poj 1988 Cube"></a>poj 1988 Cube</h1><p><a href="http://poj.org/problem?id=1988" target="_blank" rel="noopener">http://poj.org/problem?id=1988</a><br>Time Limit: 2000MS        Memory Limit: 30000K</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Farmer John and Betsy are playing a game with N (1 &lt;= N &lt;= 30,000)identical cubes labeled 1 through N. They start with N stacks, each containing a single cube. Farmer John asks Betsy to perform P (1&lt;= P &lt;= 100,000) operation. There are two types of operations:<br>moves and counts.   </p><ul><li>In a move operation, Farmer John asks Bessie to move the stack containing cube X on top of the stack containing cube Y. </li><li>In a count operation, Farmer John asks Bessie to count the number of cubes on the stack with cube X that are under the cube X and report that value. </li></ul><p>Write a program that can verify the results of the game. </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><ul><li><p>Line 1: A single integer, P </p></li><li><p>Lines 2..P+1: Each of these lines describes a legal operation. Line 2 describes the first operation, etc. Each line begins with a ‘M’ for a move operation or a ‘C’ for a count operation. For move operations, the line also contains two integers: X and Y.For count operations, the line also contains a single integer: X. </p></li></ul><p>Note that the value for N does not appear in the input file. No move operation will request a move a stack onto itself. </p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Print the output from each of the count operations in the same order as the input file. </p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">M 1 6</span><br><span class="line">C 1</span><br><span class="line">M 2 4</span><br><span class="line">M 2 6</span><br><span class="line">C 3</span><br><span class="line">C 4</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">2</span><br></pre></td></tr></table></figure><hr><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给n个箱子 1-n排成n列<br>有两种操作：</p><ul><li>M：将x所在列上的箱子移到y所在列箱子上面</li><li>C：求x箱子下有几个箱子</li></ul><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>因为有合并两堆箱子的操作 所以想到用并查集 </p><p>这题巧妙的地方在于如何求解这个箱子下面的箱子数 开两个数组</p><p>num[i]记录当前第i列有几个箱子<br>place[i]记录箱子i下面的箱子个数</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=30010;</span><br><span class="line">int fa[N],num[N],place[N];</span><br><span class="line"></span><br><span class="line">int find(int x)&#123;</span><br><span class="line">    if(fa[x]==x)return x;</span><br><span class="line">    int temp=fa[x];</span><br><span class="line">    fa[x]=find(fa[x]);</span><br><span class="line">    place[x]+=place[temp];</span><br><span class="line">    return fa[x];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">    fa[x]=y;</span><br><span class="line">    place[x]+=num[y];</span><br><span class="line">    num[y]+=num[x];</span><br><span class="line">    num[x]=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=1;i&lt;=30000;i++)&#123;</span><br><span class="line">        place[i]=0;</span><br><span class="line">        num[i]=1;</span><br><span class="line">        fa[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        char s[5];</span><br><span class="line">        scanf(&quot;%S&quot;,&amp;s);</span><br><span class="line">        if(s[0]==&apos;M&apos;)&#123;</span><br><span class="line">            int x,y;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);</span><br><span class="line">            int x1=find(x),y1=find(y);</span><br><span class="line">            if(x1!=y1)join(x1,y1);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(s[0]==&apos;C&apos;)&#123;</span><br><span class="line">            int x;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">            find(x);</span><br><span class="line">            printf(&quot;%d\n&quot;,place[x]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Teemo&#39;s bad day（并查集）</title>
      <link href="/2018/08/18/Teemo&#39;s%20bad%20day%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89/"/>
      <url>/2018/08/18/Teemo&#39;s%20bad%20day%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="Teemo’s-bad-day（并查集）"><a href="#Teemo’s-bad-day（并查集）" class="headerlink" title="Teemo’s bad day（并查集）"></a>Teemo’s bad day（并查集）</h1><p><a href="https://nanti.jisuanke.com/t/29203" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/29203</a></p><p>Today is a bad day. Teemo is scolded badly by his teacher because he didn’t do his homework.But Teemo is very self-confident, he tells the teacher that the problems in the homework are too simple to solve. So the teacher gets much angrier and says”I will choose a problem in the homework, if you can’t solve it, I will call you mother! “</p><p>The problem is that:</p><p>There is an array A which contains n integers, and an array B which also contains n integers. You can pay one dollar to buy a card which contains two integers a1 and a2, The card can arbitrary number of times transform a single integer a1 to a2 and vise-versa on both array A and Array B. Please calculate the minimum dollars you should pay to make the two array same(For every 1&lt;=i&lt;=n,A[i]=B[i]);</p><h3 id="Input-Format"><a href="#Input-Format" class="headerlink" title="Input Format"></a>Input Format</h3><p>The first line of the input contains an integer T(1&lt;=T&lt;=10), giving the number of test cases.<br>For every test case, the first line contains an integer n(1&lt;=n&lt;=500000). The second line contains n integers. The i th integer represents A<a href="1&lt;=A[i]&lt;=100000">i</a>. And the third line contains n integers. The i th integer represents B<a href="1&lt;=B[i]&lt;=100000">i</a>.</p><h3 id="Output-Format"><a href="#Output-Format" class="headerlink" title="Output Format"></a>Output Format</h3><p>For each test case, output an integer which means the minimum dollars you should pay in a line.</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5</span><br><span class="line">1 1 2 3 2</span><br><span class="line">1 2 3 1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><hr><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给两个序列，某一张卡片可以把数a换成数b，次数不限，求把两个序列变成相同需要的最少卡片数</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>两个数父亲不同就join（a,b），然后ans++</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;climits&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;limits&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=100005;</span><br><span class="line">int fa[N];</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">    int tmp=x;</span><br><span class="line">    while(fa[tmp]!=tmp)tmp=fa[tmp]; </span><br><span class="line">    fa[x]=tmp;</span><br><span class="line">    return tmp;</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">    if(find(x)!=find(y))fa[find(x)]=fa[find(y)];</span><br><span class="line">&#125;</span><br><span class="line">int a[N*5],b[N*5];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        int n;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        for(int i=1;i&lt;=N;i++)fa[i]=i;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">        for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;b[i]);</span><br><span class="line">        int ans=0;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            int aa=find(a[i]),bb=find(b[i]);</span><br><span class="line">            if(aa==bb)continue;</span><br><span class="line">            else&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                join(aa,bb);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>1365 浴火银河星际跳跃（并查集）</title>
      <link href="/2018/08/18/1365%20%E6%B5%B4%E7%81%AB%E9%93%B6%E6%B2%B3%E6%98%9F%E9%99%85%E8%B7%B3%E8%B7%83%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89/"/>
      <url>/2018/08/18/1365%20%E6%B5%B4%E7%81%AB%E9%93%B6%E6%B2%B3%E6%98%9F%E9%99%85%E8%B7%B3%E8%B7%83%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="1365-浴火银河星际跳跃（并查集）"><a href="#1365-浴火银河星际跳跃（并查集）" class="headerlink" title="1365 浴火银河星际跳跃（并查集）"></a>1365 浴火银河星际跳跃（并查集）</h1><p><a href="http://codevs.cn/problem/1365/" target="_blank" rel="noopener">http://codevs.cn/problem/1365/</a></p><p> 时间限制: 1 s<br> 空间限制: 128000 KB<br> 题目等级 : 黄金 Gold</p><h3 id="题目描述-Description"><a href="#题目描述-Description" class="headerlink" title="题目描述 Description"></a>题目描述 Description</h3><p>小 K 又在玩浴火银河了。。。不过这次他的目的不是跑运输赚钱，而<br>是做任务赚钱。<br>他想知道关于一个任务的两个星系是否可以连通。</p><h3 id="输入描述-Input-Description"><a href="#输入描述-Input-Description" class="headerlink" title="输入描述 Input Description"></a>输入描述 Input Description</h3><p>第一行，三个数，X,N,M<br>X 表示出现的星系代号的最大值；<br>N 表示有 N 个星际跳跃门;<br>M 表示有 M 个任务。<br>接下来的 N 行描述每个星际跳跃门：每行为两个数字（星系代号），<br>星际跳跃门连通这两个星系（星际跳跃门是可以双向通行的）<br>；<br>接下来的 M 行表示每个任务需要到达的星系，每个任务需要到达两<br>个星系。</p><h3 id="输出描述-Output-Description"><a href="#输出描述-Output-Description" class="headerlink" title="输出描述 Output Description"></a>输出描述 Output Description</h3><p>共 M 行。<br>第 i 行表示第 i 个任务是否能完成：即两个星系是否能连通。（能→<br>Yes；不能→No）</p><h3 id="样例输入-Sample-Input"><a href="#样例输入-Sample-Input" class="headerlink" title="样例输入 Sample Input"></a>样例输入 Sample Input</h3><p>5 2 1<br>3 5<br>4 5<br>3 4</p><h3 id="样例输出-Sample-Output"><a href="#样例输出-Sample-Output" class="headerlink" title="样例输出 Sample Output"></a>样例输出 Sample Output</h3><p>Yes</p><h3 id="数据范围及提示-Data-Size-amp-Hint"><a href="#数据范围及提示-Data-Size-amp-Hint" class="headerlink" title="数据范围及提示 Data Size &amp; Hint"></a>数据范围及提示 Data Size &amp; Hint</h3><p>最大数据第一行：19999 17542 1664</p><hr><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=20005;</span><br><span class="line">int fa[N];</span><br><span class="line">int find(int t)&#123;</span><br><span class="line">    int tmp=t;</span><br><span class="line">    while(tmp!=fa[tmp])tmp=fa[tmp];</span><br><span class="line">    fa[t]=tmp;</span><br><span class="line">    return tmp;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int x,n,m,a,b;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=x;i++)fa[i]=i;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        int tmpa=find(a),tmpb=find(b);</span><br><span class="line">        if(tmpa!=tmpb)fa[tmpb]=tmpa;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        int tmpa=find(a),tmpb=find(b);</span><br><span class="line">        if(tmpa==tmpb)cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;</span><br><span class="line">        else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>1240 莫比乌斯函数（数论）</title>
      <link href="/2018/08/18/1240%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/"/>
      <url>/2018/08/18/1240%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h2 id="1240-莫比乌斯函数（数论）"><a href="#1240-莫比乌斯函数（数论）" class="headerlink" title="1240 莫比乌斯函数（数论）"></a>1240 莫比乌斯函数（数论）</h2><p>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 </p><p>莫比乌斯函数，由德国数学家和天文学家莫比乌斯提出。梅滕斯(Mertens)首先使用μ(n)（miu(n)）作为莫比乌斯函数的记号。（据说，高斯(Gauss)比莫比乌斯早三十年就曾考虑过这个函数）。</p><p>具体定义如下：</p><p>如果一个数包含平方因子，那么miu(n) = 0。例如：miu(4), miu(12), miu(18) = 0。</p><p>如果一个数不包含平方因子，并且有k个不同的质因子，那么miu(n) = (-1)^k。例如：miu(2), miu(3), miu(30) = -1,miu(1), miu(6), miu(10) = 1。</p><p>给出一个数n, 计算miu(n)。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入包括一个数n，(2 &lt;= n &lt;= 10^9)</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出miu(n)。</p><h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><p><code>5</code></p><h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><p><code>-1</code></p><hr><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>只有一个输入 直接求因子数就好 不用线筛</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line"></span><br><span class="line">int mu(int x)&#123;</span><br><span class="line">    int flag=0,num=0;</span><br><span class="line">    for(int i=2;i*i&lt;=x;i++)&#123;</span><br><span class="line">        if(x%i==0)&#123;</span><br><span class="line">            x/=i;</span><br><span class="line">            num++;</span><br><span class="line">            if(x%i==0)&#123;</span><br><span class="line">                flag=1;//包含平方因子</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(num&amp;1)return 1;</span><br><span class="line">    else return -1;</span><br><span class="line">&#125;</span><br><span class="line">/*o(n)线筛</span><br><span class="line">int mu[N],prime[N];</span><br><span class="line">bool vis[N];</span><br><span class="line">int ji;</span><br><span class="line">void init()&#123;</span><br><span class="line">    mu[1]=1;</span><br><span class="line">    memset(vis,false,sizeof(vis));</span><br><span class="line">    for(int i=2;i&lt;N;i++)&#123;</span><br><span class="line">        if(!vis[i])&#123;</span><br><span class="line">            prime[ji++]=i;</span><br><span class="line">            mu[i]=-1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=0;j&lt;ji&amp;&amp;i*prime[j]&lt;N;j++)&#123;</span><br><span class="line">            vis[i*prime[j]]=true;</span><br><span class="line">            if(i%prime[j])mu[i*prime[j]]=-mu[i];</span><br><span class="line">            else&#123;</span><br><span class="line">                mu[i*prime[j]]=0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">int main()&#123; </span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    printf(&quot;%d\n&quot;,mu(n));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 51nod基础题 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>1256 乘法逆元（数论）</title>
      <link href="/2018/08/18/1256%20%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"/>
      <url>/2018/08/18/1256%20%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/</url>
      <content type="html"><![CDATA[<h2 id="1256-乘法逆元（数论）"><a href="#1256-乘法逆元（数论）" class="headerlink" title="1256 乘法逆元（数论）"></a>1256 乘法逆元（数论）</h2><p>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题</p><p>给出2个数M和N(M &lt; N)，且M与N互质，找出一个数K满足0 &lt; K &lt; N且K * M % N = 1，如果有多个满足条件的，输出最小的。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入2个数M, N中间用空格分隔（1 &lt;= M &lt; N &lt;= 10^9)</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一个数K，满足0 &lt; K &lt; N且K * M % N = 1，如果有多个满足条件的，输出最小的。</p><h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3</span><br></pre></td></tr></table></figure><h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><hr><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>数论 —— 扩展欧几里得</p><p>ax+by=gcd(a,b)   </p><p>a,b互质 有ax+by=1  </p><p>ax%b=1%b </p><p>记x为inv(a) 则a*inv(a)%b=1%b  </p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">void ex_gcd(LL a,LL b,LL &amp;x,LL &amp;y,LL &amp;d)&#123;</span><br><span class="line">    if(!b)&#123;</span><br><span class="line">        d=a;x=1;y=0;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        ex_gcd(b,a%b,y,x,d);</span><br><span class="line">        y-=x*(a/b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">LL inv(LL t,LL p)&#123;</span><br><span class="line">    LL d,x,y;</span><br><span class="line">    ex_gcd(t,p,x,y,d);</span><br><span class="line">    return d==1?(x%p+p)%p:-1;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123; </span><br><span class="line">    LL m,n;</span><br><span class="line">    scanf(&quot;%lld%lld&quot;,&amp;m,&amp;n);</span><br><span class="line">    printf(&quot;%lld\n&quot;,inv(m,n));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 51nod基础题 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>1264 线段相交（计算几何）</title>
      <link href="/2018/08/17/1264%20%E7%BA%BF%E6%AE%B5%E7%9B%B8%E4%BA%A4/"/>
      <url>/2018/08/17/1264%20%E7%BA%BF%E6%AE%B5%E7%9B%B8%E4%BA%A4/</url>
      <content type="html"><![CDATA[<h2 id="1264-线段相交（计算几何）"><a href="#1264-线段相交（计算几何）" class="headerlink" title="1264 线段相交（计算几何）"></a>1264 线段相交（计算几何）</h2><p>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 </p><p>给出平面上两条线段的两个端点，判断这两条线段是否相交（有一个公共点或有部分重合认为相交）。 如果相交，输出”Yes”，否则输出”No”。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：一个数T，表示输入的测试数量(1 &lt;= T &lt;= 1000)<br>第2 - T + 1行：每行8个数，x1,y1,x2,y2,x3,y3,x4,y4。(-10^8 &lt;= xi, yi &lt;= 10^8)<br>(直线1的两个端点为x1,y1 | x2, y2,直线2的两个端点为x3,y3 | x4, y4)</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出共T行，如果相交输出”Yes”，否则输出”No”。</p><h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1 2 2 1 0 0 2 2</span><br><span class="line">-1 1 1 1 0 0 1 -1</span><br></pre></td></tr></table></figure><h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure><hr><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>计算几何判断线段相交模版</p><p>注释掉的部分是不包括端点和线段重合的模版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define eps 1e-8</span><br><span class="line">#define zero(x) (((x)&gt;0?(x):-(x))&lt;eps)</span><br><span class="line">struct point&#123;</span><br><span class="line">double x,y,z;</span><br><span class="line">&#125;q[4];</span><br><span class="line">//叉积</span><br><span class="line">double xmult(point p1,point p2,point p0)&#123;</span><br><span class="line">    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);</span><br><span class="line">&#125;</span><br><span class="line">//判三点共线</span><br><span class="line">int dots_inline(point p1,point p2,point p3)&#123;</span><br><span class="line">    return zero(xmult(p1,p2,p3));</span><br><span class="line">&#125;</span><br><span class="line">//判点是否在线段上，包括端点</span><br><span class="line">int dot_online_in(point p,point l1,point l2)&#123;</span><br><span class="line">    return zero(xmult(p,l1,l2)&amp;&amp;(l1.x-p.x)*(l2.x-p.x)&lt;eps&amp;&amp;(l1.y-p.y)*(l2.y-p.y)&lt;eps);</span><br><span class="line">&#125;</span><br><span class="line">//判两点在线段同侧,点在线段上返回0</span><br><span class="line">int same_side(point p1,point p2,point l1,point l2)&#123;</span><br><span class="line">    return xmult(l1,p1,l2)*xmult(l1,p2,l2)&gt;eps;</span><br><span class="line">&#125;</span><br><span class="line">//判两线段相交，包括端点和重合(p14)</span><br><span class="line">int intersect_in(point u1,point u2,point v1,point v2)&#123;</span><br><span class="line">    if(!dots_inline(u1,u2,v1)||!dots_inline(u1,u2,v2))</span><br><span class="line">        return !same_side(u1,u2,v1,v2)&amp;&amp;!same_side(v1,v2,u1,u2);</span><br><span class="line">    return (dot_online_in(u1,v1,v2)||dot_online_in(u2,v1,v2)||</span><br><span class="line">            dot_online_in(v1,u1,u2)||dot_online_in(v2,u1,u2));</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">//判两点在线段异侧</span><br><span class="line">int opposite_side(point p1,point p2,point l1,point l2)&#123;</span><br><span class="line">    return xmult(l1,p1,l2)*xmult(l1,p2,l2)&lt;-eps;</span><br><span class="line">&#125;</span><br><span class="line">//判两线段相交，不包括端点和重合</span><br><span class="line">int intersect_ex(point u1,point u2,point v1,point v2)&#123;</span><br><span class="line">    return opposite_side(u1,u2,v1,v2)&amp;&amp;opposite_side(v1,v2,u1,u2);</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">int main()&#123; </span><br><span class="line">    int t; </span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        for(int i=0;i&lt;4;i++)scanf(&quot;%lf%lf&quot;,&amp;q[i].x,&amp;q[i].y);</span><br><span class="line">        if(intersect_in(q[0],q[1],q[2],q[3]))puts(&quot;Yes&quot;);</span><br><span class="line">        else puts(&quot;No&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 51nod基础题 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>1265 四点共面（计算几何）</title>
      <link href="/2018/08/17/1265%20%E5%9B%9B%E7%82%B9%E5%85%B1%E9%9D%A2/"/>
      <url>/2018/08/17/1265%20%E5%9B%9B%E7%82%B9%E5%85%B1%E9%9D%A2/</url>
      <content type="html"><![CDATA[<h2 id="1265-四点共面（计算几何）"><a href="#1265-四点共面（计算几何）" class="headerlink" title="1265 四点共面（计算几何）"></a>1265 四点共面（计算几何）</h2><p>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题</p><p>给出三维空间上的四个点（点与点的位置均不相同），判断这4个点是否在同一个平面内（4点共线也算共面）。如果共面，输出”Yes”，否则输出”No”。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：一个数T，表示输入的测试数量(1 &lt;= T &lt;= 1000)<br>第2 - 4T + 1行：每行4行表示一组数据，每行3个数，x, y, z, 表示该点的位置坐标(-1000 &lt;= x, y, z &lt;= 1000)。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出共T行，如果共面输出”Yes”，否则输出”No”。</p><h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1 2 0</span><br><span class="line">2 3 0</span><br><span class="line">4 0 0</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure><h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><hr><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>计算几何四点共面模版 已经包含四点共线的情况了  </p><p>如果四点不能共线 那就用两次三点共线判断一下就行</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define eps 1e-8</span><br><span class="line">#define zero(x) (((x)&gt;0?(x):-(x))&lt;eps)</span><br><span class="line">struct point&#123;</span><br><span class="line">double x,y,z;</span><br><span class="line">&#125;q[4];</span><br><span class="line">//叉积</span><br><span class="line">point xmult(point u,point v)&#123;</span><br><span class="line">    point ret;</span><br><span class="line">    ret.x=u.y*v.z-v.y*u.z;</span><br><span class="line">    ret.y=u.z*v.x-u.x*v.z;</span><br><span class="line">    ret.z=u.x*v.y-u.y*v.x;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">//点积</span><br><span class="line">double dmult(point u,point v)&#123;</span><br><span class="line">    return u.x*v.x+u.y*v.y+u.z*v.z;</span><br><span class="line">&#125;</span><br><span class="line">//矢量差</span><br><span class="line">point subt(point u,point v)&#123;</span><br><span class="line">    point ret;</span><br><span class="line">    ret.x=u.x-v.x;</span><br><span class="line">    ret.y=u.y-v.y;</span><br><span class="line">    ret.z=u.z-v.z;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">//取平面法向量</span><br><span class="line">point pvec(point s1,point s2,point s3)&#123;</span><br><span class="line">    return xmult(subt(s1,s2),subt(s2,s3));</span><br><span class="line">&#125;</span><br><span class="line">//向量大小</span><br><span class="line">double vlen(point p)&#123;</span><br><span class="line">    return sqrt(p.x*p.x+p.y*p.y+p.z*p.z);</span><br><span class="line">&#125;</span><br><span class="line">//判三点共线</span><br><span class="line">int dots_inline(point a,point b,point c)&#123;</span><br><span class="line">    return vlen(xmult(subt(a,b),subt(b,c)))&lt;eps;</span><br><span class="line">&#125;</span><br><span class="line">//判四点共面</span><br><span class="line">int dots_onplane(point a,point b,point c,point d)&#123;</span><br><span class="line">    return zero(dmult(pvec(a,b,c),subt(d,a)));</span><br><span class="line">&#125;</span><br><span class="line">bool check()&#123;</span><br><span class="line">    if(dots_onplane(q[0],q[1],q[2],q[3]))return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123; </span><br><span class="line">    int t; </span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">            scanf(&quot;%lf%lf%lf&quot;,&amp;q[i].x,&amp;q[i].y,&amp;q[i].z);</span><br><span class="line">        &#125;</span><br><span class="line">        if(check())puts(&quot;Yes&quot;);</span><br><span class="line">        else puts(&quot;No&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 51nod基础题 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>1298 圆与三角形（计算几何）</title>
      <link href="/2018/08/17/1298-%E5%9C%86%E4%B8%8E%E4%B8%89%E8%A7%92%E5%BD%A2/"/>
      <url>/2018/08/17/1298-%E5%9C%86%E4%B8%8E%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
      <content type="html"><![CDATA[<hr><hr><p><img src="/2018/08/17/1298-圆与三角形/1.png" alt=""></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：一个数T，表示输入的测试数量(1 &lt;= T &lt;= 10000)，之后每4行用来描述一组测试数据。<br>4-1：三个数，前两个数为圆心的坐标xc, yc，第3个数为圆的半径R。(-3000 &lt;= xc, yc &lt;= 3000, 1 &lt;= R &lt;= 3000）<br>4-2：2个数，三角形第1个点的坐标。<br>4-3：2个数，三角形第2个点的坐标。<br>4-4：2个数，三角形第3个点的坐标。(-3000 &lt;= xi, yi &lt;= 3000）</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>共T行，对于每组输入数据，相交输出”Yes”，否则输出”No”。</p><h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">0 0 10</span><br><span class="line">10 0</span><br><span class="line">15 0</span><br><span class="line">15 5</span><br><span class="line">0 0 10</span><br><span class="line">0 0</span><br><span class="line">5 0</span><br><span class="line">5 5</span><br></pre></td></tr></table></figure><h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure><hr><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>判断圆和三角形是否相交 直接判断三角形三条线段和圆是否有交点 上个计算几何模版</p><p>最初的思路是分成三种情况考虑 一种是内包含 只要判断三个点是否都在圆内即可 第二种是外包含 要判断三个点都在圆外且圆心到三边距离都大于半径 第三种是下图情况 就不好操作了 所以还是直接用模版啦</p><p><img src="/2018/08/17/1298-圆与三角形/3.png" alt=""></p><p>然后系统说我编译错误 明明sublime编译通过了的 麻烦诶。。然后用devc++试了下 报了下图的错  </p><p><img src="/2018/08/17/1298-圆与三角形/2.png" alt=""></p><p>查了是因为distance和内置的函数重名了 改改就好了下次注意</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define eps 1e-8</span><br><span class="line">double a0,b0,r,a1,a2,a3,b1,b2,b3;</span><br><span class="line">struct point&#123;</span><br><span class="line">double x,y;</span><br><span class="line">&#125;q0,q1,q2,q3;</span><br><span class="line">double xmult(point p1,point p2,point p0)&#123;</span><br><span class="line">    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);</span><br><span class="line">&#125;</span><br><span class="line">double Distance(point p1,point p2)&#123;</span><br><span class="line">    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));</span><br><span class="line">&#125;</span><br><span class="line">// 点到直线距离</span><br><span class="line">double disptoline(point p,point l1,point l2)&#123;</span><br><span class="line">    return fabs(xmult(p,l1,l2)/Distance(l1,l2));</span><br><span class="line">&#125;</span><br><span class="line">// 判断线段和圆相交，包括端点和相切(p33)</span><br><span class="line">int intersect_seg_circle(point c,double r0,point l1,point l2)&#123;</span><br><span class="line">    double t1=Distance(c,l1)-r,t2=Distance(c,l2)-r;</span><br><span class="line">    point t=c;</span><br><span class="line">    if(t1&lt;eps||t2&lt;eps)return t1&gt;-eps||t2&gt;-eps;</span><br><span class="line">    t.x+=l1.y-l2.y;</span><br><span class="line">    t.y+=l2.x-l1.x;</span><br><span class="line">    return xmult(l1,c,t)*xmult(l2,c,t)&lt;eps&amp;&amp;disptoline(c,l1,l2)-r&lt;eps;</span><br><span class="line">&#125;</span><br><span class="line">bool check()&#123;</span><br><span class="line">    if(intersect_seg_circle(q0,r,q1,q2))return true;</span><br><span class="line">    if(intersect_seg_circle(q0,r,q1,q3))return true;</span><br><span class="line">    if(intersect_seg_circle(q0,r,q2,q3))return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;   </span><br><span class="line">int main()&#123; </span><br><span class="line">    int t; </span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%lf%lf%lf&quot;,&amp;a0,&amp;b0,&amp;r);q0.x=a0;q0.y=b0;</span><br><span class="line">        scanf(&quot;%lf%lf&quot;,&amp;a1,&amp;b1);q1.x=a1;q1.y=b1;</span><br><span class="line">        scanf(&quot;%lf%lf&quot;,&amp;a2,&amp;b2);q2.x=a2;q2.y=b2;</span><br><span class="line">        scanf(&quot;%lf%lf&quot;,&amp;a3,&amp;b3);q3.x=a3;q3.y=b3;</span><br><span class="line">        if(check())puts(&quot;Yes&quot;);</span><br><span class="line">        else puts(&quot;No&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 51nod基础题 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>1384 全排列（STL/dfs）</title>
      <link href="/2018/08/17/1384%20%E5%85%A8%E6%8E%92%E5%88%97/"/>
      <url>/2018/08/17/1384%20%E5%85%A8%E6%8E%92%E5%88%97/</url>
      <content type="html"><![CDATA[<h2 id="1384-全排列（STL-dfs）"><a href="#1384-全排列（STL-dfs）" class="headerlink" title="1384 全排列（STL/dfs）"></a>1384 全排列（STL/dfs）</h2><p>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题</p><p>给出一个字符串S（可能有重复的字符），按照字典序从小到大，输出S包括的字符组成的所有排列。例如：S = “1312”，<br>输出为：</p><p>1123<br>1132<br>1213<br>1231<br>1312<br>1321<br>2113<br>2131<br>2311<br>3112<br>3121<br>3211   </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入一个字符串S（S的长度 &lt;= 9，且只包括0 - 9的阿拉伯数字）</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出S所包含的字符组成的所有排列</p><h2 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1312</span><br></pre></td></tr></table></figure><h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1123</span><br><span class="line">1132</span><br><span class="line">1213</span><br><span class="line">1231</span><br><span class="line">1312</span><br><span class="line">1321</span><br><span class="line">2113</span><br><span class="line">2131</span><br><span class="line">2311</span><br><span class="line">3112</span><br><span class="line">3121</span><br><span class="line">3211</span><br></pre></td></tr></table></figure><hr><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>题意很简单 就水水的全排列</p><p>直接next_permutation就好啦 诶好用</p><p>printf竟然tle了 改成 <strong>puts()</strong> 之后跑了46ms </p><p>不过这样太依赖stl了 还是乖乖再写个dfs吧。。</p><p>然后又t了。。1900ms+。。把printf改成cout就过了 跑了484ms 不是很懂 printf不是比cout快的嘛？？？</p><p>而且加上输入输出优化之后<code>ios::sync_with_stdio(false);cin.tie(0);</code> 没有跑得更快反而慢了一丢丢</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    char s[10];</span><br><span class="line">    scanf(&quot;%s&quot;,s);</span><br><span class="line">    int len=strlen(s);</span><br><span class="line">    sort(s,s+len);</span><br><span class="line">    do&#123;</span><br><span class="line">        // printf(&quot;%s\n&quot;,s);</span><br><span class="line">        puts(s);</span><br><span class="line">    &#125;while(next_permutation(s,s+len));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char s[10];</span><br><span class="line">int ans[10],len;</span><br><span class="line">bool vis[10];</span><br><span class="line">void dfs(int x)&#123;</span><br><span class="line">    if(x==len)&#123;</span><br><span class="line">        for(int i=0;i&lt;len;i++)cout&lt;&lt;ans[i];</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">        if(!vis[i])&#123;</span><br><span class="line">            vis[i]=true;</span><br><span class="line">            ans[x]=s[i]-&apos;0&apos;;</span><br><span class="line">            dfs(x+1);</span><br><span class="line">            vis[i]=false;</span><br><span class="line">            while(i&lt;=len&amp;&amp;s[i]==s[i+1])i++;//去重</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;  </span><br><span class="line">    scanf(&quot;%s&quot;,s);</span><br><span class="line">    len=strlen(s);</span><br><span class="line">    sort(s,s+len);</span><br><span class="line">    memset(vis,false,sizeof(vis));</span><br><span class="line">    dfs(0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 51nod基础题 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>1459 迷宫游戏（Dijkstra）</title>
      <link href="/2018/08/16/1459%20%E8%BF%B7%E5%AE%AB%E6%B8%B8%E6%88%8F/"/>
      <url>/2018/08/16/1459%20%E8%BF%B7%E5%AE%AB%E6%B8%B8%E6%88%8F/</url>
      <content type="html"><![CDATA[<h2 id="1459-迷宫游戏（Dijkstra）"><a href="#1459-迷宫游戏（Dijkstra）" class="headerlink" title="1459 迷宫游戏（Dijkstra）"></a>1459 迷宫游戏（Dijkstra）</h2><p>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题</p><p>你来到一个迷宫前。该迷宫由若干个房间组成，每个房间都有一个得分，第一次进入这个房间，你就可以得到这个分数。还有若干双向道路连结这些房间，你沿着这些道路从一个房间走到另外一个房间需要一些时间。游戏规定了你的起点和终点房间，你首要目标是从起点尽快到达终点，在满足首要目标的前提下，使得你的得分总和尽可能大。现在问题来了，给定房间、道路、分数、起点和终点等全部信息，你能计算在尽快离开迷宫的前提下，你的最大得分是多少么？</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行4个整数n (&lt;=500), m, start, end。n表示房间的个数，房间编号从0到(n - 1)，m表示道路数,任意两个房间之间最多只有一条道路，start和end表示起点和终点房间的编号。<br>第二行包含n个空格分隔的正整数(不超过600)，表示进入每个房间你的得分。<br>再接下来m行，每行3个空格分隔的整数x, y, z (0&lt;z&lt;=200)表示道路,表示从房间x到房间y(双向)的道路,注意，最多只有一条道路连结两个房间, 你需要的时间为z。<br>输入保证从start到end至少有一条路径。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一行，两个空格分隔的整数，第一个表示你最少需要的时间，第二个表示你在最少时间前提下可以获得的最大得分。</p><h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 2 0 2</span><br><span class="line">1 2 3</span><br><span class="line">0 1 10</span><br><span class="line">1 2 11</span><br></pre></td></tr></table></figure><h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">21 6</span><br></pre></td></tr></table></figure><hr><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>dijkstra</p><p><a href="https://blog.csdn.net/qq_35644234/article/details/60870719/" target="_blank" rel="noopener">最短路径问题—Dijkstra算法详解</a></p><p>这题还要在最短路的基础上求权值最大 开个数组记录一下然后和路径一起更新就行</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=505;</span><br><span class="line">const int INF=0x3f3f3f3f;</span><br><span class="line">int a[N],cost[N],ans[N];</span><br><span class="line">bool vis[N];</span><br><span class="line">int n,m,start,endd;</span><br><span class="line">vector&lt;int&gt;mp[N];</span><br><span class="line">vector&lt;int&gt;t[N];</span><br><span class="line">void dij()&#123; </span><br><span class="line">    int x=start;</span><br><span class="line">    vis[x]=true;</span><br><span class="line">    while(x!=endd)&#123;</span><br><span class="line">        for(int i=0;i&lt;mp[x].size();i++)&#123;</span><br><span class="line">            int y=mp[x][i];</span><br><span class="line">            int tmpcost=cost[x]+t[x][i];</span><br><span class="line">            int tmpans=ans[x]+a[y];</span><br><span class="line">            if(cost[y]==0||tmpcost&lt;cost[y]||(tmpcost==cost[y]&amp;&amp;tmpans&gt;ans[y]))&#123;</span><br><span class="line">                //如果x-&gt;y的路在之前还未连通</span><br><span class="line">                //或者新路径从x-&gt;y的时间小于原来的，或等于但是权值更大，就更新答案</span><br><span class="line">                ans[y]=tmpans;</span><br><span class="line">                cost[y]=tmpcost;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int minn=INF,maxx=0;</span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            //如果i没有标记过且x-&gt;i目前最优，从i出发继续找</span><br><span class="line">            if(!vis[i]&amp;&amp;cost[i]!=0&amp;&amp;(cost[i]&lt;minn||(cost[i]==minn&amp;&amp;ans[i]&gt;maxx)))&#123;</span><br><span class="line">                minn=cost[i];</span><br><span class="line">                maxx=ans[i];</span><br><span class="line">                x=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[x]=true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;start,&amp;endd);</span><br><span class="line">    memset(vis,false,sizeof(vis));</span><br><span class="line">    memset(cost,0,sizeof(cost));</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">        ans[i]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int u,v,w;</span><br><span class="line">    for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        mp[u].push_back(v);</span><br><span class="line">        mp[v].push_back(u);</span><br><span class="line">        t[u].push_back(w);</span><br><span class="line">        t[v].push_back(w);</span><br><span class="line">    &#125;</span><br><span class="line">    dij();</span><br><span class="line">    printf(&quot;%d %d\n&quot;,cost[endd],ans[endd]);  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 51nod基础题 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>F.The Best Path--ACM-ICPC 2016 Qingdao Preliminary Contest</title>
      <link href="/2018/08/15/F.The%20Best%20Path/"/>
      <url>/2018/08/15/F.The%20Best%20Path/</url>
      <content type="html"><![CDATA[<h3 id="ACM-ICPC-2016-Qingdao-Preliminary-Contest"><a href="#ACM-ICPC-2016-Qingdao-Preliminary-Contest" class="headerlink" title="ACM-ICPC 2016 Qingdao Preliminary Contest"></a>ACM-ICPC 2016 Qingdao Preliminary Contest</h3><h2 id="F-The-Best-Path"><a href="#F-The-Best-Path" class="headerlink" title="F. The Best Path"></a>F. The Best Path</h2><p><a href="https://nanti.jisuanke.com/t/29370" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/29370</a></p><p><img src="/2018/08/15/F.The Best Path/123.png" alt=""></p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3 2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">4 3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">Impossible</span><br></pre></td></tr></table></figure><p>题目来源<br>ACM-ICPC 2016 Qingdao Preliminary Contest</p><hr><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>给一个图，每个点有一个权值，找欧拉通路或者欧拉回路，然后求路径上每个点异或结果的最大值；</p><p>首先判断有没有欧拉回路或者通路，用一下定理就好了，有且仅有两个度数为奇数的点则有欧拉通路，没有度数为奇数的点则有欧拉回路；</p><p>然后把对异或值有贡献的算上，有贡献的点就是d为奇数的点和（d/2）为奇数的点，因为经过偶数次的点相当于没有贡献；</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=100005;</span><br><span class="line">int n,m,a[N],d[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,u,v;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        int ans=0;</span><br><span class="line">        memset(d,0,sizeof(d));</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">        for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">        for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">            d[u]++;d[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">        int num=0;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            if(d[i]&amp;1)num++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(num==0)&#123;</span><br><span class="line">            for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">                if((d[i]/2)&amp;1||d[i]&amp;1)ans^=a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            int tmp=ans;</span><br><span class="line">            for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">                ans=max(ans,tmp^a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;%d\n&quot;,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(num==2)&#123;</span><br><span class="line">            for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">                if((d[i]/2)&amp;1||d[i]&amp;1)ans^=a[i];</span><br><span class="line">            &#125;      </span><br><span class="line">            printf(&quot;%d\n&quot;,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        else printf(&quot;Impossible\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>D.Tea--ACM-ICPC 2016 Qingdao Preliminary Contest</title>
      <link href="/2018/08/15/D.Tea/"/>
      <url>/2018/08/15/D.Tea/</url>
      <content type="html"><![CDATA[<h3 id="ACM-ICPC-2016-Qingdao-Preliminary-Contest"><a href="#ACM-ICPC-2016-Qingdao-Preliminary-Contest" class="headerlink" title="ACM-ICPC 2016 Qingdao Preliminary Contest"></a>ACM-ICPC 2016 Qingdao Preliminary Contest</h3><h2 id="D-Tea"><a href="#D-Tea" class="headerlink" title="D.Tea"></a>D.Tea</h2><p><a href="https://nanti.jisuanke.com/t/29368" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/29368</a><br>Tea is good.</p><p>Tea is life.</p><p>Tea is everything.</p><p>The balance of tea is a journey of pursuing balance of the universe.</p><p>Alice knows that.</p><p>Alice wants to teach you the art of pouring tea.</p><p>Alice has a pot of tea.</p><p>The exact volume of tea is not important.</p><p>The exact volume of tea is at least LL.</p><p>The exact volume of tea is at most RR.</p><p>Alice put two empty cups between you and her.</p><p>Alice wants the two cups filled by almost equal volume of tea.</p><p>Yours cannot be 11 unit more than hers.</p><p>Hers cannot be 11 unit more than yours.</p><p>Alice wants you to pour the tea.</p><p>Alice wants you to pour until the pot is almost empty.</p><p>Alice wants no more than 11 unit volume of tea remaining in the pot.</p><p>You cannot read the residue volume of tea remaining in the pot.</p><p>You can only know the tea status in the pot, empty or not.</p><p>Alice does not want you to pour the tea too many times.</p><p>You better pour as few times as possible.</p><h3 id="Input-Format"><a href="#Input-Format" class="headerlink" title="Input Format"></a>Input Format</h3><p>There are multiple cases.</p><p>For each case, there is one line of two integers LL and RR, separated by single space.</p><p>Here are some analyses about sample cases.</p><p>For the first case, pouring 11 unit into one cup will satisfy Alice.</p><p>For the second case, it is clearly that you cannot only pour once to reach the desired balance, but she can achieve it by pouring twice.</p><p>First you pour 1.51.5 units into one cup, then you attempt to pour another 1.51.5 units into the other cup.</p><p>Since the lower bound is 22, at least 0.50.5 unit remains in the pot after the first pouring.</p><p>If the initial volume is in range [2,\ 3][2, 3], the second cup will have volume in range [0.5,\ 1.5][0.5, 1.5] which is balanced with 1.51.5 unit in the first cup, and at most 11 unit remain after these two attempts.</p><p>About 10001000 test cases, and 0\le L\le R \le 10^{16}0≤L≤R≤10<br>16<br> .</p><h3 id="Output-Format"><a href="#Output-Format" class="headerlink" title="Output Format"></a>Output Format</h3><p>For each case, there should be a single integer in a single line, the least number of pouring attempts.</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 2</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>题目来源<br>ACM-ICPC 2016 Qingdao Preliminary Contest</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>一开始的策略有点问题，第一杯倒 l/2 第二杯倒 l/2+1 这样不一定是最优的； </p><p>举个例子（4 9）这组数据，第一杯2，第二杯3，第一杯2+2，第二杯还需要再加一次；  </p><p>而第一杯倒（l+1）/2 ，第二杯倒（l+1）/2+1的话，（4 9），第一杯2.5 第二杯3.5 第一杯 2.5 +2，达成要求；  </p><p>所以最优策略是第一杯倒（l+1）/2 ，第二杯倒（l+1）/2+1 ，然后剩下的轮流加2，直至壶中水小于等于1；</p><p>特判几个特殊情况，具体见代码，需要注意的是，如果l=0，那么一开始（0+1）/2=0，显然不倒水是不划算的，所以如果特判结束后l=0则l=1；</p><hr><p>###代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">int main()&#123;</span><br><span class="line">    LL l,r;</span><br><span class="line">    while(~scanf(&quot;%lld%lld&quot;,&amp;l,&amp;r))&#123;</span><br><span class="line">        if(r==0||r==1)puts(&quot;0&quot;);</span><br><span class="line">        else if(r==2)puts(&quot;1&quot;);</span><br><span class="line">        else if(l==r||l==r-1)puts(&quot;2&quot;);</span><br><span class="line">        else&#123;</span><br><span class="line">            if(l==0)l=1;</span><br><span class="line">            printf(&quot;%lld\n&quot;,(r-l+2)/2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 杂 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>2006 飞行员配对(二分图最大匹配,匈牙利算法)</title>
      <link href="/2018/08/15/2006%20%E9%A3%9E%E8%A1%8C%E5%91%98%E9%85%8D%E5%AF%B9/"/>
      <url>/2018/08/15/2006%20%E9%A3%9E%E8%A1%8C%E5%91%98%E9%85%8D%E5%AF%B9/</url>
      <content type="html"><![CDATA[<h2 id="2006-飞行员配对-二分图最大匹配"><a href="#2006-飞行员配对-二分图最大匹配" class="headerlink" title="2006 飞行员配对(二分图最大匹配)"></a>2006 飞行员配对(二分图最大匹配)</h2><p>题目来源： 网络流24题<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题  </p><p>第二次世界大战时期，英国皇家空军从沦陷国征募了大量外籍飞行员。由皇家空军派出的每一架飞机都需要配备在航行技能和语言上能互相配合的2名飞行员，其中1名是英国飞行员，另1名是外籍飞行员。在众多的飞行员中，每一名外籍飞行员都可以与其他若干名英国飞行员很好地配合。如何选择配对飞行的飞行员才能使一次派出最多的飞机。对于给定的外籍飞行员与英国飞行员的配合情况，试设计一个算法找出最佳飞行员配对方案，使皇家空 军一次能派出最多的飞机 。对于给定的外籍飞行员与英国飞行员的配合情况，编程找出一个最佳飞行员配对方案， 使皇家空军一次能派出最多的飞机。 </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行有2个正整数 m 和 n。n 是皇家空军的飞行 员总数(n&lt;100);m 是外籍飞行员数。外籍飞行员编号为 1~m;英国飞行员编号为 m+1~n。接下来每行有 2 个正整数 i 和 j，表示外籍飞行员 i 可以和英国飞行员 j 配合。输入最后以 2 个-1 结束。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>第 1 行是最佳飞行 员配对方案一次能派出的最多的飞机数 M。如果所求的最佳飞行员配对方案不存在，则输出‘No Solution!’。</p><hr><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>裸的匈牙利算法求二分图最大匹配</p><p>这篇讲的超级生动形象了<a href="https://blog.csdn.net/cillyb/article/details/55511666" target="_blank" rel="noopener">https://blog.csdn.net/cillyb/article/details/55511666</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=105;</span><br><span class="line">vector&lt;int&gt;g[N];</span><br><span class="line">int n,m,ans=0,match[N];</span><br><span class="line">bool vis[N];</span><br><span class="line">bool dfs(int x)&#123;</span><br><span class="line">    for(int i=0;i&lt;g[x].size();i++)&#123;</span><br><span class="line">        int v=g[x][i];</span><br><span class="line">        if(!vis[v])&#123;</span><br><span class="line">            vis[v]=true;//标记已试图匹配</span><br><span class="line">            if(match[v]==-1||dfs(match[v]))&#123;</span><br><span class="line">            //这个点没匹配过或者这个点匹配的可拆</span><br><span class="line">                match[v]=x;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);</span><br><span class="line">    int x,y;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;,&amp;x,&amp;y),x!=-1&amp;&amp;y!=-1)&#123;</span><br><span class="line">        g[x].push_back(y);</span><br><span class="line">        g[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    memset(match,-1,sizeof(match));</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        memset(vis,false,sizeof(vis));</span><br><span class="line">        if(dfs(i))ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 51nod基础题 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Mac Os下用「hexo+github」搭建个人博客！</title>
      <link href="/2018/08/14/blog/"/>
      <url>/2018/08/14/blog/</url>
      <content type="html"><![CDATA[<h1 id="Mac-Os下用「hexo-github」搭建个人博客！"><a href="#Mac-Os下用「hexo-github」搭建个人博客！" class="headerlink" title="Mac Os下用「hexo+github」搭建个人博客！"></a>Mac Os下用「hexo+github」搭建个人博客！</h1><hr><p>这个不是教程 只是搭建过程记录向 记录一下我报错查教程改错报错查教程改错报错查教程改错。。的过程 前面有些步骤在后面有报错然后修正 所以千万不要相信我的步骤</p><hr><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><strong> 安装nodejs和git（这个自己在官网安装就可以）</strong><br><strong> 接着要用npm安装hexo </strong><br>在终端输入<code>npm install -g hexo-cli</code></p><p><img src="/2018/08/14/blog/0.png" alt=""></p><p>很多报错 可以看见好几个都是permission denied（因为权限不足无法访问）<br>可以看见提示的建议是：<code>Please try running this command again as root/Administrator.</code><br>所以重新输入<code>sudo npm install -g hexo-cli</code>（sudo：申请root权限）<br>下图表明安装成功  </p><p><img src="/2018/08/14/blog/1.png" alt=""></p><h2 id="用hexo在本地新建一个博客"><a href="#用hexo在本地新建一个博客" class="headerlink" title="用hexo在本地新建一个博客"></a>用hexo在本地新建一个博客</h2><p><strong> 新建文件夹然后右键「新建位于文件夹位置的终端窗口」</strong><br>（第一次使用的话可以在【finder-服务-服务偏好设置】中勾选上那一项）<br><strong> 文件夹位置下终端输入 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo i blog//blog是项目名，叫别的也随便</span><br><span class="line">cd blog//进入blog文件夹</span><br><span class="line">hexo g//编译</span><br><span class="line">hexo s//本地预览</span><br></pre></td></tr></table></figure></p><p><img src="/2018/08/14/blog/2.png" alt=""></p><p>（后两句不加sudo的话同样会出现permission denied的问题 所以在开头加上sudo给他权限就可以啦 下面有些地方还会遇到sudo的问题 就不赘述了 报权限不够的错误的话自己加上）</p><p>成功后会给出一个链接 一个在本地的博客就这样建好了 点开就可以发现已经有一个博客的大概了</p><p><img src="/2018/08/14/blog/3.png" alt=""></p><p><img src="/2018/08/14/blog/4.png" alt=""></p><p>这里用到了4000端口 如果该端口被占用的话可以查一下是什么东西占用了这个端口<code>sudo lsof -i:端口号</code> 如果没有输出表面该端口没有被占用 被占用的话会给出一个进程 里面有一个PID号 如果是没设么用的进程 输入<code>sudo kill -9 pid号</code>结束掉他即可</p><p>默认给的是个叫「landscape」的主题 不同主题有不同的功能布局外观 当然也可以自己写个主题出来<br>不过这种是大佬们的操作 我这个小白还是先找个主题用吧。。<br>这里放上一些主题：<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="noopener">https://github.com/hexojs/hexo/wiki/Themes</a> 此外知乎上也有关于hexo主题的讨论</p><h2 id="设置博客主题"><a href="#设置博客主题" class="headerlink" title="设置博客主题"></a>设置博客主题</h2><p><strong> 在文件夹打开终端输入git clone加上所选主题的地址 </strong></p><p>(此处以及后面所说的终端一般都是blog文件夹终端了)</p><p><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></p><p><img src="/2018/08/14/blog/5.png" alt=""></p><p><strong> 打开文件夹下的这个文件 官方名叫站点配置文件 </strong></p><p><img src="/2018/08/14/blog/6.png" alt=""></p><p><strong> 然后找到里面的theme并更改 </strong>  </p><p><img src="/2018/08/14/blog/7.png" alt=""></p><p><strong> 回到终端输入 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hero s</span><br></pre></td></tr></table></figure></p><p>点进生成的blog可以看见主题已经换好啦</p><p><img src="/2018/08/14/blog/8.png" alt=""></p><p><strong> 在[themes/next/config.yml]里配置next </strong></p><p>冒号后面是有空格的 后面有些地方也是一样！！！一定要有空格 不然会报很长很长的错！！！</p><p>可以看见备注写了三个方案给你选</p><p><img src="/2018/08/14/blog/9.png" alt=""></p><p>然后重新输入以下代码查看效果   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hero s</span><br></pre></td></tr></table></figure><p><img src="/2018/08/14/blog/10.png" alt=""></p><p>这时候这里出现了一个警告 </p><p><img src="/2018/08/14/blog/11.png" alt=""></p><p><a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">https://github.com/theme-next/hexo-theme-next</a></p><p>我用的这个next主题已经移动到别的地方了 所以问题不大复制一下然后找到这个主题的新的地址 按照上面步骤改一下就行<br>注意要把之前的主题所在文件夹删了 或者生成的时候自己换个不同的文件夹名字</p><p><img src="/2018/08/14/blog/12.png" alt=""></p><p>上面是Gemini 还蛮好看蛮直男审美的 就这个吧诶嘿</p><p>以上就是在本地建立了一个看得过去的blog了<br>下面要把这个本地blog上传到github</p><h2 id="把博客部署到GitHub上"><a href="#把博客部署到GitHub上" class="headerlink" title="把博客部署到GitHub上"></a>把博客部署到GitHub上</h2><p><strong> 先在GitHub上创建一个新项目 </strong></p><p><img src="/2018/08/14/blog/13.png" alt=""></p><p>项目名必须按如下格式输入 最后一项选上</p><p><img src="/2018/08/14/blog/14.png" alt=""></p><p>创建后点项目的setting 下拉找到github pages</p><p><img src="/2018/08/14/blog/15.png" alt=""></p><p>看不懂就翻译了一下 那么发现啦那个网址就是我们要用的<br>现在还是宇宙洪荒混沌初始的状态</p><p><img src="/2018/08/14/blog/16.png" alt=""></p><p>接下来要把hexo上的内容部署到github上</p><p><strong> 打开之前提到过的站点配置文件 把最后几行改成如下格式 </strong></p><p><img src="/2018/08/14/blog/17.png" alt=""></p><p><strong> 在终端输入如下 装个插件 </strong><br><code>npm install hexo-deployer-git --save</code></p><p><img src="/2018/08/14/blog/18.png" alt=""></p><p>emmmmmm???报了一堆错 没事 照他的提示在mac终端输入<code>npm i -g npm</code>更新一下就好了<br>更新成功的界面如下</p><p><img src="/2018/08/14/blog/19.png" alt=""></p><p>查一下也可以发现变成 6.3.0 版本了。。这不重要</p><p><img src="/2018/08/14/blog/20.png" alt=""></p><p>然后就是最后激动人心的一步了！！！！！<br><strong> 输入hexo d把它部署到github的网站上去 </strong></p><p>然后就走上了漫长的报错之路。。</p><p><img src="/2018/08/14/blog/21.png" alt=""></p><p>然后又经历了一系列艰苦卓绝我也不知道发生了啥的几个小时的查来查去试来试去！<br>最后 终于突然一下的改好了？？！</p><p>emmmmm不废话了先记录下来 大概讲讲我干了些啥</p><p>主要问题还是出在站点配置文件上 因为报错的时候一直说这个找不到那个找不到。。你都找不到我哪找得到啊</p><p>然后去找了一些有关hexo站点配置的教程 其中这份讲的是比较详细的了 照着这个改了最后那一段</p><p><a href="https://blog.csdn.net/xuezhisdc/article/details/53130383" target="_blank" rel="noopener">https://blog.csdn.net/xuezhisdc/article/details/53130383</a></p><p><img src="/2018/08/14/blog/22.png" alt=""></p><p>然后输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save </span><br><span class="line">sudo hexo clean </span><br><span class="line">sudo hexo g </span><br><span class="line">sudo hexo d</span><br></pre></td></tr></table></figure><p>还原一下我的小白操作。。<br>最后终端的结果没报错了也没说啥奇奇怪怪得话了就说明成功了</p><p><img src="/2018/08/14/blog/23.png" alt=""></p><p>回到github上可以发现 这些东西已经上传到GitHub了</p><p><img src="/2018/08/14/blog/24.png" alt=""></p><p>然后就点开github之前给的那个链接 如图</p><p><img src="/2018/08/14/blog/25.png" alt=""></p><p><strong> 之前的本地网站已经上传了！！撒花！！！！ </strong></p><hr><h3 id="补充一点内容："><a href="#补充一点内容：" class="headerlink" title="补充一点内容："></a>补充一点内容：</h3><p>首先是关于博客美化的问题 这个就看到什么好看的功能就往上使就是了 next主题美化教程还是很多哒 还有一些关于目录标签的功能 都很好上手</p><p>然后就是耍了几天博客会发现一个严重的问题！百度！Google！！竟然查不到我自己的网站 但是吧这个坑已经挖了。。不填怎么行。。网上找一下百度Google递交搜索引擎的教程就好了 </p><p>但是百度的http认证到现在都没通过 还不知道问题出在哪 这个坑挖着先。。 google的效率倒是相当快操作也很简洁 站点地图也交好了 一觉醒来在google上搜索到自己博客的感觉 还蛮妙2333333</p><p>这里在站点地图提交的时候遇到一个问题 <code>此位置的 Sitemap 不允许此网址</code> </p><p>是因为之前在站点配置文件里的 <code>url:</code>  那一项没有设置 要改成自己网站的地址 改完后提交站点地图就不会报错了</p><hr>]]></content>
      
      <categories>
          
          <category> poi </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>1995 三子棋</title>
      <link href="/2018/08/14/1995%20%E4%B8%89%E5%AD%90%E6%A3%8B%20%20/"/>
      <url>/2018/08/14/1995%20%E4%B8%89%E5%AD%90%E6%A3%8B%20%20/</url>
      <content type="html"><![CDATA[<h1 id="1995-三子棋"><a href="#1995-三子棋" class="headerlink" title="1995 三子棋"></a>1995 三子棋</h1><hr><p>题目来源： syu校赛<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 </p><p>小的时候大家一定玩过“井”字棋吧。也就是在九宫格中，只要任意行、列，或者任意连续对角线上面出现三个相同的，就能获胜。现在小明和小花也在玩三子棋，但是他们不是在九宫格里，而是在3×4的格子里面。现在小明先下，但是他知道小花这个人很聪明，他想知道第一步下在哪一个地方最合适，你能帮帮他吗？</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行输入一个整数T，表示数据组数（1&lt;T&lt;10000）；<br>第二行输入两个整数x,y,表示3×4格子里面的一个坐标(x,y)（1&lt;=x&lt;=3,1&lt;=y&lt;=4）；    </p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>每组数据输出最后小明输赢的结果，如果小明一定能赢，第一行输出“Win”,第二行输出小明所需要花的最少步数；如果小明跟小花只能打成平手，第一行输出“Equal”，第二行输出数字0；如果小明不能赢也不能跟小花打成平手，第一行输出“Lose”,第二行输出小花赢小明所需要花的最少步数</p><hr><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>抱着作a+b的心态开始刷基础题，结果基础题怎么这么不水呢么。。<br>没想到啥好方法，就自己跟自己下模拟；<br>策略就和一般五子棋差不多，关于最少步数，由于对手也是绝顶聪明的，所以不会让你下在很快赢的地方，其实应该算最多步数的最少步数那个意思。。大概；   </p><p>棋盘是对称的，所以只要看（1，1）（1，2）（2，1）（2，2）四个点就可以；<br>如下表：  </p><table><thead><tr><th>1</th><th>2</th><th>2</th><th>1</th></tr></thead><tbody><tr><td>3</td><td>4</td><td>4</td><td>3</td></tr><tr><td>1</td><td>2</td><td>2</td><td>1</td></tr></tbody></table><p>然后结论是对先手来说（1，1）（1，2）（2，2）必胜，（2，1）平局；  </p><p>（1，1）的最短路是6：<br>先手:11-&gt;12-&gt;31-&gt;23-&gt;32形成“双二”再下一步就赢了<br>后手:21-&gt;13-&gt;21-&gt;34-&gt;   </p><p>（1，2）的最短路是4：<br>先手:12-&gt;23-&gt;32形成“双二”再下一步就赢了<br>后手:13-&gt;34-&gt;   </p><p>（2，2）的最短路是4：<br>先手:22-&gt;13-&gt;11形成“双二”再下一步就赢了<br>后手:23-&gt;31-&gt;   </p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int a[3][4]=&#123;6,4,4,6,0,4,4,0,6,4,4,6&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,x,y;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);</span><br><span class="line">        x--;</span><br><span class="line">        y--;</span><br><span class="line">        if(a[x][y]==0)printf(&quot;Equal\n0\n&quot;);</span><br><span class="line">        else printf(&quot;Win\n%d\n&quot;,a[x][y]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 51nod基础题 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/08/11/hello-world/"/>
      <url>/2018/08/11/hello-world/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/LeFlacon/LeFlacon.github.io/blob/master/images/0.png?raw=true" alt=""></p>]]></content>
      
      <categories>
          
          <category> poi </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
