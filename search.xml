<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hdu 1102 Constructing Roads(最小生成树)]]></title>
    <url>%2F2018%2F08%2F19%2Fhdu%201102%20Constructing%20Roads(%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91)%2F</url>
    <content type="text"><![CDATA[hdu 1102 Constructing Roads(最小生成树)http://acm.hdu.edu.cn/showproblem.php?pid=1102Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Problem DescriptionThere are N villages, which are numbered from 1 to N, and you should build some roads such that every two villages can connect to each other. We say two village A and B are connected, if and only if there is a road between A and B, or there exists a village C such that there is a road between A and C, and C and B are connected. We know that there are already some roads between some villages and your job is the build some roads such that all the villages are connect and the length of all the roads built is minimum. InputThe first line is an integer N (3 &lt;= N &lt;= 100), which is the number of villages. Then come N lines, the i-th of which contains N integers, and the j-th of these N integers is the distance (the distance should be an integer within [1, 1000]) between village i and village j. Then there is an integer Q (0 &lt;= Q &lt;= N * (N + 1) / 2). Then come Q lines, each line contains two integers a and b (1 &lt;= a &lt; b &lt;= N), which means the road between village a and village b has been built. OutputYou should output a line contains an integer, which is the length of all the roads to be built such that all the villages are connected, and this value is minimum. Sample Input12345630 990 692990 0 179692 179 011 2 Sample Output1179 题解：裸的最小生成树的题 两种算法都放上 prim加点 kruscal加边 现在整理以前的代码感觉以前写的好详细。。 代码：Prim 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;const int N=105;const int INF=0x3f3f3f3f;int n,ans;int map_[N][N],dis[N],vis[N];void prim()&#123; for(int i=1;i&lt;=n;i++)&#123; dis[i]=map_[1][i]; vis[i]=0; &#125; dis[1]=0; vis[1]=1; int k,tmp; for(int i=1;i&lt;=n;i++)&#123; tmp=INF; for(int j=1;j&lt;=n;j++)&#123;//在从i到j还没访问过的j中找出代价最小的 if(!vis[j]&amp;&amp;tmp&gt;dis[j])&#123; k=j; tmp=dis[j]; &#125; &#125; if(tmp==INF)break;//没找到即全部访问过了，prim结束 vis[k]=1;//给k标记已访问 ans+=dis[k]; for(int j=1;j&lt;=n;j++)&#123;//加入从k出发的最短路 if(!vis[j]&amp;&amp;dis[j]&gt;map_[k][j])&#123; dis[j]=map_[k][j]; &#125; &#125; &#125;&#125;int main()&#123; while(scanf(&quot;%d&quot;,&amp;n)!=EOF)&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; scanf(&quot;%d&quot;,&amp;map_[i][j]); &#125; &#125; int q,a,b; scanf(&quot;%d&quot;,&amp;q); while(q--)&#123; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); map_[a][b]=map_[b][a]=0; &#125; ans=0; prim(); printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125; Kruscal 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;const int N=105;struct Edge&#123; int u,v; int cap;&#125;Edge[N*N];int n,ans,cnt;//cnt为边数 int fa[N];void init()&#123; for(int i=1;i&lt;=n;i++)&#123; fa[i]=i; &#125;&#125;int find(int x)&#123; if(x!=fa[x])fa[x]=find(fa[x]); return fa[x];&#125;void join(int x,int y)&#123; int a=find(x),b=find(y); if(a==b)return; else&#123; fa[a]=b; &#125;&#125; bool cmp(struct Edge a,struct Edge b)&#123; return a.cap&lt;b.cap;&#125;void kruskal()&#123; sort(Edge,Edge+cnt,cmp);//按边的最小代价排序 for(int i=0;i&lt;cnt;i++)&#123; int fx=find(Edge[i].u),fy=find(Edge[i].v); if(fx==fy)continue; ans+=Edge[i].cap;//u，v不在一棵树上，就加上这条边 join(fx,fy); &#125;&#125;int main()&#123; while(scanf(&quot;%d&quot;,&amp;n)!=EOF)&#123; init(); cnt=0; int w; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; scanf(&quot;%d&quot;,&amp;w); Edge[cnt].u=i; Edge[cnt].v=j; Edge[cnt].cap=w; cnt++; &#125; &#125; int q,u,v; scanf(&quot;%d&quot;,&amp;q); while(q--)&#123;//建树 scanf(&quot;%d%d&quot;,&amp;u,&amp;v); join(u,v); &#125; ans=0; kruskal(); printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hdu 1198 Farm Irrigation（并查集）]]></title>
    <url>%2F2018%2F08%2F18%2Fhdu%201198%20Farm%20Irrigation%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[hdu 1198 Farm Irrigation（并查集）http://acm.hdu.edu.cn/showproblem.php?pid=1198 Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Problem DescriptionBenny has a spacious farm land to irrigate. The farm land is a rectangle, and is divided into a lot of samll squares. Water pipes are placed in these squares. Different square has a different type of pipe. There are 11 types of pipes, which is marked from A to K, as Figure 1 shows. Benny has a map of his farm, which is an array of marks denoting the distribution of water pipes over the whole farm. For example, if he has a map ADCFJKIHE then the water pipes are distributed like Several wellsprings are found in the center of some squares, so water can flow along the pipes from one square to another. If water flow crosses one square, the whole farm land in this square is irrigated and will have a good harvest in autumn. Now Benny wants to know at least how many wellsprings should be found to have the whole farm land irrigated. Can you help him? Note: In the above example, at least 3 wellsprings are needed, as those red points in Figure 2 show. InputThere are several test cases! In each test case, the first line contains 2 integers M and N, then M lines follow. In each of these lines, there are N characters, in the range of ‘A’ to ‘K’, denoting the type of water pipe over the corresponding square. A negative M or N denotes the end of input, else you can assume 1 &lt;= M, N &lt;= 50. OutputFor each test case, output in one line the least number of wellsprings needed. Sample Input 12345678910112 2DKHF3 3ADCFJKIHE-1 -1``` **Sample Output** 2312345678910111213141516---### 题解：一个并查集好题水管连通本质上就是集合的合并，最后求有几个集合的问题，很容易想到并查集只需要对每个地块与右方和下方的地块进行合并即可，合并之前先判断是否能连通，若能连通则合并，不能连通，则不能合并每个地块的四个方向用数组的01来表示，用位运算来判断可连性具体见代码注释还有一种二进制的位运算写法 const int type[11] = {3,6,9,12,10,5,7,11,13,14,15}; if(dir==1){ if(((type[ta]&gt;&gt;3) &amp; 1) &amp;&amp; ((type[tb]&gt;&gt;1) &amp; 1))mark = true;}else{ if(((type[ta]&gt;&gt;2) &amp; 1) &amp;&amp; (type[tb] &amp; 1))mark = true;}123### 代码： #include&lt;bits/stdc++.h&gt;using namespace std; const int N=505;const int type[11][4]={ {1,1,0,0},{0,1,1,0},{1,0,0,1},{0,0,1,1},{0,1,0,1},{1,0,1,0},{1,1,1,0},{1,1,0,1},{1,0,1,1},{0,1,1,1},{1,1,1,1} };int n,m,num,cnt;int fa[NN+1];char f[N][N];int find(int x){ if(x!=fa[x])fa[x]=find(fa[x]); return fa[x];}void join(int x1,int y1,int x2,int y2,int dir){ if(x2&gt;n||y2&gt;m)return;//超出地图不合并 bool flag=false;//标记是否可连通 int t1,t2; t1=f[x1][y1]-‘A’; t2=f[x2][y2]-‘A’; if(dir==1){ if(type[t1][3]&amp;&amp;type[t2][1])flag=true;//竖直方向 } else{ if(type[t1][2]&amp;&amp;type[t2][0])flag=true;//水平方向 } if(flag){//合并 int a=find((x1-1)m+y1),b=find((x2-1)m+y2); if(a!=b){ fa[b]=a; –cnt;//消去一个水井 } }}int main(){ while(scanf(“%d%d”,&amp;n,&amp;m)!=EOF){ if(n==-1&amp;&amp;m==-1)break; for(int i=1;i&lt;=nm;i++){ fa[i]=i; } cnt=n*m;//初始化，假设所有田里都有水井 for(int i=1;i&lt;=n;i++){ scanf(“%s”,f[i]+1); } for(int i=1;i&lt;=n;i++){//统一向右or下合并 for(int j=1;j&lt;=m;j++){ join(i,j,i+1,j,1);//竖直 join(i,j,i,j+1,0);//水平 } } printf(“%d\n”,cnt); } return 0;}`]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hdu 1856 More is better（并查集）]]></title>
    <url>%2F2018%2F08%2F18%2Fhdu%201856%20More%20is%20better%2F</url>
    <content type="text"><![CDATA[hdu 1856 More is better（并查集）http://acm.hdu.edu.cn/showproblem.php?pid=1856 Problem DescriptionMr Wang wants some boys to help him with a project. Because the project is rather complex, the more boys come, the better it will be. Of course there are certain requirements. Mr Wang selected a room big enough to hold the boys. The boy who are not been chosen has to leave the room immediately. There are 10000000 boys in the room numbered from 1 to 10000000 at the very beginning. After Mr Wang’s selection any two of them who are still in this room should be friends (direct or indirect), or there is only one boy left. Given all the direct friend-pairs, you should decide the best way. InputThe first line of the input contains an integer n (0 &lt;= n &lt;= 100000) - the number of direct friend-pairs. The following n lines each contains a pair of numbers A and B separated by a single space that suggests A and B are direct friends. (A != B, 1 &lt;= A, B &lt;= 10000000) OutputThe output in one line contains exactly one integer equals to the maximum number of boys Mr Wang may keep. Sample Input1234567891041 23 45 61 641 23 45 67 8 Sample Output1242 题意：一开始1e7个人，有n对朋友，a和b是朋友 最后剩下的人必须直接或间接是朋友 求剩下人数的最大值 题解：求每个集合中元素的个数，然后求个数的最大值 求集合个数的方法:只需要在合并两个集合时处理一下，让这两个集合的元素个数也合并一下就行了 要注意的一个地方就是：当n=0时特判，没人是朋友，最多选一个人要输出1 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;const int N=100005;int fa[N],sum[N];int find(int x)&#123; int tmp=x; while(tmp!=fa[tmp])tmp=fa[tmp]; fa[x]=tmp; return tmp;&#125;void join(int x,int y)&#123; int a,b; a=find(x);b=find(y); if(a!=b)&#123; fa[a]=b; sum[b]+=sum[a];//合并集合中元素个数 &#125;&#125;int main()&#123; int n; while(scanf(&quot;%d&quot;,&amp;n)!=EOF)&#123; if(n==0)&#123; printf(&quot;1\n&quot;); continue; &#125; for(int i=1;i&lt;=N;i++)&#123; fa[i]=i; sum[i]=1;//开始时数量的都为1 &#125; int num=0; while(n--)&#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); num=a&gt;num?a:num; num=b&gt;num?b:num; join(a,b); &#125; int ans=0; for(int i=1;i&lt;=num;i++)&#123; ans=sum[i]&gt;ans?sum[i]:ans; &#125; printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hdu 1232 畅通工程（并查集）]]></title>
    <url>%2F2018%2F08%2F18%2Fhdu%201232%20%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[hdu 1232 畅通工程（并查集）http://acm.hdu.edu.cn/showproblem.php?pid=1232 Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Problem Description某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ Input测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。 注意:两个城市之间可以有多条道路相通,也就是说 3 31 21 22 1这种输入也是合法的 当N为0时，输入结束，该用例不被处理。 Output对每个测试用例，在1行里输出最少还需要建设的道路数目。 Sample Input 1234567891011124 21 34 33 31 21 32 35 21 23 5999 00 Sample Output 1234102998 题解：初始化时每个城镇都没有路，所以总共要连接的路的数量为n-1个，在增加路的过程中，先用并查集判断，如果两个城镇确实不在一个集合，这条路就有用，两个城镇归为一个集合中，要连接的路减一。如果两个城镇之前就已经在一个集合里，增加的这条路就无用，要连接的路不变 代码：12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;const int N=100005;int fa[N];int ed;int find(int x)&#123; int tmp=x; while(tmp!=fa[tmp])tmp=fa[tmp]; fa[x]=tmp; return tmp;&#125;void join(int x,int y)&#123; int a,b; a=find(x);b=find(y); if(a!=b)&#123; fa[a]=b; ed++; &#125;&#125;int main()&#123; int m,n,a,b; while(1)&#123; scanf(&quot;%d&quot;,&amp;n); if(n==0)break; scanf(&quot;%d&quot;,&amp;m); ed=0; for(int i=1;i&lt;=n;i++)fa[i]=i; while(m--)&#123; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); join(a,b); &#125; int k=0,flag=1; int ans=n-1-ed; printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hdu 1272 小希的迷宫（并查集）]]></title>
    <url>%2F2018%2F08%2F18%2Fhdu%201272%20%E5%B0%8F%E5%B8%8C%E7%9A%84%E8%BF%B7%E5%AE%AB%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[hdu 1272 小希的迷宫（并查集）http://acm.hdu.edu.cn/showproblem.php?pid=1272Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Problem Description上次Gardon的迷宫城堡小希玩了很久（见Problem B），现在她也想设计一个迷宫让Gardon来走。但是她设计迷宫的思路不一样，首先她认为所有的通道都应该是双向连通的，就是说如果有一个通道连通了房间A和B，那么既可以通过它从房间A走到房间B，也可以通过它从房间B走到房间A，为了提高难度，小希希望任意两个房间有且仅有一条路径可以相通（除非走了回头路）。小希现在把她的设计图给你，让你帮忙判断她的设计图是否符合她的设计思路。比如下面的例子，前两个是符合条件的，但是最后一个却有两种方法从5到达8。 Input输入包含多组数据，每组数据是一个以0 0结尾的整数对列表，表示了一条通道连接的两个房间的编号。房间的编号至少为1，且不超过100000。每两组数据之间有一个空行。整个文件以两个-1结尾。 Output对于输入的每一组数据，输出仅包括一行。如果该迷宫符合小希的思路，那么输出”Yes”，否则输出”No”。 Sample Input123456789106 8 5 3 5 2 6 45 6 0 08 1 7 3 6 2 8 9 7 57 4 7 8 7 6 0 03 8 6 8 6 45 3 5 6 5 2 0 0-1 -1 Sample Output123YesYesNo 题解： 保证图是连通的，且连通分量为1 不存在环（包括自环） 因为这是一个无向图，只要保证 顶点数 = 边数+1 ， 就可以说明是连通的 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3fconst int N=100005;int fa[N];bool vis[N];bool circle;//判断是否成环int ed,v;//边数和顶点数 int find(int x)&#123; int tmp=x; while(tmp!=fa[tmp])tmp=fa[tmp]; fa[x]=tmp; return tmp;&#125;void join(int x,int y)&#123; if(x==y)circle=true; int a,b; a=find(x);b=find(y); if(a!=b)&#123; fa[a]=b; ed++;//多一条边 &#125; else circle=true;//要join(x,y)，而a=b说明 x,y是同一祖先，再连起来就成环了 &#125;int main()&#123; int a,b; while(1)&#123; memset(vis,0,sizeof(vis)); circle=false; ed=0;v=0; for(int i=1;i&lt;N;i++)fa[i]=i; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); if(a==0&amp;&amp;b==0)&#123;//空树特判 puts(&quot;Yes&quot;); continue; &#125; if(a==-1&amp;&amp;b==-1)return 0; vis[a]=true;vis[b]=true; join(a,b); while(1)&#123; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); if(a==0&amp;&amp;b==0)break; join(a,b); vis[a]=true;vis[b]=true; &#125; int k=0,flag=1; for(int i=1;i&lt;N;i++)&#123; if(vis[i])v++; &#125; if(!circle&amp;&amp;ed+1==v)puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hdu 1325 Is it a tree？（并查集）]]></title>
    <url>%2F2018%2F08%2F18%2Fhdu%201325%20Is%20it%20a%20tree%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[hdu 1325 Is it a tree？http://acm.hdu.edu.cn/showproblem.php?pid=1325 InputThe input will consist of a sequence of descriptions (test cases) followed by a pair of negative integers. Each test case will consist of a sequence of edge descriptions followed by a pair of zeroes Each edge description will consist of a pair of integers; the first integer identifies the node from which the edge begins, and the second integer identifies the node to which the edge is directed. Node numbers will always be greater than zero. OutputFor each test case display the line Case k is a tree.&quot; or the lineCase k is not a tree.”, where k corresponds to the test case number (they are sequentially numbered starting with 1). Sample Input12345676 8 5 3 5 2 6 45 6 0 08 1 7 3 6 2 8 9 7 57 4 7 8 7 6 0 03 8 6 8 6 45 3 5 6 5 2 0 0-1 -1 Sample Output123Case 1 is a tree.Case 2 is a tree.Case 3 is not a tree. 题意：按题意判断是不是一棵树 题解：类似hdu1272 无环； 除了根，所有的入度为1，根入度为0； 这个结构只有一个根，空树也是树。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3fconst int N=100005;int fa[N];bool vis[N];bool circle;//判断是否成环int du[N];int find(int x)&#123; int tmp=x; while(tmp!=fa[tmp])tmp=fa[tmp]; fa[x]=tmp; return tmp;&#125;void join(int x,int y)&#123; du[y]++; if(x==y)circle=true; int a,b; a=find(x);b=find(y); if(a!=b)&#123; fa[a]=b; &#125; else circle=true;//要join(x,y)，而a=b说明 x,y是同一祖先，再连起来就成环了 &#125;int main()&#123; int a,b; int cas=1; while(1)&#123; memset(vis,0,sizeof(vis)); memset(du,0,sizeof(du)); circle=false; for(int i=1;i&lt;N;i++)fa[i]=i; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); if(a==0&amp;&amp;b==0)&#123;//空树特判 printf(&quot;Case %d is a tree.\n&quot;,cas); cas++; continue; &#125; if(a&lt;0&amp;&amp;b&lt;0)return 0; vis[a]=true;vis[b]=true; join(a,b); while(1)&#123; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); if(a==0&amp;&amp;b==0)break; join(a,b); vis[a]=true;vis[b]=true; &#125; int gen=0,flag=0; for(int i=1;i&lt;N;i++)&#123; if(vis[i])&#123; if(du[i]&gt;1)&#123; flag=1;break; &#125; else if(du[i]==0)gen++; &#125; &#125; if(!circle&amp;&amp;flag==0&amp;&amp;gen==1)printf(&quot;Case %d is a tree.\n&quot;,cas); else printf(&quot;Case %d is not a tree.\n&quot;,cas); cas++; &#125; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[poj 1182 食物链（并查集）]]></title>
    <url>%2F2018%2F08%2F18%2Fpoj%201182%20%E9%A3%9F%E7%89%A9%E9%93%BE%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[poj 1182 食物链（并查集）http://poj.org/problem?id=1182 Time Limit: 1000MS Memory Limit: 10000K Description动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。有人用两种说法对这N个动物所构成的食物链关系进行描述：第一种说法是”1 X Y”，表示X和Y是同类。第二种说法是”2 X Y”，表示X吃Y。此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。1） 当前的话与前面的某些真的话冲突，就是假话；2） 当前的话中X或Y比N大，就是假话；3） 当前的话表示X吃X，就是假话。你的任务是根据给定的N（1 &lt;= N &lt;= 50,000）和K句话（0 &lt;= K &lt;= 100,000），输出假话的总数。 Input第一行是两个整数N和K，以一个空格分隔。以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。若D=1，则表示X和Y是同类。若D=2，则表示X吃Y。 Output只有一个整数，表示假话的数目。 Sample Input12345678100 71 101 1 2 1 22 2 3 2 3 3 1 1 3 2 3 1 1 5 5 Sample Output13 题解：分成三类 所以用 并查集+数组加倍 不知道当时在哪看到的这种数组加倍的写法 反正巨好用 i (i+n) (i+2*n) 分别代表abc三个种类 如果a吃b 就分别把三种的a和b的下一个join起来 注意这题不合法的输入也要处理成假话 下面是网上找的带权并查集的写法 但是我还是喜欢数组加倍。。https://blog.csdn.net/sunmaoxiang/article/details/80959300 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;using namespace std;const int N=50005;int fa[N*3];int find(int x)&#123; return fa[x]==x?x:fa[x]=find(fa[x]);&#125; void join(int x,int y)&#123; fa[find(x)]=find(y);&#125;int main()&#123; int n,k,ans=0; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=0;i&lt;=3*n;i++)fa[i]=i; for(int i=0;i&lt;k;i++)&#123; int a,b,d; scanf(&quot;%d%d%d&quot;,&amp;d,&amp;a,&amp;b); if(a&gt;n||b&gt;n||a&lt;1||b&lt;1)&#123; ans++; continue; &#125; else if(d==1)&#123; if(find(a)==find(b+n)||find(a)==find(b+2*n))&#123; ans++; continue; &#125; join(a,b); join(a+n,b+n); join(a+2*n,b+2*n); &#125; else &#123; if(find(a)==find(b)||find(a)==find(b+2*n))&#123; ans++; continue; &#125; else&#123; join(a,b+n); join(a+n,b+2*n); join(a+2*n,b); &#125; &#125; &#125; printf(&quot;%d\n&quot;,ans);&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[poj 1988 Cube Stacking（并查集）]]></title>
    <url>%2F2018%2F08%2F18%2Fpoj%201988%20Cube%20Stacking%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[poj 1988 Cubehttp://poj.org/problem?id=1988Time Limit: 2000MS Memory Limit: 30000K DescriptionFarmer John and Betsy are playing a game with N (1 &lt;= N &lt;= 30,000)identical cubes labeled 1 through N. They start with N stacks, each containing a single cube. Farmer John asks Betsy to perform P (1&lt;= P &lt;= 100,000) operation. There are two types of operations:moves and counts. In a move operation, Farmer John asks Bessie to move the stack containing cube X on top of the stack containing cube Y. In a count operation, Farmer John asks Bessie to count the number of cubes on the stack with cube X that are under the cube X and report that value. Write a program that can verify the results of the game. Input Line 1: A single integer, P Lines 2..P+1: Each of these lines describes a legal operation. Line 2 describes the first operation, etc. Each line begins with a ‘M’ for a move operation or a ‘C’ for a count operation. For move operations, the line also contains two integers: X and Y.For count operations, the line also contains a single integer: X. Note that the value for N does not appear in the input file. No move operation will request a move a stack onto itself. OutputPrint the output from each of the count operations in the same order as the input file. Sample Input12345676M 1 6C 1M 2 4M 2 6C 3C 4 Sample Output123102 题意：给n个箱子 1-n排成n列有两种操作： M：将x所在列上的箱子移到y所在列箱子上面 C：求x箱子下有几个箱子 题解：因为有合并两堆箱子的操作 所以想到用并查集 这题巧妙的地方在于如何求解这个箱子下面的箱子数 开两个数组 num[i]记录当前第i列有几个箱子place[i]记录箱子i下面的箱子个数 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;using namespace std;const int N=30010;int fa[N],num[N],place[N];int find(int x)&#123; if(fa[x]==x)return x; int temp=fa[x]; fa[x]=find(fa[x]); place[x]+=place[temp]; return fa[x];&#125; void join(int x,int y)&#123; fa[x]=y; place[x]+=num[y]; num[y]+=num[x]; num[x]=0;&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=30000;i++)&#123; place[i]=0; num[i]=1; fa[i]=i; &#125; for(int i=0;i&lt;n;i++)&#123; char s[5]; scanf(&quot;%S&quot;,&amp;s); if(s[0]==&apos;M&apos;)&#123; int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); int x1=find(x),y1=find(y); if(x1!=y1)join(x1,y1); &#125; else if(s[0]==&apos;C&apos;)&#123; int x; scanf(&quot;%d&quot;,&amp;x); find(x); printf(&quot;%d\n&quot;,place[x]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Teemo's bad day（并查集）]]></title>
    <url>%2F2018%2F08%2F18%2FTeemo's%20bad%20day%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Teemo’s bad day（并查集）https://nanti.jisuanke.com/t/29203 Today is a bad day. Teemo is scolded badly by his teacher because he didn’t do his homework.But Teemo is very self-confident, he tells the teacher that the problems in the homework are too simple to solve. So the teacher gets much angrier and says”I will choose a problem in the homework, if you can’t solve it, I will call you mother! “ The problem is that: There is an array A which contains n integers, and an array B which also contains n integers. You can pay one dollar to buy a card which contains two integers a1 and a2, The card can arbitrary number of times transform a single integer a1 to a2 and vise-versa on both array A and Array B. Please calculate the minimum dollars you should pay to make the two array same(For every 1&lt;=i&lt;=n,A[i]=B[i]); Input FormatThe first line of the input contains an integer T(1&lt;=T&lt;=10), giving the number of test cases.For every test case, the first line contains an integer n(1&lt;=n&lt;=500000). The second line contains n integers. The i th integer represents Ai. And the third line contains n integers. The i th integer represents Bi. Output FormatFor each test case, output an integer which means the minimum dollars you should pay in a line. 样例输入1234151 1 2 3 21 2 3 1 1 样例输出12 题意：给两个序列，某一张卡片可以把数a换成数b，次数不限，求把两个序列变成相同需要的最少卡片数 题解：两个数父亲不同就join（a,b），然后ans++ 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;ctype.h&gt;#include &lt;cstdlib&gt;#include &lt;climits&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;deque&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;#include &lt;limits&gt;using namespace std;const int N=100005;int fa[N];int find(int x)&#123; int tmp=x; while(fa[tmp]!=tmp)tmp=fa[tmp]; fa[x]=tmp; return tmp;&#125;void join(int x,int y)&#123; if(find(x)!=find(y))fa[find(x)]=fa[find(y)];&#125;int a[N*5],b[N*5];int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=N;i++)fa[i]=i; for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;b[i]); int ans=0; for(int i=1;i&lt;=n;i++)&#123; int aa=find(a[i]),bb=find(b[i]); if(aa==bb)continue; else&#123; ans++; join(aa,bb); &#125; &#125; printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1365 浴火银河星际跳跃（并查集）]]></title>
    <url>%2F2018%2F08%2F18%2F1365%20%E6%B5%B4%E7%81%AB%E9%93%B6%E6%B2%B3%E6%98%9F%E9%99%85%E8%B7%B3%E8%B7%83%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1365 浴火银河星际跳跃（并查集）http://codevs.cn/problem/1365/ 时间限制: 1 s 空间限制: 128000 KB 题目等级 : 黄金 Gold 题目描述 Description小 K 又在玩浴火银河了。。。不过这次他的目的不是跑运输赚钱，而是做任务赚钱。他想知道关于一个任务的两个星系是否可以连通。 输入描述 Input Description第一行，三个数，X,N,MX 表示出现的星系代号的最大值；N 表示有 N 个星际跳跃门;M 表示有 M 个任务。接下来的 N 行描述每个星际跳跃门：每行为两个数字（星系代号），星际跳跃门连通这两个星系（星际跳跃门是可以双向通行的）；接下来的 M 行表示每个任务需要到达的星系，每个任务需要到达两个星系。 输出描述 Output Description共 M 行。第 i 行表示第 i 个任务是否能完成：即两个星系是否能连通。（能→Yes；不能→No） 样例输入 Sample Input5 2 13 54 53 4 样例输出 Sample OutputYes 数据范围及提示 Data Size &amp; Hint最大数据第一行：19999 17542 1664 代码12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;const int N=20005;int fa[N];int find(int t)&#123; int tmp=t; while(tmp!=fa[tmp])tmp=fa[tmp]; fa[t]=tmp; return tmp;&#125;int main()&#123; int x,n,m,a,b; cin&gt;&gt;x&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=x;i++)fa[i]=i; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;a&gt;&gt;b; int tmpa=find(a),tmpb=find(b); if(tmpa!=tmpb)fa[tmpb]=tmpa; &#125; for(int i=0;i&lt;m;i++)&#123; cin&gt;&gt;a&gt;&gt;b; int tmpa=find(a),tmpb=find(b); if(tmpa==tmpb)cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1240 莫比乌斯函数（数论）]]></title>
    <url>%2F2018%2F08%2F18%2F1240%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1240 莫比乌斯函数（数论）基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 莫比乌斯函数，由德国数学家和天文学家莫比乌斯提出。梅滕斯(Mertens)首先使用μ(n)（miu(n)）作为莫比乌斯函数的记号。（据说，高斯(Gauss)比莫比乌斯早三十年就曾考虑过这个函数）。 具体定义如下： 如果一个数包含平方因子，那么miu(n) = 0。例如：miu(4), miu(12), miu(18) = 0。 如果一个数不包含平方因子，并且有k个不同的质因子，那么miu(n) = (-1)^k。例如：miu(2), miu(3), miu(30) = -1,miu(1), miu(6), miu(10) = 1。 给出一个数n, 计算miu(n)。 Input输入包括一个数n，(2 &lt;= n &lt;= 10^9) Output输出miu(n)。 Input示例5 Output示例-1 题解：只有一个输入 直接求因子数就好 不用线筛 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;fstream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;list&gt;#include &lt;vector&gt;using namespace std;#define LL long longint mu(int x)&#123; int flag=0,num=0; for(int i=2;i*i&lt;=x;i++)&#123; if(x%i==0)&#123; x/=i; num++; if(x%i==0)&#123; flag=1;//包含平方因子 return 0; &#125; &#125; &#125; if(num&amp;1)return 1; else return -1;&#125;/*o(n)线筛int mu[N],prime[N];bool vis[N];int ji;void init()&#123; mu[1]=1; memset(vis,false,sizeof(vis)); for(int i=2;i&lt;N;i++)&#123; if(!vis[i])&#123; prime[ji++]=i; mu[i]=-1; &#125; for(int j=0;j&lt;ji&amp;&amp;i*prime[j]&lt;N;j++)&#123; vis[i*prime[j]]=true; if(i%prime[j])mu[i*prime[j]]=-mu[i]; else&#123; mu[i*prime[j]]=0; break; &#125; &#125; &#125;&#125;*/int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); printf(&quot;%d\n&quot;,mu(n)); return 0;&#125;]]></content>
      <categories>
        <category>51nod基础题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1256 乘法逆元（数论）]]></title>
    <url>%2F2018%2F08%2F18%2F1256%20%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%2F</url>
    <content type="text"><![CDATA[1256 乘法逆元（数论）基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 给出2个数M和N(M &lt; N)，且M与N互质，找出一个数K满足0 &lt; K &lt; N且K * M % N = 1，如果有多个满足条件的，输出最小的。 Input输入2个数M, N中间用空格分隔（1 &lt;= M &lt; N &lt;= 10^9) Output输出一个数K，满足0 &lt; K &lt; N且K * M % N = 1，如果有多个满足条件的，输出最小的。 Input示例12 3 Output示例12 题解：数论 —— 扩展欧几里得 ax+by=gcd(a,b) a,b互质 有ax+by=1 ax%b=1%b 记x为inv(a) 则a*inv(a)%b=1%b 代码：123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;fstream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;list&gt;#include &lt;vector&gt;using namespace std;#define LL long longvoid ex_gcd(LL a,LL b,LL &amp;x,LL &amp;y,LL &amp;d)&#123; if(!b)&#123; d=a;x=1;y=0; &#125; else&#123; ex_gcd(b,a%b,y,x,d); y-=x*(a/b); &#125;&#125;LL inv(LL t,LL p)&#123; LL d,x,y; ex_gcd(t,p,x,y,d); return d==1?(x%p+p)%p:-1;&#125;int main()&#123; LL m,n; scanf(&quot;%lld%lld&quot;,&amp;m,&amp;n); printf(&quot;%lld\n&quot;,inv(m,n)); return 0;&#125;]]></content>
      <categories>
        <category>51nod基础题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1264 线段相交（计算几何）]]></title>
    <url>%2F2018%2F08%2F17%2F1264%20%E7%BA%BF%E6%AE%B5%E7%9B%B8%E4%BA%A4%2F</url>
    <content type="text"><![CDATA[1264 线段相交（计算几何）基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 给出平面上两条线段的两个端点，判断这两条线段是否相交（有一个公共点或有部分重合认为相交）。 如果相交，输出”Yes”，否则输出”No”。 Input第1行：一个数T，表示输入的测试数量(1 &lt;= T &lt;= 1000)第2 - T + 1行：每行8个数，x1,y1,x2,y2,x3,y3,x4,y4。(-10^8 &lt;= xi, yi &lt;= 10^8)(直线1的两个端点为x1,y1 | x2, y2,直线2的两个端点为x3,y3 | x4, y4) Output输出共T行，如果相交输出”Yes”，否则输出”No”。 Input示例12321 2 2 1 0 0 2 2-1 1 1 1 0 0 1 -1 Output示例12YesNo 题解：计算几何判断线段相交模版 注释掉的部分是不包括端点和线段重合的模版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;fstream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;list&gt;#include &lt;vector&gt;using namespace std;#define eps 1e-8#define zero(x) (((x)&gt;0?(x):-(x))&lt;eps)struct point&#123; double x,y,z;&#125;q[4];//叉积double xmult(point p1,point p2,point p0)&#123; return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);&#125;//判三点共线int dots_inline(point p1,point p2,point p3)&#123; return zero(xmult(p1,p2,p3));&#125;//判点是否在线段上，包括端点int dot_online_in(point p,point l1,point l2)&#123; return zero(xmult(p,l1,l2)&amp;&amp;(l1.x-p.x)*(l2.x-p.x)&lt;eps&amp;&amp;(l1.y-p.y)*(l2.y-p.y)&lt;eps);&#125;//判两点在线段同侧,点在线段上返回0int same_side(point p1,point p2,point l1,point l2)&#123; return xmult(l1,p1,l2)*xmult(l1,p2,l2)&gt;eps;&#125;//判两线段相交，包括端点和重合(p14)int intersect_in(point u1,point u2,point v1,point v2)&#123; if(!dots_inline(u1,u2,v1)||!dots_inline(u1,u2,v2)) return !same_side(u1,u2,v1,v2)&amp;&amp;!same_side(v1,v2,u1,u2); return (dot_online_in(u1,v1,v2)||dot_online_in(u2,v1,v2)|| dot_online_in(v1,u1,u2)||dot_online_in(v2,u1,u2));&#125;/*//判两点在线段异侧int opposite_side(point p1,point p2,point l1,point l2)&#123; return xmult(l1,p1,l2)*xmult(l1,p2,l2)&lt;-eps;&#125;//判两线段相交，不包括端点和重合int intersect_ex(point u1,point u2,point v1,point v2)&#123; return opposite_side(u1,u2,v1,v2)&amp;&amp;opposite_side(v1,v2,u1,u2);&#125;*/int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; for(int i=0;i&lt;4;i++)scanf(&quot;%lf%lf&quot;,&amp;q[i].x,&amp;q[i].y); if(intersect_in(q[0],q[1],q[2],q[3]))puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>51nod基础题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1265 四点共面（计算几何）]]></title>
    <url>%2F2018%2F08%2F17%2F1265%20%E5%9B%9B%E7%82%B9%E5%85%B1%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[1265 四点共面（计算几何）基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 给出三维空间上的四个点（点与点的位置均不相同），判断这4个点是否在同一个平面内（4点共线也算共面）。如果共面，输出”Yes”，否则输出”No”。 Input第1行：一个数T，表示输入的测试数量(1 &lt;= T &lt;= 1000)第2 - 4T + 1行：每行4行表示一组数据，每行3个数，x, y, z, 表示该点的位置坐标(-1000 &lt;= x, y, z &lt;= 1000)。 Output输出共T行，如果共面输出”Yes”，否则输出”No”。 Input示例1234511 2 02 3 04 0 00 0 0 Output示例1Yes 题解：计算几何四点共面模版 已经包含四点共线的情况了 如果四点不能共线 那就用两次三点共线判断一下就行 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;fstream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;list&gt;#include &lt;vector&gt;using namespace std;#define eps 1e-8#define zero(x) (((x)&gt;0?(x):-(x))&lt;eps)struct point&#123; double x,y,z;&#125;q[4];//叉积point xmult(point u,point v)&#123; point ret; ret.x=u.y*v.z-v.y*u.z; ret.y=u.z*v.x-u.x*v.z; ret.z=u.x*v.y-u.y*v.x; return ret;&#125;//点积double dmult(point u,point v)&#123; return u.x*v.x+u.y*v.y+u.z*v.z;&#125;//矢量差point subt(point u,point v)&#123; point ret; ret.x=u.x-v.x; ret.y=u.y-v.y; ret.z=u.z-v.z; return ret;&#125;//取平面法向量point pvec(point s1,point s2,point s3)&#123; return xmult(subt(s1,s2),subt(s2,s3));&#125;//向量大小double vlen(point p)&#123; return sqrt(p.x*p.x+p.y*p.y+p.z*p.z);&#125;//判三点共线int dots_inline(point a,point b,point c)&#123; return vlen(xmult(subt(a,b),subt(b,c)))&lt;eps;&#125;//判四点共面int dots_onplane(point a,point b,point c,point d)&#123; return zero(dmult(pvec(a,b,c),subt(d,a)));&#125;bool check()&#123; if(dots_onplane(q[0],q[1],q[2],q[3]))return true; return false;&#125;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; for(int i=0;i&lt;4;i++)&#123; scanf(&quot;%lf%lf%lf&quot;,&amp;q[i].x,&amp;q[i].y,&amp;q[i].z); &#125; if(check())puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>51nod基础题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1298 圆与三角形（计算几何）]]></title>
    <url>%2F2018%2F08%2F17%2F1298-%E5%9C%86%E4%B8%8E%E4%B8%89%E8%A7%92%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[Input第1行：一个数T，表示输入的测试数量(1 &lt;= T &lt;= 10000)，之后每4行用来描述一组测试数据。4-1：三个数，前两个数为圆心的坐标xc, yc，第3个数为圆的半径R。(-3000 &lt;= xc, yc &lt;= 3000, 1 &lt;= R &lt;= 3000）4-2：2个数，三角形第1个点的坐标。4-3：2个数，三角形第2个点的坐标。4-4：2个数，三角形第3个点的坐标。(-3000 &lt;= xi, yi &lt;= 3000） Output共T行，对于每组输入数据，相交输出”Yes”，否则输出”No”。 Input示例12345678920 0 1010 015 015 50 0 100 05 05 5 Output示例12YesNo 题解：判断圆和三角形是否相交 直接判断三角形三条线段和圆是否有交点 上个计算几何模版 最初的思路是分成三种情况考虑 一种是内包含 只要判断三个点是否都在圆内即可 第二种是外包含 要判断三个点都在圆外且圆心到三边距离都大于半径 第三种是下图情况 就不好操作了 所以还是直接用模版啦 然后系统说我编译错误 明明sublime编译通过了的 麻烦诶。。然后用devc++试了下 报了下图的错 查了是因为distance和内置的函数重名了 改改就好了下次注意 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;fstream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;list&gt;#include &lt;vector&gt;using namespace std;#define eps 1e-8double a0,b0,r,a1,a2,a3,b1,b2,b3;struct point&#123; double x,y;&#125;q0,q1,q2,q3;double xmult(point p1,point p2,point p0)&#123; return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);&#125;double Distance(point p1,point p2)&#123; return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));&#125;// 点到直线距离double disptoline(point p,point l1,point l2)&#123; return fabs(xmult(p,l1,l2)/Distance(l1,l2));&#125;// 判断线段和圆相交，包括端点和相切(p33)int intersect_seg_circle(point c,double r0,point l1,point l2)&#123; double t1=Distance(c,l1)-r,t2=Distance(c,l2)-r; point t=c; if(t1&lt;eps||t2&lt;eps)return t1&gt;-eps||t2&gt;-eps; t.x+=l1.y-l2.y; t.y+=l2.x-l1.x; return xmult(l1,c,t)*xmult(l2,c,t)&lt;eps&amp;&amp;disptoline(c,l1,l2)-r&lt;eps;&#125;bool check()&#123; if(intersect_seg_circle(q0,r,q1,q2))return true; if(intersect_seg_circle(q0,r,q1,q3))return true; if(intersect_seg_circle(q0,r,q2,q3))return true; return false;&#125; int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%lf%lf%lf&quot;,&amp;a0,&amp;b0,&amp;r);q0.x=a0;q0.y=b0; scanf(&quot;%lf%lf&quot;,&amp;a1,&amp;b1);q1.x=a1;q1.y=b1; scanf(&quot;%lf%lf&quot;,&amp;a2,&amp;b2);q2.x=a2;q2.y=b2; scanf(&quot;%lf%lf&quot;,&amp;a3,&amp;b3);q3.x=a3;q3.y=b3; if(check())puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>51nod基础题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1384 全排列（STL/dfs）]]></title>
    <url>%2F2018%2F08%2F17%2F1384%20%E5%85%A8%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[1384 全排列（STL/dfs）基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 给出一个字符串S（可能有重复的字符），按照字典序从小到大，输出S包括的字符组成的所有排列。例如：S = “1312”，输出为： 112311321213123113121321211321312311311231213211 Input输入一个字符串S（S的长度 &lt;= 9，且只包括0 - 9的阿拉伯数字） Output输出S所包含的字符组成的所有排列 Input示例11312 Output示例123456789101112112311321213123113121321211321312311311231213211 题解：题意很简单 就水水的全排列 直接next_permutation就好啦 诶好用 printf竟然tle了 改成 puts() 之后跑了46ms 不过这样太依赖stl了 还是乖乖再写个dfs吧。。 然后又t了。。1900ms+。。把printf改成cout就过了 跑了484ms 不是很懂 printf不是比cout快的嘛？？？ 而且加上输入输出优化之后ios::sync_with_stdio(false);cin.tie(0); 没有跑得更快反而慢了一丢丢 代码：1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;fstream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;list&gt;#include &lt;vector&gt;using namespace std;int main()&#123; char s[10]; scanf(&quot;%s&quot;,s); int len=strlen(s); sort(s,s+len); do&#123; // printf(&quot;%s\n&quot;,s); puts(s); &#125;while(next_permutation(s,s+len)); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;fstream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;list&gt;#include &lt;vector&gt;using namespace std;char s[10];int ans[10],len;bool vis[10];void dfs(int x)&#123; if(x==len)&#123; for(int i=0;i&lt;len;i++)cout&lt;&lt;ans[i]; cout&lt;&lt;endl; return; &#125; for(int i=0;i&lt;len;i++)&#123; if(!vis[i])&#123; vis[i]=true; ans[x]=s[i]-&apos;0&apos;; dfs(x+1); vis[i]=false; while(i&lt;=len&amp;&amp;s[i]==s[i+1])i++;//去重 &#125; &#125;&#125;int main()&#123; scanf(&quot;%s&quot;,s); len=strlen(s); sort(s,s+len); memset(vis,false,sizeof(vis)); dfs(0); return 0;&#125;]]></content>
      <categories>
        <category>51nod基础题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1459 迷宫游戏（Dijkstra）]]></title>
    <url>%2F2018%2F08%2F16%2F1459%20%E8%BF%B7%E5%AE%AB%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[1459 迷宫游戏（Dijkstra）基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 你来到一个迷宫前。该迷宫由若干个房间组成，每个房间都有一个得分，第一次进入这个房间，你就可以得到这个分数。还有若干双向道路连结这些房间，你沿着这些道路从一个房间走到另外一个房间需要一些时间。游戏规定了你的起点和终点房间，你首要目标是从起点尽快到达终点，在满足首要目标的前提下，使得你的得分总和尽可能大。现在问题来了，给定房间、道路、分数、起点和终点等全部信息，你能计算在尽快离开迷宫的前提下，你的最大得分是多少么？ Input第一行4个整数n (&lt;=500), m, start, end。n表示房间的个数，房间编号从0到(n - 1)，m表示道路数,任意两个房间之间最多只有一条道路，start和end表示起点和终点房间的编号。第二行包含n个空格分隔的正整数(不超过600)，表示进入每个房间你的得分。再接下来m行，每行3个空格分隔的整数x, y, z (0&lt;z&lt;=200)表示道路,表示从房间x到房间y(双向)的道路,注意，最多只有一条道路连结两个房间, 你需要的时间为z。输入保证从start到end至少有一条路径。 Output一行，两个空格分隔的整数，第一个表示你最少需要的时间，第二个表示你在最少时间前提下可以获得的最大得分。 Input示例12343 2 0 21 2 30 1 101 2 11 Output示例121 6 题解：dijkstra 最短路径问题—Dijkstra算法详解 这题还要在最短路的基础上求权值最大 开个数组记录一下然后和路径一起更新就行 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;fstream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;list&gt;#include &lt;vector&gt;using namespace std;const int N=505;const int INF=0x3f3f3f3f;int a[N],cost[N],ans[N];bool vis[N];int n,m,start,endd;vector&lt;int&gt;mp[N];vector&lt;int&gt;t[N];void dij()&#123; int x=start; vis[x]=true; while(x!=endd)&#123; for(int i=0;i&lt;mp[x].size();i++)&#123; int y=mp[x][i]; int tmpcost=cost[x]+t[x][i]; int tmpans=ans[x]+a[y]; if(cost[y]==0||tmpcost&lt;cost[y]||(tmpcost==cost[y]&amp;&amp;tmpans&gt;ans[y]))&#123; //如果x-&gt;y的路在之前还未连通 //或者新路径从x-&gt;y的时间小于原来的，或等于但是权值更大，就更新答案 ans[y]=tmpans; cost[y]=tmpcost; &#125; &#125; int minn=INF,maxx=0; for(int i=0;i&lt;n;i++)&#123; //如果i没有标记过且x-&gt;i目前最优，从i出发继续找 if(!vis[i]&amp;&amp;cost[i]!=0&amp;&amp;(cost[i]&lt;minn||(cost[i]==minn&amp;&amp;ans[i]&gt;maxx)))&#123; minn=cost[i]; maxx=ans[i]; x=i; &#125; &#125; vis[x]=true; &#125;&#125;int main()&#123; scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;start,&amp;endd); memset(vis,false,sizeof(vis)); memset(cost,0,sizeof(cost)); for(int i=0;i&lt;n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); ans[i]=a[i]; &#125; int u,v,w; for(int i=0;i&lt;m;i++)&#123; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); mp[u].push_back(v); mp[v].push_back(u); t[u].push_back(w); t[v].push_back(w); &#125; dij(); printf(&quot;%d %d\n&quot;,cost[endd],ans[endd]); return 0;&#125;]]></content>
      <categories>
        <category>51nod基础题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[F.The Best Path--ACM-ICPC 2016 Qingdao Preliminary Contest]]></title>
    <url>%2F2018%2F08%2F15%2FF.The%20Best%20Path%2F</url>
    <content type="text"><![CDATA[ACM-ICPC 2016 Qingdao Preliminary ContestF. The Best Pathhttps://nanti.jisuanke.com/t/29370 样例输入12345678910111213141523 23451 22 34 312341 22 32 4 样例输出122Impossible 题目来源ACM-ICPC 2016 Qingdao Preliminary Contest 题解：给一个图，每个点有一个权值，找欧拉通路或者欧拉回路，然后求路径上每个点异或结果的最大值； 首先判断有没有欧拉回路或者通路，用一下定理就好了，有且仅有两个度数为奇数的点则有欧拉通路，没有度数为奇数的点则有欧拉回路； 然后把对异或值有贡献的算上，有贡献的点就是d为奇数的点和（d/2）为奇数的点，因为经过偶数次的点相当于没有贡献； 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;fstream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;list&gt;#include &lt;vector&gt;using namespace std;const int N=100005;int n,m,a[N],d[N];int main()&#123; int t,u,v; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; int ans=0; memset(d,0,sizeof(d)); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]); for(int i=0;i&lt;m;i++)&#123; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); d[u]++;d[v]++; &#125; int num=0; for(int i=1;i&lt;=n;i++)&#123; if(d[i]&amp;1)num++; &#125; if(num==0)&#123; for(int i=1;i&lt;=n;i++)&#123; if((d[i]/2)&amp;1||d[i]&amp;1)ans^=a[i]; &#125; int tmp=ans; for(int i=1;i&lt;=n;i++)&#123; ans=max(ans,tmp^a[i]); &#125; printf(&quot;%d\n&quot;,ans); &#125; else if(num==2)&#123; for(int i=1;i&lt;=n;i++)&#123; if((d[i]/2)&amp;1||d[i]&amp;1)ans^=a[i]; &#125; printf(&quot;%d\n&quot;,ans); &#125; else printf(&quot;Impossible\n&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[D.Tea--ACM-ICPC 2016 Qingdao Preliminary Contest]]></title>
    <url>%2F2018%2F08%2F15%2FD.Tea%2F</url>
    <content type="text"><![CDATA[ACM-ICPC 2016 Qingdao Preliminary ContestD.Teahttps://nanti.jisuanke.com/t/29368Tea is good. Tea is life. Tea is everything. The balance of tea is a journey of pursuing balance of the universe. Alice knows that. Alice wants to teach you the art of pouring tea. Alice has a pot of tea. The exact volume of tea is not important. The exact volume of tea is at least LL. The exact volume of tea is at most RR. Alice put two empty cups between you and her. Alice wants the two cups filled by almost equal volume of tea. Yours cannot be 11 unit more than hers. Hers cannot be 11 unit more than yours. Alice wants you to pour the tea. Alice wants you to pour until the pot is almost empty. Alice wants no more than 11 unit volume of tea remaining in the pot. You cannot read the residue volume of tea remaining in the pot. You can only know the tea status in the pot, empty or not. Alice does not want you to pour the tea too many times. You better pour as few times as possible. Input FormatThere are multiple cases. For each case, there is one line of two integers LL and RR, separated by single space. Here are some analyses about sample cases. For the first case, pouring 11 unit into one cup will satisfy Alice. For the second case, it is clearly that you cannot only pour once to reach the desired balance, but she can achieve it by pouring twice. First you pour 1.51.5 units into one cup, then you attempt to pour another 1.51.5 units into the other cup. Since the lower bound is 22, at least 0.50.5 unit remains in the pot after the first pouring. If the initial volume is in range [2,\ 3][2, 3], the second cup will have volume in range [0.5,\ 1.5][0.5, 1.5] which is balanced with 1.51.5 unit in the first cup, and at most 11 unit remain after these two attempts. About 10001000 test cases, and 0\le L\le R \le 10^{16}0≤L≤R≤1016 . Output FormatFor each case, there should be a single integer in a single line, the least number of pouring attempts. 样例输入122 22 4 样例输出1212 题目来源ACM-ICPC 2016 Qingdao Preliminary Contest 题解：一开始的策略有点问题，第一杯倒 l/2 第二杯倒 l/2+1 这样不一定是最优的； 举个例子（4 9）这组数据，第一杯2，第二杯3，第一杯2+2，第二杯还需要再加一次； 而第一杯倒（l+1）/2 ，第二杯倒（l+1）/2+1的话，（4 9），第一杯2.5 第二杯3.5 第一杯 2.5 +2，达成要求； 所以最优策略是第一杯倒（l+1）/2 ，第二杯倒（l+1）/2+1 ，然后剩下的轮流加2，直至壶中水小于等于1； 特判几个特殊情况，具体见代码，需要注意的是，如果l=0，那么一开始（0+1）/2=0，显然不倒水是不划算的，所以如果特判结束后l=0则l=1； ###代码：1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;fstream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;list&gt;#include &lt;vector&gt;using namespace std;#define LL long longint main()&#123; LL l,r; while(~scanf(&quot;%lld%lld&quot;,&amp;l,&amp;r))&#123; if(r==0||r==1)puts(&quot;0&quot;); else if(r==2)puts(&quot;1&quot;); else if(l==r||l==r-1)puts(&quot;2&quot;); else&#123; if(l==0)l=1; printf(&quot;%lld\n&quot;,(r-l+2)/2); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>杂</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2006 飞行员配对(二分图最大匹配,匈牙利算法)]]></title>
    <url>%2F2018%2F08%2F15%2F2006%20%E9%A3%9E%E8%A1%8C%E5%91%98%E9%85%8D%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[2006 飞行员配对(二分图最大匹配)题目来源： 网络流24题基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 第二次世界大战时期，英国皇家空军从沦陷国征募了大量外籍飞行员。由皇家空军派出的每一架飞机都需要配备在航行技能和语言上能互相配合的2名飞行员，其中1名是英国飞行员，另1名是外籍飞行员。在众多的飞行员中，每一名外籍飞行员都可以与其他若干名英国飞行员很好地配合。如何选择配对飞行的飞行员才能使一次派出最多的飞机。对于给定的外籍飞行员与英国飞行员的配合情况，试设计一个算法找出最佳飞行员配对方案，使皇家空 军一次能派出最多的飞机 。对于给定的外籍飞行员与英国飞行员的配合情况，编程找出一个最佳飞行员配对方案， 使皇家空军一次能派出最多的飞机。 Input第1行有2个正整数 m 和 n。n 是皇家空军的飞行 员总数(n&lt;100);m 是外籍飞行员数。外籍飞行员编号为 1~m;英国飞行员编号为 m+1~n。接下来每行有 2 个正整数 i 和 j，表示外籍飞行员 i 可以和英国飞行员 j 配合。输入最后以 2 个-1 结束。 Output第 1 行是最佳飞行 员配对方案一次能派出的最多的飞机数 M。如果所求的最佳飞行员配对方案不存在，则输出‘No Solution!’。 题解：裸的匈牙利算法求二分图最大匹配 这篇讲的超级生动形象了https://blog.csdn.net/cillyb/article/details/55511666 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;fstream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;list&gt;#include &lt;vector&gt;using namespace std;const int N=105;vector&lt;int&gt;g[N];int n,m,ans=0,match[N];bool vis[N];bool dfs(int x)&#123; for(int i=0;i&lt;g[x].size();i++)&#123; int v=g[x][i]; if(!vis[v])&#123; vis[v]=true;//标记已试图匹配 if(match[v]==-1||dfs(match[v]))&#123; //这个点没匹配过或者这个点匹配的可拆 match[v]=x; return true; &#125; &#125; &#125; return false;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;m,&amp;n); int x,y; while(scanf(&quot;%d%d&quot;,&amp;x,&amp;y),x!=-1&amp;&amp;y!=-1)&#123; g[x].push_back(y); g[y].push_back(x); &#125; memset(match,-1,sizeof(match)); for(int i=1;i&lt;=m;i++)&#123; memset(vis,false,sizeof(vis)); if(dfs(i))ans++; &#125; printf(&quot;%d\n&quot;,ans); return 0;&#125;]]></content>
      <categories>
        <category>51nod基础题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mac Os下用「hexo+github」搭建个人博客！]]></title>
    <url>%2F2018%2F08%2F14%2Fblog%2F</url>
    <content type="text"><![CDATA[Mac Os下用「hexo+github」搭建个人博客！ 这个不是教程 只是搭建过程记录向 记录一下我报错查教程改错报错查教程改错报错查教程改错。。的过程 前面有些步骤在后面有报错然后修正 所以千万不要相信我的步骤 准备工作 安装nodejs和git（这个自己在官网安装就可以） 接着要用npm安装hexo 在终端输入npm install -g hexo-cli 很多报错 可以看见好几个都是permission denied（因为权限不足无法访问）可以看见提示的建议是：Please try running this command again as root/Administrator.所以重新输入sudo npm install -g hexo-cli（sudo：申请root权限）下图表明安装成功 用hexo在本地新建一个博客 新建文件夹然后右键「新建位于文件夹位置的终端窗口」（第一次使用的话可以在【finder-服务-服务偏好设置】中勾选上那一项） 文件夹位置下终端输入 1234hexo i blog//blog是项目名，叫别的也随便cd blog//进入blog文件夹hexo g//编译hexo s//本地预览 （后两句不加sudo的话同样会出现permission denied的问题 所以在开头加上sudo给他权限就可以啦 下面有些地方还会遇到sudo的问题 就不赘述了 报权限不够的错误的话自己加上） 成功后会给出一个链接 一个在本地的博客就这样建好了 点开就可以发现已经有一个博客的大概了 这里用到了4000端口 如果该端口被占用的话可以查一下是什么东西占用了这个端口sudo lsof -i:端口号 如果没有输出表面该端口没有被占用 被占用的话会给出一个进程 里面有一个PID号 如果是没设么用的进程 输入sudo kill -9 pid号结束掉他即可 默认给的是个叫「landscape」的主题 不同主题有不同的功能布局外观 当然也可以自己写个主题出来不过这种是大佬们的操作 我这个小白还是先找个主题用吧。。这里放上一些主题：https://github.com/hexojs/hexo/wiki/Themes 此外知乎上也有关于hexo主题的讨论 设置博客主题 在文件夹打开终端输入git clone加上所选主题的地址 (此处以及后面所说的终端一般都是blog文件夹终端了) git clone https://github.com/iissnan/hexo-theme-next themes/next 打开文件夹下的这个文件 官方名叫站点配置文件 然后找到里面的theme并更改 回到终端输入 123hexo cleanhexo ghero s 点进生成的blog可以看见主题已经换好啦 在[themes/next/config.yml]里配置next 冒号后面是有空格的 后面有些地方也是一样！！！一定要有空格 不然会报很长很长的错！！！ 可以看见备注写了三个方案给你选 然后重新输入以下代码查看效果 123hexo cleanhexo ghero s 这时候这里出现了一个警告 https://github.com/theme-next/hexo-theme-next 我用的这个next主题已经移动到别的地方了 所以问题不大复制一下然后找到这个主题的新的地址 按照上面步骤改一下就行注意要把之前的主题所在文件夹删了 或者生成的时候自己换个不同的文件夹名字 上面是Gemini 还蛮好看蛮直男审美的 就这个吧诶嘿 以上就是在本地建立了一个看得过去的blog了下面要把这个本地blog上传到github 把博客部署到GitHub上 先在GitHub上创建一个新项目 项目名必须按如下格式输入 最后一项选上 创建后点项目的setting 下拉找到github pages 看不懂就翻译了一下 那么发现啦那个网址就是我们要用的现在还是宇宙洪荒混沌初始的状态 接下来要把hexo上的内容部署到github上 打开之前提到过的站点配置文件 把最后几行改成如下格式 在终端输入如下 装个插件 npm install hexo-deployer-git --save emmmmmm???报了一堆错 没事 照他的提示在mac终端输入npm i -g npm更新一下就好了更新成功的界面如下 查一下也可以发现变成 6.3.0 版本了。。这不重要 然后就是最后激动人心的一步了！！！！！ 输入hexo d把它部署到github的网站上去 然后就走上了漫长的报错之路。。 然后又经历了一系列艰苦卓绝我也不知道发生了啥的几个小时的查来查去试来试去！最后 终于突然一下的改好了？？！ emmmmm不废话了先记录下来 大概讲讲我干了些啥 主要问题还是出在站点配置文件上 因为报错的时候一直说这个找不到那个找不到。。你都找不到我哪找得到啊 然后去找了一些有关hexo站点配置的教程 其中这份讲的是比较详细的了 照着这个改了最后那一段 https://blog.csdn.net/xuezhisdc/article/details/53130383 然后输入 1234npm install hexo-deployer-git --save sudo hexo clean sudo hexo g sudo hexo d 还原一下我的小白操作。。最后终端的结果没报错了也没说啥奇奇怪怪得话了就说明成功了 回到github上可以发现 这些东西已经上传到GitHub了 然后就点开github之前给的那个链接 如图 之前的本地网站已经上传了！！撒花！！！！ 补充一点内容：首先是关于博客美化的问题 这个就看到什么好看的功能就往上使就是了 next主题美化教程还是很多哒 还有一些关于目录标签的功能 都很好上手 然后就是耍了几天博客会发现一个严重的问题！百度！Google！！竟然查不到我自己的网站 但是吧这个坑已经挖了。。不填怎么行。。网上找一下百度Google递交搜索引擎的教程就好了 但是百度的http认证到现在都没通过 还不知道问题出在哪 这个坑挖着先。。 google的效率倒是相当快操作也很简洁 站点地图也交好了 一觉醒来在google上搜索到自己博客的感觉 还蛮妙2333333 这里在站点地图提交的时候遇到一个问题 此位置的 Sitemap 不允许此网址 是因为之前在站点配置文件里的 url: 那一项没有设置 要改成自己网站的地址 改完后提交站点地图就不会报错了]]></content>
      <categories>
        <category>poi</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1995 三子棋]]></title>
    <url>%2F2018%2F08%2F14%2F1995%20%E4%B8%89%E5%AD%90%E6%A3%8B%20%20%2F</url>
    <content type="text"><![CDATA[1995 三子棋 题目来源： syu校赛基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 小的时候大家一定玩过“井”字棋吧。也就是在九宫格中，只要任意行、列，或者任意连续对角线上面出现三个相同的，就能获胜。现在小明和小花也在玩三子棋，但是他们不是在九宫格里，而是在3×4的格子里面。现在小明先下，但是他知道小花这个人很聪明，他想知道第一步下在哪一个地方最合适，你能帮帮他吗？ Input第一行输入一个整数T，表示数据组数（1&lt;T&lt;10000）；第二行输入两个整数x,y,表示3×4格子里面的一个坐标(x,y)（1&lt;=x&lt;=3,1&lt;=y&lt;=4）； Output每组数据输出最后小明输赢的结果，如果小明一定能赢，第一行输出“Win”,第二行输出小明所需要花的最少步数；如果小明跟小花只能打成平手，第一行输出“Equal”，第二行输出数字0；如果小明不能赢也不能跟小花打成平手，第一行输出“Lose”,第二行输出小花赢小明所需要花的最少步数 题解：抱着作a+b的心态开始刷基础题，结果基础题怎么这么不水呢么。。没想到啥好方法，就自己跟自己下模拟；策略就和一般五子棋差不多，关于最少步数，由于对手也是绝顶聪明的，所以不会让你下在很快赢的地方，其实应该算最多步数的最少步数那个意思。。大概； 棋盘是对称的，所以只要看（1，1）（1，2）（2，1）（2，2）四个点就可以；如下表： 1 2 2 1 3 4 4 3 1 2 2 1 然后结论是对先手来说（1，1）（1，2）（2，2）必胜，（2，1）平局； （1，1）的最短路是6：先手:11-&gt;12-&gt;31-&gt;23-&gt;32形成“双二”再下一步就赢了后手:21-&gt;13-&gt;21-&gt;34-&gt; （1，2）的最短路是4：先手:12-&gt;23-&gt;32形成“双二”再下一步就赢了后手:13-&gt;34-&gt; （2，2）的最短路是4：先手:22-&gt;13-&gt;11形成“双二”再下一步就赢了后手:23-&gt;31-&gt; 代码：123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;fstream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;list&gt;using namespace std;int a[3][4]=&#123;6,4,4,6,0,4,4,0,6,4,4,6&#125;;int main()&#123; int t,x,y; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); x--; y--; if(a[x][y]==0)printf(&quot;Equal\n0\n&quot;); else printf(&quot;Win\n%d\n&quot;,a[x][y]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>51nod基础题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>poi</category>
      </categories>
  </entry>
</search>
