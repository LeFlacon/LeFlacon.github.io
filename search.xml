<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>「hello-world」</title>
    <url>/52e47f72/</url>
    <content><![CDATA[<p><center>

<p>❤️ 冬天会很长的，春天会来的 ❤️</p>
</center></p>

<a id="more"></a>

<image src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg8ac5rqm1j30k01k8q7a.jpg" width="600px">

<hr>
]]></content>
      <categories>
        <category>love&amp;peace</category>
      </categories>
  </entry>
  <entry>
    <title>python的xml格式response中文乱码问题及解决方法</title>
    <url>/44a12aea/</url>
    <content><![CDATA[<p>本文给出了python post得到的gbk编码的xml响应报文出现中文乱码问题的一种解决方法。</p>
<a id="more"></a>

<p>头秃了两个星期终于解决了，要发的是一个gbk编码的xml报文，然后响应报文也是gbk编码，一开始是用的requests库的post方法<code>res=requests.post(url,body.encode(&quot;gbk&quot;))</code>，返回的结果是一个requests.models.Response对象，但是无论对结果怎么encode和decode，都没法显示中文，直接输出res.text的话就只能返回中文乱码。在大家都用utf-8编码的时候，网上只能找到一堆无用的资料。。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjkmcb9yioj308w025q2r.jpg" alt=""></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjkmcdz1ytj308z02da9v.jpg" alt=""></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjkmci86voj30ck01mwee.jpg" alt=""></p>
<p>💡如果直接尝试转化的话会报类似<code>&#39;gb2312&#39; codec can&#39;t encode character &#39;\xbd&#39; in position 83</code>这样的错误；</p>
<p>💡尝试把xml转化成json再处理的方式也失败了；</p>
<p>💡如果直接解析又会报<code>ValueError: multi-byte encodings are not supported</code>，需要xml头把<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;gbk&quot; ?&gt;</code>里改成utf-8才可以……</p>
<p>最后是被这个2011年的代码启发的：➡️<a href="https://www.toolbox.com/tech/devops/blogs/request-get-reply-and-display-xml-in-python-beauty-of-simplicity-121611/" target="_blank" rel="noopener">DEVOPS<br>Request, Get Reply and Display XML in Python – Beauty of Simplicity</a></p>
<p>它这里用的是python2，我最后改完的python3功能函数是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def interRequest(businessCode, body):</span><br><span class="line">    url &#x3D; CommonConf.url_root + businessCode</span><br><span class="line">    result &#x3D; urllib.request.urlopen(url, data&#x3D;bytes(body, encoding&#x3D;&quot;gbk&quot;))</span><br><span class="line">    res &#x3D; str(result.read(), encoding&#x3D;&quot;gbk&quot;)</span><br><span class="line">    res &#x3D; xmltodict.parse(res)</span><br><span class="line">    return res[&#39;stream&#39;]</span><br></pre></td></tr></table></figure>

<p>传入的body是str，把它转化为bytes，通过urllib.request.urlopen方法提交post请求返回一个HTTPResponse对象，通过它的read方法可以获得bytes，在把bytes转化为str的时候根据gbk编码，就可以成功显示中文了。</p>
<p>以后要是遇见别的编码的接口靠这个方法也可以顺利解决啦~</p>
<p>🌈如果有更优雅的方式欢迎给我发邮件！感谢 ！</p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>curl下载出现「Failed to connect to raw.githubusercontent.com:443」问题的原因及解决办法</title>
    <url>/ab602d23/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>之前安装brew也报的这个错，然后好不容易通过直接下载运行sh的方式七装八装装好了，但是还是没解决curl不能用的问题</p>
<p>想装个「oh my zsh」，<code>sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</code>，然后也遇到了这个问题</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>在知乎一个问题的评论区找到了很靠谱的方法，这个问题里也给了一些解决方案和说明，记录一下⬇️</p>
<p>🔗 Failed to connect to raw.githubusercontent.com:443 - CaptainInPHW的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/115450863" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/115450863</a></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghg0n4re4xj312005a74v.jpg" alt=""></p>
<p>打开Wi-Fi的高级设置，设置dns为8.8.8.8和114.114.114.114：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghg0vu9gr0j310m0hmk1t.jpg" alt=""></p>
<p>然后就好使了</p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>🌚字跳凉凉面经</title>
    <url>/441aa9f/</url>
    <content><![CDATA[<p>有生以来第一次社畜面试，非常紧张特别紧张紧张到手凉然后做运动，而且很久没写题了甚至c++的NULL都写了null。啥也没答上来，凉透啦。但是经验总结还是要的。</p>
<a id="more"></a>

<p>一开始自我介绍，然后主要是介绍项目，这一块感觉还好，把我那市创介绍了下，后来室友说我听起来思路还算清楚就是用了太多连接词“然后”了，嗯有道理。然后面试官也问了蛮多项目里的问题，这还是在我的范围内的。</p>
<p>然后说到集成学习，就问我还了不了解集成学习的其他算法，我说我项目里用的Bagging，其他还有Boosting啥的，但是不了解，就把Bagging的思路讲了一遍。然后妆容迁移里有说到生成式对抗网络，话题就到了机器学习上。然后问了知不知道其他常见的Loss函数，我说我就用过平方的那个。。（甚至忘了他学名叫啥），然后说项目用的是RMSE，又聊了决策树是啥，正则化是啥（但是正则化当时写的时候我也没有特别了解原理，就套公式。。自己挖的坑现在都得还上）。</p>
<p>先补充补充知识点：</p>
<blockquote>
<p><strong>常见的损失函数</strong>  </p>
<ol>
<li>0-1函数，预测值和目标相等为0，不等为1  </li>
<li>绝对值损失函数 <code>L(Y,f(X))=|Y-f(X)|</code>  </li>
<li>对数损失函数 <code>L(Y,P(Y|X))=-logP(Y|X)</code>  </li>
<li>平方损失函数 <code>L(Y,f(X))=∑(Y-f(X))^2</code>  </li>
<li>指数损失函数 <code>L(Y,f(X))=exp[-Yf(X)]</code>  </li>
<li>Hinge损失函数 <code>L(Y,f(X))=max(0,1-Yf(X))</code> 使分类器可以更专注于整体的误差   </li>
<li>感知损失函数 <code>L(Y,f(X))=max(0,-f(x))</code> 对判定边界附近的点(正确端)惩罚力度很高     </li>
<li>交叉熵损失函数   </li>
</ol>
<p>🔗常见的损失函数(loss function)总结 - yyHaker的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/58883095" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/58883095</a></p>
<p><strong>正则化</strong><br>目的：减小测试误差，因为复杂模型容易过拟合，导致泛化能力下降，正则化可以降低模型复杂度<br>常用方法：L1正则化惩罚项为L1范数、用于特征选择，L2正则化惩罚项为L2范数、用于防止模型过拟合、对特征系数进行一个比例缩放</p>
</blockquote>
<p>然后开始做题。</p>
<p>第一个题是坐飞机的题（去网上找了找描述是下面这样）：</p>
<blockquote>
<p>有100个人上飞机，本应该按照各自的座位1-100号坐下，但其中有一个是疯子。疯子的行为是：随机选择一个座位坐下。正常人的行为是：尽量做自己的座位，如果自己的座位被占了，就随机选一个座位。问最后一个人坐在自己的位置的概率是多大。  </p>
<p>🔗100人坐飞机，第一个乘客在座位中随便选一个坐下，第100人正确坐到自己坐位的概率是？ - 知乎<br><a href="https://www.zhihu.com/question/35950050" target="_blank" rel="noopener">https://www.zhihu.com/question/35950050</a></p>
</blockquote>
<p>我第一反应宁夏区域赛也是坐飞机的题啊，当时推了个公式出来。然后我就从n=1、2、3开始推，然后面试官问我思路，我说一般推123然后答案就出来了，f(2)=1/2，f(3)=1/2，然后我就宕机了，我记得宁夏的答案是带n的啊，，然后就开始1/n+？的想。。。面试官说那换一个题</p>
<blockquote>
<p>这题结果是1/2 </p>
<p>知乎看见一个很巧妙的思路就是：<br>2-99号如果发现1号疯子占了自己的位置，就只能随机坐到位置x上，这等价于他们让疯子把自己的位置让出来，然后让疯子去坐x，这并不影响后面人的局面，所以到最后2-99都在自己位子上，疯子可能在1也可能在100，所以就是1/2的概率。</p>
<p>还有一个思路是：<br>分成三种情况讨论，第一种疯子坐对了、没事，第二种疯子坐到了第k个位置、那么2-(k-1)的人都坐对，对于第k个人来说、这又变成了一个疯子问题，第三种疯子坐到了第100个位置结束。所以第二个情况实际上无效，因为它变成了n小一些的子问题，那么只要看第一种和第三种的情况，这俩概率一样的，所以最后就是1/2。（这个思路也可以写成递推形式）</p>
<p>宁夏区域赛的那个题「Take Your Seat」是这样的：第一问和上面一样，第二问是大家会按照一个随机的顺序上飞机。（唉那个题当时还是我推的，结果面试考反倒没答出来，还是思路没那么清楚啊）  </p>
<p>按照随机顺序上飞机之后，正常人是会好好坐的，所以只要看疯子是第几个上飞机，疯子最后一个上飞机肯定坐对，这是<code>1*1/n</code>，如果疯子不是最后一个上飞机那么疯子前面的人都是对的，后面其实就相当于疯子第一问第一个上飞机的问题，是<code>(1/2)*(n-1/n)</code>，加起来就是<code>(n+1)/2n</code>。</p>
</blockquote>
<p>然后第二个题，一个圆周上有随机n个点，问这n个点落在同一个半圆内的概率，这个题我没懂意思，面试官好像也不好描述，他就说那下一个，后来查了查是这样意思的一个题：</p>
<blockquote>
<p>🔗又是万能的知乎：在一个圆里随机取n个点，它们在同一个半圆的概率是多少？ - 知乎 <a href="https://www.zhihu.com/question/341018905" target="_blank" rel="noopener">https://www.zhihu.com/question/341018905</a></p>
<p>知乎这个题说的是圆里，但是其实无论圆里还是圆周上都是一样的。思路是把这n个点看成是在n条直径上，那么对于任意一个圆周上的点来说，他可以在直径的一条半径，也可以在另一条半径，所以如果这n个点在同一个半圆上，也就是这n个点所在半径都相邻的概率。问题转化为在n个直径中选n个半径，n个半径相邻的概率是多少？<br>那么只要选定一条边界之后剩下的要么取一边要么取另一边，n条直径会把圆形分成2n个部分，以每一个部分为界，所以总共有2n个可行解，所以<code>ans=2n/2^n=n/2^(n-1)</code>。</p>
<hr>
<p>然后又看到一个蛮有意思的同理的题：🔗圆上任选三点组成三角形，这个三角形是锐角、钝角和直角三角形的概率分别是多少？ - 知乎 <a href="https://www.zhihu.com/question/19824740" target="_blank" rel="noopener">https://www.zhihu.com/question/19824740</a></p>
<p>先按照上面半圆的思路想了下，对于直角三角形来说，必须两个点得是直径，圆上任选两个点为直径的概率几乎为0，所以直角三角形概率为0；对于钝角三角形来说，其实就是三个点在同一个半圆内才能形成钝角，套一下上一题推出来的公式<code>p(钝角)=3/2^(3-1)=3/4</code>，剩下的就是锐角三角形的概率了，<code>p(锐角)=1=3/4=1/4</code>。</p>
<hr>
<p>然后可以继续扩展到球上的情况，🔗在一个球内任取n个点，则这n个点落在同一个半球内的概率是多少？ - 知乎 <a href="https://www.zhihu.com/question/342593905" target="_blank" rel="noopener">https://www.zhihu.com/question/342593905</a></p>
<p>按照之前的思路问题可以转化为在n个直径中选n个半径，总方法数还是2^n。然后就是考虑在三维空间里出现在同一半球的方法数，那么考虑n条直径可以把三维球分成多少部分，一条直径就是两个部分，2条直径就是四个部分，n条直径是<code>n^2-n+2</code>个部分，推导就是已知<code>f(1)=2,f(n)=f(n-1)+2*(n-1)</code>然后用高中数列的错位相减法求f(n)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(n)-f(n-1)&#x3D;2*(n-1)</span><br><span class="line">f(n-1)-f(n-2)&#x3D;2*(n-1-1)</span><br><span class="line">...</span><br><span class="line">f(2)-f(1)&#x3D;2*(2-1)</span><br><span class="line">n-1个式子求和得f(n)-f(1)&#x3D;2*((n+2)*(n-1)&#x2F;2-(n-1))</span><br><span class="line">化简得f(n)&#x3D;n^2-n+2</span><br></pre></td></tr></table></figure>


<p>那么选一个部分作为边界剩下的就确定了，所以就是<code>n^2-n+2</code>种情况，概率就是<code>ans=(n^2-n+2)/2^n</code>。</p>
</blockquote>
<p>第三个是抛硬币的题，一个不均匀的硬币一面是p一面是1-p，问有没有公平的抛法。</p>
<p>没想出来。我只觉得答案肯定是多抛几次，但是不知道咋抛抛。</p>
<blockquote>
<p>用硬币的A面对应决定a，B面对应决定b，抛N次<br>然后用硬币的B面对应决定a，A面对应决定b，抛N次<br>总共抛2N次</p>
<p>感觉其实和以前练的博弈思维挺像的，博弈论里比如巴什博弈也是看对手的操作然后决定自己的操作，一对一对凑好了就是最优策略。</p>
</blockquote>
<p>然后说那写代码吧，凉凉预警。</p>
<p>让写个翻转链表，输出表头返回表头，一开始写了个2n的方法，先记下来然后再建一个链表，然后面试官问有没有直接转向的方法，然后写了个while循环里面四行这样的直接迭代的方法：tmpp先存下右边，中间的tmp指向左边上一个，上一个res更新为中间的，中间的移动到存好的下一个位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(tmp!&#x3D;null)&#123;</span><br><span class="line">	node* tmpp&#x3D;tmp-&gt;next;</span><br><span class="line">	tmp-&gt;next&#x3D;res;</span><br><span class="line">	res&#x3D;tmp;</span><br><span class="line">	tmp&#x3D;tmpp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我感觉没啥问题0.0，然后面试官问我返回值，我就返回了res，感觉没啥问题。他说这样会不会哪里有问题。。</p>
<p>面试之后去写了一下「leetcode 206. 反转链表」：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggslfs8duoj30nq0aoq3v.jpg" alt=""></p>
<p>然后我写的果然有问题。。执行出错了，首先发现是错在最后那个NULL，所以要判断一下加个NULL，<code>if(res==head)res-&gt;next=NULL;</code>，然后又在开头执行错误了，发现没有判断一开始就是NULL的特例，改了就过了。太久没写题了太意识流了以至于很随便，也不考虑特殊情况边界处理啥的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        ListNode* res&#x3D;head;</span><br><span class="line">        if(res&#x3D;&#x3D;NULL)return res;</span><br><span class="line">        ListNode* tmp&#x3D;res-&gt;next;</span><br><span class="line">        while(tmp!&#x3D;NULL)&#123;</span><br><span class="line">            ListNode* tmpp&#x3D;tmp-&gt;next;</span><br><span class="line">            tmp-&gt;next&#x3D;res;</span><br><span class="line">            if(res&#x3D;&#x3D;head)res-&gt;next&#x3D;NULL;</span><br><span class="line">            res&#x3D;tmp;</span><br><span class="line">            tmp&#x3D;tmpp;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>题目里说有迭代和递归两种思路，我写的那种是迭代，然后补了一下递归的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        if(head&#x3D;&#x3D;NULL||head-&gt;next&#x3D;&#x3D;NULL)return head;</span><br><span class="line">        ListNode* res&#x3D;reverseList(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next&#x3D;head;</span><br><span class="line">        head-&gt;next&#x3D;NULL;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>就这样时间差不多过去了一个小时，面试官问还有没有想问他的，我就问那个硬币的到底咋做，他说让我回去想想。别的问题就没有了，我是真的不知道要问啥。。第一次面试真的是来刷经验了我太菜了。</p>
<p>面试就这样结束了，面试官说回去等通知，凉透了凉透了，不过也没有那么惨烈。体验了一把收获还是很大的，面试官人也很nice就正常交流。</p>
<p>以后面试应该不会这么紧张了。接下来还是好好刷leetcode吧，得把以前学过的东西都捞捞。记不住的那些东西感觉被问了一遍之后反倒记住了，这样就可以把会的东西列下来，平时给自己模拟模拟试试。</p>
<p>From now on。</p>
]]></content>
      <categories>
        <category>love&amp;peace</category>
      </categories>
  </entry>
  <entry>
    <title>实现leancloud统计所有文章总访问量的一段js代码</title>
    <url>/88ef7bff/</url>
    <content><![CDATA[<p>用来给leancloud统计的文章访问量求和的</p>
<a id="more"></a>

<p>「chrome浏览器右键」-「检查」-「Console」</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AV.initialize(&quot;你的appid&quot;, &quot;你的appkey&quot;);</span><br><span class="line">var sum&#x3D;0</span><br><span class="line">var time&#x3D;0</span><br><span class="line">var title&#x3D;&quot;&quot;</span><br><span class="line">var url&#x3D;&quot;&quot;</span><br><span class="line">var query &#x3D; new AV.Query(&#39;Counter&#39;);</span><br><span class="line">query.notEqualTo(&#39;id&#39;,0);</span><br><span class="line">&#x2F;&#x2F;query.descending(&#39;time&#39;);&#x2F;&#x2F;按照文章访问次数降序排列</span><br><span class="line">query.limit(383);&#x2F;&#x2F;控制返回结果个数</span><br><span class="line">query.find().then(function(todo)&#123;</span><br><span class="line">  for (var i&#x3D;0;i&lt;383;i++)&#123;</span><br><span class="line">    var result&#x3D;todo[i].attributes;</span><br><span class="line">    time&#x3D;result.time;</span><br><span class="line">    title&#x3D;result.title;</span><br><span class="line">    url&#x3D;result.url;</span><br><span class="line">    sum&#x3D;sum+time;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,function (error)&#123;</span><br><span class="line">  console.log(&quot;error&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>然后输出一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(sum);</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gghkhlak3yj30gd04vjrx.jpg" alt=""></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo Ayer主题个性化设置</title>
    <url>/8b8f12ca/</url>
    <content><![CDATA[<p>换主题啦～啦啦啦啦啦</p>
<a id="more"></a>

<p>之前的NexT主题是这样的，截个图纪念一下hhhhh</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gejseqa8cdj31400jo12h.jpg" alt=""></p>
<hr>
<p>☀️Ayer是个很好看很有设计感的主题，<a href="https://shen-yu.gitee.io/2019/ayer/" target="_blank" rel="noopener">作者的教程</a>写的非常用心，所以作者教程中已经给出的配置我就直接罗列了，有需要的可以去看作者的说明，也可以直接看主题配置文件里的注释：</p>
<ul>
<li>搜索功能，需要安装插件hexo-generator-searchdb</li>
<li>RSS订阅，需要安装插件hexo-generate-feed</li>
<li>文章置顶，hexo-generator-index-pin-top </li>
<li>文章加密，hexo-blog-encrypt</li>
<li>播放音乐，hexo-tag-aplayer</li>
<li>播放视频，hexo-tag-dplayer</li>
<li>二次元看板娘，hexo-helper-live2d</li>
<li>相册</li>
<li>文章悬浮目录，tocbot解析标题</li>
<li>百度和谷歌统计</li>
<li>busuanzi访问量统计</li>
</ul>
<p>☀️以下是一些我自己的修改，加了一些我喜欢的或是习惯的小美化和小功能(((o(*ﾟ▽ﾟ*)o)))</p>
<ul>
<li>github丝带</li>
<li>下雪特效</li>
<li>百度自动递交链接</li>
<li>live2d看板娘</li>
<li>设置不显示版权信息</li>
<li>自定义友链页面</li>
<li>「阅读全文」图标定制</li>
<li>打赏页面自定义样式</li>
<li>邮件评论回复</li>
<li>more截断自动（有bug）</li>
<li>文章显示leancloud阅读次数</li>
</ul>
<hr>
<h2 id="0-github丝带"><a href="#0-github丝带" class="headerlink" title="0 github丝带"></a>0 github丝带</h2><p>💡本博客现在没用这个啦</p>
<p>在<a href="https://github.blog/2008-12-19-github-ribbons/" target="_blank" rel="noopener">Ribbon</a>或者<a href="http://tholman.com/github-corners/" target="_blank" rel="noopener">Corners</a>获取喜欢的样式的代码，加上自己的github地址，然后复制到<code>/themes/ayer/layout/layout.ejs</code>的<code>&lt;body&gt;</code>标签内的开头部分</p>
<p>我的效果如右上角：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gemg5gpzfmj31400jn47u.jpg" alt=""></p>
<h2 id="1-下雪特效"><a href="#1-下雪特效" class="headerlink" title="1 下雪特效"></a>1 下雪特效</h2><p>💡本博客现在没用这个啦</p>
<p>在<a href="https://www.yaxi.net/2016-12-28/1211.html" target="_blank" rel="noopener">原教程：JQuery+Html5实现超真实3D雪花飞舞特效</a>中下载<code>snow.js</code>文件，放在<code>/themes/ayer/source/js/snow.js</code></p>
<p>在<code>ayer/layout/layout.ejs</code>里在body标签内部（<code>&lt;/body&gt;</code>前）添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 漂亮雪花 --&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;apps.bdimg.com&#x2F;libs&#x2F;jquery&#x2F;1.7.2&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;js&#x2F;snow.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">.snow-container&#123;</span><br><span class="line">position:fixed;</span><br><span class="line">top:0;left:0;</span><br><span class="line">width:100%;</span><br><span class="line">height:100%;</span><br><span class="line">pointer-events:none;</span><br><span class="line">z-index:100001;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;snow-container&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>注意此处的js路径要根据自己放的路径来，比如在NexT主题下我放在了<code>next/source/js/src/snow.js</code>下，那么对应的路径写的就是<code>/js/src/snow.js</code></p>
<p>效果如图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gemfrqpcblj31400jkhdt.jpg" alt=""></p>
<h2 id="2-百度自动递交链接"><a href="#2-百度自动递交链接" class="headerlink" title="2 百度自动递交链接"></a>2 百度自动递交链接</h2><p>百度收录和两年前相比真的好慢呀ORZ，不知道这玩意儿还有没有用，先加上再说吧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--百度自动递交链接--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">(function()&#123;</span><br><span class="line">    var bp &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">    var curProtocol &#x3D; window.location.protocol.split(&#39;:&#39;)[0];</span><br><span class="line">    if (curProtocol &#x3D;&#x3D;&#x3D; &#39;https&#39;) &#123;</span><br><span class="line">        bp.src &#x3D; &#39;https:&#x2F;&#x2F;zz.bdstatic.com&#x2F;linksubmit&#x2F;push.js&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        bp.src &#x3D; &#39;http:&#x2F;&#x2F;push.zhanzhang.baidu.com&#x2F;push.js&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0];</span><br><span class="line">    s.parentNode.insertBefore(bp, s);</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-live2d"><a href="#3-live2d" class="headerlink" title="3 live2d"></a>3 live2d</h2><p>💡本博客现在没用这个啦</p>
<p>这个网上有许多版本，我是以前下载的别人写好的一个（不是用插件的那种），如果用插件那种的话作者的文档中已经给出了一个选择：<a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md" target="_blank" rel="noopener">hexo-helper-live2d</a></p>
<p>这里就说明一下我调用的地方：</p>
<p>在<code>ayer/layout/layout.ejs</code>里最后（<code>&lt;/html&gt;</code>结束前）加上<code>&lt;footer&gt;&lt;/footer&gt;</code>标签，然后在footer标签内部加上调用live2d的代码</p>
<h2 id="4-设置不显示版权信息"><a href="#4-设置不显示版权信息" class="headerlink" title="4 设置不显示版权信息"></a>4 设置不显示版权信息</h2><p>主题配置中的版权信息设置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 版权声明</span><br><span class="line"># 版权声明type设定：0-关闭版权声明； 1-文章对应的md文件里有copyright: true属性，才有版权声明； 2-所有文章均有版权声明</span><br><span class="line">copyright_type: 2</span><br></pre></td></tr></table></figure>

<p>为了避免每个文章都写上<code>copyright: true</code>，肯定是选2号模式，但是这样又会有一个问题，就是如果是一些自定义的页面（友链什么的），写上版权信息就感觉怪怪的</p>
<p>所以这里参考<code>no_reward</code>的实现，在<code>ayer/layout/_partial/article.ejs</code>里加了个<code>!post.no_copyright</code>的判断条件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- copyright --&gt;</span><br><span class="line">      &lt;% if (((theme.copyright_type &#x3D;&#x3D;&#x3D; 2) || (theme.copyright_type &#x3D;&#x3D;&#x3D; 1 &amp;&amp; post.copyright)) &amp;&amp; !index &amp;&amp; !post.no_copyright)&#123; %&gt;</span><br><span class="line"></span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>这样如果在<code>copyright_type: 2</code>模式下，md文件里有<code>no_copyright: true</code>，就不会显示版权信息</p>
<h2 id="5-自定义友链页面"><a href="#5-自定义友链页面" class="headerlink" title="5 自定义友链页面"></a>5 自定义友链页面</h2><h3 id="新建页面"><a href="#新建页面" class="headerlink" title="新建页面"></a>新建页面</h3><p>终端输入<code>hexo new page friends</code>新建一个友链页面</p>
<p>然后修改<code>source/friends/index.md</code>开头，加上type</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 友链</span><br><span class="line">type: &quot;friends&quot;</span><br><span class="line">no_reward: true</span><br><span class="line">no_copyright: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>在主题配置文件的menu部分加上这个页面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  主页: &#x2F;</span><br><span class="line">  归档: &#x2F;archives</span><br><span class="line">  分类: &#x2F;categories</span><br><span class="line">  标签: &#x2F;tags</span><br><span class="line">  友链: &#x2F;friends</span><br><span class="line">  关于: &#x2F;about</span><br></pre></td></tr></table></figure>

<h3 id="css-js-json"><a href="#css-js-json" class="headerlink" title="css/js/json"></a>css/js/json</h3><p>然后添加<code>source/friends/links.json</code>和<code>source/friends/friends.css</code>和<code>source/friends/friends.js</code></p>
<p>css内容如下，大小颜色啥的根据自己的主题调一调：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#links&#123;</span><br><span class="line">   margin-top: 5rem;</span><br><span class="line">&#125;</span><br><span class="line">.links-content&#123;</span><br><span class="line">    margin-top:1rem;</span><br><span class="line">&#125;</span><br><span class="line">.link-navigation::after &#123;</span><br><span class="line">    content: &quot; &quot;;</span><br><span class="line">    display: block;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br><span class="line">.card &#123;</span><br><span class="line">    width: 380px;</span><br><span class="line">    height: 70px;</span><br><span class="line">    font-size: 1rem;</span><br><span class="line">    padding: 10px 10px 10px 10px;</span><br><span class="line">    border-radius: 10px;</span><br><span class="line">    transition-duration: 0.15s;</span><br><span class="line">    margin: 0.5rem 0.5rem 0.5rem 0.5rem;</span><br><span class="line">    &#x2F;*margin-bottom: 1rem;*&#x2F;</span><br><span class="line">    display:flex;</span><br><span class="line">    box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04);</span><br><span class="line">&#125;</span><br><span class="line">.card:nth-child(odd) &#123;</span><br><span class="line">    float: left;</span><br><span class="line">&#125;</span><br><span class="line">.card:nth-child(even) &#123;</span><br><span class="line">    float: right;</span><br><span class="line">    #float: left;</span><br><span class="line">&#125;</span><br><span class="line">.card:hover &#123;</span><br><span class="line">    transform: scale(1.1);</span><br><span class="line">    box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04);</span><br><span class="line">&#125;</span><br><span class="line">.card a &#123;</span><br><span class="line">    border:none;</span><br><span class="line">&#125;</span><br><span class="line">.card .ava &#123;</span><br><span class="line">    width: 5rem!important;</span><br><span class="line">    height: 5rem!important;</span><br><span class="line">    margin:0!important;</span><br><span class="line">    margin-right: 1em!important;</span><br><span class="line">    border-radius:4px;</span><br><span class="line">&#125;</span><br><span class="line">.card .card-header &#123;</span><br><span class="line">    font-style: italic;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    width: 236px;</span><br><span class="line">    font-size: 1.6rem!important;</span><br><span class="line">&#125;</span><br><span class="line">.card .card-header a &#123;</span><br><span class="line">    font-style: normal;</span><br><span class="line">    color: #adbbd5;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    text-decoration: none;</span><br><span class="line">&#125;</span><br><span class="line">.card .card-header a:hover &#123;</span><br><span class="line">    color: #8899dd;</span><br><span class="line">    text-decoration: none;</span><br><span class="line">&#125;</span><br><span class="line">.card .card-header .info &#123;</span><br><span class="line">    font-style:normal;</span><br><span class="line">    color:#a3a3a3;</span><br><span class="line">    font-size:14px;</span><br><span class="line">    min-width: 0;</span><br><span class="line">    text-overflow: ellipsis;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    white-space: nowrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>js内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">link &#x3D; &#123;</span><br><span class="line">    init:function() &#123;</span><br><span class="line">        const that&#x3D;this;</span><br><span class="line">        $.getJSON(&quot;links.json&quot;,</span><br><span class="line">            function(data)&#123;</span><br><span class="line">                that.render(data);</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    render:function(data)&#123;</span><br><span class="line">        let name,site,info,avatar,li&#x3D;&quot;&quot;;</span><br><span class="line">        for(let i&#x3D;0;i&lt;data.length;i++)&#123;</span><br><span class="line">            name&#x3D;data[i].name;</span><br><span class="line">            site&#x3D;data[i].site;</span><br><span class="line">            info&#x3D;data[i].info;</span><br><span class="line">            avatar&#x3D;data[i].avatar;</span><br><span class="line">            li+&#x3D;&#39;&lt;div class&#x3D;&quot;card&quot;&gt;&#39;+&#39;&lt;img class&#x3D;&quot;ava&quot; src&#x3D;&quot;&#39;+avatar+&#39;&quot;&#x2F;&gt;&lt;div class&#x3D;&quot;card-header&quot;&gt;&lt;div&gt;&lt;a href&#x3D;&quot;&#39;+site+&#39;&quot; target&#x3D;&quot;_blank&quot;&gt;&#39;+name+&#39;&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;info&quot;&gt;&#39;+info+&#39;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">        $(&quot;.link-navigation&quot;).append(li);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">link.init();</span><br></pre></td></tr></table></figure>

<p><code>source/friends/index.md</code>中添加内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;friends.css&quot;&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;2.2.4&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;friends.js&quot; type&#x3D;&quot;text&#x2F;javascript&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;links&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;links-content&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;link-navigation&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>如果出现显示不出来可以看下控制台报的啥错：如果是<code>Uncaught ReferenceError: $ is not defined</code>这样的错的话不要慌，可能是因为js引入顺序的问题，<code>jquery.min.js</code>必须在自己写的js前面引入</p>
<p>links.json文件格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">	&#123;</span><br><span class="line">		&quot;name&quot;: &quot;这里写名称&quot;,</span><br><span class="line">		&quot;site&quot;: &quot;https:&#x2F;&#x2F;leflacon.top&#x2F;&quot;,</span><br><span class="line">		&quot;info&quot;: &quot;这里随便写写信息&quot;,</span><br><span class="line">		&quot;avatar&quot;: &quot;https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;006y8mN6ly1g9613jrgg4j30ku0ku452.jpg&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		&quot;name&quot;: &quot;这里再写一个名称&quot;,</span><br><span class="line">		&quot;site&quot;: &quot;https:&#x2F;&#x2F;leflacon.top&#x2F;&quot;,</span><br><span class="line">		&quot;info&quot;: &quot;这里还是随便写写信息&quot;,</span><br><span class="line">		&quot;avatar&quot;: &quot;https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;006y8mN6ly1g9613jrgg4j30ku0ku452.jpg&quot;</span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>我这显示的效果是这个样子的：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gegvy9x9q6j30o10ivdk5.jpg" alt=""></p>
<p>参考教程：<a href="https://tding.top/archives/73ce4e7.html" target="_blank" rel="noopener">Hexo-NexT 新增友链</a></p>
<h2 id="6-「阅读全文」图标定制"><a href="#6-「阅读全文」图标定制" class="headerlink" title="6 「阅读全文」图标定制"></a>6 「阅读全文」图标定制</h2><p>首先在主题配置文件里可以修改文字，<code>excerpt_link</code>默认是“阅读更多…”</p>
<p>感觉原来的按钮有点呆呆的想改一改_(:з」∠)_，在<code>ayer/source/dist/main.css</code>里搜索<code>article-more-link</code>，这个就是阅读全文按钮对应的样式设置（PS：原先的css代码被压缩成一行了，不太容易读，可以用sublime的<strong>CSS Format</strong>插件👍格式化一下）</p>
<p>改完是这样的，我就是想加个hover，这样鼠标移上去的时候会换一下样式，有transition真是好看啊：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.articles .article-entry .article-more-link &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    float: right;</span><br><span class="line">    background-color: #ffffff;</span><br><span class="line">    padding: .5rem 1rem;</span><br><span class="line">    border: 2px solid #555555;</span><br><span class="line">    border-radius: 2px;</span><br><span class="line">    color: #222222;</span><br><span class="line">    font-size: 12px;</span><br><span class="line">    text-decoration: none;</span><br><span class="line">    transition: background-color 0.3s ease-in-out 0s;</span><br><span class="line">    margin:20px 0px 5px 5px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.articles .article-entry .article-more-link:hover &#123;</span><br><span class="line">    border-color: #222222;</span><br><span class="line">    color: #ffffff;</span><br><span class="line">    background: #222222;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>平时的样子：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gegyzs5w5kj30at05jaak.jpg" alt=""></p>
<p>鼠标放上去的样子：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gegyzwgi1hj30bw05o74u.jpg" alt=""></p>
<h2 id="7-打赏页面自定义样式"><a href="#7-打赏页面自定义样式" class="headerlink" title="7 打赏页面自定义样式"></a>7 打赏页面自定义样式</h2><p>就我个人而言，感觉原来的打赏页面和整个主题的风格不是很搭呀😂所以自己改了改</p>
<p>原先是这样的：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gegmbodxkaj30cf0brq4m.jpg" alt=""></p>
<p>在<code>themes/ayer/layout/_partial/modal.ejs</code>里</p>
<p>只改动了<code>main.css</code>里的两块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#reward &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    z-index: 9999;</span><br><span class="line">    left: 50%;</span><br><span class="line">    top: 20%;</span><br><span class="line">    transform: translateX(-50%);</span><br><span class="line">    margin: 60px 0;</span><br><span class="line">    padding: 0 20px 20px;</span><br><span class="line">    &#x2F;*background-color: #dbedff;*&#x2F;</span><br><span class="line">    background-color: rgba(255,255,255,0.8);</span><br><span class="line">    border-radius: 30px;</span><br><span class="line">    box-shadow: 7px 7px 13px 7px rgba(0,0,0,0.3);</span><br><span class="line">    display: none</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line">#reward .reward-p &#123;</span><br><span class="line">    color: #222222;</span><br><span class="line">    font-weight: 700;</span><br><span class="line">    font-size: 18px;</span><br><span class="line">    text-align: center;</span><br><span class="line">    &#x2F;*text-shadow: 1px 1px 1px #888888*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改完是这个样子哒：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gemf5c8uiej30b207qgmv.jpg" alt=""></p>
<h2 id="8-评论邮件回复"><a href="#8-评论邮件回复" class="headerlink" title="8 评论邮件回复"></a>8 评论邮件回复</h2><p>参考自这个教程：<a href="http://www.zhaojun.im/hexo-valine-admin/" target="_blank" rel="noopener">Hexo 优化 — Valine 扩展之邮件通知</a></p>
<p>因为以前NexT主题的时候就做了这个功能，都是在leancloud里设置设置就行了，这里就不重新做一遍了（选择这个主题的原因之一就是他是支持Valine的）</p>
<h2 id="9-more截断自动"><a href="#9-more截断自动" class="headerlink" title="9 more截断自动"></a>9 more截断自动</h2><p>我不想显示全文，这样会很长，但是作者只提供了两种截断模式：</p>
<ul>
<li>一种是手动截断，每篇文章都要手动加more标记</li>
<li>一种是excerpt_all设置成true，这样首页显示成归档</li>
</ul>
<p>所以对于我这种又需要截断又懒得一个一个添加more标记的人来说，这两种模式都不适合，所以加一个自动截断</p>
<p>⚠️前排提示，我的实现是有bug的（很大很大的bug，可能还是手动添加more标记更方便，仅供参考）</p>
<p>写在这篇里➡️<a href="https://leflacon.github.io/89c583ee/" target="_blank" rel="noopener">hexo的Ayer主题添加首页文章自动截断功能</a></p>
<p>实现的效果是这样的（截断200个字符，然后加上省略号）：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehmtutryaj30o20b70uh.jpg" alt=""></p>
<h2 id="10-文章显示leancloud阅读次数"><a href="#10-文章显示leancloud阅读次数" class="headerlink" title="10 文章显示leancloud阅读次数"></a>10 文章显示leancloud阅读次数</h2><p>主题中自带的阅读次数显示的是busuanzi记录的当前页面的阅读次数，因为我之前用的是leancloud的阅读数统计，所以还是想继续用那个</p>
<p>这个内容比较多所以另起了一篇➡️<a href="https://leflacon.github.io/6e6b7173" target="_blank" rel="noopener">hexo的Ayer主题文章内显示leancloud阅读次数（和NexT无缝衔接）</a></p>
<p>实现的效果是这样的（只能在post里面看，index里不显示，因为我debug不出来ORZ，明明<code>document.getElementById</code>然后设置text了但是就是不显示啊，不会唉)：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gemd7hvt09j30oi0dmagf.jpg" alt=""></p>
<hr>
<p>end</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo的Ayer主题文章内显示leancloud阅读次数（和NexT无缝衔接）</title>
    <url>/6e6b7173/</url>
    <content><![CDATA[<p>Ayer主题中自带的阅读次数显示的是busuanzi记录的当前页面的阅读次数</p>
<p>而我之前用的是NexT主题，配合NexT里leancloud的阅读数统计，所以还是想继续用那个，就自己改了一下</p>
<p>✨2020.06.28 做了一些修改，现在可以顺畅的无bug的使用啦～</p>
<a id="more"></a>

<h2 id="1-leancloud配置"><a href="#1-leancloud配置" class="headerlink" title="1 leancloud配置"></a>1 leancloud配置</h2><p>首先是leancloud里的具体配置：（包括注册/在leancloud里新建应用/进行相关设置/创建API类）</p>
<p>因为这些我之前用NexT主题的时候配置过了，过程和NexT主题配置leancloud阅读次数统计是一样的</p>
<h3 id="1-1-注册leancloud-创建应用"><a href="#1-1-注册leancloud-创建应用" class="headerlink" title="1.1 注册leancloud/创建应用"></a>1.1 注册leancloud/创建应用</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geme1xzsbqj30gp0c4757.jpg" alt=""></p>
<h3 id="1-2-获取APPID和APPKEY"><a href="#1-2-获取APPID和APPKEY" class="headerlink" title="1.2 获取APPID和APPKEY"></a>1.2 获取APPID和APPKEY</h3><p>在「设置」-「应用Keys」里，这个等待要填到主题配置文件里</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geme362vhwj307b0aqaam.jpg" alt=""></p>
<h3 id="1-3-添加安全域名"><a href="#1-3-添加安全域名" class="headerlink" title="1.3 添加安全域名"></a>1.3 添加安全域名</h3><p>在「设置」-「安全中心」里添加安全域名</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geme4qei3jj30e50c0403.jpg" alt=""></p>
<h3 id="1-4-创建Class"><a href="#1-4-创建Class" class="headerlink" title="1.4 创建Class"></a>1.4 创建Class</h3><p>在「存储」创建Class，起名为Counter</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geme694lwwj30sj0c876d.jpg" alt=""></p>
<h2 id="2-Ayer修改"><a href="#2-Ayer修改" class="headerlink" title="2 Ayer修改"></a>2 Ayer修改</h2><p>然后讲怎么给Ayer增加leancloud阅读次数统计，和NexT的阅读次数统计无缝衔接</p>
<p>事实证明，想偷懒是不行的ORZ，还是要老老实实看官方文档➡️<a href="https://leancloud.cn/docs/leanengine_cloudfunction_guide-node.html#hash682783061" target="_blank" rel="noopener">云函数开发指南 · Node.js</a></p>
<h3 id="2-1-参考NexT"><a href="#2-1-参考NexT" class="headerlink" title="2.1 参考NexT"></a>2.1 参考NexT</h3><p>NexT里看<code>/themes/next/layout/_macro/post.swig</code>的LeanCould PageView部分和<code>/next/layout/_third-party/analytics/lean-analytics.swig</code></p>
<h3 id="2-2-增加语言"><a href="#2-2-增加语言" class="headerlink" title="2.2 增加语言"></a>2.2 增加语言</h3><p>先修改下语言包<code>themes/ayer/languages/zh-CN.yml</code>，在最后post里加一个time_count属性，中文是阅读次数（叫别的也行），如果配置的是其他语言就在其他语言包里加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post:</span><br><span class="line">  time_count: 阅读次数</span><br><span class="line">  word_count: 字数统计</span><br><span class="line">  read_time: 阅读时长</span><br></pre></td></tr></table></figure>

<h3 id="2-3-修改ariticle-ejs"><a href="#2-3-修改ariticle-ejs" class="headerlink" title="2.3 修改ariticle.ejs"></a>2.3 修改ariticle.ejs</h3><p>根据<code>themes/ayer/layout/_partial/article.ejs</code>中的内容，如果要在article-meta部分在日期和分类后面加上一个阅读次数的话，就是加上下面代码中的8-10行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% if (index || is_post()) &#123; %&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;article-meta&quot;&gt;</span><br><span class="line">  &lt;%- partial(&#39;post&#x2F;date&#39;, &#123;class_name: &#39;article-date&#39;, date_format: null&#125;) %&gt;</span><br><span class="line">  &lt;%- partial(&#39;post&#x2F;category&#39;) %&gt;</span><br><span class="line">  &lt;% if(theme.word_count &amp;&amp; theme.word_count.enable &amp;&amp; !post.no_word_count)&#123;%&gt;</span><br><span class="line">  &lt;%- partial(&#39;post&#x2F;word&#39;) %&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">  &lt;% if(theme.leancloud.time_count &amp;&amp; is_post())&#123; %&gt;</span><br><span class="line">      &lt;%- partial(&#39;post&#x2F;times&#39;) %&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-新建times-ejs"><a href="#2-4-新建times-ejs" class="headerlink" title="2.4 新建times.ejs"></a>2.4 新建times.ejs</h3><p>根据上文的<code>&lt;%- partial(&#39;post/times&#39;) %&gt;</code>，现在需要新建一个<code>/themes/ayer/layout/_partial/post/times.ejs</code></p>
<p>因为要和那行别的东西的格式统一，所以参考那个目录下的<code>category.ejs</code>和<code>date.ejs</code>或者<code>word.ejs</code>的实现即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;article-times&quot;&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;post-time&quot;&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;post-meta-item-text&quot;&gt; &lt;%&#x3D; __(&#39;post.time_count&#39;) %&gt;: &lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span id&#x3D;&quot;&lt;%&#x3D; url_for(post.path) %&gt;&quot; class&#x3D;&quot;leancloud_visitors&quot; data-flag-title&#x3D;&quot;&lt;%- post.title %&gt;&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-css样式设置"><a href="#2-5-css样式设置" class="headerlink" title="2.5 css样式设置"></a>2.5 css样式设置</h3><p><code>/themes/ayer/source/dist/main.css</code>中加上一些样式，抄的是<code>artical-category</code>的样式</p>
<p>before的content那个其实是webfont（找了半天才知道，，见的太少了我）作者用的webfont的图标库是<a href="https://remixicon.com/" target="_blank" rel="noopener">REMIX ICON</a>，然后编码在<a href="https://cdn.jsdelivr.net/npm/remixicon@2.1.0/fonts/remixicon.css" target="_blank" rel="noopener">remixicon.css</a>里可以查（⚠️注意作者引入的版本是2.1.0的）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.article-times &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    margin-left: 1.5rem</span><br><span class="line">    text-decoration: none;</span><br><span class="line">    color: #5c6b72</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.article-times:hover &#123;</span><br><span class="line">    text-decoration: none;</span><br><span class="line">    color: #5c6b72</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.article-times:before &#123;</span><br><span class="line">    content: &quot;\ec2a&quot;;</span><br><span class="line">    font-family: remixicon;</span><br><span class="line">    margin-right: .15rem;</span><br><span class="line">    margin-left: 1.5rem;</span><br><span class="line">    opacity: .6</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.archive-article-header+.article-times &#123;</span><br><span class="line">    margin-left: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-js实现"><a href="#2-6-js实现" class="headerlink" title="2.6 js实现"></a>2.6 js实现</h3><p>导入js代码，<code>themes/ayer/layout/_partial/footer.ejs</code>里<code>&lt;footer&gt;</code>标签前加上下面这段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;2.2.4&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;script src&#x3D;&quot;&#x2F;&#x2F;cdn1.lncld.net&#x2F;static&#x2F;js&#x2F;2.5.0&#x2F;av-min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  var APP_ID&#x3D;&#39;&lt;%- theme.leancloud.app_id %&gt;&#39;;</span><br><span class="line">  var APP_KEY&#x3D;&#39;&lt;%- theme.leancloud.app_key %&gt;&#39;;</span><br><span class="line">  AV.init(&#123;</span><br><span class="line">      appId: APP_ID,</span><br><span class="line">      appKey: APP_KEY</span><br><span class="line">  &#125;);</span><br><span class="line">  function showTime(Counter)&#123;</span><br><span class="line">      var query&#x3D;new AV.Query(&quot;Counter&quot;);</span><br><span class="line">      var url&#x3D;$(&quot;.leancloud_visitors&quot;).attr(&#39;id&#39;).trim();</span><br><span class="line">      query.equalTo(&quot;xid&quot;,url);</span><br><span class="line">      query.find().then(function(results)&#123;</span><br><span class="line">        for(var i&#x3D;0;i&lt;results.length;i++)&#123;</span><br><span class="line">          var number&#x3D;results[i]._serverData.time;</span><br><span class="line">          var urll&#x3D;results[i]._serverData.url;</span><br><span class="line">          &#x2F;&#x2F; console.log(number);</span><br><span class="line">          $(document.getElementById(urll)).text(number);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  function addCount(Counter)&#123;</span><br><span class="line">    var $visitors&#x3D;$(&quot;.leancloud_visitors&quot;);</span><br><span class="line">    var url&#x3D;$visitors.attr(&#39;id&#39;).trim();</span><br><span class="line">    var title&#x3D;$visitors.attr(&#39;data-flag-title&#39;).trim();</span><br><span class="line">    var query&#x3D;new AV.Query(Counter);</span><br><span class="line">    query.equalTo(&quot;xid&quot;,url);</span><br><span class="line">    query.find().then(function(results)&#123;</span><br><span class="line">      if(results.length&gt;0)&#123;</span><br><span class="line">        var counter&#x3D;results[0];</span><br><span class="line">        counter.fetchWhenSave(true);</span><br><span class="line">        counter.increment(&quot;time&quot;);</span><br><span class="line">        counter.save();</span><br><span class="line">        &#x2F;&#x2F; console.log(&quot;ok&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      else&#123;</span><br><span class="line">        var newcounter&#x3D;new Counter();</span><br><span class="line">        newcounter.set(&quot;title&quot;,title);</span><br><span class="line">        newcounter.set(&quot;url&quot;,url);</span><br><span class="line">        newcounter.set(&quot;xid&quot;,url);</span><br><span class="line">        newcounter.set(&quot;time&quot;,1);</span><br><span class="line">        newcounter.save(null,&#123;</span><br><span class="line">          success: function(newcounter)&#123;</span><br><span class="line">            &#x2F;&#x2F; console.log(&quot;new&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  $(function()&#123;</span><br><span class="line">    &lt;% if(theme.leancloud.time_count)&#123; %&gt;</span><br><span class="line">      var Counter&#x3D;AV.Object.extend(&quot;Counter&quot;);</span><br><span class="line">      &lt;% if(is_post())&#123; %&gt;</span><br><span class="line">        addCount(Counter);</span><br><span class="line">      &lt;% &#125; %&gt;</span><br><span class="line">      showTime(Counter);</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>


<h2 id="3-效果"><a href="#3-效果" class="headerlink" title="3 效果"></a>3 效果</h2><p>最终的样式效果是这样的：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehxu5rlajj30o107q40d.jpg" alt=""></p>
<hr>
<p>参考链接：</p>
<ul>
<li><a href="http://crescentmoon.info/2014/12/11/popular-widget/" target="_blank" rel="noopener">使用LeanCloud平台为Hexo博客添加文章浏览量统计组件</a></li>
<li><a href="http://www.icafebolger.com/hexo/hexopostcount.html" target="_blank" rel="noopener">Hexo统计post阅读次数</a></li>
<li><a href="https://www.jianshu.com/p/be00795a502b" target="_blank" rel="noopener">Hexo+Yilia+github主题统计文章阅读次数</a></li>
</ul>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo的Ayer主题添加首页文章自动截断功能（有巨大bug）</title>
    <url>/89c583ee/</url>
    <content><![CDATA[<p>⚠️前排提示，我的实现是有bug的（很大很大的bug，建议先跳到最后看效果）</p>
<p>换到Ayer主题后，这个主题没有自动截断，只能手动添加more标记或者不显示文章内容，所以考虑加一个自动截断</p>
<h2 id="1-参考NexT"><a href="#1-参考NexT" class="headerlink" title="1 参考NexT"></a>1 参考NexT</h2><p>之前用的NexT主题中有一个自动截断的设置，可以直接设置length进行自动截断，NexT主题配置文件对应的部分如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># next</span><br><span class="line">auto_excerpt:</span><br><span class="line">  enable: true #阅读全文截断</span><br><span class="line">  length: 200</span><br></pre></td></tr></table></figure>

<p>于是阅读了NexT里这部分的代码（在<code>next/layout/_macro/post.swig</code>里），尝试在Ayer主题中加上自动截断</p>
<h2 id="2-修改主题配置文件"><a href="#2-修改主题配置文件" class="headerlink" title="2 修改主题配置文件"></a>2 修改主题配置文件</h2><p>首先在Ayer主题配置文件里加上属性，enable开启自动截断，length就是自动截断的长度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 自动截断</span><br><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 200</span><br></pre></td></tr></table></figure>

<h2 id="3-修改article-ejs"><a href="#3-修改article-ejs" class="headerlink" title="3 修改article.ejs"></a>3 修改article.ejs</h2><p>查看index.ejs，然后跳到<code>_partial/archive</code>，首页对应的是pagination==2的部分，于是跳到article.ejs（这里搜索了一下发现这些设置没有别的调用关系，就放心大胆的改了）</p>
<p>我的逻辑是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果开启了截断功能并且是首页</span><br><span class="line">	如果已经有more标志</span><br><span class="line">		显示more标志截断内容</span><br><span class="line">		加上省略号</span><br><span class="line">		显示阅读全文按钮</span><br><span class="line">	如果设置了自动截断</span><br><span class="line">		显示截断length的内容（通过substring函数）</span><br><span class="line">		加上省略号</span><br><span class="line">		显示阅读全文按钮</span><br><span class="line">	否则</span><br><span class="line">		显示全文内容</span><br></pre></td></tr></table></figure>

<p>就是改<code>themes/ayer/layout/_partial/artical.ejs</code>，改完如下面代码的25-47行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;article id&#x3D;&quot;&lt;%&#x3D; post.layout %&gt;-&lt;%&#x3D; post.slug %&gt;&quot; class&#x3D;&quot;article article-type-&lt;%&#x3D; post.layout %&gt;&quot; itemscope</span><br><span class="line">  itemprop&#x3D;&quot;blogPost&quot; data-scroll-reveal&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div class&#x3D;&quot;article-inner&quot;&gt;</span><br><span class="line">    &lt;% if (post.link || post.title)&#123; %&gt;</span><br><span class="line">    &lt;header class&#x3D;&quot;article-header&quot;&gt;</span><br><span class="line">      &lt;%- partial(&#39;post&#x2F;title&#39;, &#123;class_name: &#39;article-title&#39;&#125;) %&gt;</span><br><span class="line">    &lt;&#x2F;header&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line"></span><br><span class="line">    &lt;% if (index || is_post()) &#123; %&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;article-meta&quot;&gt;</span><br><span class="line">      &lt;%- partial(&#39;post&#x2F;date&#39;, &#123;class_name: &#39;article-date&#39;, date_format: null&#125;) %&gt;</span><br><span class="line">      &lt;%- partial(&#39;post&#x2F;category&#39;) %&gt;</span><br><span class="line">      &lt;% if(theme.word_count &amp;&amp; theme.word_count.enable &amp;&amp; !post.no_word_count)&#123;%&gt;</span><br><span class="line">      &lt;%- partial(&#39;post&#x2F;word&#39;) %&gt;</span><br><span class="line">      &lt;% &#125; %&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line"></span><br><span class="line">    &lt;% if (theme.toc &amp;&amp; is_post())&#123; %&gt;</span><br><span class="line">    &lt;%- partial(&#39;post&#x2F;tocbot&#39;) %&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line"></span><br><span class="line">    &lt;% if (theme.excerpt_all&amp;&amp;index)&#123; %&gt;</span><br><span class="line">    &lt;% &#125;else&#123; %&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;article-entry&quot; itemprop&#x3D;&quot;articleBody&quot;&gt;</span><br><span class="line">      &lt;%- partial(&#39;post&#x2F;justifiedGallery&#39;) %&gt;</span><br><span class="line">      &lt;%- partial(&#39;post&#x2F;gallery&#39;) %&gt;</span><br><span class="line">      &lt;% if (post.excerpt &amp;&amp; index)&#123; %&gt;</span><br><span class="line">      &lt;%- post.excerpt %&gt;</span><br><span class="line">      &lt;%- &quot;...&quot; %&gt;</span><br><span class="line">      &lt;% if (theme.excerpt_link)&#123; %&gt;</span><br><span class="line">      &lt;a class&#x3D;&quot;article-more-link&quot; href&#x3D;&quot;&lt;%- url_for(post.path) %&gt;&quot;&gt;&lt;%&#x3D; theme.excerpt_link %&gt;&lt;&#x2F;a&gt;</span><br><span class="line">      &lt;% &#125; %&gt;</span><br><span class="line">      &lt;% &#125; else if(theme.auto_excerpt.enable&amp;&amp;index) &#123; %&gt;</span><br><span class="line">      &lt;% var cc &#x3D; post.content %&gt;</span><br><span class="line">      &lt;%- cc.substring(0, theme.auto_excerpt.length) %&gt;</span><br><span class="line">      &lt;% if (cc.length &gt; theme.auto_excerpt.length)&#123; %&gt;</span><br><span class="line">      &lt;%- &quot;...&quot; %&gt;</span><br><span class="line">      &lt;% &#125; %&gt;</span><br><span class="line">      &lt;% if (theme.excerpt_link)&#123; %&gt;</span><br><span class="line">      &lt;a class&#x3D;&quot;article-more-link&quot; href&#x3D;&quot;&lt;%- url_for(post.path) %&gt;&quot;&gt;&lt;%&#x3D; theme.excerpt_link %&gt;&lt;&#x2F;a&gt;</span><br><span class="line">      &lt;% &#125; %&gt;</span><br><span class="line">      &lt;% &#125; else &#123; %&gt;</span><br><span class="line">      &lt;%- post.content %&gt;</span><br><span class="line">      &lt;% &#125; %&gt;</span><br><span class="line">      &lt;!-- reward --&gt;</span><br><span class="line">      &lt;% if ((theme.reward_type &#x3D;&#x3D;&#x3D; 2 || (theme.reward_type &#x3D;&#x3D;&#x3D; 1 &amp;&amp; post.reward)) &amp;&amp; !index &amp;&amp; !post.no_reward)&#123; %&gt;</span><br><span class="line">      &lt;div id&#x3D;&quot;reward-btn&quot;&gt;</span><br><span class="line">        &lt;%&#x3D; __(&#39;post.reward&#39;) %&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;% &#125; %&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">    </span><br><span class="line">      &lt;!-- copyright --&gt;</span><br><span class="line">      &lt;% if (((theme.copyright_type &#x3D;&#x3D;&#x3D; 2) || (theme.copyright_type &#x3D;&#x3D;&#x3D; 1 &amp;&amp; post.copyright)) &amp;&amp; !index &amp;&amp; !post.no_copyright)&#123; %&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;declare&quot;&gt;</span><br><span class="line">          &lt;ul class&#x3D;&quot;post-copyright&quot;&gt;</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">              &lt;i class&#x3D;&quot;ri-copyright-line&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">              &lt;strong&gt;&lt;%&#x3D; __(&#39;post.copyright_title&#39;) %&gt;： &lt;&#x2F;strong&gt;</span><br><span class="line">              &lt;%&#x3D; __(&#39;post.copyright_content&#39;) %&gt;</span><br><span class="line">            &lt;&#x2F;li&gt;</span><br><span class="line">          &lt;&#x2F;ul&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;% &#125; %&gt;</span><br><span class="line">    &lt;footer class&#x3D;&quot;article-footer&quot;&gt;</span><br><span class="line">      &lt;% if (!index &amp;&amp; theme.share_enable)&#123; %&gt;</span><br><span class="line">          &lt;%- partial(&#39;post&#x2F;share&#39;) %&gt;</span><br><span class="line">      &lt;% &#125; %&gt;</span><br><span class="line">      &lt;%- partial(&#39;post&#x2F;tag&#39;) %&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;footer&gt;</span><br><span class="line"></span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;% if (!index)&#123; %&gt;</span><br><span class="line">  &lt;%- partial(&#39;post&#x2F;nav&#39;) %&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line"></span><br><span class="line">  &lt;% if (theme.valine &amp;&amp; theme.valine.enable &amp;&amp; !post.no_valine)&#123; %&gt;</span><br><span class="line">  &lt;%- partial(&#39;post&#x2F;valine&#39;, &#123;</span><br><span class="line">            key: post.slug,</span><br><span class="line">            title: post.title,</span><br><span class="line">            url: config.url+url_for(post.path)</span><br><span class="line">          &#125;) %&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line"></span><br><span class="line">  &lt;% if (is_post()) &#123; %&gt;</span><br><span class="line">  &lt;%- partial(&#39;post&#x2F;gitalk&#39;) %&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;% if (theme.minivaline &amp;&amp; theme.minivaline.enable &amp;&amp; !post.no_minivaline)&#123; %&gt;</span><br><span class="line">  &lt;%- partial(&#39;post&#x2F;minivaline&#39;) %&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;article&gt;</span><br></pre></td></tr></table></figure>

<p>这个改了好久才成功，不知道为什么直接用substring函数那个变量是不会改的（我也不会ejs，全是依样画葫芦的改）</p>
<h2 id="4-效果"><a href="#4-效果" class="headerlink" title="4 效果"></a>4 效果</h2><p>效果如图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehmtutryaj30o20b70uh.jpg" alt=""></p>
<h2 id="5-bug说明"><a href="#5-bug说明" class="headerlink" title="5 bug说明"></a>5 bug说明</h2><p>但是现在还是会有很大的bug，因为截断的是固定的，这样截断的奇奇怪怪的时候就会出一些问题（卡在文字是没事的，但是比如200字符刚好卡到图片的一半，或是table的一半，或是链接的一半，或是代码的一半……）</p>
<p>比如下图按钮失效直接变成链接了，并且一些错误可能影响到侧边栏啥的：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gegzsj65pqj31400hd427.jpg" alt=""></p>
<p>我目前的解决方式是对那样的文章直接手动添加more标记（有一说一三百多篇一百多篇是需要手动加的，这工作量其实还是直接手动300篇少ORZ，不过写写也蛮有意思）</p>
<hr>
<p>还不知道NexT是怎么做到自动截断而不会出bug的，如果有大佬会请务必教教我%%%</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo NexT主题下修改全局jQuery在线引用地址加快博客访问速度</title>
    <url>/b82ce712/</url>
    <content><![CDATA[<p>前排感谢levi指出的问题以及Royce的提示</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdpul4y5u3j303c02wt8h.jpg" alt=""></p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>昨天刚好有人给我留言说博客访问速度有点慢，「chrome右键」-「检查」-「network」-「刷新」-「按time排序」了一下</p>
<p>确实加载了一个世纪，16.07s看呆0.0</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdptoia8kyj30jj05hab7.jpg" alt=""></p>
<h1 id="原因及解决"><a href="#原因及解决" class="headerlink" title="原因及解决"></a>原因及解决</h1><p>NexT主题里是通过CDN来引用jQuery的，但是有些开源的js库用的是国外CDN托管，在国内访问速度就不咋地</p>
<p>然后对整个next全局搜索一下就可以找到设置全局的jquery.min.js的地方，在主体配置文件<code>themes/next/_config.yml</code>的vendors部分</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdptqp1xurj30ft039dgb.jpg" alt=""></p>
<p>原先的<code>ajax.cat.net……</code>不知道为什么变慢了，那个带<code>cat</code>的是一个为了国内访问加速的公益项目，反代了Ajax（还有些别的</p>
<p>把原先的删掉，改成Staticfile CDN的在线引用地址：<code>https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js</code></p>
<p>然后获取jQuery就很快啦，91ms，又拍云/百度/新浪……啥的也都有jQuery在线引用地址，速度懒得试了hhhhhh，反正Staticfile CDN的很快</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdpuadwvj4j30jj02wjs0.jpg" alt=""></p>
<hr>
<p>然后还发现daovoice有时候也加载特别慢，就把他关掉啦（反正用的也不多</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdpubquom3j30ji02mdgb.jpg" alt=""></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS下用C语言在75行实现简易版贪吃蛇（写的天旋地转）</title>
    <url>/a9177535/</url>
    <content><![CDATA[<p>之前在知乎看见的链接在这里➡️<a href="https://www.zhihu.com/question/360814879" target="_blank" rel="noopener">用C语言，能在100行之内实现贪吃蛇吗？</a>%%%，大一c++课程作业也是贪吃蛇来着，不过那个代码可长可长hhhhhh而且是在windows平台下的，主要是考察链表结构？</p>
<p>知乎里面好些都用了<a href="https://zh.wikipedia.org/wiki/Ncurses" target="_blank" rel="noopener">ncurses库</a>，这个库用来编写独立于终端的基于文本的用户界面，不过我还是想偷懒不想安装别的库，所以写一个只使用标准库的，参考了<a href="https://www.zhihu.com/question/360814879/answer/1013986215" target="_blank" rel="noopener">知乎Milo Yip</a>的超清思路，只在macOS上试过，写交互的的时候真的感觉没学过C一样，，一无所知水平受限可能有哪里理解的不对，欢迎指出QWQ</p>
<hr>
<h1 id="0-代码"><a href="#0-代码" class="headerlink" title="0 代码"></a>0 代码</h1><p>总共有75行，其实有些可以再压缩一下，但是没有必要啦</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;sys&#x2F;select.h&gt;</span><br><span class="line">#include&lt;termios.h&gt;</span><br><span class="line">#define W 64</span><br><span class="line">#define H 20</span><br><span class="line">int mapp[W*H],snake[W*H],pos,npos,change&#x3D;1,food,head&#x3D;0,len&#x3D;1,ch&#x3D;67;</span><br><span class="line">struct termios orig_termios;</span><br><span class="line">void reset_terminal_mode()&#123;</span><br><span class="line">    tcsetattr(0, TCSANOW, &amp;orig_termios);</span><br><span class="line">&#125;</span><br><span class="line">void set_conio_terminal_mode()&#123;</span><br><span class="line">    struct termios new_termios;</span><br><span class="line">    tcgetattr(0, &amp;orig_termios);</span><br><span class="line">    memcpy(&amp;new_termios, &amp;orig_termios, sizeof(new_termios));</span><br><span class="line">    new_termios.c_lflag&amp;&#x3D;~(ICANON|ECHO);</span><br><span class="line">    atexit(reset_terminal_mode);</span><br><span class="line">    tcsetattr(0, TCSANOW, &amp;new_termios);</span><br><span class="line">&#125;</span><br><span class="line">int kbhit()&#123;</span><br><span class="line">    struct timeval tv &#x3D; &#123; 0L, 0L &#125;;</span><br><span class="line">    fd_set fds;</span><br><span class="line">    FD_ZERO(&amp;fds);</span><br><span class="line">    FD_SET(0, &amp;fds);</span><br><span class="line">    return select(1, &amp;fds, NULL, NULL, &amp;tv);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    set_conio_terminal_mode();</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    for(int i&#x3D;0;i&lt;W*H;i++)mapp[i]&#x3D;((i&#x2F;W%(H-1)&#x3D;&#x3D;0)||(i%W%(W-1)&#x3D;&#x3D;0))?1:0;&#x2F;&#x2F;board</span><br><span class="line">    snake[0]&#x3D;pos&#x3D;64*10+32;&#x2F;&#x2F;init the position of snake</span><br><span class="line">    mapp[pos]&#x3D;1;</span><br><span class="line">    npos&#x3D;pos+1;&#x2F;&#x2F;define the first step</span><br><span class="line">    do&#123;food&#x3D;rand()%(W*H);&#125;while(mapp[food]&#x3D;&#x3D;1);&#x2F;&#x2F;create food</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        while(!kbhit())&#123;&#x2F;&#x2F;not press</span><br><span class="line">            if(mapp[npos]&#x3D;&#x3D;1)return 0;&#x2F;&#x2F;gg</span><br><span class="line">            head&#x3D;(head+1)%(W*H);&#x2F;&#x2F;snake move</span><br><span class="line">            snake[head]&#x3D;npos;</span><br><span class="line">            mapp[npos]&#x3D;1;</span><br><span class="line">            if(npos&#x3D;&#x3D;food)&#123;</span><br><span class="line">                do&#123;food&#x3D;rand()%(W*H);&#125;while(mapp[food]&#x3D;&#x3D;1);&#x2F;&#x2F;eat then create food</span><br><span class="line">                ++len;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;&#x2F;&#x2F;clear the tail of the snake</span><br><span class="line">                int tail&#x3D;(head+W*H-len)%(W*H);</span><br><span class="line">                mapp[snake[tail]]&#x3D;0;</span><br><span class="line">            &#125;</span><br><span class="line">            pos&#x3D;npos;&#x2F;&#x2F;this step is ok</span><br><span class="line">            for(int i&#x3D;0;i&lt;W*H;i++)&#123;&#x2F;&#x2F;show</span><br><span class="line">                if(i&#x3D;&#x3D;food)&#123;</span><br><span class="line">                    printf(&quot;*&quot;);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                printf(&quot;%c&quot;,mapp[i]&#x3D;&#x3D;0?&#39; &#39;:&#39;#&#39;);</span><br><span class="line">                if(i%W&#x3D;&#x3D;(W-1))printf(&quot;\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;score: %d\n&quot;,len-1);</span><br><span class="line">            printf(&quot;\033[1;1H\033[2J&quot;);</span><br><span class="line">            usleep(abs(change)&gt;1?250000-len*200:125000-len*100);</span><br><span class="line">            npos&#x3D;pos+change;</span><br><span class="line">        &#125;</span><br><span class="line">        if((ch&#x3D;getchar())!&#x3D;27)continue;</span><br><span class="line">        if((ch&#x3D;getchar())!&#x3D;91)return 0;</span><br><span class="line">        ch&#x3D;getchar();&#x2F;&#x2F; get direction</span><br><span class="line">        if(ch&#x3D;&#x3D;65)change&#x3D;-W;</span><br><span class="line">        else if(ch&#x3D;&#x3D;66)change&#x3D;W;</span><br><span class="line">        else if(ch&#x3D;&#x3D;67)change&#x3D;1;</span><br><span class="line">        else if(ch&#x3D;&#x3D;68)change&#x3D;-1;</span><br><span class="line">        else change&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1-运行效果"><a href="#1-运行效果" class="headerlink" title="1 运行效果"></a>1 运行效果</h1><p>能吃能跑能撞墙_(:з」∠)_</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gd2t1v85rmj30cs088gm8.jpg" alt=""></p>
<h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h1><h2 id="2-1-建图及建蛇"><a href="#2-1-建图及建蛇" class="headerlink" title="2.1 建图及建蛇"></a>2.1 建图及建蛇</h2><h3 id="2-1-1-建图"><a href="#2-1-1-建图" class="headerlink" title="2.1.1 建图"></a>2.1.1 建图</h3><p>定义地图的宽W/高H，实际可移动的范围是(0,64)(0,20)，而第0行/19行/0列/63列是边界</p>
<p>mapp数组用来存图，<code>mapp[i]==0</code>表示无障碍，<code>mapp[i]==1</code>表示有障碍，有障碍的地方就是蛇身和边界</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define W 64</span><br><span class="line">#define H 20</span><br><span class="line">int mapp[W*H];</span><br></pre></td></tr></table></figure>

<p>抛弃二维的思路，直接用一维，坐标(x,y)表示成pos，<code>pos=W*x+y</code>，那么就可以获得地图的边界条件</p>
<ul>
<li>左右边界：<code>pos/W%(H-1)==0</code>，即第0列和(W-1)列</li>
<li>上下边界：<code>pos%W%(W-1)==0</code>，即第0行和(H-1)行</li>
</ul>
<p>蛇身就是蛇的初始位置，那个位置也设置为1</p>
<h3 id="2-1-2-建蛇"><a href="#2-1-2-建蛇" class="headerlink" title="2.1.2 建蛇"></a>2.1.2 建蛇</h3><p>开一个数组表示蛇，蛇最长就是<code>(W-1)*(H-1)</code>那么长，如果用链表结构的话很方便的可以进行插入的操作，但是代码量也会大大增加，所以直接用数组记录蛇的每一节的坐标</p>
<p>snake[i]表示蛇的某一节（不一定是第i节，这个数组是循环利用的，见蛇的移动部分）</p>
<h2 id="2-2-食物的生成"><a href="#2-2-食物的生成" class="headerlink" title="2.2 食物的生成"></a>2.2 食物的生成</h2><p>随机数生成食物，<code>food_pos=rand()%(W*H)</code>就可以获得一个随机的位置，判断食物位置不合法的条件就是<code>m[food_pos]==1</code>，那么写一个do while循环就可以在一行实现</p>
<p>生成食物只需要在两个地方调用，一次是初始化部分调用一次，还有是在食物被吃了的时候调用</p>
<h2 id="2-3-蛇的移动"><a href="#2-3-蛇的移动" class="headerlink" title="2.3 蛇的移动"></a>2.3 蛇的移动</h2><h3 id="2-3-1-上下左右"><a href="#2-3-1-上下左右" class="headerlink" title="2.3.1 上下左右"></a>2.3.1 上下左右</h3><p>因为已经把问题投影到一维地图上了，所以上下左右带来的坐标变化量<code>change</code>也投影到一维上：</p>
<ul>
<li>上：(x,y)-&gt;(x-1,y) change=-W</li>
<li>下：(x,y)-&gt;(x+1,y) change=W</li>
<li>右：(x,y)-&gt;(x,y+1) change=1</li>
<li>左：(x,y)-&gt;(x,y-1) change=-1</li>
</ul>
<p>新的蛇头坐标就是<code>npos=pos+change</code>，然后需要判断这一步npos是否可行</p>
<h3 id="2-3-2-吃或没吃或死"><a href="#2-3-2-吃或没吃或死" class="headerlink" title="2.3.2 吃或没吃或死"></a>2.3.2 吃或没吃或死</h3><p>移动一步后<code>npos</code>位置总共面临三种情况：碰到蛇身或边界死亡/吃食物/没吃食物可以继续移动</p>
<h4 id="碰到蛇身或边界死亡"><a href="#碰到蛇身或边界死亡" class="headerlink" title="碰到蛇身或边界死亡"></a>碰到蛇身或边界死亡</h4><p>直接判断新位置的<code>m[npos]</code>是否为0即可，死亡肯定是最先判断的</p>
<h4 id="没吃食物可以继续移动"><a href="#没吃食物可以继续移动" class="headerlink" title="没吃食物可以继续移动"></a>没吃食物可以继续移动</h4><p>继续循环，这就要涉及到那个保存蛇位置的snake数组了，我觉得这里有点用到<strong>滚动数组</strong>的思想</p>
<p>我设置了一个head记录蛇的头的索引号，头的位置就保存在<code>snake[head]</code>里</p>
<p>len记录蛇的长度，同时这个量也可以表示蛇头索引到蛇尾索引的偏移，也可以输出得分</p>
<p>每次有了新的蛇头后，就把新蛇头的坐标记录在<code>snake[(head+1)%(W*H)]</code>中，那么如果没有吃食物的话，除了蛇尾的位置需要改变，其他记录的蛇身是不变的</p>
<p>利用这个“滚动数组”，计算出蛇尾的索引就是<code>(head+W*H-len)%(W*H)</code>，那么把对应位置的mapp值设置成0即实现了抹去旧蛇尾</p>
<h4 id="吃食物"><a href="#吃食物" class="headerlink" title="吃食物"></a>吃食物</h4><p>吃了那么蛇的长度加一，这样就不用抹去旧蛇尾</p>
<p>至此游戏部分的逻辑基本清楚了，然后就是万恶的可视化和交互ORZ</p>
<h2 id="2-4-可视化"><a href="#2-4-可视化" class="headerlink" title="2.4 可视化"></a>2.4 可视化</h2><p>基本想法是图的可视化就print输出，每次输出完到一下一个时间间隔的时候清屏</p>
<h3 id="2-4-1-清屏"><a href="#2-4-1-清屏" class="headerlink" title="2.4.1 清屏"></a>2.4.1 清屏</h3><p>然后考虑如何清屏</p>
<h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>当时大一课程作业贪吃蛇的交互部分老师给出代码了，，太久远了我也不记得咋实现的，但是没想到搜了一下我们学校+贪吃蛇，竟然搜到了我们那届的贪吃蛇代码！（而且经过大胆假设小心求证后那个大佬我认识hhhhh！神奇！！还发现当时写代码的助教是我们现在一个课的老师，我真的一点印象都没有了ORZ）</p>
<p>大佬存档的大一课程作业的贪吃蛇代码的思路在这里，可惜我当时的代码不知道被我丢哪里去了：<a href="https://blog.csdn.net/weixin_40903598/article/details/80232514" target="_blank" rel="noopener">c++贪吃蛇补充</a></p>
<p>然后清屏似乎就变的顺利起来，Windows下清屏是<code>system(&quot;cls&quot;);</code>(stdlib.h)，那么macOS下是<code>system(&quot;clear&quot;);</code>(unistd.h)</p>
<p>但是问题又来了，只清屏不行，还需要把光标定格在最上面的位置再开始输出图啊，这要怎么实现？</p>
<h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>查啊查终于找到了这个东西：<a href="http://www.climagic.org/mirrors/VT100_Escape_Codes.html" target="_blank" rel="noopener">VT100 escape codes</a>，就是发送一个转义码给屏幕，就可以实现对终端的一些特殊效果，然后这个码是以<code>^[</code>开头的（具体的也不太会翻译就不翻了QAQ）</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcwsij3nrdj30eu04fjru.jpg" alt=""></p>
<p>那么<code>printf(&quot;\033[2J&quot;);</code>就可以实现清屏（奇怪的代码增加了.jpg）</p>
<p>再找找cursor相关的，(v,h)参数就是移动到屏幕的(v,h)位置，所以<code>^[[1;1H</code>就可以移动到(1,1)的位置，然后重新打印地图，nice！</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gd2tjbp61vj30g806jgn8.jpg" alt=""></p>
<p>结合在一起就是：<code>printf(&quot;\033[1;1H\033[2J&quot;);</code></p>
<h3 id="2-4-2-速度"><a href="#2-4-2-速度" class="headerlink" title="2.4.2 速度"></a>2.4.2 速度</h3><p>时间间隔通过<code>usleep</code>实现，查询可得单位是微秒</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gd2t71x0wgj30fr09fq3y.jpg" alt=""></p>
<p>macOS终端默认的字体是SF Mono Regular，截图计算了下单个字符宽高比是1:2的样子，也就是说如果要使左右移动的速度和上下移动速度看起来相等的话，在左右移动路程是上下移动路程的<code>1/2</code>的情况下，左右移动的时间也需要是上下移动时间的<code>1/2</code></p>
<p>那么判断左右后设置不同的等待时间即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usleep(abs(change) &gt; 1 ? 250000 : 125000);</span><br></pre></td></tr></table></figure>

<p>此处还可以增加蛇的变速功能，吃的食物越多蛇的速度越快，增加游戏体验，反正并不需要增加代码的行数hhhhh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usleep(abs(change)&gt;1?250000-len*200:125000-len*100);</span><br></pre></td></tr></table></figure>

<h2 id="2-5-交互"><a href="#2-5-交互" class="headerlink" title="2.5 交互"></a>2.5 交互</h2><p>再然后最没有头绪的就是交互部分了，，</p>
<h3 id="2-5-1-按键"><a href="#2-5-1-按键" class="headerlink" title="2.5.1 按键"></a>2.5.1 按键</h3><p>windows下是<code>GetAsyncKeyState</code>，“是一个用来判断函数调用时指定虚拟键的状态，确定用户当前是否按下了键盘上的一个键的函数。”</p>
<p>又或者用<code>_kbhit(),_getch()</code>这样的组合</p>
<p>macOS下或者linux下都有方法来实现<code>kbhit()</code>函数：（我一开始看的其实是linux那个，但是倒腾了半天最后发现macOS标准库里都没有<code>#include&lt;stropts.h&gt;</code>这个库，，，）</p>
<ul>
<li><a href="https://www.flipcode.com/archives/_kbhit_for_Linux.shtml" target="_blank" rel="noopener">flipcode: _kbhit() for Linux</a></li>
<li><a href="https://stackoverflow.com/questions/29335758/using-kbhit-and-getch-on-linux" target="_blank" rel="noopener">stackoverflow: Using kbhit() and getch() on Linux</a>，，显然macOS下用ncurses.h库会很方便的样子，唉但是说好不用就不用ORZ</li>
<li><a href="https://stackoverflow.com/questions/312185/kbhit-in-mac" target="_blank" rel="noopener">stackoverflow: kbhit() in mac</a></li>
<li><a href="https://stackoverflow.com/questions/448944/c-non-blocking-keyboard-input#448982" target="_blank" rel="noopener">stackoverflow: C non-blocking keyboard input</a>⬅️最后参考的是这篇里@Alnitak的回答和<a href="https://www.zhihu.com/question/360814879/answer/1047231879" target="_blank" rel="noopener">知乎</a>里@Aqua的魔法代码</li>
</ul>
<p>最后的结构大概是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set_conio_terminal_mode();&#x2F;&#x2F;一些初始工作</span><br><span class="line">while(1)&#123;</span><br><span class="line">    while(!kbhit())&#123;&#x2F;&#x2F;没按键，按键了就退出最里层while</span><br><span class="line">        &#x2F;&#x2F;do something</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获取按键</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="set-conio-terminal-mode-初始工作"><a href="#set-conio-terminal-mode-初始工作" class="headerlink" title="set_conio_terminal_mode()初始工作"></a><code>set_conio_terminal_mode()</code>初始工作</h4><p>参考以下这三个文档：</p>
<ul>
<li><a href="https://en.wikiversity.org/wiki/Linux/linux-0.01.tar/include/termios.h" target="_blank" rel="noopener">wiki: Linux/linux-0.01.tar/include/termios.h</a></li>
<li><a href="https://baike.baidu.com/item/Termios/1467529?fr=aladdin" target="_blank" rel="noopener">百度百科: Termios</a></li>
<li><a href="http://man7.org/linux/man-pages/man3/termios.3.html" target="_blank" rel="noopener">man7.org &gt; Linux &gt; man-pages &gt; TERMIOS(3) </a></li>
</ul>
<p>首先linux命令行（macOS也一样）是行缓冲的，也就是直到按下了回车之前输入的内容才会到stdin里，这样显然不符合上下左右的实时交互，所以<code>_kbhit()</code>函数里的第一步就是关闭行缓冲，需要用到<code>termios.h</code>这个库（是标准库里的），这个库主要是一些终端的传输设置？</p>
<p>总之接下来要干的事情就是设置一堆参数，用<code>termios</code>结构体，一开始我唯一认识的就是atexit了，，，还是PA里讲的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void reset_terminal_mode()&#123;</span><br><span class="line">    tcsetattr(0, TCSANOW, &amp;orig_termios);</span><br><span class="line">&#125;</span><br><span class="line">void set_conio_terminal_mode()&#123;</span><br><span class="line">    struct termios new_termios;</span><br><span class="line">    tcgetattr(0, &amp;orig_termios);&#x2F;&#x2F;获取原始与终端相关的参数</span><br><span class="line">    memcpy(&amp;new_termios, &amp;orig_termios, sizeof(new_termios));&#x2F;&#x2F;复制</span><br><span class="line">    new_termios.c_lflag&amp;&#x3D;~(ICANON|ECHO);&#x2F;&#x2F;设置控制模式，后面两个是宏定义</span><br><span class="line">    &#x2F;&#x2F; ICANON: Enable canonical mode (described below)</span><br><span class="line">    &#x2F;&#x2F; ECHO: Echo input characters.</span><br><span class="line">    atexit(reset_terminal_mode);&#x2F;&#x2F;在程序结束return 0后调用atexit，把终端恢复成原来的设置</span><br><span class="line">    tcsetattr(0, TCSANOW, &amp;new_termios);&#x2F;&#x2F;TCSANOW表示设置的对终端的更改立即发生</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="kbhit"><a href="#kbhit" class="headerlink" title="kbhit()"></a>kbhit()</h4><p>timeout设置为0即非阻塞编程，select函数用来检查可读性</p>
<p>如果readset有fd被set了表明有新数据可读（在贪吃蛇中也就是按键了，这样函数返回值就是1，会退出while循环开始getchar）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int kbhit()&#123;</span><br><span class="line">    struct timeval tv &#x3D; &#123; 0L, 0L &#125;;&#x2F;&#x2F;timeval: 高精度结构体，秒&#x2F;微秒</span><br><span class="line">    fd_set fds;</span><br><span class="line">    FD_ZERO(&amp;fds);&#x2F;&#x2F;fds清零</span><br><span class="line">    FD_SET(0, &amp;fds);&#x2F;&#x2F;0加入fds集合</span><br><span class="line">    return select(1, &amp;fds, NULL, NULL, &amp;tv);</span><br><span class="line">    &#x2F;&#x2F; 函数原型: int select(int nfds,fd_set* readset,fd_set* writeset,fe_set* exceptset,struct timeval* timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getchar"><a href="#getchar" class="headerlink" title="getchar()"></a>getchar()</h4><p>编码是之前搜到的那个VT100 escape codes，唉这部分我最后都没怎么搞懂TAT</p>
<p>VT100 User Guide可以在这里获得：<a href="https://vt100.net/docs/vt100-ug/" target="_blank" rel="noopener">https://vt100.net/docs/vt100-ug/</a>，可以找到3.6节是需要的控制编码</p>
<p>esc对应的ascii码是27，<code>[</code>的ascii是91，A/B/C/D对应的ascii分别是65/66/67/68</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gd330jgqqlj30pt05i3zd.jpg" alt=""></p>
<p>所以如果要识别一个方向键，实际上是要getchar()三次的，比如按up实际上接收的是27/91/65，就参考@Aqua的代码那么写了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if((ch&#x3D;getchar())!&#x3D;27)continue;</span><br><span class="line">if((ch&#x3D;getchar())!&#x3D;91)return 0;</span><br><span class="line">ch&#x3D;getchar();&#x2F;&#x2F; get direction</span><br><span class="line">if(ch&#x3D;&#x3D;65)change&#x3D;-W;</span><br><span class="line">else if(ch&#x3D;&#x3D;66)change&#x3D;W;</span><br><span class="line">else if(ch&#x3D;&#x3D;67)change&#x3D;1;</span><br><span class="line">else if(ch&#x3D;&#x3D;68)change&#x3D;-1;</span><br><span class="line">else change&#x3D;1;</span><br></pre></td></tr></table></figure>

<p>我最后会有一点bug，就是按ESC退出的话，并没有直接结束再按一下才结束？按照代码的逻辑，接收到27之后，确实是需要再getchar才有机会return 0，不知道要怎么改，真的不会了一点也不会了ORZ先这样吧</p>
<hr>
<p>本来以为半天就能搞完这个贪吃蛇的结果最后终端交互部分拖了好几好几天，真的后悔折腾这个了是我太菜了得去赶作业了_(´ཀ`」 ∠)_ddl你慢点</p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>《抽卡人生》通关记录</title>
    <url>/5e426f3/</url>
    <content><![CDATA[<image src="https://tva1.sinaimg.cn/large/00831rSTly1gcesnwjyplj30960g9n3v.jpg" width="250px">

<a id="more"></a>

<p>3月1号玩的了，现在才突然发现这篇乱七八糟的文档没写完ORZ，，当时想随便找个能抽卡的游戏开心一下´д` ;，然后就被这个游戏的设定吸引了：</p>
<center>

<font size="2px" color="#777777">

<p>2419年<br>在中国由于游戏业的快速恶劣发展<br>游戏类型也趋向单一化<br>并且禁止了引进国外游戏<br>用在游戏中的商业模式被用在了社会各个地方<br>想吃巧克力冰淇淋？<br>对不起，不能直接买，需要花钱抽食物卡<br>你有可能抽到香草口味，也有可能抽到草莓口味、等等。<br>想要买件衣服？试穿合适了，直接掏钱？<br>不，你需要掏钱去店里抽卡，抽到那一套，才能给你。<br>因为这样商家可以收获最大的利益，而且能造就更高的GDP。<br>甚至，当有人犯罪了被关在监狱里，每天提供的食物和水也需要抽卡，抽到吃饭，抽不到饿死。<br>重犯可以在囚禁的时间里抽到100张最稀有的卡来免刑。<br>我，因为被人认为在世界卡池里抽卡作弊被判刑，这在现在是很严重的罪。<br>入狱后，如果我用监狱每天提供的有限金钱抽到100张最稀有的卡，我就会被无罪释放。<br>这太难了，但是我首先应该考虑的是会不会被饿死，渴死等等。。<br>我必须先活下去。。。</p>
</font>
</center>

<image src="https://tva1.sinaimg.cn/large/00831rSTly1gceqnx737cj30950gaq8z.jpg" width="300px">

<p>许多都是随机，包括可能不限于：抽卡，因为没抽到生存卡或ssr的精神状态的下降，感染/白血病/发热疾病的发生，交易价格的波动，交易的卡牌……</p>
<p>刚开始打的时候完全没注意开头介绍的后半段，直到通关了回头看自己摸索出来的策略才发现原来一早就给提示了，，必须先活下去，，这可能就是我死了十五次的原因（饿死，乐极生悲，精神失常……QWQ）</p>
<p>然后才意识到主角的天赋对于今后的生存真的影响非常大，比如“忍者”天赋每天消耗更少的食物和水，“生存者”天赋更容易抽到生存类卡牌，“少汗”每天消耗更少的水。想靠着“多汗”/“体虚”/“肥胖”……之类的天赋生存下去是很难的。</p>
<p>最后是在「“喜欢食物”/“贪婪”/“生存者”/“忍者”」的天赋下通关的。在这种天赋条件下，因为没有精神角度的能力增幅所以前期就要多屯生存卡和购买镇定剂，疾病卡牌只要每个屯一张或者两张保证有病就治就行，生存角度增幅的三个天赋可以保证形成有生存卡结余的良性循环，然后后期食物卡的价格很高，在价格合适的时候把多余的生存卡卖出狂抽ssr，精神就利用之前囤的镇定剂及时补给。</p>
<p>但是如果有增强精神力的天赋或许就得换一种策略了，这样抽卡其实消耗不了多少精神，不需要很多镇定剂补充，交易的时候就要多换生存卡之类的，总之得靠变通呐。当然欧洲人如果四个全都是超强超开挂的天赋或者就是乱出ssr，，那也没什么好说的，，通关应该会容易一些吧，，反正非洲人没有这种游戏体验:)</p>
<p>但是无论如何这确实不是个抽卡游戏，更多是一种人定胜天的较量。</p>
<p>其实最后通关的时候真的被感动了……</p>
<p>一个大概是被自己感动了hhhhhh一个小游戏打了六个多小时才通关，我学习的时候怎么就，，这么坐不住呢_(:з」∠)_</p>
<image src="https://tva1.sinaimg.cn/large/00831rSTly1gcen7yzqdqj30db05bwez.jpg" width="500px">

<p>再就是被这个游戏本身感动，通关后的那段动画是这样的：</p>
<image src="https://tva1.sinaimg.cn/large/00831rSTly1gcesm4wdjsj30960gawlx.jpg" width="200px">

<image src="https://tva1.sinaimg.cn/large/00831rSTly1gcesmjnfhej30950gbtf2.jpg" width="200px">

<image src="https://tva1.sinaimg.cn/large/00831rSTly1gcesmyb07cj30950gaqa7.jpg" width="200px">

<image src="https://tva1.sinaimg.cn/large/00831rSTly1gcesnb6ymej30950d2jwy.jpg" width="200px">

<image src="https://tva1.sinaimg.cn/large/00831rSTly1gcesnorrxpj30950gatf6.jpg" width="200px">

<image src="https://tva1.sinaimg.cn/large/00831rSTly1gcesnwjyplj30960g9n3v.jpg" width="200px">

<p>关于第四帧那两个人是干嘛的还未能理解作者的意图，或许什么时候灵机一动能理解吧，不理解也无所谓（我有时候喜欢上帝视角，有时候却讨厌，这种想法说不清楚说不出来），在App Store的评论里倒是捕捉到了作者的一条回复：</p>
<image src="https://tva1.sinaimg.cn/large/00831rSTly1gceujxubysj30my0gmwi4.jpg" width="350px">

<p>唉有空的时候再试试其他两个模式。</p>
<p>就我个人感受再谈一点运气论吧。</p>
<p>我曾幼稚的以为运气很重要。但是其实很多时候的运气确实只是一个<code>srand((unsigned)time(NULL));rand();</code>的事情，它被分配的并不偏颇。</p>
<p>ssr会以一个设定的概率发生在任意时刻，但疾病或是低等级的卡片也同理。真正从监狱里走出来的人并不全是那些永远有好运气的人，而是有较好的品性（“天赋”）的人，并且他们能利用这些品性（“天赋”）增加自己碰运气的机会（抽卡的次数），从而达成游戏100张ssr卡的通关目标。有抽1000次抽卡机会一定能比有100次得到的ssr多么，未必，但必然的是前者大于后者的概率更大。</p>
<p>但是假设运气是均等的命题成立的话，为什么很多时候我们还是会觉得自己没那么幸运，或者是羡慕别人的幸运？</p>
<p>对抽卡游戏执着的原因可能是希望在游戏抽卡中能找到一个欧非的答案，以及希望获得被“证明”为欧之后的快乐。运气好的时候仿佛所有好运都集中在一天，事事顺心如意；运气不好的时候所有的坏事也都集中在一天，各种压抑的负面情绪。</p>
<p>这个命题的漏洞在于，在大多数情况下，我们评判运气好坏时只是以有限次的结果作为判断的依据，而这个判断中可能还掺入了过高的期待/被高看的付出/因结果忽略的过程等等。</p>
<p>游戏里“疯狂抽卡”的设定向人揭示了，在抽卡次数足够多的时候，所谓的运气其实就是几个平稳的数字组成的概率。但是现实毕竟不是游戏。在现实中，我们没有游戏里那样百次千次万次的抽卡机会，真切的摆在眼前的抽卡机会就那么一下，所有的期望都灌注在将要到来的结果上，以至于产生了关于运气好坏的落差感。</p>
<p>但要把现实看成一场时空无限划分的游戏，或者说用微分的理论去看它，当基数无限庞大抽卡次数无限多的时候，任何一件小事都能被拿来说道：就比如此刻在打字，一次打对是幸，打了错字退格重来是不幸……如此，欧非又能有多大的分别呢？不过需要指出的是，不是所有人都像游戏里那样抽着同一个卡池。</p>
<p>尽管以上一切理性告诉我把情感寄托在运气之类的载体上，太过不切实际，但是说到底，感性上还是愿意去相信它。何况同一件事物有许许多多看待它的角度：和喜欢的人一起等车时车晚点了是幸，赶着去办事车晚点了是不幸，若是在一个平凡的日子等晚点的车只会觉得那不过是一个随机事件罢了。</p>
<p>现实中运气究竟是否重要？答，重要，但不可控。幸运的是，抽卡的次数和不同概率的卡池，可能是有选择的机会的；内心对于某个随机事件的情感偏向，也是可以轻微的波动天平的一边使其失衡的。</p>
<p>但是……胡说了一堆最后还是觉得，在抽卡游戏面前，我就是个非洲小孩QWQ</p>
<p>end。</p>
<hr>
<center><font size="12" color=#5959ff>J</font><font size="12" color=#a5b2ff>’</font><font size="8" color=#8888fd>a</font><font size="8" color=#7762fd>i</font><font size="8" color=#f1a8ce>m</font><font size="8" color=#a97afd>e </font><font size="8" color=#a7a7f5>m</font><font size="8" color=#628dfd>a </font><font size="8" color=#6363ff>v</font><font size="8" color=#8e64ff>i</font><font size="8" color=#ffafc7>e</font></center>

<hr>
]]></content>
      <categories>
        <category>love&amp;peace</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+github+coding双线部署（加快博客访问速度）</title>
    <url>/b61b079a/</url>
    <content><![CDATA[<p>终于去做了胃镜有种某个阶段尘埃落定的感觉，要做个好好生活的快乐小学鸡～把之前咕咕咕的双线部署先干掉！٩(˃̶͈̀௰˂̶͈́)و</p>
<hr>
<h1 id="双线部署"><a href="#双线部署" class="headerlink" title="双线部署"></a>双线部署</h1><p>github-pages的访问速度一般，所以可以国内访问走coding，国外走github</p>
<p><a href="http://leflacon.github.io/3ca6f02/" target="_blank" rel="noopener">Mac OS下用「hexo+github」搭建个人博客！</a></p>
<p>首先假设我的博客已经上传了github仓库，利用github-page，有了一个<code>leflacon.github.io</code>这样的域名，我的所有SEO优化也是基于原先的域名做的</p>
<h1 id="1-Coding"><a href="#1-Coding" class="headerlink" title="1 Coding"></a>1 Coding</h1><h2 id="1-1-创建项目"><a href="#1-1-创建项目" class="headerlink" title="1.1 创建项目"></a>1.1 创建项目</h2><p>先去注册balabala➡️ <a href="https://coding.net/" target="_blank" rel="noopener">Coding官网</a>，没想到之前注册的个人账号在Coding改版成团队之后还能用，诶嘿</p>
<p>在右上角选择「创建项目」：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcnzjxmo03j30bj07b0t4.jpg" alt=""></p>
<p>选择「代码托管项目」，第一个「项目名称」这项填<code>balabala用户名.coding.me</code>，别的随意，然后勾选readme的选项，</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcnznyqgwtj30vc0fkdim.jpg" alt=""></p>
<h2 id="1-2-打开静态网站"><a href="#1-2-打开静态网站" class="headerlink" title="1.2 打开静态网站"></a>1.2 打开静态网站</h2><p>进入项目后在左下角有个「项目设置」，点击会进入「项目与成员」页面，把第四个选项构建与部署打开</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcnzt6o1qwj31400h9wid.jpg" alt=""></p>
<p>此时返回左侧设置页面就会多了个「构架与部署」选项，进入「静态网站」，先实名验证然后「立即发布静态网站」</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcnzvjn7g8j31400g20vk.jpg" alt=""></p>
<p>填表，网站名称写<code>balabala用户名</code>，按照默认的：触发机制「自动部署」，勾选「代码更新时自动部署」，选择「推送到master时自动构建」</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcnzyy1qwuj30oc0he40e.jpg" alt=""></p>
<p>然后就显示网站创建成功了，coding会给一个奇奇怪怪的不太好看的访问地址，但是没事，我也不看它。。</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gco05nmsb4j31400c975s.jpg" alt=""></p>
<h2 id="1-3-添加SSH公钥"><a href="#1-3-添加SSH公钥" class="headerlink" title="1.3 添加SSH公钥"></a>1.3 添加SSH公钥</h2><p>这个就不具体说咋创建了，创建过的复制出来就好了</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gco0fd44w5j308v01vwek.jpg" alt=""></p>
<p>回到Coding，右上角进入「个人设置」-「SSH公钥」-「新增公钥」，把刚刚的公钥复制进去，然后勾选「永久有效」！！！</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gco0gwosxij30x90gy771.jpg" alt=""></p>
<p>然后终端输入<code>ssh -T git@e.coding.net</code>，看看是不是通过了，如果显示<code>xxx，你好，你已经通过 SSH 协议认证 Coding.net 服务，这是一个个人公钥.</code>那么就可以进入下一步啦</p>
<h1 id="2-域名"><a href="#2-域名" class="headerlink" title="2 域名"></a>2 域名</h1><p>一直都没买自己的域名来着，<a href="https://cloud.tencent.com/" target="_blank" rel="noopener">腾讯云</a>，因为腾讯云买域名附带「域名云解析」服务，安全访问快速多节点多线路，看起来很靠谱0.0</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gco103zj6kj30wc09u414.jpg" alt=""></p>
<p>输入自己想要的搜一下，不过不知道新域名的收录效果咋样，先试试水吧反正首年很便宜0.0</p>
<p>买完之后进入<a href="https://console.cloud.tencent.com/domain" target="_blank" rel="noopener">「控制台」</a>，然后就是实名认证等待审核之类的了</p>
<p>然后接下来状态出现了「域名 DNS 未修改」这样的问题，如果DNS服务器不正确的话解析是没法生效的，但是等我看完<a href="https://cloud.tencent.com/document/product/302/5518" target="_blank" rel="noopener">官方文档：修改域名DNS服务器</a>之后，啥都没干一刷新解析状态就变成正常啦～诶嘿那继续</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gco1nx5jboj30xl02w74l.jpg" alt=""></p>
<h1 id="3-域名解析"><a href="#3-域名解析" class="headerlink" title="3 域名解析"></a>3 域名解析</h1><p>点击上图的「解析」选项，然后开始添加记录</p>
<h2 id="3-1-解析一"><a href="#3-1-解析一" class="headerlink" title="3.1 解析一"></a>3.1 解析一</h2><p>先添加github-pages的：</p>
<p>主机记录选www（主机记录就是域名前缀），记录类型选CNAME（将一个域名指向另一个域名），线路选默认（境外访问走github，境内走coding，但是coding似乎没那么靠谱。。所以github这项填默认吧），记录值就写github-pages的那个博客地址，TTL就600（地方DNS缓存域名记录信息的时间，默认的600s最常用，不用修改）</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gco3046vvfj30vg05sdgg.jpg" alt=""></p>
<h2 id="3-2-解析二"><a href="#3-2-解析二" class="headerlink" title="3.2 解析二"></a>3.2 解析二</h2><p>然后ping一下原来的github域名，可以得到一个ip，复制下来</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gco20nxz3gj30cq020dg1.jpg" alt=""></p>
<p>添加第二条记录，主机记录选<code>@</code>，记录类型选A，线路默认，记录值写刚刚得到的那个ip，TTL还是600s</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gco32p9av0j30ve01r74c.jpg" alt=""></p>
<p>过了几天我又ping了一下这个域名，然后那个ip不一样了，，我就又加了一条解析0.0</p>
<h2 id="3-3-解析三-四"><a href="#3-3-解析三-四" class="headerlink" title="3.3 解析三/四"></a>3.3 解析三/四</h2><p>同理添加coding的解析记录，也是两条，线路类型都选境内（这样境内访问就走Coding的仓库啦）</p>
<p>但是看了其他一些教程coding的线路选择写的是默认，因为coding不太稳定之类的，我也不太清楚，所以此处先填「默认」，目前使用还未出现问题</p>
<p>ping codingpage给的奇奇怪怪得链接</p>
<p>最后的解析是这样哒：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcts93nicyj30og07zmxt.jpg" alt=""></p>
<h1 id="4-域名设置"><a href="#4-域名设置" class="headerlink" title="4 域名设置"></a>4 域名设置</h1><h2 id="4-1-Github设置"><a href="#4-1-Github设置" class="headerlink" title="4.1 Github设置"></a>4.1 Github设置</h2><p>在「Settings」里下拉到「GitHub Pages」部分，填好腾讯云那个新域名，然后勾选https，save</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gco27kap1tj30ky0ho40x.jpg" alt=""></p>
<p>之后上面的状态提示就会改变：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gco2ac4mbsj30ky0ec408.jpg" alt=""></p>
<h2 id="4-2-Coding设置"><a href="#4-2-Coding设置" class="headerlink" title="4.2 Coding设置"></a>4.2 Coding设置</h2><p>在「静态网站」页面点击右上角的设置，就可以进入「修改静态网站」页面</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gco2k6q36nj314006ht9o.jpg" alt=""></p>
<p>下拉，在「自定义域名」部分绑定新域名，勾选https</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gco2lk2xhdj30j10bjjss.jpg" alt=""></p>
<div class="note warning"><p>这里补充一个设置：如果直接按照上面这样的流程下来，证书状态那一项是会出错的，需要先把关于github的解析记录都暂停，然后申请SSL证书（很快就有结果），申请成功后勾选https，这样证书状态才会显示为下面的绿色正常</p></div>

<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcrk9wh0gfj30ou02cglu.jpg" alt=""></p>
<h2 id="4-3-CNAME"><a href="#4-3-CNAME" class="headerlink" title="4.3 CNAME"></a>4.3 CNAME</h2><p>💡4.3节为3.29补充</p>
<p>上一步中可见coding是可以绑定自己的新域名的，但是github没有绑定域名这个选项，所以需要手动绑定，如果没有绑定的话就会产生下面这样的状况：</p>
<blockquote>
<p>每次<code>hexo d</code>之后在「Settings」里下拉到「GitHub Pages」部分，那个site提示会变回<code>xxx.github.io</code>，需要重新手动再填新域名0.0<br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gco2ac4mbsj30ky0ec408.jpg" alt=""></p>
</blockquote>
<p>手动绑定的操作如下：</p>
<p><code>cd source</code>在source目录下<code>touch CNAME</code>新建一个<code>CNAME</code>文件</p>
<p>直接输入新域名：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdaujqbqh3j30e302ot8y.jpg" alt=""></p>
<p>然后在站点配置文件（根目录下）中的不渲染的文件中加上这个文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">skip_render:</span><br><span class="line">  - CNAME</span><br></pre></td></tr></table></figure>

<h1 id="5-站点配置文件"><a href="#5-站点配置文件" class="headerlink" title="5 站点配置文件"></a>5 站点配置文件</h1><p>进博客根目录把站点配置文件（根目录下的<code>_config.yml</code>）的<code>deploy</code>部分改改，加一条coding的：</p>
<p>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git@e.coding.net:team-name&#x2F;project-name.git</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gco4kp3ru9j30f704rgmb.jpg" alt=""></p>
<p>然后就是<code>hexo clean &amp;&amp; hexo g &amp;&amp; sudo hexo d</code>了</p>
<p>然后万一出现了<code>Error: git@e.coding.net: Permission denied (publickey).fatal: Could not read from remote repository.</code>这样的问题QAQ，或许是站点配置文件里deploy没写对，或许是ssh没链接好，坑了我好久好久唉ORZ</p>
<h1 id="6-其他"><a href="#6-其他" class="headerlink" title="6 其他"></a>6 其他</h1><p>可以用<a href="https://help.github.com/en/github/working-with-github-pages/managing-a-custom-domain-for-your-github-pages-site" target="_blank" rel="noopener">dig命令</a>查询一下是否解析成功了</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gd0r9nbqnzj30jg05p0tw.jpg" alt=""></p>
<p>请求<code>leflacon.top</code>这个域名的时候，要先去DNS服务器把这个通俗的名字转化成一个ip地址，然后就得到了<code>124.156.193.111</code>（就是之前ping coding给的链接 得到的ip地址）<code>A</code>表示地址记录（域名-&gt;地址）</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gd0rpxgdzjj30db020aa7.jpg" alt=""></p>
<p>最后，如果有用leancloud之类的，不要忘了在安全域名里加上新域名～</p>
<hr>
<p>SEO优化什么的之后再补吧，不晓得会出什么问题先这样，，至少现在博客的访问速度和之前相比似乎快了很多（也可能是我的心理作用hhhhhh）！世界晚安！</p>
<p>3.12更新</p>
<p>在站长工具测了一下速度，之前的github.io和现在的.top的速度对比还是非常特别很明显的（并不是我的心理作用hhhhh）真实的快了四倍(((o(*ﾟ▽ﾟ*)o)))</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcrkgb59cbj30xb0dzaeq.jpg" alt=""></p>
<p>目前出现问题的有评分小星星，就加载不出来不知道什么原因。。</p>
<p>还有一个问题是busuanzi的计数清零了，找了老半天据说可以通过在官网注册登录来实现数据转移，但是官网现在关闭注册了ORZ，还是有一丢丢心痛的毕竟这一年也有好几万了</p>
<p>此外google可以正常收录，那么就先这样啦</p>
<p>3.16更新</p>
<p>发现看板娘似乎不会说话了，之前调用的是一言的API看板娘说个没完的0.0，然后去<a href="https://developer.hitokoto.cn/sentence/#%E7%AE%80%E4%BB%8B" target="_blank" rel="noopener">一言的官方文档</a>看了一下，我之前的那个是初版接口，换成v1稳定接口<code>v1.hitokoto.cn</code>就好啦，v1的线路是全球的</p>
<p>3.18更新</p>
<div class="note warning"><p>还是要把站点配置文件的url改成新域名</p></div>

<p>这样才能保证sitemap里的url和主域名的一致性，不然sitemap里的链接提交不了，也就是说之前在百度和google提交的站点都要重做，，，嗯就是这样，之前的都废弃了</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcxxuorg5lj30rg04xmxp.jpg" alt=""></p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcxxuzpb80j30qy0bf3zj.jpg" alt=""></p>
<p>3.26更新</p>
<p>百度的收录速度着实比google慢很多很多，百度的sitemap提交后一直是等待状态，看了下网上的讨论这个要多久好像看百度的心情，那就先放着不管了（我自己又手动提交了一遍所有链接ORZ）</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gd7f36shdaj30r9049t95.jpg" alt=""></p>
<p>3.27更新</p>
<p>昨天在访问友链的博客的时候发现有些博客不能访问，会报下图这样的错误，有点庆幸及时搞了双线部署（等coding崩的时候我就笑不出来了hhhhhh_(:з」∠)_</p>
<p>似乎是神奇的BGP FlowSpec：<a href="https://www.zhihu.com/question/382718053" target="_blank" rel="noopener">如何看待2020 年 3 月 26 日 GitHub 疑似遭受中间人攻击？</a></p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gd7f59schdj30l10cnwew.jpg" alt=""></p>
<hr>
<p>参考教程：</p>
<ul>
<li>%%%高一大佬➡️<a href="https://royce2003.top/posts/13128/" target="_blank" rel="noopener">Coding+GitHub双线部署</a></li>
<li><a href="https://help.coding.net/docs/project/features/ssh.html?_ga=2.244048389.1663542333.1583759188-2136734544.1583759188" target="_blank" rel="noopener">配置 SSH 公钥</a></li>
<li><a href="https://tding.top/archives/e09249d2.html" target="_blank" rel="noopener">Hexo 博客部署到 Coding</a></li>
<li><a href="https://support.dnsimple.com/categories/dns/" target="_blank" rel="noopener">DNS articles</a>➡️一个神仙文档，有关DNS的知识</li>
</ul>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+NexT主题下的一些功能优化</title>
    <url>/4f06b9da/</url>
    <content><![CDATA[<p>填一点坑，好多坑没填啊QAQ</p>
<p>最近在Royce的博客里了解到了还有「双线部署」这种好东西，我记得我当时好像传过coding但是报错了，后来就没有后来了，唔有空的时候去试试（不然有时有打开博客的速度是不咋滴，比起花里胡哨的东西，，还是速度比较实在哇QAQ）</p>
<a id="more"></a>

<hr>
<h1 id="0-一些本博客的效果"><a href="#0-一些本博客的效果" class="headerlink" title="0 一些本博客的效果"></a>0 一些本博客的效果</h1><p>大概这几个经常被问到，整理出来⬇️</p>
<blockquote>
<p>博客的评论邮件回复系统是怎么实现的？</p>
</blockquote>
<p>参考自这个教程：<a href="http://www.zhaojun.im/hexo-valine-admin/" target="_blank" rel="noopener">Hexo 优化 — Valine 扩展之邮件通知</a>，valine评论系统+leancloud云引擎，nice！</p>
<blockquote>
<p>博客下雪的效果是怎么实现的？</p>
</blockquote>
<p>又是一个厉害的教程：<a href="https://www.yaxi.net/2016-12-28/1211.html" target="_blank" rel="noopener">JQuery+Html5实现超真实3D雪花飞舞特效</a></p>
<p>这是我自己部署这个的时候遇到的一点小问题及解决办法：<a href="https://leflacon.github.io/128c2cae/" target="_blank" rel="noopener">Mixed Content ”The page at ‘xxxdomain’ was loaded over HTTPS, but requested an insecure script ‘xxx’.This request has been blocked.the content must be served over HTTPS“ 的解决办法</a></p>
<blockquote>
<p>图片点击放大查看是怎么实现的？</p>
</blockquote>
<p>一个叫「fancybox」的插件</p>
<p>还有一个没人问但是我特别想安利的哈哈哈哈哈哈，macOS下的「iPic图床」太方便啦～给制作人员疯狂打call！</p>
<h1 id="1-标签云"><a href="#1-标签云" class="headerlink" title="1 标签云"></a>1 标签云</h1><p>参考自Royce的博客～</p>
<p>github项目地址：<a href="https://github.com/MikeCoder/hexo-tag-cloud" target="_blank" rel="noopener">https://github.com/MikeCoder/hexo-tag-cloud</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>先装上这个插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-cloud@^2.1.* --save</span><br></pre></td></tr></table></figure>

<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>不同模版方法不同，我是NexT主题（也就是swig）</p>
<p>在<code>themes/next/layout/_custom/sidebar.swig</code>文件里添加这么一段话，这个文件里我之前放的是<a href="https://leflacon.github.io/783cca3a" target="_blank" rel="noopener">「revolvermaps小地球」</a>，就会显示下图这样的效果</p>
<img src="https://tva1.sinaimg.cn/large/0082zybply1gbzeeqorhyj307d0hfgn8.jpg" width = "250px">

<p>现在改成下面这段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if site.tags.length &gt; 1 %&#125;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; charset&#x3D;&quot;utf-8&quot; src&#x3D;&quot;&#x2F;js&#x2F;tagcloud.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; charset&#x3D;&quot;utf-8&quot; src&#x3D;&quot;&#x2F;js&#x2F;tagcanvas.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;widget-wrap&quot;&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;myCanvasContainer&quot; class&#x3D;&quot;widget tagcloud&quot;&gt;</span><br><span class="line">        &lt;canvas width&#x3D;&quot;250&quot; height&#x3D;&quot;250&quot; id&#x3D;&quot;resCanvas&quot; style&#x3D;&quot;width&#x3D;100%&quot;&gt;</span><br><span class="line">            &#123;&#123; list_tags() &#125;&#125;</span><br><span class="line">        &lt;&#x2F;canvas&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>然后在站点配置文件<code>_config.yml</code>（根目录下的那个）里加上一些设置，随便照自己喜欢设置就好啦～</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># hexo-tag-cloud</span><br><span class="line">tag_cloud:</span><br><span class="line">	textFont: Trebuchet MS, Helvetica</span><br><span class="line">	textColor: &#39;#535257&#39;</span><br><span class="line">	textHeight: 25</span><br><span class="line">	outlineColor: &#39;#d5dded&#39;</span><br><span class="line">	maxSpeed: 0.4</span><br></pre></td></tr></table></figure>

<h1 id="2-评分小星星"><a href="#2-评分小星星" class="headerlink" title="2 评分小星星"></a>2 评分小星星</h1><p>感觉蛮可爱的就加了0.0</p>
<p>在主题配置文件里配置：<code>themes/next/_config.yml</code>，搜索<code>rating</code>，有这么一段，把false改成true，然后照着注释说的去这个网站注册一下<a href="https://widgetpack.com" target="_blank" rel="noopener">https://widgetpack.com</a>获取一个id然后填进去</p>
<img src="https://tva1.sinaimg.cn/large/0082zybply1gbzeszgssxj30lq05075c.jpg" width = "600px">

<p>填一下博客的基本信息</p>
<img src="https://tva1.sinaimg.cn/large/0082zybply1gbzewt18fqj30c20adwf0.jpg" width = "350px">

<p>然后进去之后在左上角就可以找到id，填到主题配置文件里</p>
<p>然后在「侧栏」-「rating」-「setting」里可以设置一些东西</p>
<p>比如下图就是设置记录方式，如果选择「social」，那么必须通过下面那些社交登陆啥的，感觉不方便呐，所以选择「ip地址」或者「cookie」</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbzf2840o5j30i005oq4q.jpg" alt=""></p>
<p>然后在「侧栏」-「site」-「setting」里勾选「Private」选项</p>
<p>然后如果还想加点什么的话，就去<code>themes/next/layout/_macro/post.swig</code>这个里面直接改</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbzfe7tc2qj30km031aak.jpg" alt=""></p>
<h1 id="3-添加版权声明"><a href="#3-添加版权声明" class="headerlink" title="3 添加版权声明"></a>3 添加版权声明</h1><p>在主题配置文件<code>themes/next/_config.yml</code>里搜索「copyright」，然后把对应的值改成true就好啦</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 flag</title>
    <url>/2020/</url>
    <content><![CDATA[<center>

<p>来写一年一度的flag，但最近写着写着思绪很容易发散，倒也没什么不好，那就随我写吧。</p>
</center>

<center><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaevtiafdwj30dw0dwjue.jpg" width = "300px"></center>

<a id="more"></a>

<hr>
<p>似乎并不经常写东西，日记都是灵光一现想到啥写啥的流水账一般，也就是不会像应试作文一样有一个规整的主题之类的。但是还是要写，为了知道自己某个阶段在想什么，回过头看时会发现惊奇的变化。不过，不可以变成“新年决心症候群”呐。</p>
<p><font size="5" color=#a9a9ef>1.身体健康</font></p>
<p>希望可以早点和疾病握手言和。</p>
<blockquote>
<p>倒也不害怕疾病，因为生病没什么，只要灵魂不生病，就一直是有药可医的。就算得了绝症，也是因为先知道那种病是绝症，那种病的死亡率是百分之一百，才会在灵魂里深深相信自己真的没救了，而不是因为生病了才觉得自己没救了。<br>——19.12.05</p>
</blockquote>
<p>感谢疾病，我觉得人喜欢思考的时候有三，一是生病的时候，二是看了有益的书的时候，三是个秘密。总之，是需要适时的脆弱的。</p>
<p><font size="5" color=#a9a9ef>2.不挂科</font></p>
<p>19年不挂科的flag达成了，那么20年的flag依然是不挂科。</p>
<p><font size="5" color=#a9a9ef>3.实习</font></p>
<p>有幸得到了一个前辈的指点，并且也获得了一点方向。要尽早搞完市创腾出手来。</p>
<p>但是似乎是太过于走一步算一步了，我的人不是规整的拼装起来的，而是随机游走在各个流水线上然后胡乱就出来了的。一段人生经历和另一段似乎并不能依据某种联系拼接起来，一个决定和另一个决定之间也不相干，不知道以后的自己看见这段话会怎么想。</p>
<p><font size="5" color=#a9a9ef>4.项目</font></p>
<p>一直拖啊拖啊拖，加油啊我。去年的flag是“佛系搞创”，真的是很佛系了。。</p>
<p><font size="5" color=#a9a9ef>5.好好更博</font></p>
<blockquote>
<p>至于博客，建立博客的初衷其实只是觉得好玩，并且非常炫酷，但是之后在更博的过程中才觉得，这是一种我与世界建立联系的方式，以此证明自己存在过。并且如果有一点经验主义的东西，或是一点拙劣的思想，能够对这个世界上的某些人产生一点极小极小的影响或事帮助，就再好不过了。<br>然而，“渴望存在被证明”的一部分原因是因为害怕，害怕某一天离开人世间，而不留一点痕迹，我觉得21岁的我尚无法理解死亡，并且惧怕它。<br>此刻能想到的关于死亡的最美妙的境界就是：“我一个人坐在炉边烤火，火萎了，我也走了。”（似乎是这么背的，不太记得了），总之是一种看遍了华枝春满天心月圆后的境界，但现在的我无疑还是个小屁孩。<br>——19.12.01</p>
</blockquote>
<p>更博的想法和几个月前并没有太大出入，对于死亡也依旧惧怕，尽管和爸爸谈了死亡的问题但是爸爸没能说服我!?(･_･;?。</p>
<p>以前是会沉溺于访问量的数字带来的成就感的（虽然现在也会hhhhh），但是渐渐明白在这个过程中收获最多的是我自己。如果是正确的事情的话，就做下去吧。</p>
<p><font size="5" color=#a9a9ef>6.学日语学日语学日语</font></p>
<p>要努力好好学啊，要多读呀。跟小宝随口约定了考级的事情TAT，不知道这样乱学能不能到那一步，无论如何，加油吧！</p>
<p>不过！日语打字也太累了啊啊啊ORZ，音调什么的也完全没有头绪，背单词emmm虽然现在还是靠中文和句子在背单词，但是总会有靠日语词典背单词的那天的0.0，或许吧。</p>
<p>“このきもちは、君のここのに伝えるのかな。”年前聚会小宝还说我这句话念的不错哈哈哈。唉说到年前聚会没想到是今年假期第一次也是唯一一次，回家第二天临时起意约呆呆去星巴克学习，真就是临时起意，不然肯定是约出去吃吃喝喝玩玩了///，然后小宝也刚好前一天回家，大家就真一起学习了。疫情来的太来势汹汹了，日语书也压根没想着带回家。</p>
<p>呐还有，日语里的「小馒头」，ボウロ，中文发音跟菠萝好像hhhhhh，太可爱啦///</p>
<p><font size="5" color=#a9a9ef>7.logic pro x</font></p>
<p>去年说要好好玩logic pro x的，但是并没有时间，或者更本质的说没有一份“闲情”。会讨厌这样的自己啊，拥有一点点扒谱的天赋却什么也没有做。上帝给我开了一扇门，我“哗啦”把它锁上啦。</p>
<blockquote>
<p>现在想小时候很后悔的一件事情就是没有好好学钢琴。<br>——19.12.06</p>
</blockquote>
<p><font size="5" color=#a9a9ef>8.看书</font></p>
<p>19年立的关于看书的flag是这么写的：<strong>“多看书，18年看的书好少啊，怀念高二高三夜自修和某炮偷偷看书的快乐时光@Charlotte”</strong>。我可真是个大猪蹄子，气死我辽，那20年的flag就这么写：“多看书，19年看的书好少啊，怀念高二高三夜自修和某炮偷偷看书的快乐时光@Charlotte”！</p>
<blockquote>
<p>有些思想是在成长过程中潜移默化形成的，在我的三观中有一些认定了不可更改的东西。但是在某些时候它是原则性的底线，在某些时候却可能成为一种阻碍。但如果说哪里可以改改什么的话，不妨修正试试。<br>——20.01.11</p>
</blockquote>
<p><font size="5" color=#a9a9ef>9.变得成熟</font></p>
<p>最近又看了一遍《麦田里的守望者》，以前看的时候并不能很好的读懂他，只是当个故事囫囵一遍。“一个不成熟的人的标志是他愿意为了某个理由而轰轰烈烈地死去，而一个成熟的人的标志是他愿意为了某个理由谦恭的活下去。”</p>
<p>我一定是个任性的不成熟的人，至少近年来都是。无论是心智、行为还是长相（，，或许吧┬─┬﻿ ノ( ゜-゜ノ)）。喜欢真实，并且认定了的喜欢真实。以至于接受不了很多“虚伪”“恶劣”的事情，但那可能只是某种合理且正常的现象，因为我只是不喜欢，却找不到理由来反驳。近年来也试图和这种情绪慢慢和解。还是很喜欢《杰克逊高地》末尾那句：“不知原谅什么，诚觉世事尽可原谅”。我羡慕那样的想法，但这个想法现在还没有在我心里自然而然的生长出来。</p>
<p><font size="5" color=#a9a9ef>10.在夏天前有马甲线</font></p>
<p>万一就练出来了呢？加油吧。但是，，，</p>
<img src="https://tva1.sinaimg.cn/large/0082zybply1gbnwem01tdj30m80gu74w.jpg" width="200">


<hr>
<p>其他一些东西，不能被立做是flag，胡乱的写一写，都是好事。</p>
<p><font size="5" color=#a9a9ef>喜欢超越妹妹</font></p>
<p>诶嘿///</p>
<p><font size="5" color=#a9a9ef>做好吃的</font></p>
<p>19年买了两个锅，一开始买的小壶就是烧烧粥还有各种养生的东西，但是后来我实在是太想煮泡面和螺蛳粉了hhhhhhh，就买了第二个泡面锅。</p>
<p>顺便终于发现了煮溏心蛋的秘籍，满足了小时候的梦想hhhhhh。</p>
<p>说到做饭这种事情，最近我爸一直怂恿我看抖音，因为他说我很多生活常识都不知道，抖音上有很多生活常识。比如糊了的锅底怎么洗。。我觉得这些事情遇到了百度一下就好了嘛。。我觉得爸爸只是沉迷于抖音生产的标准化的多巴胺。。但是我打雀魂也是这个道理，沉迷胡牌和看人放铳生产的标准化的多巴胺。。嘛不过，爸爸看抖音还发展了一下制作各种黑暗料理的兴趣，不坏。</p>
<p>但我之前对抖音是有偏见的，现在倒不那么认为。“抖音是否正在毁掉年轻人”之类的问题是把抖音一棒子定论了，不好，虽然我并不清楚抖音对年轻人如何，因为对这个产品并不了解，但是我更愿意相信的是，一个东西好还是不好，利或是弊，还是要看使用者怎么来使用它。说到这个又想到前两天看的《卢旺达饭店》里，中国生产的砍刀，可以割成熟的香蕉，也可以让一个无辜的民族血流成河。我们该要求父母什么呢，我们不该要求父母什么。他们靠着自己的人生经验活到那个岁数，把他们的孩子抚养长大，对他们来说，他们的人生经验就是行得通的经验，是已知下最合理的行动准则，尽管时代变了。我该自己去摸索我们这个时代的人生存下去的经验。</p>
<p><font size="5" color=#a9a9ef>关于爱情？</font></p>
<p>我也不清楚爱情对我来说究竟意味着什么，可能是一个人习惯了，所以有时候夜晚走回寝室的路会觉得好冷好孤独，但是心情明亮的时候，就一点都不畏冷了。</p>
<blockquote>
<p>我发现我这个人很奇怪，要是有人喜欢我的话我就有很大很大可能性会喜欢上他（这个可能性是和生命中的芸芸众生相比），但是如果我觉得他不喜欢我，我马上就不那么喜欢他了，然后就不在意了。<br>但前几天呆呆给我出了道心理学的题“什么造就了友谊和吸引？”我做了才发现，这确实是有依据的，其中一条理论就是：“喜欢那些喜欢我们的人”。<br>——19.12.30</p>
</blockquote>
<p>“人一生会遇到2920万人，两个人相爱的概率是0.000049，所以你不爱我，我不怪你。”——来自高中记得乱七八糟的句子哈哈哈哈哈，还是和以前一样，有些句子吧你会觉得它不理性，没什么道理可言，但是还是会觉得它美，又美又好，十分美好。</p>
<p>如果有一天我真的非常喜欢哪个男孩子的话，我想我会告诉他的。告诉他我喜欢他，他很好很优秀，我喜欢他在发光的可爱样子。但是不是说非得和他在一起，因为我知道我还有许多许多不足的地方，希望自己努力有朝一日可以配得上想象中的那个身影。虽然我知道爱情是可以试错的，但是我还是希望的是有一天我能下定决心对一个人说“答案很长，我得用一生去回答”。好像过于理想化了///，不过先想想嘛。许多东西是要一步步建立的，比如两个人之间不是先建立了十足的信任才决定走近彼此的，而是靠时间与距离，十足的信任是在其中一点一点被建立起来的。</p>
<p>被爱情这种虚无缥缈的事情灌醉的时候就会想，在那个人出现之前，我的人生中还未曾出现过这么这么可爱的一个人。若他不再出现在往后的人生中，我只能就着回忆感叹“纵我阅人，再多无人似你”，该有多可惜。</p>
<p><font size="5" color=#a9a9ef>世界这么大，我想去看看</font></p>
<p>19.12.06拍的，后两张是一棵树，转了个角度就是另一副姿态了，多么神奇啊。</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbnw249q29j31400u0hdt.jpg" width="260"><img src="https://tva1.sinaimg.cn/large/0082zybply1gbnw2btdd3j31400u0hdt.jpg" width="260"><img src="https://tva1.sinaimg.cn/large/0082zybply1gbnw2gbx60j31400u0kjl.jpg" width="260"></p>
<p>下面这段写的是冬天遇到的阳光，因为我们宿舍不是向阳面的（我分不清东南西北。。），但是竟然可以通过对面7B楼的窗户获得三分钟反射的太阳光，唉太美好了。两张图是同一时刻不同一天拍的，宿舍窗户脏糊糊的0.0。</p>
<blockquote>
<p>好准时啊，3:44，她出现了:)<br>拿了束花准备摆拍，摆好了也就过了两分钟，她走了:(<br>人生有太多惊艳与错过，always。<br>——19.12.27</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbnw9ghlwbj30gm0iats7.jpg" width="200"><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9jgwm1fc2j30rt0rt177.jpg" width="200"></p>
<p>还有一场期末的时候突发奇想的「随机之旅」：在寒假的某一天，坐车到天塔，然后展开一场随机之旅。记录这一切就靠选一个随机数拍下指南针那个角度的照片。坐上下一辆来的公交车，上车后看到一个顺眼的站名下车，然后找一家顺眼的小店吃饭，买一个顺眼的东西回去……会发生什么呢，who knows……</p>
<p>本来觉得一个人有点无聊，都和呆呆说好了，期末考完后找一天我俩一起云同步，我在天津的某个名字顺眼的公交车站下车之后她就在北京的下一站下。最终还是咕咕咕了，忘了为啥咕咕咕了。现在也不可能出去了，不知道今年这个小小的随机旅行能不能实现。至少此刻，是会有点期待那一路上能看见什么遇见什么的。</p>
<hr>
<p>最后，我就是太懒太懒啦！行动力极其低下啊，有些事情明白却不想改，有时候又会有各种动力催促着我，就这么稀里糊涂的又过了一年了_(:з」∠) </p>
<hr>
<center><font size="12" color=#5959ff>J</font><font size="12" color=#a5b2ff>’</font><font size="8" color=#8888fd>a</font><font size="8" color=#7762fd>i</font><font size="8" color=#f1a8ce>m</font><font size="8" color=#a97afd>e </font><font size="8" color=#a7a7f5>m</font><font size="8" color=#628dfd>a </font><font size="8" color=#6363ff>v</font><font size="8" color=#8e64ff>i</font><font size="8" color=#ffafc7>e</font></center>

<hr>
]]></content>
      <categories>
        <category>love&amp;peace</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>《信息检索》一个简单的古诗词检索系统（双词索引）</title>
    <url>/87c5ccc3/</url>
    <content><![CDATA[<p>前排放效果图（UI很难看啦，但是tkinter好<s>偷懒</s>简洁的嘛，几行就写完了）</p>
<table><tr>
<td><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbkpcz5plrj30av04hgls.jpg" width="250"></td>
<td><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbkpd4xzewj30b0047mxe.jpg" width="250"></td>
<td><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbkpdc89mdj309x040jrn.jpg" width="250"></td>
</tr></table>

<a id="more"></a>

<table><tr>
<td><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbkpeui6jkj30az0fkdh5.jpg" width="250"></td>
<td><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbkpf7udmmj30b10cn0tv.jpg" width="250"></td>
<td><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbkpfed861j30b20d0gmb.jpg" width="250"></td>
</tr></table>

<p>整个数据集共311828首古诗词构建索引共花费8分09秒，打开构建好的索引需要30秒。不过好像有个bug，年代久远忘的差不多了，就不再考证了</p>
<h1 id="0-要求"><a href="#0-要求" class="headerlink" title="0 要求"></a>0 要求</h1><p>要求是这样的：</p>
<img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbko4nk1vrj313x0u0jz8.jpg" width="400">

<p><strong>支持短语查询，支持与、或、非操作，构建复合索引（双词+位置）</strong></p>
<p>原数据格式：都删掉了懒得再去下载了，总之数据是很干净的漂漂亮亮的json格式的字典，nice！</p>
<h1 id="1-思路"><a href="#1-思路" class="headerlink" title="1 思路"></a>1 思路</h1><p>从当时写的作业文档里直接搬运了，代码在<a href="https://github.com/LeFlacon/Simple-Python-Practice/blob/master/poem_search.py" target="_blank" rel="noopener">这里٩(˃̶͈̀௰˂̶͈́)و</a></p>
<h2 id="1-1-索引"><a href="#1-1-索引" class="headerlink" title="1.1 索引"></a>1.1 索引</h2><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><p>建立索引前先确定索引结构。这里建立两个索引，一个用于存字的位置，一个用于存双词</p>
<p>双词索引的存储格式如下，先用词典存单字，再用词典存以这个字为前缀的词，最后用列表存这个词出现的古诗编号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;每&quot;: &#123;</span><br><span class="line">        &quot;每勞書&quot;: [</span><br><span class="line">            308302</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;毒&quot;: &#123;</span><br><span class="line">        &quot;毒匪&quot;: [</span><br><span class="line">            875</span><br><span class="line">        ],</span><br><span class="line">        &quot;毒萬蜂&quot;: [</span><br><span class="line">            1545</span><br><span class="line">        ],</span><br><span class="line">        &quot;毒發&quot;: [</span><br><span class="line">            2548,</span><br><span class="line">            65517</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>位置索引的存储格式如下，先用词典存单个的汉字，再用词典存包含这个汉字的古诗的编号，最后存这个字在诗中出现的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;上&quot;: &#123;</span><br><span class="line">        &quot;1&quot;: [</span><br><span class="line">            27</span><br><span class="line">        ],</span><br><span class="line">        &quot;3&quot;: [</span><br><span class="line">            38</span><br><span class="line">        ],</span><br><span class="line">        &quot;8&quot;: [</span><br><span class="line">            42</span><br><span class="line">        ],</span><br><span class="line">        &quot;10&quot;: [</span><br><span class="line">            33</span><br><span class="line">        ],</span><br><span class="line">        &quot;12&quot;: [</span><br><span class="line">            64</span><br><span class="line">        ],</span><br><span class="line">        &quot;15&quot;: [</span><br><span class="line">            1,</span><br><span class="line">            4</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是一些为了便于输出结果存的索引了，不展开说明</p>
<h3 id="构建索引"><a href="#构建索引" class="headerlink" title="构建索引"></a>构建索引</h3><p>接下来就是构建索引。先利用结巴分词对诗句进行划分，如果得到的结果是一个字就跳过，如否则就把这个词加入到第一个字对应的字典中，并记录古诗编号。这样每个字后面都会存有所有以这个字为前缀的词</p>
<p>在构建位置索引时，一个字一个字读取诗句字符串，并保存某个字在某首诗中出现的位置。最后对两个索引按照发音顺序排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def create_index():</span><br><span class="line">    path &#x3D; file_path</span><br><span class="line">    filenames &#x3D; os.listdir(path)</span><br><span class="line">    shuangci_index &#x3D; &#123;&#125;</span><br><span class="line">    weizhi_index &#x3D; &#123;&#125;</span><br><span class="line">    msg_poet &#x3D; []</span><br><span class="line">    ji &#x3D; 0</span><br><span class="line">    for filename in filenames:</span><br><span class="line">        # print(filename)</span><br><span class="line">        name &#x3D; os.path.split(filename)[1].split(&quot;.&quot;)</span><br><span class="line">        if name[0] &#x3D;&#x3D; &#39;authors&#39;:</span><br><span class="line">            continue</span><br><span class="line">        else:</span><br><span class="line">            poet_json &#x3D; get_poet(filename)</span><br><span class="line">            for poet in poet_json:</span><br><span class="line">                author &#x3D; poet[&#39;author&#39;]</span><br><span class="line">                paragragh &#x3D; poet[&#39;paragraphs&#39;]</span><br><span class="line">                title &#x3D; poet[&#39;title&#39;]</span><br><span class="line">                # 储存古诗词信息</span><br><span class="line">                poet_dict &#x3D; &#123;&#125;</span><br><span class="line">                poet_dict[&#39;title&#39;] &#x3D; title</span><br><span class="line">                poet_dict[&#39;author&#39;] &#x3D; author</span><br><span class="line">                poet_dict[&#39;paragragh&#39;] &#x3D; paragragh</span><br><span class="line">                msg_poet.append(poet_dict)</span><br><span class="line">                # 建立双词索引</span><br><span class="line">                hang &#x3D; len(paragragh)</span><br><span class="line">                paragraphs &#x3D; &#39;&#39;</span><br><span class="line">                for j in range(hang):</span><br><span class="line">                    paragraphs &#x3D; paragraphs + paragragh[j]</span><br><span class="line">                results &#x3D; list(jieba.cut_for_search(paragraphs))</span><br><span class="line">                # 去除停用词</span><br><span class="line">                final &#x3D; []</span><br><span class="line">                for word in results:</span><br><span class="line">                    if word not in STOPWORDS:</span><br><span class="line">                        final.append(word)</span><br><span class="line">                results &#x3D; final</span><br><span class="line">                for word in results:</span><br><span class="line">                    if len(word) &lt;&#x3D; 1:</span><br><span class="line">                        continue</span><br><span class="line">                    if word[0] not in shuangci_index:</span><br><span class="line">                        poet_list &#x3D; []</span><br><span class="line">                        poet_list.append(ji)</span><br><span class="line">                        shuangci_index[word[0]] &#x3D; &#123;&#125;</span><br><span class="line">                        shuangci_index[word[0]][word] &#x3D; poet_list</span><br><span class="line">                    else:</span><br><span class="line">                        if word not in shuangci_index[word[0]]:</span><br><span class="line">                            poet_list &#x3D; []</span><br><span class="line">                            poet_list.append(ji)</span><br><span class="line">                            shuangci_index[word[0]][word] &#x3D; poet_list</span><br><span class="line">                        else:</span><br><span class="line">                            shuangci_index[word[0]][word].append(ji)</span><br><span class="line"></span><br><span class="line">                # 建立位置索引</span><br><span class="line">                for i in range(len(paragraphs)):</span><br><span class="line">                    if paragraphs[i] not in STOPWORDS:</span><br><span class="line">                        if paragraphs[i] not in weizhi_index:</span><br><span class="line">                            weizhi_list &#x3D; []</span><br><span class="line">                            weizhi_list.append(i)</span><br><span class="line">                            weizhi_index[paragraphs[i]] &#x3D; &#123;&#125;</span><br><span class="line">                            weizhi_index[paragraphs[i]][ji] &#x3D; weizhi_list</span><br><span class="line">                        else:</span><br><span class="line">                            if ji not in weizhi_index[paragraphs[i]]:</span><br><span class="line">                                weizhi_list &#x3D; []</span><br><span class="line">                                weizhi_list.append(i)</span><br><span class="line">                                weizhi_index[paragraphs[i]][ji] &#x3D; weizhi_list</span><br><span class="line">                            else:</span><br><span class="line">                                weizhi_index[paragraphs[i]][ji].append(i)</span><br><span class="line">                ji +&#x3D; 1</span><br><span class="line">    shuangci_index &#x3D; sort_list(shuangci_index)</span><br><span class="line">    write_to_file(shuangci_index, project_path + &#39;&#x2F;shuangci.json&#39;)</span><br><span class="line">    weizhi_index &#x3D; sort_list(weizhi_index)</span><br><span class="line">    write_to_file(weizhi_index, project_path + &#39;&#x2F;weizhi.json&#39;)</span><br><span class="line">    write_to_file(msg_poet, project_path + &#39;&#x2F;poet_msg.json&#39;)</span><br></pre></td></tr></table></figure>

<h2 id="1-2-搜索"><a href="#1-2-搜索" class="headerlink" title="1.2 搜索"></a>1.2 搜索</h2><h3 id="简繁体转换"><a href="#简繁体转换" class="headerlink" title="简繁体转换"></a>简繁体转换</h3><p>由于输入一般都是简体，而该古诗集中的数据都是繁体，因此需要把输入的简体转化为繁体再进行搜索，利用zhconv库的convert函数实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">text &#x3D; zhconv.convert(text, &#39;zh-tw&#39;)</span><br></pre></td></tr></table></figure>

<h3 id="单个短语查询"><a href="#单个短语查询" class="headerlink" title="单个短语查询"></a>单个短语查询</h3><p>先写一个可以查询单个字或短语的函数，作用是返回包含这个词或短语的古诗编号列表</p>
<p>一开始先判断输入的词是否为双词索引中存在的长的词，如“明月”，若双词索引中包含“明”，而下一级的字典中又包含“明月”，那么可以快速的直接返回包含“明月”的古诗编号集合</p>
<p>如果输入的字或词在双词索引中不存在，那么就需要通过位置索引来寻找。位置索引中的键为单个字，实现搜索存在某字的古诗是容易的</p>
<p>而如果是短语的话，就需要利用到位置信息。如果搜索“花间一壶酒”，那么如果“花”在编号为i的古诗中的位置是x，那么需要满足存在“间”在编号为i的古诗中的位置是i+1，“一”在编号为i的古诗中的位置是x+2，……，以此类推</p>
<p>因此首先对于每个字返回的列表集合，编写函数JiaoList实现两两合并，获得一个同时出现了所有字的文档集合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def JiaoList(list1, list2):</span><br><span class="line">    res &#x3D; []</span><br><span class="line">    for item in list1:</span><br><span class="line">        if item in list2:</span><br><span class="line">            res.append(item)</span><br><span class="line">    return res</span><br></pre></td></tr></table></figure>

<p>对于初步筛选出来的古诗集合，循环古诗i，在每次循环中初始集合为第一个字在文档i中出现的位置，然后利用下面的CheckList函数对位置进行判断，如果第二个字在文档i出现的某个位置恰好比第一个中的某个大1，说明这两个字在文档1中是连在一起的。以此类推返回所有位置列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def CheckList(list1, list2):</span><br><span class="line">    res &#x3D; []</span><br><span class="line">    for item1 in list1:</span><br><span class="line">        for item2 in list2:</span><br><span class="line">            if item2 &#x3D;&#x3D; item1 + 1:</span><br><span class="line">                res.append(item2)</span><br><span class="line">    return res</span><br></pre></td></tr></table></figure>

<p>如果短语中的所有字遍历完后位置列表不为空，那么说明存在这个短语，就在结果列表中加入古诗i，最终根据一个词或短语word返回包含该词或短语的所有古诗编号集合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def SearchWord(word):</span><br><span class="line">    if (len(word) &#x3D;&#x3D; 0):</span><br><span class="line">        return</span><br><span class="line">    print(word)</span><br><span class="line">    if (len(word) &gt; 1):</span><br><span class="line">        if word[0] in INDEX_SHUANGCI:</span><br><span class="line">            if word in INDEX_SHUANGCI[word[0]]:</span><br><span class="line">                return INDEX_SHUANGCI[word[0]][word]</span><br><span class="line">    if word[0] not in INDEX_WEIZHI:</span><br><span class="line">        return []</span><br><span class="line">    # poeta存储包含每个字的文档集</span><br><span class="line">    poeta &#x3D; INDEX_WEIZHI[word[0]].keys()</span><br><span class="line">    for i in range(1, len(word)):</span><br><span class="line">        zi &#x3D; word[i]</span><br><span class="line">        if zi not in INDEX_WEIZHI:</span><br><span class="line">            return []</span><br><span class="line">        poetb &#x3D; INDEX_WEIZHI[zi].keys()</span><br><span class="line">        poeta &#x3D; JiaoList(poeta, poetb)</span><br><span class="line">    if len(poeta) &#x3D;&#x3D; 0:</span><br><span class="line">        return []</span><br><span class="line">    res &#x3D; []</span><br><span class="line">    for poetid in poeta:</span><br><span class="line">        weizhia &#x3D; INDEX_WEIZHI[word[0]][poetid]</span><br><span class="line">        for i in range(1, len(word)):</span><br><span class="line">            weizhib &#x3D; INDEX_WEIZHI[word[i]][poetid]</span><br><span class="line">            weizhia &#x3D; CheckList(weizhia, weizhib)</span><br><span class="line">        if len(weizhia) !&#x3D; 0:</span><br><span class="line">            res.append(poetid)</span><br><span class="line">    # if len(res) &#x3D;&#x3D; 0:</span><br><span class="line">    # print(&quot;没有找到关于\&quot;&quot; + word + &quot;\&quot;的信息&quot;)</span><br><span class="line">    return res</span><br></pre></td></tr></table></figure>

<h3 id="与或非查询"><a href="#与或非查询" class="headerlink" title="与或非查询"></a>与或非查询</h3><p>“或搜索”是同时输入很多字或短语，返回包含其中任一的所有古诗集合。“或”的实现思路是对于每个字或短语得到的结果列表，因为只要包含其中一个就可以，所以相加即可，然后利用set实现去重</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def SearchOr():</span><br><span class="line">    text_or &#x3D; e1.get()</span><br><span class="line">    if (text_or &#x3D;&#x3D; &quot;&quot;):</span><br><span class="line">        print(&quot;输入为空！&quot;)</span><br><span class="line">        return</span><br><span class="line">    text_or &#x3D; zhconv.convert(text_or, &#39;zh-tw&#39;)</span><br><span class="line">    search_list &#x3D; list(text_or.split(&quot; &quot;))</span><br><span class="line">    print(&quot;您输入的词语集合为:&quot;, end&#x3D;&quot;&quot;)</span><br><span class="line">    print(search_list)</span><br><span class="line">    res &#x3D; []</span><br><span class="line">    for word in search_list:</span><br><span class="line">        poetlist &#x3D; SearchWord(word)</span><br><span class="line">        res &#x3D; res + poetlist</span><br><span class="line">    res &#x3D; set(res)</span><br><span class="line">    if len(res) &#x3D;&#x3D; 0:</span><br><span class="line">        print(&quot;没有找到关于\&quot;&quot; + text_or + &quot;\&quot;的信息&quot;)</span><br><span class="line">    return res</span><br></pre></td></tr></table></figure>

<p>“与搜索”是同时输入很多字或短语，返回同时包含所有词的古诗集合。与的实现思路是，对于每个字或短语返回的结果集，因为要包含所有，所以求交集即可，利用set去重</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def SearchAnd():</span><br><span class="line">    text_and &#x3D; e2.get()</span><br><span class="line">    if (text_and &#x3D;&#x3D; &quot;&quot;):</span><br><span class="line">        print(&quot;输入为空！&quot;)</span><br><span class="line">        return</span><br><span class="line">    text_and &#x3D; zhconv.convert(text_and, &#39;zh-tw&#39;)</span><br><span class="line">    search_list &#x3D; list(text_and.split(&quot; &quot;))</span><br><span class="line">    print(&quot;您输入的词语集合为:&quot;, end&#x3D;&quot;&quot;)</span><br><span class="line">    print(search_list)</span><br><span class="line">    res &#x3D; []</span><br><span class="line">    for word in search_list:</span><br><span class="line">        poetlist &#x3D; SearchWord(word)</span><br><span class="line">        if len(res) !&#x3D; 0:</span><br><span class="line">            res &#x3D; JiaoList(res, poetlist)</span><br><span class="line">        else:</span><br><span class="line">            res &#x3D; poetlist</span><br><span class="line">    res &#x3D; set(res)</span><br><span class="line">    if len(res) &#x3D;&#x3D; 0:</span><br><span class="line">        print(&quot;没有找到关于\&quot;&quot; + text_and + &quot;\&quot;的信息&quot;)</span><br><span class="line">    return res</span><br></pre></td></tr></table></figure>

<p>“非搜索”是同时输入很多字或短语，返回所有包含其中任一的古诗集合。因为这样筛选出的古诗会很多，因此非搜索只支持在“与搜索”或者“或搜索”的基础上减去“非搜索”的结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def SearchNot():</span><br><span class="line">    text_not &#x3D; e3.get()</span><br><span class="line">    if (text_not &#x3D;&#x3D; &quot;&quot;):</span><br><span class="line">        print(&quot;输入为空！&quot;)</span><br><span class="line">        return</span><br><span class="line">    text_not &#x3D; zhconv.convert(text_not, &#39;zh-tw&#39;)</span><br><span class="line">    search_list &#x3D; list(text_not.split(&quot; &quot;))</span><br><span class="line">    print(&quot;您输入的词语集合为:&quot;, end&#x3D;&quot;&quot;)</span><br><span class="line">    print(search_list)</span><br><span class="line">    res &#x3D; []</span><br><span class="line">    for word in search_list:</span><br><span class="line">        poetlist &#x3D; SearchWord(word)</span><br><span class="line">        if len(res) !&#x3D; 0:</span><br><span class="line">            res &#x3D; JiaoList(res, poetlist)</span><br><span class="line">        else:</span><br><span class="line">            res &#x3D; poetlist</span><br><span class="line">    res &#x3D; set(res)</span><br><span class="line">    return res</span><br></pre></td></tr></table></figure>

<p>“复合搜索”，在“非搜索”的描述中已经实现了初步的复合搜索，“非搜索”只能与“与搜索”或“或搜索”同时进行。将“或与非”分开输入，分别保存在e1,e2,e3中，假设返回结果保存在t1，t2，t3中，那么最终复合搜索的结果为：+t1+t2-t3。</p>
<h2 id="3-加了个好玩的"><a href="#3-加了个好玩的" class="headerlink" title="3 加了个好玩的"></a>3 加了个好玩的</h2><p>上面效果图的对诗系统参考自github上的<a href="https://github.com/wb14123/seq2seq-couplet" target="_blank" rel="noopener">seq2seq-couplet项目</a>。这是一个使用seq2seq模型对对联的项目，用Tensorflow编写，数据集为<a href="https://github.com/wb14123/couplet-dataset/releases" target="_blank" rel="noopener">70万个对联</a>，原作者在Nivida GTX-1080 GPU上训练了模型约4天。</p>
<p>原作者并未公开训练好的模型，算力有限因此使用了github上别人训练好的模型，<a href="https://github.com/luern0313/CoupletWriter" target="_blank" rel="noopener">模型来源</a>。</p>
<hr>
<h1 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h1><p>大三上的信息检索是个有点刺激的课</p>
<p>没有别人做不出来的，只有我做不出来的<br>没有一届做的差的，只有一届比一届做的更好的<br>所以没有很水的作业，只有一届比一届难的作业</p>
<p>要不是为了那两个学分！<img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbknyovaqhj301o01dgld.jpg" width="50"></p>
<p>（开玩笑的，课是好课）</p>
<p>第一个作业是「安然邮件系统检索」，那个原数据格式太乱了，我讨厌洗数据！所以那个作业我做的非常囫囵吞枣，</p>
<p>第二个作业就是本博客讲的这个，这可能是我完成的最完整的一个了QAQ所以记录下来</p>
<p>第三个作业是「nku教师检索系统」，我还是觉得Django好难用啊ORZ，主要不是它难用，是我不会用，就各种报错唉，做的也十分凹糟</p>
<p>第四个作业是「智能小开问答系统」，很有意思的作业。数据来源是自己爬的页面和google文件搜索，然后学了一下word2vec计算词向量和句向量，检索就是基于向量相似度的比较，用抽样和多线程加了个速（从别人github里学的真的好厉害）。在一个大佬的安利下还试了试chatterbot，但是训练出来的是什么玩意儿，我猜想这个肯定需要自己构造许多问句才可以，不然只能获得各种文不对题的回答</p>
<p>就是这样啦～</p>
]]></content>
      <categories>
        <category>一些作业</category>
      </categories>
  </entry>
  <entry>
    <title>UnicodeEncodeError: ascii codec cant encode characters in position 38-41: ordinal not in range(128)问题的原因及解决办法</title>
    <url>/c66010a2/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  File &quot;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;lib&#x2F;python3.6&#x2F;urllib&#x2F;request.py&quot;, line 1346, in http_open</span><br><span class="line">    return self.do_open(http.client.HTTPConnection, req)</span><br><span class="line">  File &quot;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;lib&#x2F;python3.6&#x2F;urllib&#x2F;request.py&quot;, line 1318, in do_open</span><br><span class="line">    encode_chunked&#x3D;req.has_header(&#39;Transfer-encoding&#39;))</span><br><span class="line">  File &quot;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;lib&#x2F;python3.6&#x2F;http&#x2F;client.py&quot;, line 1239, in request</span><br><span class="line">    self._send_request(method, url, body, headers, encode_chunked)</span><br><span class="line">  File &quot;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;lib&#x2F;python3.6&#x2F;http&#x2F;client.py&quot;, line 1250, in _send_request</span><br><span class="line">    self.putrequest(method, url, **skips)</span><br><span class="line">  File &quot;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;lib&#x2F;python3.6&#x2F;http&#x2F;client.py&quot;, line 1117, in putrequest</span><br><span class="line">    self._output(request.encode(&#39;ascii&#39;))</span><br><span class="line">UnicodeEncodeError: &#39;ascii&#39; codec can&#39;t encode characters in position 38-41: ordinal not in range(128)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>原因是在调用百度地图的API的时候，<code>urllib.request.urlopen(url)</code>，那个url里直接传入了中文参数</p>
<p>在python2中直接传中文是没有问题的，但是python3中url不可以包含中文，需要编码</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaki7t2w9jj30cl05874t.jpg" alt=""></p>
<p>所以就如上用<code>urllib.parse.quote</code>对中文先编码再加到url里，这样就不会报这个错了</p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>《Marching cubes: A high resolution 3D surface construction algorithm》论文阅读笔记：3D表面构造算法</title>
    <url>/4fdb446a/</url>
    <content><![CDATA[<p>虽然这篇论文年龄比我还大很多0.0，但是真是超级经典的一篇了，一万多的引用量</p>
<p>前排放上论文地址：<a href="https://dl.acm.org/doi/10.1145/37401.37422" target="_blank" rel="noopener">https://dl.acm.org/doi/10.1145/37401.37422</a></p>
<a id="more"></a>

<hr>
<p>这篇文章提出了一种高分辨率3D表面构造算法。这种算法和其他的图像到网格的算法相比，生成的网格质量好并且可并行性高，所以应用范围很广。</p>
<p>这个算法最初是用在医学上对3D解剖结构进行可视化的，所以论文前面部分一些涉及医学图像生成的部分我就没咋看了，后面部分是一些优化和医学效果图也没咋看，重点看表面生成的部分，有些不理解的地方结合了看的一些其他资料来说明。</p>
<h1 id="MARCHING-CUBES-ALGORITHM"><a href="#MARCHING-CUBES-ALGORITHM" class="headerlink" title="MARCHING CUBES ALGORITHM"></a>MARCHING CUBES ALGORITHM</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>首先是“体元（Cell）”的概念。使用分治法将表面定位在由八个像素创建的逻辑立方体中，两个相邻的切片各四个。如下图：（就是建立了空间网格），体元就是8个体素构成的方格，每个体素都被8个体元共享。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gajehlxi6mj30x20lqtc5.jpg" alt=""></p>
<p>该算法确定曲面如何与该立方体相交，然后移动到下一个立方体。</p>
<h2 id="表面内外"><a href="#表面内外" class="headerlink" title="表面内外"></a>表面内外</h2><p>这个算法是基于标量场的，所以本来是不知道这个网格点在表面内还是表面外的，需要借助一个隐函数，<code>f(x,y,z)=0</code>表示表面上的点集。</p>
<p>如果这8个顶点连续的两个有一个<code>&gt;0</code>一个<code>&lt;0</code>，也就是一个在表面外一个在内，那么表面肯定在这两个顶点之间，那么之后通过插值就可以获得表面的位置。</p>
<h2 id="256种方式"><a href="#256种方式" class="headerlink" title="256种方式"></a>256种方式</h2><p>每个立方体有八个顶点，因此曲面与立方体相交的方式有<code>2^8=256</code>种。</p>
<h2 id="15种类型"><a href="#15种类型" class="headerlink" title="15种类型"></a>15种类型</h2><p>然后对着256种方式考虑两种对称性：</p>
<ul>
<li>第一种是互补的情况，因为取<code>x</code>个点其实和取互补的<code>8-x</code>个是一样的表面，所以只需要考虑0-4个点的情况，那么总方式减为<code>256/2=128</code>种</li>
<li>第二种是旋转的情况，在上面只考虑0-4个点的基础上加上旋转，最后可以总结出下图15种类型的结构：</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gajemsqld7j30q20zmki4.jpg" alt=""></p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>接下来根据顶点的状态为每种情况创建一个索引。使用下图中的顶点编号，八位索引的每个位表示一个顶点v。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gajppr8l6rj30k80jmn0d.jpg" alt=""></p>
<p>举个例子，点索引是78，也就是二进制的01001110，对应的点集就是（1，2，3，6），对应的三角形集合是：{（3，11，6），（0，3，6），（0，6，5），（0，5，9）}，这样可以得到一张网上代代流传的三角形表（附在文末）（<code>256*16</code>的二维数组，每行对应一种方式的三角形集，-1或者255代表无效）</p>
<p>上图还给12条边e编了号，最后的三角片面的顶点都在边上，所以再用边建立一个索引。</p>
<p>也举个例子，点索引是1，二进制的00000001，那么只有v1在表面内，所以三角面片的点就在边e1，e4，e9上，那么二进制的边索引就是001000001001，也就是十六进制的0x109，根据这个可以列出另一个边表（附在文末）。</p>
<p>然后就可以利用三角形表获得三角形面片集合，利用边表来获取在表面的顶点。</p>
<h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><p>最后一步是为每个三角形顶点计算一个单位法线。渲染算法使用该法线生成 Gouraud-shaded 图像。</p>
<p>下面这部分有点没看懂，说的是梯度向量是密度的导数。然后就是要计算这个梯度向量，首先计算顶点处的梯度，相交点处的靠插值来计算。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gajq38tfefj31aq0psaft.jpg" alt=""></p>
<h2 id="算法总体思路"><a href="#算法总体思路" class="headerlink" title="算法总体思路"></a>算法总体思路</h2><p>最终的对一个体元绘制表面的思路是这样的：</p>
<ul>
<li>对于一个体元，根据八个体素（顶点）的像素值，可以确定一个体元配置V</li>
<li>根据这个体元配置V，从三角形表中获取对应的三角形面片集合A</li>
<li>根据这个三角面片集合A，根据边表可以获得边的索引</li>
<li>根据每组边索引可以得到对应的两个端点</li>
<li>根据两个端点坐标可以得到边上的插值坐标，从而得到三角表面的坐标</li>
</ul>
<h1 id="附表"><a href="#附表" class="headerlink" title="附表"></a>附表</h1><p>三角形表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define X 255</span><br><span class="line">const int triTable[256][16] &#x3D; &#123;</span><br><span class="line">    &#123;X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,8,3,X,X,X,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,1,9,X,X,X,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;1,8,3,9,8,1,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;1,2,10,X,X,X,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,8,3,1,2,10,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;9,2,10,0,2,9,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;2,8,3,2,10,8,10,9,8,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;3,11,2,X,X,X,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,11,2,8,11,0,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;1,9,0,2,3,11,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;1,11,2,1,9,11,9,8,11,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;3,10,1,11,10,3,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,10,1,0,8,10,8,11,10,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;3,9,0,3,11,9,11,10,9,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;9,8,10,10,8,11,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;4,7,8,X,X,X,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;4,3,0,7,3,4,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,1,9,8,4,7,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;4,1,9,4,7,1,7,3,1,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;1,2,10,8,4,7,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;3,4,7,3,0,4,1,2,10,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;9,2,10,9,0,2,8,4,7,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;2,10,9,2,9,7,2,7,3,7,9,4,X,X,X,X&#125;,</span><br><span class="line">    &#123;8,4,7,3,11,2,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;11,4,7,11,2,4,2,0,4,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;9,0,1,8,4,7,2,3,11,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;4,7,11,9,4,11,9,11,2,9,2,1,X,X,X,X&#125;,</span><br><span class="line">    &#123;3,10,1,3,11,10,7,8,4,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;1,11,10,1,4,11,1,0,4,7,11,4,X,X,X,X&#125;,</span><br><span class="line">    &#123;4,7,8,9,0,11,9,11,10,11,0,3,X,X,X,X&#125;,</span><br><span class="line">    &#123;4,7,11,4,11,9,9,11,10,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;9,5,4,X,X,X,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;9,5,4,0,8,3,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,5,4,1,5,0,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;8,5,4,8,3,5,3,1,5,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;1,2,10,9,5,4,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;3,0,8,1,2,10,4,9,5,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;5,2,10,5,4,2,4,0,2,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;2,10,5,3,2,5,3,5,4,3,4,8,X,X,X,X&#125;,</span><br><span class="line">    &#123;9,5,4,2,3,11,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,11,2,0,8,11,4,9,5,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,5,4,0,1,5,2,3,11,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;2,1,5,2,5,8,2,8,11,4,8,5,X,X,X,X&#125;,</span><br><span class="line">    &#123;10,3,11,10,1,3,9,5,4,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;4,9,5,0,8,1,8,10,1,8,11,10,X,X,X,X&#125;,</span><br><span class="line">    &#123;5,4,0,5,0,11,5,11,10,11,0,3,X,X,X,X&#125;,</span><br><span class="line">    &#123;5,4,8,5,8,10,10,8,11,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;9,7,8,5,7,9,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;9,3,0,9,5,3,5,7,3,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,7,8,0,1,7,1,5,7,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;1,5,3,3,5,7,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;9,7,8,9,5,7,10,1,2,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;10,1,2,9,5,0,5,3,0,5,7,3,X,X,X,X&#125;,</span><br><span class="line">    &#123;8,0,2,8,2,5,8,5,7,10,5,2,X,X,X,X&#125;,</span><br><span class="line">    &#123;2,10,5,2,5,3,3,5,7,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;7,9,5,7,8,9,3,11,2,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;9,5,7,9,7,2,9,2,0,2,7,11,X,X,X,X&#125;,</span><br><span class="line">    &#123;2,3,11,0,1,8,1,7,8,1,5,7,X,X,X,X&#125;,</span><br><span class="line">    &#123;11,2,1,11,1,7,7,1,5,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;9,5,8,8,5,7,10,1,3,10,3,11,X,X,X,X&#125;,</span><br><span class="line">    &#123;5,7,0,5,0,9,7,11,0,1,0,10,11,10,0,X&#125;,</span><br><span class="line">    &#123;11,10,0,11,0,3,10,5,0,8,0,7,5,7,0,X&#125;,</span><br><span class="line">    &#123;11,10,5,7,11,5,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;10,6,5,X,X,X,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,8,3,5,10,6,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;9,0,1,5,10,6,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;1,8,3,1,9,8,5,10,6,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;1,6,5,2,6,1,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;1,6,5,1,2,6,3,0,8,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;9,6,5,9,0,6,0,2,6,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;5,9,8,5,8,2,5,2,6,3,2,8,X,X,X,X&#125;,</span><br><span class="line">    &#123;2,3,11,10,6,5,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;11,0,8,11,2,0,10,6,5,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,1,9,2,3,11,5,10,6,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;5,10,6,1,9,2,9,11,2,9,8,11,X,X,X,X&#125;,</span><br><span class="line">    &#123;6,3,11,6,5,3,5,1,3,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,8,11,0,11,5,0,5,1,5,11,6,X,X,X,X&#125;,</span><br><span class="line">    &#123;3,11,6,0,3,6,0,6,5,0,5,9,X,X,X,X&#125;,</span><br><span class="line">    &#123;6,5,9,6,9,11,11,9,8,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;5,10,6,4,7,8,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;4,3,0,4,7,3,6,5,10,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;1,9,0,5,10,6,8,4,7,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;10,6,5,1,9,7,1,7,3,7,9,4,X,X,X,X&#125;,</span><br><span class="line">    &#123;6,1,2,6,5,1,4,7,8,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;1,2,5,5,2,6,3,0,4,3,4,7,X,X,X,X&#125;,</span><br><span class="line">    &#123;8,4,7,9,0,5,0,6,5,0,2,6,X,X,X,X&#125;,</span><br><span class="line">    &#123;7,3,9,7,9,4,3,2,9,5,9,6,2,6,9,X&#125;,</span><br><span class="line">    &#123;3,11,2,7,8,4,10,6,5,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;5,10,6,4,7,2,4,2,0,2,7,11,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,1,9,4,7,8,2,3,11,5,10,6,X,X,X,X&#125;,</span><br><span class="line">    &#123;9,2,1,9,11,2,9,4,11,7,11,4,5,10,6,X&#125;,</span><br><span class="line">    &#123;8,4,7,3,11,5,3,5,1,5,11,6,X,X,X,X&#125;,</span><br><span class="line">    &#123;5,1,11,5,11,6,1,0,11,7,11,4,0,4,11,X&#125;,</span><br><span class="line">    &#123;0,5,9,0,6,5,0,3,6,11,6,3,8,4,7,X&#125;,</span><br><span class="line">    &#123;6,5,9,6,9,11,4,7,9,7,11,9,X,X,X,X&#125;,</span><br><span class="line">    &#123;10,4,9,6,4,10,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;4,10,6,4,9,10,0,8,3,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;10,0,1,10,6,0,6,4,0,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;8,3,1,8,1,6,8,6,4,6,1,10,X,X,X,X&#125;,</span><br><span class="line">    &#123;1,4,9,1,2,4,2,6,4,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;3,0,8,1,2,9,2,4,9,2,6,4,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,2,4,4,2,6,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;8,3,2,8,2,4,4,2,6,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;10,4,9,10,6,4,11,2,3,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,8,2,2,8,11,4,9,10,4,10,6,X,X,X,X&#125;,</span><br><span class="line">    &#123;3,11,2,0,1,6,0,6,4,6,1,10,X,X,X,X&#125;,</span><br><span class="line">    &#123;6,4,1,6,1,10,4,8,1,2,1,11,8,11,1,X&#125;,</span><br><span class="line">    &#123;9,6,4,9,3,6,9,1,3,11,6,3,X,X,X,X&#125;,</span><br><span class="line">    &#123;8,11,1,8,1,0,11,6,1,9,1,4,6,4,1,X&#125;,</span><br><span class="line">    &#123;3,11,6,3,6,0,0,6,4,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;6,4,8,11,6,8,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;7,10,6,7,8,10,8,9,10,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,7,3,0,10,7,0,9,10,6,7,10,X,X,X,X&#125;,</span><br><span class="line">    &#123;10,6,7,1,10,7,1,7,8,1,8,0,X,X,X,X&#125;,</span><br><span class="line">    &#123;10,6,7,10,7,1,1,7,3,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;1,2,6,1,6,8,1,8,9,8,6,7,X,X,X,X&#125;,</span><br><span class="line">    &#123;2,6,9,2,9,1,6,7,9,0,9,3,7,3,9,X&#125;,</span><br><span class="line">    &#123;7,8,0,7,0,6,6,0,2,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;7,3,2,6,7,2,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;2,3,11,10,6,8,10,8,9,8,6,7,X,X,X,X&#125;,</span><br><span class="line">    &#123;2,0,7,2,7,11,0,9,7,6,7,10,9,10,7,X&#125;,</span><br><span class="line">    &#123;1,8,0,1,7,8,1,10,7,6,7,10,2,3,11,X&#125;,</span><br><span class="line">    &#123;11,2,1,11,1,7,10,6,1,6,7,1,X,X,X,X&#125;,</span><br><span class="line">    &#123;8,9,6,8,6,7,9,1,6,11,6,3,1,3,6,X&#125;,</span><br><span class="line">    &#123;0,9,1,11,6,7,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;7,8,0,7,0,6,3,11,0,11,6,0,X,X,X,X&#125;,</span><br><span class="line">    &#123;7,11,6,X,X,X,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;7,6,11,X,X,X,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;3,0,8,11,7,6,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,1,9,11,7,6,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;8,1,9,8,3,1,11,7,6,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;10,1,2,6,11,7,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;1,2,10,3,0,8,6,11,7,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;2,9,0,2,10,9,6,11,7,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;6,11,7,2,10,3,10,8,3,10,9,8,X,X,X,X&#125;,</span><br><span class="line">    &#123;7,2,3,6,2,7,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;7,0,8,7,6,0,6,2,0,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;2,7,6,2,3,7,0,1,9,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;1,6,2,1,8,6,1,9,8,8,7,6,X,X,X,X&#125;,</span><br><span class="line">    &#123;10,7,6,10,1,7,1,3,7,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;10,7,6,1,7,10,1,8,7,1,0,8,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,3,7,0,7,10,0,10,9,6,10,7,X,X,X,X&#125;,</span><br><span class="line">    &#123;7,6,10,7,10,8,8,10,9,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;6,8,4,11,8,6,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;3,6,11,3,0,6,0,4,6,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;8,6,11,8,4,6,9,0,1,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;9,4,6,9,6,3,9,3,1,11,3,6,X,X,X,X&#125;,</span><br><span class="line">    &#123;6,8,4,6,11,8,2,10,1,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;1,2,10,3,0,11,0,6,11,0,4,6,X,X,X,X&#125;,</span><br><span class="line">    &#123;4,11,8,4,6,11,0,2,9,2,10,9,X,X,X,X&#125;,</span><br><span class="line">    &#123;10,9,3,10,3,2,9,4,3,11,3,6,4,6,3,X&#125;,</span><br><span class="line">    &#123;8,2,3,8,4,2,4,6,2,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,4,2,4,6,2,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;1,9,0,2,3,4,2,4,6,4,3,8,X,X,X,X&#125;,</span><br><span class="line">    &#123;1,9,4,1,4,2,2,4,6,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;8,1,3,8,6,1,8,4,6,6,10,1,X,X,X,X&#125;,</span><br><span class="line">    &#123;10,1,0,10,0,6,6,0,4,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;4,6,3,4,3,8,6,10,3,0,3,9,10,9,3,X&#125;,</span><br><span class="line">    &#123;10,9,4,6,10,4,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;4,9,5,7,6,11,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,8,3,4,9,5,11,7,6,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;5,0,1,5,4,0,7,6,11,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;11,7,6,8,3,4,3,5,4,3,1,5,X,X,X,X&#125;,</span><br><span class="line">    &#123;9,5,4,10,1,2,7,6,11,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;6,11,7,1,2,10,0,8,3,4,9,5,X,X,X,X&#125;,</span><br><span class="line">    &#123;7,6,11,5,4,10,4,2,10,4,0,2,X,X,X,X&#125;,</span><br><span class="line">    &#123;3,4,8,3,5,4,3,2,5,10,5,2,11,7,6,X&#125;,</span><br><span class="line">    &#123;7,2,3,7,6,2,5,4,9,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;9,5,4,0,8,6,0,6,2,6,8,7,X,X,X,X&#125;,</span><br><span class="line">    &#123;3,6,2,3,7,6,1,5,0,5,4,0,X,X,X,X&#125;,</span><br><span class="line">    &#123;6,2,8,6,8,7,2,1,8,4,8,5,1,5,8,X&#125;,</span><br><span class="line">    &#123;9,5,4,10,1,6,1,7,6,1,3,7,X,X,X,X&#125;,</span><br><span class="line">    &#123;1,6,10,1,7,6,1,0,7,8,7,0,9,5,4,X&#125;,</span><br><span class="line">    &#123;4,0,10,4,10,5,0,3,10,6,10,7,3,7,10,X&#125;,</span><br><span class="line">    &#123;7,6,10,7,10,8,5,4,10,4,8,10,X,X,X,X&#125;,</span><br><span class="line">    &#123;6,9,5,6,11,9,11,8,9,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;3,6,11,0,6,3,0,5,6,0,9,5,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,11,8,0,5,11,0,1,5,5,6,11,X,X,X,X&#125;,</span><br><span class="line">    &#123;6,11,3,6,3,5,5,3,1,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;1,2,10,9,5,11,9,11,8,11,5,6,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,11,3,0,6,11,0,9,6,5,6,9,1,2,10,X&#125;,</span><br><span class="line">    &#123;11,8,5,11,5,6,8,0,5,10,5,2,0,2,5,X&#125;,</span><br><span class="line">    &#123;6,11,3,6,3,5,2,10,3,10,5,3,X,X,X,X&#125;,</span><br><span class="line">    &#123;5,8,9,5,2,8,5,6,2,3,8,2,X,X,X,X&#125;,</span><br><span class="line">    &#123;9,5,6,9,6,0,0,6,2,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;1,5,8,1,8,0,5,6,8,3,8,2,6,2,8,X&#125;,</span><br><span class="line">    &#123;1,5,6,2,1,6,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;1,3,6,1,6,10,3,8,6,5,6,9,8,9,6,X&#125;,</span><br><span class="line">    &#123;10,1,0,10,0,6,9,5,0,5,6,0,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,3,8,5,6,10,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;10,5,6,X,X,X,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;11,5,10,7,5,11,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;11,5,10,11,7,5,8,3,0,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;5,11,7,5,10,11,1,9,0,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;10,7,5,10,11,7,9,8,1,8,3,1,X,X,X,X&#125;,</span><br><span class="line">    &#123;11,1,2,11,7,1,7,5,1,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,8,3,1,2,7,1,7,5,7,2,11,X,X,X,X&#125;,</span><br><span class="line">    &#123;9,7,5,9,2,7,9,0,2,2,11,7,X,X,X,X&#125;,</span><br><span class="line">    &#123;7,5,2,7,2,11,5,9,2,3,2,8,9,8,2,X&#125;,</span><br><span class="line">    &#123;2,5,10,2,3,5,3,7,5,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;8,2,0,8,5,2,8,7,5,10,2,5,X,X,X,X&#125;,</span><br><span class="line">    &#123;9,0,1,5,10,3,5,3,7,3,10,2,X,X,X,X&#125;,</span><br><span class="line">    &#123;9,8,2,9,2,1,8,7,2,10,2,5,7,5,2,X&#125;,</span><br><span class="line">    &#123;1,3,5,3,7,5,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,8,7,0,7,1,1,7,5,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;9,0,3,9,3,5,5,3,7,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;9,8,7,5,9,7,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;5,8,4,5,10,8,10,11,8,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;5,0,4,5,11,0,5,10,11,11,3,0,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,1,9,8,4,10,8,10,11,10,4,5,X,X,X,X&#125;,</span><br><span class="line">    &#123;10,11,4,10,4,5,11,3,4,9,4,1,3,1,4,X&#125;,</span><br><span class="line">    &#123;2,5,1,2,8,5,2,11,8,4,5,8,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,4,11,0,11,3,4,5,11,2,11,1,5,1,11,X&#125;,</span><br><span class="line">    &#123;0,2,5,0,5,9,2,11,5,4,5,8,11,8,5,X&#125;,</span><br><span class="line">    &#123;9,4,5,2,11,3,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;2,5,10,3,5,2,3,4,5,3,8,4,X,X,X,X&#125;,</span><br><span class="line">    &#123;5,10,2,5,2,4,4,2,0,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;3,10,2,3,5,10,3,8,5,4,5,8,0,1,9,X&#125;,</span><br><span class="line">    &#123;5,10,2,5,2,4,1,9,2,9,4,2,X,X,X,X&#125;,</span><br><span class="line">    &#123;8,4,5,8,5,3,3,5,1,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,4,5,1,0,5,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;8,4,5,8,5,3,9,0,5,0,3,5,X,X,X,X&#125;,</span><br><span class="line">    &#123;9,4,5,X,X,X,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;4,11,7,4,9,11,9,10,11,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,8,3,4,9,7,9,11,7,9,10,11,X,X,X,X&#125;,</span><br><span class="line">    &#123;1,10,11,1,11,4,1,4,0,7,4,11,X,X,X,X&#125;,</span><br><span class="line">    &#123;3,1,4,3,4,8,1,10,4,7,4,11,10,11,4,X&#125;,</span><br><span class="line">    &#123;4,11,7,9,11,4,9,2,11,9,1,2,X,X,X,X&#125;,</span><br><span class="line">    &#123;9,7,4,9,11,7,9,1,11,2,11,1,0,8,3,X&#125;,</span><br><span class="line">    &#123;11,7,4,11,4,2,2,4,0,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;11,7,4,11,4,2,8,3,4,3,2,4,X,X,X,X&#125;,</span><br><span class="line">    &#123;2,9,10,2,7,9,2,3,7,7,4,9,X,X,X,X&#125;,</span><br><span class="line">    &#123;9,10,7,9,7,4,10,2,7,8,7,0,2,0,7,X&#125;,</span><br><span class="line">    &#123;3,7,10,3,10,2,7,4,10,1,10,0,4,0,10,X&#125;,</span><br><span class="line">    &#123;1,10,2,8,7,4,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;4,9,1,4,1,7,7,1,3,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;4,9,1,4,1,7,0,8,1,8,7,1,X,X,X,X&#125;,</span><br><span class="line">    &#123;4,0,3,7,4,3,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;4,8,7,X,X,X,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;9,10,8,10,11,8,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;3,0,9,3,9,11,11,9,10,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,1,10,0,10,8,8,10,11,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;3,1,10,11,3,10,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;1,2,11,1,11,9,9,11,8,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;3,0,9,3,9,11,1,2,9,2,11,9,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,2,11,8,0,11,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;3,2,11,X,X,X,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;2,3,8,2,8,10,10,8,9,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;9,10,2,0,9,2,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;2,3,8,2,8,10,0,1,8,1,10,8,X,X,X,X&#125;,</span><br><span class="line">    &#123;1,10,2,X,X,X,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;1,3,8,9,1,8,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,9,1,X,X,X,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;0,3,8,X,X,X,X,X,X,X,X,X,X,X,X,X&#125;,</span><br><span class="line">    &#123;X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X&#125;</span><br><span class="line">&#125;;</span><br><span class="line">#undef X</span><br></pre></td></tr></table></figure>

<p>边表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const unsigned int edgeTable[256] &#x3D; &#123;</span><br><span class="line">    0x0  ,0x109,0x203,0x30a,0x406,0x50f,0x605,0x70c,</span><br><span class="line">    0x80c,0x905,0xa0f,0xb06,0xc0a,0xd03,0xe09,0xf00,</span><br><span class="line">    0x190,0x99 ,0x393,0x29a,0x596,0x49f,0x795,0x69c,</span><br><span class="line">    0x99c,0x895,0xb9f,0xa96,0xd9a,0xc93,0xf99,0xe90,</span><br><span class="line">    0x230,0x339,0x33 ,0x13a,0x636,0x73f,0x435,0x53c,</span><br><span class="line">    0xa3c,0xb35,0x83f,0x936,0xe3a,0xf33,0xc39,0xd30,</span><br><span class="line">    0x3a0,0x2a9,0x1a3,0xaa ,0x7a6,0x6af,0x5a5,0x4ac,</span><br><span class="line">    0xbac,0xaa5,0x9af,0x8a6,0xfaa,0xea3,0xda9,0xca0,</span><br><span class="line">    0x460,0x569,0x663,0x76a,0x66 ,0x16f,0x265,0x36c,</span><br><span class="line">    0xc6c,0xd65,0xe6f,0xf66,0x86a,0x963,0xa69,0xb60,</span><br><span class="line">    0x5f0,0x4f9,0x7f3,0x6fa,0x1f6,0xff ,0x3f5,0x2fc,</span><br><span class="line">    0xdfc,0xcf5,0xfff,0xef6,0x9fa,0x8f3,0xbf9,0xaf0,</span><br><span class="line">    0x650,0x759,0x453,0x55a,0x256,0x35f,0x55 ,0x15c,</span><br><span class="line">    0xe5c,0xf55,0xc5f,0xd56,0xa5a,0xb53,0x859,0x950,</span><br><span class="line">    0x7c0,0x6c9,0x5c3,0x4ca,0x3c6,0x2cf,0x1c5,0xcc ,</span><br><span class="line">    0xfcc,0xec5,0xdcf,0xcc6,0xbca,0xac3,0x9c9,0x8c0,</span><br><span class="line">    0x8c0,0x9c9,0xac3,0xbca,0xcc6,0xdcf,0xec5,0xfcc,</span><br><span class="line">    0xcc ,0x1c5,0x2cf,0x3c6,0x4ca,0x5c3,0x6c9,0x7c0,</span><br><span class="line">    0x950,0x859,0xb53,0xa5a,0xd56,0xc5f,0xf55,0xe5c,</span><br><span class="line">    0x15c,0x55 ,0x35f,0x256,0x55a,0x453,0x759,0x650,</span><br><span class="line">    0xaf0,0xbf9,0x8f3,0x9fa,0xef6,0xfff,0xcf5,0xdfc,</span><br><span class="line">    0x2fc,0x3f5,0xff ,0x1f6,0x6fa,0x7f3,0x4f9,0x5f0,</span><br><span class="line">    0xb60,0xa69,0x963,0x86a,0xf66,0xe6f,0xd65,0xc6c,</span><br><span class="line">    0x36c,0x265,0x16f,0x66 ,0x76a,0x663,0x569,0x460,</span><br><span class="line">    0xca0,0xda9,0xea3,0xfaa,0x8a6,0x9af,0xaa5,0xbac,</span><br><span class="line">    0x4ac,0x5a5,0x6af,0x7a6,0xaa ,0x1a3,0x2a9,0x3a0,</span><br><span class="line">    0xd30,0xc39,0xf33,0xe3a,0x936,0x83f,0xb35,0xa3c,</span><br><span class="line">    0x53c,0x435,0x73f,0x636,0x13a,0x33 ,0x339,0x230,</span><br><span class="line">    0xe90,0xf99,0xc93,0xd9a,0xa96,0xb9f,0x895,0x99c,</span><br><span class="line">    0x69c,0x795,0x49f,0x596,0x29a,0x393,0x99 ,0x190,</span><br><span class="line">    0xf00,0xe09,0xd03,0xc0a,0xb06,0xa0f,0x905,0x80c,</span><br><span class="line">    0x70c,0x605,0x50f,0x406,0x30a,0x203,0x109,0x0</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>阅读笔记</tag>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL——GLM数学库（Ps：平安夜快乐🍎，圣诞快乐🎄）</title>
    <url>/7c9c35a7/</url>
    <content><![CDATA[<p>还没有找到很好的中文教程类资源啥的，那就直接自己看官方手册吧，，(･_･;</p>
<p>既然决定了写一篇GLM的博客就想写全一点，不然有点难受，害，，真麻烦，好多东西其实估计我用不上。不过其实很多都没有展开讲，只是暂且先知道了有这么一个东西，这样要用的时候查就会有概念一些方便找头文件是啥0.0</p>
<hr>
<h1 id="0-GLM介绍"><a href="#0-GLM介绍" class="headerlink" title="0 GLM介绍"></a>0 GLM介绍</h1><p>GLM库的官网：<a href="https://glm.g-truc.net/0.9.9/index.html" target="_blank" rel="noopener">https://glm.g-truc.net/0.9.9/index.html</a>（似乎是需要快乐上网的）</p>
<p>github地址：<a href="https://github.com/g-truc/glm" target="_blank" rel="noopener">https://github.com/g-truc/glm</a></p>
<p>官方手册：<a href="https://github.com/g-truc/glm/blob/master/manual.md" target="_blank" rel="noopener">https://github.com/g-truc/glm/blob/master/manual.md</a></p>
<p>OpenGL没有自己内置的数学库，所以有了OpenGL Mathematics（GLM），基于OpenGL Shading Language（GLSL）规范的图形软件的数学库</p>
<p>支持以下编译器：</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga700ja4r8j30eu0620tk.jpg" alt=""></p>
<p>接下来就进正题:D</p>
<h1 id="1-入门"><a href="#1-入门" class="headerlink" title="1 入门"></a>1 入门</h1><p>总结起来头文件其实就两个，一个是核心实现，还有一个ext是一些扩展，直接用这两个头文件显然很方便，但是这样要导入太多东西会浪费编译时间，所以没有必要，更多的时候是要啥导入具体的那个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Include all GLM core &#x2F; GLSL features</span><br><span class="line">#include &lt;glm&#x2F;glm.hpp&gt; &#x2F;&#x2F; vec2, vec3, mat4, radians</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Include all GLM extensions</span><br><span class="line">#include &lt;glm&#x2F;ext.hpp&gt; &#x2F;&#x2F; perspective, translate, rotate</span><br></pre></td></tr></table></figure>

<p>下面就是glm里具体的，有啥数据类型大概可以看这些名字猜一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;glm&#x2F;vec2.hpp&gt;               &#x2F;&#x2F; vec2, bvec2, dvec2, ivec2 and uvec2</span><br><span class="line">#include &lt;glm&#x2F;vec3.hpp&gt;               &#x2F;&#x2F; vec3, bvec3, dvec3, ivec3 and uvec3</span><br><span class="line">#include &lt;glm&#x2F;vec4.hpp&gt;               &#x2F;&#x2F; vec4, bvec4, dvec4, ivec4 and uvec4</span><br><span class="line">#include &lt;glm&#x2F;mat2x2.hpp&gt;             &#x2F;&#x2F; mat2, dmat2</span><br><span class="line">#include &lt;glm&#x2F;mat2x3.hpp&gt;             &#x2F;&#x2F; mat2x3, dmat2x3</span><br><span class="line">#include &lt;glm&#x2F;mat2x4.hpp&gt;             &#x2F;&#x2F; mat2x4, dmat2x4</span><br><span class="line">#include &lt;glm&#x2F;mat3x2.hpp&gt;             &#x2F;&#x2F; mat3x2, dmat3x2</span><br><span class="line">#include &lt;glm&#x2F;mat3x3.hpp&gt;             &#x2F;&#x2F; mat3, dmat3</span><br><span class="line">#include &lt;glm&#x2F;mat3x4.hpp&gt;             &#x2F;&#x2F; mat3x4, dmat2</span><br><span class="line">#include &lt;glm&#x2F;mat4x2.hpp&gt;             &#x2F;&#x2F; mat4x2, dmat4x2</span><br><span class="line">#include &lt;glm&#x2F;mat4x3.hpp&gt;             &#x2F;&#x2F; mat4x3, dmat4x3</span><br><span class="line">#include &lt;glm&#x2F;mat4x4.hpp&gt;             &#x2F;&#x2F; mat4, dmat4</span><br><span class="line">#include &lt;glm&#x2F;common.hpp&gt;             &#x2F;&#x2F; all the GLSL common functions: abs, min, mix, isnan, fma, etc.</span><br><span class="line">#include &lt;glm&#x2F;exponential.hpp&gt;        &#x2F;&#x2F; all the GLSL exponential functions: pow, log, exp2, sqrt, etc.</span><br><span class="line">#include &lt;glm&#x2F;geometry.hpp&gt;           &#x2F;&#x2F; all the GLSL geometry functions: dot, cross, reflect, normalize, etc.</span><br><span class="line">&#x2F;&#x2F;上面这个我在实际用的时候(0.9.9.7)发现应该是#include &lt;glm&#x2F;geometric.hpp&gt;</span><br><span class="line">#include &lt;glm&#x2F;integer.hpp&gt;            &#x2F;&#x2F; all the GLSL integer functions: findMSB, bitfieldExtract, etc.</span><br><span class="line">#include &lt;glm&#x2F;matrix.hpp&gt;             &#x2F;&#x2F; all the GLSL matrix functions: transpose, inverse, etc.</span><br><span class="line">#include &lt;glm&#x2F;packing.hpp&gt;            &#x2F;&#x2F; all the GLSL packing functions: packUnorm4x8, unpackHalf2x16, etc.</span><br><span class="line">#include &lt;glm&#x2F;trigonometric.hpp&gt;      &#x2F;&#x2F; all the GLSL trigonometric functions: radians, cos, asin, etc.</span><br><span class="line">#include &lt;glm&#x2F;vector_relational.hpp&gt;  &#x2F;&#x2F; all the GLSL vector relational functions: equal, less, etc.</span><br></pre></td></tr></table></figure>

<h1 id="2-预处理器配置"><a href="#2-预处理器配置" class="headerlink" title="2 预处理器配置"></a>2 预处理器配置</h1><p>这节讲的东西大概是可以用一些固定的宏定义来更改GLM配置，简述如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GLM_FORCE_MESSAGES: 平台自动检测和默认配置</span><br><span class="line">GLM_FORCE_PLATFORM_UNKNOWN: 强制GLM不检测构建平台</span><br><span class="line">GLM_FORCE_COMPILER_UNKNOWN: 强制GLM不检测C++编译器</span><br><span class="line">GLM_FORCE_ARCH_UNKNOWN: 强制GLM不检测构建体系结构</span><br><span class="line">GLM_FORCE_CXX_UNKNOWN: 强制GLM不检测C++标准</span><br><span class="line">GLM_FORCE_CXX**: C++语言检测detectionGLM_FORCE_EXPLICIT_CTOR: 需要显式转换</span><br><span class="line">GLM_FORCE_INLINE: 强制内联</span><br><span class="line">GLM_FORCE_ALIGNED_GENTYPES: 强制GLM启用对齐类型</span><br><span class="line">GLM_FORCE_DEFAULT_ALIGNED_GENTYPES: 强制GLM默认使用对齐类型</span><br><span class="line">GLM_FORCE_INTRINSICS: 使用SIMD优化optimizationsGLM_FORCE_PRECISION_**: 默认精度</span><br><span class="line">GLM_FORCE_SINGLE_ONLY: 删除了显式的64位浮点类型</span><br><span class="line">GLM_FORCE_SWIZZLE: 启用Swizzle运算符</span><br><span class="line">GLM_FORCE_XYZW_ONLY: 仅公开x，y，z和w分量</span><br><span class="line">GLM_FORCE_LEFT_HANDED: 强制左手坐标系</span><br><span class="line">GLM_FORCE_DEPTH_ZERO_TO_ONE: 强制使用0到1之间的剪辑空间</span><br><span class="line">GLM_FORCE_SIZE_T_LENGTH: 向量和矩阵的静态大小</span><br><span class="line">GLM_FORCE_UNRESTRICTED_GENTYPE: 删除genType限制</span><br><span class="line">GLM_FORCE_SILENT_WARNINGS: 来自语言扩展的静默C++警告</span><br></pre></td></tr></table></figure>

<h1 id="3-Stable-extensions"><a href="#3-Stable-extensions" class="headerlink" title="3 Stable extensions"></a>3 Stable extensions</h1><h2 id="3-1-标量类型"><a href="#3-1-标量类型" class="headerlink" title="3.1 标量类型"></a>3.1 标量类型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GLM_EXT_scalar_int_sized：sized and signed integer types</span><br><span class="line">GLM_EXT_scalar_uint_sized：sized and unsigned integer types</span><br></pre></td></tr></table></figure>

<h2 id="3-2-标量函数"><a href="#3-2-标量函数" class="headerlink" title="3.2 标量函数"></a>3.2 标量函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GLM_EXT_scalar_common：min&#x2F;max&#x2F;fmin&#x2F;fmax</span><br><span class="line">GLM_EXT_scalar_relational：等于equal&#x2F;不等于notEqual</span><br><span class="line">GLM_EXT_scalar_constants：一些常量，比如epsilon&#x2F;pi</span><br><span class="line">GLM_EXT_scalar_ulp：数值计算中的准确性度量</span><br></pre></td></tr></table></figure>

<h2 id="3-3-向量类型"><a href="#3-3-向量类型" class="headerlink" title="3.3 向量类型"></a>3.3 向量类型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GLM_EXT_vector_float1：float型的一维向量</span><br><span class="line">GLM_EXT_vector_float2：float型的二维向量</span><br><span class="line">GLM_EXT_vector_float3</span><br><span class="line">GLM_EXT_vector_float4</span><br><span class="line">GLM_EXT_vector_double1：double型的一维向量</span><br><span class="line">GLM_EXT_vector_double2</span><br><span class="line">GLM_EXT_vector_double3</span><br><span class="line">GLM_EXT_vector_double4</span><br><span class="line">GLM_EXT_vector_int1：int型的一维向量</span><br><span class="line">GLM_EXT_vector_int2</span><br><span class="line">GLM_EXT_vector_int3</span><br><span class="line">GLM_EXT_vector_int4</span><br><span class="line">GLM_EXT_vector_uint1：uint型的一维向量</span><br><span class="line">GLM_EXT_vector_uint2</span><br><span class="line">GLM_EXT_vector_uint3</span><br><span class="line">GLM_EXT_vector_uint4</span><br><span class="line">GLM_EXT_vector_bool1：bool型的一维向量</span><br><span class="line">GLM_EXT_vector_bool2</span><br><span class="line">GLM_EXT_vector_bool3</span><br><span class="line">GLM_EXT_vector_bool4</span><br></pre></td></tr></table></figure>

<h2 id="3-4-具有精度限定词的向量类型"><a href="#3-4-具有精度限定词的向量类型" class="headerlink" title="3.4 具有精度限定词的向量类型"></a>3.4 具有精度限定词的向量类型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GLM_EXT_vector_float1_precision</span><br><span class="line">GLM_EXT_vector_float2_precision</span><br><span class="line">GLM_EXT_vector_float3_precision</span><br><span class="line">GLM_EXT_vector_float4_precision</span><br><span class="line">GLM_EXT_vector_double1_precision</span><br><span class="line">GLM_EXT_vector_double2_precision</span><br><span class="line">GLM_EXT_vector_double3_precision</span><br><span class="line">GLM_EXT_vector_double4_precision</span><br></pre></td></tr></table></figure>

<h2 id="3-5-向量函数"><a href="#3-5-向量函数" class="headerlink" title="3.5 向量函数"></a>3.5 向量函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GLM_EXT_vector_common：min&#x2F;max&#x2F;fmin&#x2F;fmax</span><br><span class="line">GLM_EXT_vector_relational：等于equal&#x2F;不等于notEqual</span><br><span class="line">GLM_EXT_vector_ulp：数值计算中的准确性度量</span><br></pre></td></tr></table></figure>

<h2 id="3-6-矩阵类型"><a href="#3-6-矩阵类型" class="headerlink" title="3.6 矩阵类型"></a>3.6 矩阵类型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GLM_EXT_matrix_float2x2</span><br><span class="line">GLM_EXT_matrix_float2x3</span><br><span class="line">GLM_EXT_matrix_float2x4</span><br><span class="line">GLM_EXT_matrix_float3x2</span><br><span class="line">GLM_EXT_matrix_float3x3</span><br><span class="line">GLM_EXT_matrix_float3x4</span><br><span class="line">GLM_EXT_matrix_float4x2</span><br><span class="line">GLM_EXT_matrix_float4x3</span><br><span class="line">GLM_EXT_matrix_float4x4</span><br><span class="line">GLM_EXT_matrix_double2x2</span><br><span class="line">GLM_EXT_matrix_double2x3</span><br><span class="line">GLM_EXT_matrix_double2x4</span><br><span class="line">GLM_EXT_matrix_double3x2</span><br><span class="line">GLM_EXT_matrix_double3x3</span><br><span class="line">GLM_EXT_matrix_double3x4</span><br><span class="line">GLM_EXT_matrix_double4x2</span><br><span class="line">GLM_EXT_matrix_double4x3</span><br><span class="line">GLM_EXT_matrix_double4x4</span><br></pre></td></tr></table></figure>

<h2 id="3-7-具有精确限定符的矩阵类型"><a href="#3-7-具有精确限定符的矩阵类型" class="headerlink" title="3.7 具有精确限定符的矩阵类型"></a>3.7 具有精确限定符的矩阵类型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GLM_EXT_matrix_float2x2_precision</span><br><span class="line">GLM_EXT_matrix_float2x3_precision</span><br><span class="line">GLM_EXT_matrix_float2x4_precision</span><br><span class="line">GLM_EXT_matrix_float3x2_precision</span><br><span class="line">GLM_EXT_matrix_float3x3_precision</span><br><span class="line">GLM_EXT_matrix_float3x4_precision</span><br><span class="line">GLM_EXT_matrix_float4x2_precision</span><br><span class="line">GLM_EXT_matrix_float4x3_precision</span><br><span class="line">GLM_EXT_matrix_float4x4_precision</span><br><span class="line">GLM_EXT_matrix_double2x2_precision</span><br><span class="line">GLM_EXT_matrix_double2x3_precision</span><br><span class="line">GLM_EXT_matrix_double2x4_precision</span><br><span class="line">GLM_EXT_matrix_double3x2_precision</span><br><span class="line">GLM_EXT_matrix_double3x3_precision</span><br><span class="line">GLM_EXT_matrix_double3x4_precision</span><br><span class="line">GLM_EXT_matrix_double4x2_precision</span><br><span class="line">GLM_EXT_matrix_double4x3_precision</span><br><span class="line">GLM_EXT_matrix_double4x4_precision</span><br></pre></td></tr></table></figure>

<h2 id="3-8-矩阵函数"><a href="#3-8-矩阵函数" class="headerlink" title="3.8 矩阵函数"></a>3.8 矩阵函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GLM_EXT_matrix_relational：等于equal&#x2F;不等于notEqual</span><br><span class="line">GLM_EXT_matrix_transform：平移translate&#x2F;旋转rotate&#x2F;缩放scale</span><br><span class="line">GLM_EXT_matrix_clip_space：将场景转换为clip space</span><br><span class="line">GLM_EXT_matrix_projection：将对象坐标映射到窗口坐标并反转</span><br></pre></td></tr></table></figure>

<h2 id="3-9-四元数"><a href="#3-9-四元数" class="headerlink" title="3.9 四元数"></a>3.9 四元数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GLM_EXT_quaternion_float</span><br><span class="line">GLM_EXT_quaternion_double</span><br></pre></td></tr></table></figure>

<h2 id="3-10-带精度限定符的四元数"><a href="#3-10-带精度限定符的四元数" class="headerlink" title="3.10 带精度限定符的四元数"></a>3.10 带精度限定符的四元数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GLM_EXT_quaternion_float_precision</span><br><span class="line">GLM_EXT_quaternion_double_precision</span><br></pre></td></tr></table></figure>

<h2 id="3-11-四元数函数"><a href="#3-11-四元数函数" class="headerlink" title="3.11 四元数函数"></a>3.11 四元数函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GLM_EXT_quaternion_common：球面线性插值slerp&#x2F;共轭conjugate&#x2F;求逆inverse</span><br><span class="line">GLM_EXT_quaternion_geometric：length&#x2F;normalize&#x2F;dot&#x2F;cross</span><br><span class="line">GLM_EXT_quaternion_trigonometric：角度angle&#x2F;轴线axis</span><br><span class="line">GLM_EXT_quaternion_exponential：exp&#x2F;log&#x2F;pow&#x2F;sqrt</span><br><span class="line">GLM_EXT_quaternion_relational：比较四元数</span><br><span class="line">GLM_EXT_quaternion_transform：转换对象</span><br></pre></td></tr></table></figure>

<h1 id="4-Recommended-extensions"><a href="#4-Recommended-extensions" class="headerlink" title="4 Recommended extensions"></a>4 Recommended extensions</h1><p>GLM通过扩展来扩展核心GLSL功能集。这些扩展包括：四元数，变换，样条，矩阵逆，色彩空间等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GLM_GTC_bitfield：标量和向量变量的快速位运算</span><br><span class="line">GLM_GTC_color_space：线性RGB和sRGB色彩空间之间的转换</span><br><span class="line">GLM_GTC_constants：提供内置常量列表</span><br><span class="line">GLM_GTC_epsilon：浮点数的近似相等比较</span><br><span class="line">GLM_GTC_integer：GLM核心函数的整数变体</span><br><span class="line">GLM_GTC_matrix_access：方便访问矩阵的各个行或列的函数</span><br><span class="line">GLM_GTC_matrix_integer：整数矩阵类型，不支持某些运算（例如逆和行列式）</span><br><span class="line">GLM_GTC_matrix_inverse：矩阵求逆函数</span><br><span class="line">GLM_GTC_matrix_transform：遵循OpenGL固定功能的矩阵转换函数</span><br><span class="line">GLM_GTC_noise：定义2D，3D和4D程序噪声函数</span><br><span class="line">GLM_GTC_packing：将标量和向量类型与打包格式之间进行转换，以节省精度为代价来节省空间（也可以打包成解压缩的格式保证无损）</span><br><span class="line">GLM_GTC_quaternion：四元数及其上的运算</span><br><span class="line">GLM_GTC_random：概率分布（最多四个维度）</span><br><span class="line">GLM_GTC_reciprocal：倒数三角函数，比如secant&#x2F;cosecant&#x2F;tangent</span><br><span class="line">GLM_GTC_round：舍入运算</span><br><span class="line">GLM_GTC_type_aligned：对齐的向量类型</span><br><span class="line">GLM_GTC_type_precision：有定义精度的向量和矩阵类型，比如i8vec4是带符号的8位整数的4维向量</span><br><span class="line">GLM_GTC_type_ptr：基本类型和GLM类型的指针之间的交互</span><br><span class="line">GLM_GTC_ulp：测量函数的准确性</span><br><span class="line">GLM_GTC_vec1：一维向量指针</span><br></pre></td></tr></table></figure>

<h1 id="5-OpenGL-interoperability"><a href="#5-OpenGL-interoperability" class="headerlink" title="5 OpenGL interoperability"></a>5 OpenGL interoperability</h1><h2 id="5-1-不建议使用的OpenGL函数的GLM替代"><a href="#5-1-不建议使用的OpenGL函数的GLM替代" class="headerlink" title="5.1 不建议使用的OpenGL函数的GLM替代"></a>5.1 不建议使用的OpenGL函数的GLM替代</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glRotate&#123;f, d&#125;:</span><br><span class="line">glScale&#123;f, d&#125;:</span><br><span class="line">glTranslate&#123;f, d&#125;:</span><br><span class="line">glLoadIdentity:</span><br><span class="line">glMultMatrix&#123;f, d&#125;:</span><br><span class="line">glLoadTransposeMatrix&#123;f, d&#125;:</span><br><span class="line">glMultTransposeMatrix&#123;f, d&#125;:</span><br><span class="line">glFrustum:</span><br><span class="line">glOrtho:</span><br></pre></td></tr></table></figure>

<h2 id="5-2-GLM替代GLU函数"><a href="#5-2-GLM替代GLU函数" class="headerlink" title="5.2 GLM替代GLU函数"></a>5.2 GLM替代GLU函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gluLookAt:</span><br><span class="line">gluOrtho2D:</span><br><span class="line">gluPerspective:</span><br><span class="line">gluPickMatrix:</span><br><span class="line">gluProject:</span><br><span class="line">gluUnProject:</span><br></pre></td></tr></table></figure>

<h1 id="6-其他记录"><a href="#6-其他记录" class="headerlink" title="6 其他记录"></a>6 其他记录</h1><ul>
<li>绝对不要用<code>using namespace glm;</code></li>
<li>glm可以针对其实现的功能自动生成SIMD优化的代码</li>
<li>某些GLM功能会因除零而崩溃，但这是域错误导致的，比如将空向量glm::normalize函数或将负数传递给std::sqrt</li>
<li>glm是弧度制</li>
</ul>
<p>手册的最后还给出了一些使用glm的项目，真是五花八门五彩缤纷五颜六色啊</p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS下搭建OpenGL环境</title>
    <url>/81586dd4/</url>
    <content><![CDATA[<p>我的环境是macOS Mojave 10.14.4，Xcode 11.3</p>
<a id="more"></a>

<hr>
<h1 id="1-download-something"><a href="#1-download-something" class="headerlink" title="1 download something"></a>1 download something</h1><h2 id="1-1-安装homebrew，安装cmake"><a href="#1-1-安装homebrew，安装cmake" class="headerlink" title="1.1 安装homebrew，安装cmake"></a>1.1 安装homebrew，安装cmake</h2><h2 id="1-2-下载安装glew"><a href="#1-2-下载安装glew" class="headerlink" title="1.2 下载安装glew"></a>1.2 下载安装glew</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install glew</span><br></pre></td></tr></table></figure>

<p>被安装在<code>/usr/local/Cellar/glew</code>路径下，打开finder然后<code>shift+command+g</code>就可以进去，下面两个路径之后会用到的</p>
<p>头文件目录：<code>/usr/local/Cellar/glew/2.1.0_1/include</code></p>
<p>静态库文件：<code>/usr/local/Cellar/glew/2.1.0_1/lib/libGLEW.a</code></p>
<h2 id="1-3-下载安装GLTools"><a href="#1-3-下载安装GLTools" class="headerlink" title="1.3 下载安装GLTools"></a>1.3 下载安装GLTools</h2><p>下载GLTools：<a href="https://github.com/HazimGazov/GLTools" target="_blank" rel="noopener">https://github.com/HazimGazov/GLTools</a></p>
<p>新建位于这个文件夹的终端，然后按照github上的说明编译：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig（macOS不是这句，见下文）</span><br></pre></td></tr></table></figure>

<p>如果没报错啥的话，那么就快乐的装完了OpenGL需要的扩展库</p>
<p>这里需要额外说明的是，github上给出的这五句是针对linux的，所以最后一句在macOS下就会报<code>command not found</code></p>
<p>首先<code>ldconfig</code>这句的作用是：“为了让动态链接库为系统所共享,还需运行动态链接库的管理命令ldconfig”</p>
<p>在stack overflow上有人提问macOS上是否有类似<code>ldconfig</code>这样的指令，有的说没有但是仍然可以通过dyld配置，还有一个回答说有，也就是下面这句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo update_dyld_shared_cache</span><br></pre></td></tr></table></figure>

<p>我试了一下这句（反正最后可以跑起来，所以应该是没什么问题的），关于这个问题的更多讨论可以去看这个 -&gt; <a href="https://stackoverflow.com/questions/1451047/ldconfig-equivalent-in-mac-os-x" target="_blank" rel="noopener">stackoverflow : ldconfig equivalent in Mac OS X?
</a></p>
<h2 id="1-4-下载安装GLFW"><a href="#1-4-下载安装GLFW" class="headerlink" title="1.4 下载安装GLFW"></a>1.4 下载安装GLFW</h2><p>从官网下载source package然后命令行cmake再install一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga6rn8yoejj30te0is0xf.jpg" alt=""></p>
<h1 id="2-创建工程"><a href="#2-创建工程" class="headerlink" title="2 创建工程"></a>2 创建工程</h1><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga6p0pmd86j31qv0u0kcf.jpg" alt=""></p>
<p>不太会用xcode，乱填了，language和storyboard没啥问题应该就行</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga6p7xcx51j31420suwlb.jpg" alt=""></p>
<h1 id="3-添加依赖库"><a href="#3-添加依赖库" class="headerlink" title="3 添加依赖库"></a>3 添加依赖库</h1><p>建好项目之后，从上面的菜单进入「Build Phases」，其中第三行「Link Binary Libraries」，添加五个依赖库：「OpenGL.framework」/「GLUT.framework」/「IOKit.framework」/「Cocoa.framework」/「CoreVideo.framework」</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaf2m5lr1oj315u0owtcb.jpg" alt=""></p>
<h1 id="4-配置路径"><a href="#4-配置路径" class="headerlink" title="4 配置路径"></a>4 配置路径</h1><h2 id="4-1-Frameworks"><a href="#4-1-Frameworks" class="headerlink" title="4.1 Frameworks"></a>4.1 Frameworks</h2><p><code>GLTools-master/build/libgltools.a</code>和<code>/usr/local/Cellar/glew/2.1.0_1/lib/libGLEW.a</code>拖到项目目录最下面的「Frameworks」里面</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga6twrpfmyj30as06240i.jpg" alt=""></p>
<h2 id="4-2-Header-Search-Paths"><a href="#4-2-Header-Search-Paths" class="headerlink" title="4.2 Header Search Paths"></a>4.2 Header Search Paths</h2><p>在「Build Settings」里搜索「search paths」，上面的小标签选「All」和「Levels」，把gltools和glew和glfw的<code>include</code>库目录路径都直接拖到到「Header Search Paths」里面</p>
<p>比如我的三个加完是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;$(SRCROOT)&#x2F;..&#x2F;..&#x2F;Downloads&#x2F;GLTools-master&#x2F;include&quot;</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;glew&#x2F;2.1.0_1&#x2F;include</span><br><span class="line">&quot;$(SRCROOT)&#x2F;..&#x2F;..&#x2F;Downloads&#x2F;glfw-3.3&#x2F;include&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga6romrhoyj318g07441p.jpg" alt=""></p>
<h2 id="4-3-Library-Search-Paths"><a href="#4-3-Library-Search-Paths" class="headerlink" title="4.3 Library Search Paths"></a>4.3 Library Search Paths</h2><p>然后「Library Search Paths」是放lib目录的，放上GLTools的build目录，因为<code>.a</code>静态库文件在这个里面</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga6tzyv4b5j30ym0800vn.jpg" alt=""></p>
<h1 id="5-main-cpp"><a href="#5-main-cpp" class="headerlink" title="5 main.cpp"></a>5 main.cpp</h1><p>新建一个main.cpp文件，菜单栏「file」-「new file」-「file」-「c++ file」（不需要头文件）</p>
<p>然后把这五个删了：main.m/ViewController.m/Viewcontroller.h/AppDelegate.m/AppDelegate.h</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga6q7p8vagj30ty05gmxq.jpg" alt=""></p>
<p>下面的代码是抄的<a href="https://juejin.im/post/5d91733af265da5bb74643b5" target="_blank" rel="noopener">别人教程</a>里的，随便改了点小东西，来测测是不是能跑了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;GLShaderManager.h&quot;</span><br><span class="line">#include &quot;GLTools.h&quot;</span><br><span class="line">#include &lt;glut&#x2F;glut.h&gt;</span><br><span class="line"></span><br><span class="line">GLBatch triangleBatch;</span><br><span class="line"></span><br><span class="line">GLShaderManager shaderManager;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;窗口大小改变时接受新的宽度和高度，其中0,0代表窗口中视口的左下角坐标，w，h代表像素</span><br><span class="line">void ChangeSize(int w,int h) &#123;</span><br><span class="line">    </span><br><span class="line">    glViewport(0,0, w, h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;为程序作一次性的设置</span><br><span class="line">void SetupRC() &#123;</span><br><span class="line">    &#x2F;&#x2F;设置背影颜色</span><br><span class="line">    glClearColor(1.0f,0.6f,1.0f,0.0f);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;初始化着色管理器</span><br><span class="line">    shaderManager.InitializeStockShaders();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;设置三角形，其中数组vVert包含所有3个顶点的x,y,笛卡尔坐标对。</span><br><span class="line">    GLfloat vVerts[] &#x3D; &#123;</span><br><span class="line">        -0.5f,0.0f,0.5f,</span><br><span class="line">        </span><br><span class="line">        0.5f,0.0f,0.0f,</span><br><span class="line"></span><br><span class="line">        0.0f,0.7f,0.0f,</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;批次处理</span><br><span class="line">    triangleBatch.Begin(GL_TRIANGLES,3);</span><br><span class="line">    </span><br><span class="line">    triangleBatch.CopyVertexData3f(vVerts);</span><br><span class="line">    </span><br><span class="line">    triangleBatch.End();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;开始渲染</span><br><span class="line">void RenderScene(void) &#123;</span><br><span class="line">    &#x2F;&#x2F;清除一个或一组特定的缓冲区</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;设置一组浮点数来表示紫色</span><br><span class="line">    GLfloat vRed[] &#x3D; &#123;0.8f,0.2f,1.0f,1.0f&#125;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;传递到存储着色器，即GLT_SHADER_IDENTITY着色器，这个着色器只是使用指定颜色以默认笛卡尔坐标第在屏幕上渲染几何图形</span><br><span class="line">    shaderManager.UseStockShader(GLT_SHADER_IDENTITY,vRed);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;提交着色器</span><br><span class="line">    triangleBatch.Draw();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;将在后台缓冲区进行渲染，然后在结束时交换到前台</span><br><span class="line">    glutSwapBuffers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc,char* argv[]) &#123;</span><br><span class="line">    &#x2F;&#x2F;设置当前工作目录，针对MAC OS X</span><br><span class="line">    gltSetWorkingDirectory(argv[0]);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;初始化GLUT库</span><br><span class="line">    glutInit(&amp;argc, argv);</span><br><span class="line">    </span><br><span class="line">    &#x2F;*初始化双缓冲窗口，其中标志GLUT_DOUBLE、GLUT_RGBA、GLUT_DEPTH、GLUT_STENCIL分别指</span><br><span class="line">     双缓冲窗口、RGBA颜色模式、深度测试、模板缓冲区*&#x2F;</span><br><span class="line">    glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGBA|GLUT_DEPTH|GLUT_STENCIL);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;GLUT窗口大小，标题窗口</span><br><span class="line">    glutInitWindowSize(800,600);</span><br><span class="line">    </span><br><span class="line">    glutCreateWindow(&quot;Triangle&quot;);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;注册回调函数</span><br><span class="line">    glutReshapeFunc(ChangeSize);</span><br><span class="line">    </span><br><span class="line">    glutDisplayFunc(RenderScene);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;驱动程序的初始化中没有出现任何问题。</span><br><span class="line">    GLenum err &#x3D; glewInit();</span><br><span class="line">    </span><br><span class="line">    if(GLEW_OK !&#x3D; err) &#123;</span><br><span class="line">        fprintf(stderr,&quot;glew error:%s\n&quot;,glewGetErrorString(err));</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;调用SetupRC</span><br><span class="line">    SetupRC();</span><br><span class="line">    glutMainLoop();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-运行"><a href="#6-运行" class="headerlink" title="6 运行"></a>6 运行</h1><p>第一次run的时候出问题了QWQ</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga6r1icxmzj31bc0muk2a.jpg" alt=""></p>
<p>报错<code>library not found for -lgltools</code>，看了一些关于library-not-found相关的问题：<a href="https://stackoverflow.com/questions/11358591/xcode-library-not-found" target="_blank" rel="noopener">stackoverflow : xcode library not found
</a>，应该是gltool的时候有什么库没有链接好之类的</p>
<p>然后我就去把之前的GLTools的库重新编译了一遍然后做了4.3节的内容（之前没有做）</p>
<p>然后就succeeded啦(≧▽≦)，效果是这样哒</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga6u4gey9ej312i0u03zx.jpg" alt=""></p>
<hr>
<h1 id="ADD：GLM库"><a href="#ADD：GLM库" class="headerlink" title="ADD：GLM库"></a>ADD：GLM库</h1><p>因为后来还用到了GLM库，所以最后再顺便补上一点GLM库的配置，其实和上面那些glew啥的差不多</p>
<p>首先去github下载GLM库：<a href="https://github.com/g-truc/glm" target="_blank" rel="noopener">https://github.com/g-truc/glm</a></p>
<p>然后把下好的直接拖到「Header Search Paths」里面就可以了</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga70ioaferj30t409g41q.jpg" alt=""></p>
<p>然后就可以导入开始用啦～</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga70jx5kiej30dm036mxf.jpg" alt=""></p>
<p>一开始都是照着别的教程做的，其实理解了熟练了之后就不用这样了，为了便于管理这些到时候把需要的库文件都放在一个include文件夹下，然后一次导入就好了</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga7ytu4wngj30zw0m643b.jpg" alt=""></p>
<hr>
<p>最后再放上一个很棒的OpenGL教程，感谢原作者和译者 -&gt; <a href="https://learnopengl-cn.github.io/#" target="_blank" rel="noopener">https://learnopengl-cn.github.io/#</a></p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>流体模拟《Fluid Simulation for Computer Graphics》——从入门到放弃（五）综合与理解</title>
    <url>/5e7e97c4/</url>
    <content><![CDATA[<p><a href="https://leflacon.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" target="_blank" rel="noopener">这个系列</a>前四篇看的时候啥都不会，很多很多都不懂，只是非常粗浅的就表面翻译进行了笨拙的理解，尤其是流体算法的部分，，what a mess，，，所以需要停下来做一个综合的整理和回顾，有些内容是直接摘录前几篇的说明，有些内容是增加了更系统更准确一点点的说明。</p>
<p>有错请尽管联系我，我理解错误什么的，，那可太正常了QAQ，，感激不尽:D</p>
<hr>
<h1 id="1-Navier-Stokes方程组"><a href="#1-Navier-Stokes方程组" class="headerlink" title="1 Navier-Stokes方程组"></a>1 Navier-Stokes方程组</h1><p>从不可压缩的<strong>Navier-Stokes方程组</strong>开始。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9f7kqzq1tj30bq03qwem.jpg" alt=""></p>
<h2 id="1-1-动量方程"><a href="#1-1-动量方程" class="headerlink" title="1.1 动量方程"></a>1.1 动量方程</h2><p>方程组里的第一个方程也叫<strong>动量方程</strong>，其本质就是牛二定律<code>F=ma</code>。</p>
<ul>
<li><strong>u</strong>表示速度场中的速度，在三维空间中的分解形式为(u,v,w)</li>
<li><code>ρ</code>表示流体密度</li>
<li><code>p</code>表示压力</li>
<li><strong>g</strong>表示重力加速度</li>
<li><code>ν</code>表示运动粘度（描述了流体在运动时抵抗变形的能力）</li>
</ul>
<p><code>a=Du/Dt</code>，根据牛二定律有<code>m*Du/Dt=F</code>。</p>
<p>这个合力F包括内力/外力。</p>
<h2 id="1-2-内力"><a href="#1-2-内力" class="headerlink" title="1.2 内力"></a>1.2 内力</h2><p>内力是影响流体粒子与附近其他粒子相互作用的两种流体力，一种是压力，一种是由流体粘度引起的力。</p>
<p>首先是<strong>压力</strong>，因为外力施加在流体上的时候，外力并没有马上传导到整个流体，而是在受力区附近产生高压，然后高压区推向低压区（所以要取负压力梯度：<code>−∇p</code>），这个值乘以体积V（这里研究的都是不可压缩流体，所以V为常量），就是别的粒子施加给它的压力和<code>−V∇p</code>。</p>
<p>第二种内力由<strong>流体粘度</strong>引起，粘性流体试图抵抗变形，这种内力试图使这个粒子以周围粒子的平均速度运动，即邻近粒子之间的速度差异最小化。这种粘度造成了动量的扩散，也可以称为<strong>数值粘性/人工粘度/假扩散</strong>。比如下图这样的随着移动边界模糊。</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g9eyiinqplj20j806kmxe.jpg" alt=""></p>
<p>这个粘度的力是这么计算的，用拉普拉斯算子<code>∇·∇</code>衡量一个量与周围平均数的差，µ是一个粘滞系数，然后乘以体积V，就得到了这一项：<code>Vµ∇·∇u</code>。</p>
<h2 id="1-3-外力"><a href="#1-3-外力" class="headerlink" title="1.3 外力"></a>1.3 外力</h2><p>外力就是均匀的作用于整个流体的力，所以主要就是考虑<strong>重力</strong>，重力似乎没啥好说的：<code>mg</code>。</p>
<h2 id="1-4-进一步推导"><a href="#1-4-进一步推导" class="headerlink" title="1.4 进一步推导"></a>1.4 进一步推导</h2><p>把上面这些作用力都加起来，就可以得到由牛二而来的这个等式：<code>m*Du/Dt=mg−V∇p+Vµ∇·∇u</code>。</p>
<p><code>Du/Dt</code>是一个全微分项，根据链式法则，可以得到：<img src="http://ww1.sinaimg.cn/large/dda38d2bly1g9ezgrvflcj20j402xaaa.jpg" alt="">，用<code>Du/Dt</code>替换<code>F=ma</code>里的加速度a，就可以得到动量方程。</p>
<h2 id="1-5-不可压缩"><a href="#1-5-不可压缩" class="headerlink" title="1.5 不可压缩"></a>1.5 不可压缩</h2><p>真实的流体，甚至是水这样的液体体积也会改变，但通常变化不大。这样的研究对象称为可压缩流，研究起来很复杂，而宏观上的影响又不大，所以就应用层面来说没必要考虑。</p>
<p>所以在流体模拟中一个前提条件是流体体积变化率为0（不可压缩），对应着Navier-Stokes方程组里的第二个式子：<code>∇·u=0</code>。</p>
<p>具体推导过程如下：</p>
<p>对于流体中一个确定的区域<code>Ω</code>，边界是<code>∂Ω</code>，不可压缩流体，所以这个区域<code>Ω</code>体积变化率为0，即：<img src="http://ww1.sinaimg.cn/large/dda38d2bly1g9f0l8bfayj205q024mx0.jpg" alt="">)。由高斯公式有：<img src="http://ww1.sinaimg.cn/large/dda38d2bly1g9f0mno9iqj20d602kdfr.jpg" alt="">，也就是对于任意<code>Ω</code>都不可压缩，所以整个流体的体积变化率也是0。然后就可以得到<code>∇·u=0</code>。</p>
<h2 id="1-6-Material-derivative"><a href="#1-6-Material-derivative" class="headerlink" title="1.6 Material derivative"></a>1.6 Material derivative</h2><p>最后，再补上一个叫<strong>物质导数</strong>的东西，根据链式法则得到下式。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8wmwqis7nj30d601jt8q.jpg" alt=""></p>
<p>其中<code>q</code>表示通过流体传输的模拟量之一（比如温度），<code>t</code>表示时间。<code>∂q/∂t</code>就表示了<code>q</code>在固定点变化的速度。第二项<code>u⋅∇q</code>纠正多少变化是由于流体流过的差异。</p>
<h1 id="2-Simulation-Viewpoints（模拟视角）"><a href="#2-Simulation-Viewpoints（模拟视角）" class="headerlink" title="2 Simulation Viewpoints（模拟视角）"></a>2 Simulation Viewpoints（模拟视角）</h1><p>跟踪运动的流体或可变形固体（连续体）的运动有两种途径：<strong>欧拉视角</strong>，<strong>拉格朗日视角</strong>。</p>
<h2 id="2-1-拉格朗日视角"><a href="#2-1-拉格朗日视角" class="headerlink" title="2.1 拉格朗日视角"></a>2.1 拉格朗日视角</h2><p>把流体看成许多点，每个点都标记为一个单独的粒子，有各自的位置<strong>x</strong>，速度<strong>u</strong>。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8vpktjumaj30ax078jrx.jpg" alt=""></p>
<h2 id="2-2-欧拉视角"><a href="#2-2-欧拉视角" class="headerlink" title="2.2 欧拉视角"></a>2.2 欧拉视角</h2><p>在空间上保持固定点，关注这些空间中的固定点，查看这些点所处的流体（速度/温度等）如何随时间变化。</p>
<p>在这种视角下，更容易在固定的欧拉网格上对一些流体量的空间导数进行分析及对这些导数进行数值逼近（而拉格朗日视角下是一堆位置任意的点集，相对获取空间导数难很多）。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8vpvrgduxj30cq08ht9b.jpg" alt=""></p>
<h2 id="2-3-两种视角的关系"><a href="#2-3-两种视角的关系" class="headerlink" title="2.3 两种视角的关系"></a>2.3 两种视角的关系</h2><p>这两种视角之间还是可以联系在一起的，联系上面的1.6节的式子。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8wmwqis7nj30d601jt8q.jpg" alt=""></p>
<p>1.6节表明从拉格朗日视角出发探究每个粒子<code>q</code>值的变化情况，链式法则推导可知每个粒子对应的物理量<code>q</code>在流体运动过程中只是被传递，而不会发生改变。其中等式右边的<code>∂q/∂t</code>就表示了<code>q</code>在固定点变化的速度，也就是在欧拉视角下，这个<code>q</code>是个不变量。</p>
<h1 id="3-流体算法"><a href="#3-流体算法" class="headerlink" title="3 流体算法"></a>3 流体算法</h1><h2 id="3-1-拉格朗日方法"><a href="#3-1-拉格朗日方法" class="headerlink" title="3.1 拉格朗日方法"></a>3.1 拉格朗日方法</h2><p><strong>拉格朗日方法</strong>显然是在拉格朗日视角下的方法，把流体模拟成很多离散的粒子，只要能描述任意一个粒子的运动状况（位置随时间变化的规律等），那么就可以获得整个流体的运动状况。</p>
<p>还是从不可压缩的Navier-Stokes方程组开始：</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9f7kqzq1tj30bq03qwem.jpg" alt=""></p>
<p>接下来就是要求解这个方程，引入<strong>SPH方法</strong>（光滑粒子流体动力学方法）。</p>
<p>首先引入一个<strong>光滑核</strong>的概念，每个粒子属性都会扩散到它周围，影响周围的粒子，越远那么影响就越小，这种随着距离衰减的函数就是<strong>光滑核函数</strong>。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9f2y6n323j30ei07at97.jpg" alt=""></p>
<p>然后考虑流体中某点<strong>r</strong>（点和粒子区分，某点不一定有粒子），以这个点为圆心，光滑核半径h为半径的圆中有其他粒子<strong>r0,r1,…,rj</strong>，那么点<strong>r</strong>处就有一个关于属性A的累加公式：<img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9f34o5ebhj309z02u74e.jpg" alt="">，其中Aj/mj/ρj代表其他粒子的属性A/质量/密度，W是光滑核函数（其实所有粒子质量一样，都是m）。</p>
<p>再考虑流体中一个位置为<strong>ri</strong>的点，由牛二推导的式子可得：<img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9f395o5zpj30bt03bmxd.jpg" alt="">)，其中u(ri)/p(ri)/ρ(ri)分别代表此处的速度/压力/密度。</p>
<p>接下来就是每一项分开求解的过程了，比如说要求密度，那么把关于属性A的累加公式里的A换成密度ρ，然后取一个光滑核函数，经过推导得到密度计算公式。（此处太过复杂，文末给出的那个“SPH算法系列”中大神博主已给出了非常详细的推导）</p>
<p>最后，虽然把流体想象成很多粒子的想法很合理，但这是一种不规则离散，在实际中很难计算（2.2节中做了说明），需要对无数多的粒子进行跟踪；而核函数的选取也很重要；并且【本系列第四篇第8节】里的用于表面追踪的水平集方法在构造光滑液体表面的问题上大大优于粒子提取出的表面；但是这种方法不需要网格划分。如果是不规则的边界条件或者多种流体混合作用，就还是用拉格朗日方法。</p>
<p>更常用的是接下来的欧拉方法。</p>
<h2 id="3-2-欧拉方法"><a href="#3-2-欧拉方法" class="headerlink" title="3.2 欧拉方法"></a>3.2 欧拉方法</h2><p><strong>欧拉方法</strong>就是欧拉视角下的方法。欧拉方法用网格法对Navier-Stokes方程组进行离散化，研究空间中的固定点，用有限差分求解。</p>
<p>还是从不可压缩的Navier-Stokes方程组开始：</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9f7kqzq1tj30bq03qwem.jpg" alt=""></p>
<p>对于任意一个确定的位置<strong>x</strong>和确定的时刻t，用矢量场<strong>v</strong>(x,y,z,t)描述流体的速度，标量场p(x,t,z,t)描述流体的压强。</p>
<p>网格法有两种，最流行的是MAC法（标记网格法），在【本系列第二篇文章4.2节】中描述了。看下图就很直观：压力定义在格子中心，r方向速度分量定义在格子左右边界中点，y方向速度分量定义在格子上下边界中点，三维同理。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9f47u93mnj30pq0b8whu.jpg" alt=""></p>
<p>还有一种方法是把所有数据都标记在网格节点上。</p>
<p>然后回到欧拉方法，有限差分求解三维Navier-Stokes方程组，半拉格朗日方法求解动量方程的对流项【本系列第三篇文章的第5节】，隐式方法求解粘度和压强。具体步骤是：初始为<code>u0(x)</code>，先增加合力得<code>u1(x)</code>，然后求解对流项得<code>u2(x)</code>，再求解粘度得<code>u3(x)</code>，最后投影得<code>u4(x)</code>。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9f4f0ll5qj30ir08e0tx.jpg" alt=""></p>
<p>欧拉方法和用于表面追踪的水平集方法结合，可以达到很好的效果。</p>
<hr>
<p>最后放上所有厉害资料集合，非常特别宇宙无敌感谢！！！</p>
<ul>
<li>论文《Fluid Simulation for Computer Graphics》，传说中的流体模拟入门书：<a href="https://dspace.library.uu.nl/handle/1874/273891" target="_blank" rel="noopener">https://dspace.library.uu.nl/handle/1874/273891</a></li>
<li>share一个图形学论文合集的网站：<a href="http://kesen.realtimerendering.com/" target="_blank" rel="noopener">http://kesen.realtimerendering.com/</a></li>
<li>share一份github犄角旮旯里发现的很有帮助的学习资料：<a href="https://github.com/muacq/FluidSimulation" target="_blank" rel="noopener">https://github.com/muacq/FluidSimulation</a></li>
<li>share一个很厉害的博主写的SPH算法系列文章，写的特别特别清楚：<a href="https://thecodeway.com/blog/?s=SPH" target="_blank" rel="noopener">https://thecodeway.com/blog/?s=SPH</a></li>
</ul>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>阅读笔记</tag>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>流体模拟《Fluid Simulation for Computer Graphics 》——从入门到放弃（四）烟雾模拟/涡度限制/表面追踪/水平集方法</title>
    <url>/d3ffa84b/</url>
    <content><![CDATA[<p><a href="https://leflacon.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" target="_blank" rel="noopener">从入门到放弃系列</a></p>
<p>学的都是个啥，，开始怀疑人生ಥ_ಥ</p>
<p>有些提到的东西可以在前置文章里找到，哪里理解错误啥的请指出3Q</p>
<hr>
<p>开头再放上之前提到的Navier-Stokes方程和变量：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8vpxst924j30ep02paa5.jpg" alt=""></p>
<ul>
<li>向量<code>u</code>表示流体速度</li>
<li><code>ρ</code>表示流体密度</li>
<li><code>p</code>表示压力，<code>1\ρ ∇p</code>体现了压力对流体的影响</li>
<li>向量<code>g</code>表示重力加速度</li>
<li><code>ν</code>表示运动粘度</li>
<li><code>q</code>表示通过流体传输的模拟量之一（比如温度）</li>
<li><code>t</code>表示时间</li>
</ul>
<hr>
<h1 id="7-烟雾"><a href="#7-烟雾" class="headerlink" title="7 烟雾"></a>7 烟雾</h1><p>在流体是烟雾的情况下，模拟烟雾需要两个额外的变量：</p>
<ul>
<li>空气的温度<code>T</code>（摄氏度）</li>
<li>烟雾颗粒的浓度<code>s</code>（0-1之间）</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8zwfd5ivqj306401nq2x.jpg" alt=""></p>
<p>二者材料导数都为0。然后研究<code>T</code>和<code>s</code>对流体速度有什么影响，我们知道热空气会上升，冷空气会下沉；好像载有较重烟雾颗粒的空气在重力作用下会被往下拉。我们可以用之前那个动量方程，然后用浮力加速度代替原来的重力加速度<code>g</code>：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8zwoa53mtj30ec00wdfu.jpg" alt=""></p>
<p>其中<code>α</code>和<code>β</code>是非负系数，<code>T_amb</code>是环境温度，比如<code>s=0</code>且<code>T=T_amb</code>的时候，这个就相当于环境里的空气，自然有<code>b=0</code>。</p>
<h2 id="7-1-烟雾来源"><a href="#7-1-烟雾来源" class="headerlink" title="7.1 烟雾来源"></a>7.1 烟雾来源</h2><p>通常要定义一个烟雾源头区域，对这个区域每个时间间隔都要增加一点烟雾和热量。对烟雾源头的每个网格点的更新公式如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8zx0festlj30ku04d74j.jpg" alt=""></p>
<p>其中<code>r_t</code>和<code>r_s</code>用于控制添加烟雾和热量的速率（在烟雾源头外这两个量都为0），<code>T_target</code>表示源头的温度。</p>
<h2 id="7-2-热量和烟雾的扩散"><a href="#7-2-热量和烟雾的扩散" class="headerlink" title="7.2 热量和烟雾的扩散"></a>7.2 热量和烟雾的扩散</h2><p>热量和烟雾也可以扩散，在这种情况下，小规模的现象（比如传导和布朗运动）或是大规模的现象（比如紊流混合），用于平滑梯度。这可以用拉普拉斯算子建模：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8zxbmrn1fj309901k0sr.jpg" alt=""></p>
<p>其中<code>k_T</code>和<code>k_s</code>是非负扩散常数。</p>
<p>比如温度扩散就是下面这个式子：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8zzhlwff0j30lk024q32.jpg" alt=""></p>
<h2 id="7-3-vorticity-confinement（涡度限制）"><a href="#7-3-vorticity-confinement（涡度限制）" class="headerlink" title="7.3 vorticity confinement（涡度限制）"></a>7.3 vorticity confinement（涡度限制）</h2><p>涡度限制是对Navier-Stokes方程的一种试图保留涡度的修改。引入<code>Δx</code>，这样在极限中涡度就没了。基本思想是检测旋涡的位置，并且增加一个力来满足每个旋涡周围的旋转运动，这样旋涡位置速度快于周围所有流体，可以简单的通过标准化<code>𝛚</code>的梯度来构造指向这些漩涡中心的单位向量<code>N</code>：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g900mv185rj30dd01zjre.jpg" alt=""></p>
<p>现在<code>N</code>指向旋涡的旋转中心，<code>𝛚</code>方向沿旋转轴，所以要获得增加的那个旋转力，只要一个叉积：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g900pajth5j30dw00w3yi.jpg" alt=""></p>
<p>其中<code>ε</code>是一个可以调整涡度限制效果的参数。</p>
<h2 id="7-4-Divergence-Control（发散控制）"><a href="#7-4-Divergence-Control（发散控制）" class="headerlink" title="7.4  Divergence Control（发散控制）"></a>7.4  Divergence Control（发散控制）</h2><p>通过使用这种浮力模型，假设流体密度是温度和烟雾浓度的函数（烟雾溶解在空气中）。在热膨胀问题中，流体应该在加热时膨胀在冷却时收缩，即在<code>DT/Dt≠0</code>时，我们不需要无散度的速度场。如果温度升高导致密度降低，那么我们需要正散度来实施这个热膨胀。可以通过在网格单元中心定义一个控制场<code>d(x)</code>，它等于在整个流体体积中的体积分数变化率<code>(ΔV/V)·Δt</code>，然后通过压力来求解这种差异。</p>
<p>文中是在使用MAC网格的数值离散的压力求解部分，将<code>d</code>加到线性系统的流体单元的右手侧。</p>
<h1 id="8-表面追踪"><a href="#8-表面追踪" class="headerlink" title="8 表面追踪"></a>8 表面追踪</h1><p>对于液体（比如水），需要找到一种方法来跟踪液体表面。这是通过使用隐式表面表示或者不同隐式表面组合来实现的。</p>
<h2 id="8-1-Tracker-particles（跟踪器粒子）"><a href="#8-1-Tracker-particles（跟踪器粒子）" class="headerlink" title="8.1 Tracker particles（跟踪器粒子）"></a>8.1 Tracker particles（跟踪器粒子）</h2><p>首先用粒子填充水体积并将其视为水的几何形状（如果存在水源添加水，那么也需要从水源处添加粒子）。在每个对流步骤中，根据网格速度场移动粒子，最后包含粒子的单元格都是水，其余单元格留空。在渲染过程中，在水和空气之间形成光滑的表面，也就是构建一层包裹在粒子周围的光滑的隐式表面：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g90dgq1raij30dy018t8p.jpg" alt=""></p>
<p>其中<code>X̄</code>是周围粒子位置的加权平均值，<code>杠r</code>是周围粒子半径的加权平均值，曲面定义为<code>φ(x) = 0</code>的所有<code>向量x</code>代表的点，也就是<code>φ</code>的零等高线或者水平集。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g90dnh7f2ij30cx0dtte1.jpg" alt=""><br>（利用粒子跟踪和渲染流体的二维模拟图）</p>
<h2 id="8-2-水平集方法"><a href="#8-2-水平集方法" class="headerlink" title="8.2 水平集方法"></a>8.2 水平集方法</h2><p>在数学中，n个变量的实值函数<code>f</code>的水平集是形式为<code>Lc(f)={(x1,…,xn)∣f(x1,…, xn)=c}</code>的集合，也就是取定一个常数<code>c</code>然后取满足<code>f(X)=c</code>的集合就好了。</p>
<p>所以不用像8.1里一样围绕粒子构建隐式函数，而是直接使用网格。在网格单元的中心定义隐式曲面函数<code>φ_(i,j,k)</code>，可以用插值来估计<code>φ(x)</code>，表面就是满足<code>φ(x)=0</code>的点集，表面内部有<code>φ(x)&lt;0</code>，外部有<code>φ(x)&gt;0</code>。</p>
<p><strong>Signed distance</strong>（距离）</p>
<p>给定一个点集<code>S</code>，定义一个距离函数，可以获得任意一点到<code>S</code>中一点的最短距离：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g90uwvpy9uj30es01amx7.jpg" alt=""></p>
<p>如果<code>S</code>将空间划分为内部和外部的话，那么对应的符号情况如下：（外部为<code>distance(x)</code>，内部为<code>-distance(x)</code>）</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g90uyuo49bj308o01nwek.jpg" alt=""></p>
<p>综上，<code>S</code>就是<code>φ(x)=0</code>或<code>distance(x)=0</code>的点集。</p>
<p><strong>Signed distance properties</strong>（一些性质）</p>
<ol>
<li>在表面内的某个点<code>x</code>处，设<code>n</code>为朝表面点集距离最近点的方向的单位向量，对于一定范围的正数<code>ε</code>，有<code>φ(x+εn)=φ(x)+ε</code>。因为如果沿<code>n</code>方向移动，在表面上的那个最近点是不变的。所以有下面这个式子：</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g90xktvwu2j30c7017749.jpg" alt=""></p>
<ol start="2">
<li>增大或减小到表面的距离的最快方法就是沿着<code>n</code>，所以<code>φ</code>的梯度必须是<code>n</code>的方向（到最近点）。</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g90xnat7asj30c701d3yh.jpg" alt=""></p>
<ol start="3">
<li>将1、2中的两个式子(25)(26)结合得：</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g90xo0htmhj30cf01l3yh.jpg" alt=""></p>
<ol start="4">
<li>对于任意点，离表面的最近点为：（后面那坨其实就是求出来一个那个方向上的距离向量了）</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g90xox0o7jj30l401bwel.jpg" alt=""></p>
<p><strong>Calculating the signed distance</strong>（计算）</p>
<p>给出一种基于几何的计算距离的算法，这个算法可以将有关表面的信息有效的传播到远处的网格点，而不用对表面上的每个点进行暴搜：</p>
<ol>
<li>找到临近网格点的最近表面点，设定他们的距离，其他网格点的距离设为未知</li>
<li>以选定的顺序遍历周围的未知的那些网格点(i,j,k)，如果新的点到表面的距离更近，那么将这个点周围的点标记为未知（这里的所有距离都按前文说的是带符号的距离）</li>
</ol>
<p>此外，这个循环顺序是按照所有未知点从近到远的顺序，靠优先队列来实现即可。</p>
<p>（英语太差了，，这部分感觉没翻译明白，，，总之我觉得意思就是不用暴力，每次可以贪心的向那个距离下降最快的方向找到一个更优的参考点，然后把它周围的点加入未知集合中，在下一轮循环中继续从近到远循环未知点，，应该是这个意思吧）</p>
<p><strong>Advecting Level Set</strong></p>
<p>水-空气之间的表面已经解决了，还要考虑实心墙的边界条件，一种可行的方法是将<code>φ</code>从水-空气区域外推到固体中。</p>
<p>（下面咋外推的就没看懂了，，略过）</p>
<p><strong>Current Fluid Simulation Loop</strong></p>
<p>（没看懂0.0，，）</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g911xh3uprj30k906tmy6.jpg" alt=""></p>
<h2 id="8-3-粒子水平集（PLS）"><a href="#8-3-粒子水平集（PLS）" class="headerlink" title="8.3 粒子水平集（PLS）"></a>8.3 粒子水平集（PLS）</h2><p>PLS用辅助标记粒子优化了上面8.2的欧拉水平集方法，在表面的正反面都添加辅助粒子，每个粒子除了自身位置外，还有一个<code>φ</code>值估计。在每个时间间隔粒子都会移动。此外还需要对那些溢出的粒子进行一点纠错操作：比如空气颗粒落入水中或者水颗粒落入空气中等等。最后，删除那些离零水平集太远的粒子，并在靠近边界的地方添加新粒子。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g912id147lj30cz0exk03.jpg" alt=""><br>（利用粒子水平集方法跟踪流体的二维模拟图，红色粒子是空气边界，绿色粒子是水边界）</p>
<hr>
<p>to be continued…</p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>阅读笔记</tag>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>流体模拟《Fluid Simulation for Computer Graphics 》——从入门到放弃（三）半拉格朗日对流/插值/MacCormack方法/压力求解</title>
    <url>/7a18301b/</url>
    <content><![CDATA[<p><a href="https://leflacon.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" target="_blank" rel="noopener">从入门到放弃系列</a></p>
<p>┬─┬﻿ ノ( ゜-゜ノ)啊啊啊啊啊啊啊啊啊啊数值分析好难啊啊啊啊啊啊啊啊啊（(╯‵□′)╯︵┻━┻在线暴躁，，真学不动了嘛就QWQ</p>
<p>接<a href="http://leflacon.github.io/2aa198bc" target="_blank" rel="noopener">上一篇文章：流体模拟《Fluid Simulation for Computer Graphics<br>》——从入门到放弃（二）模拟视角/Navier-Stokes流体方程/MAC法</a>，有些提到的东西可以在前置文章里找到，哪里理解错误啥的请指出3Q</p>
<a id="more"></a>

<hr>
<p>开头再放上前一篇博客里的Navier-Stokes方程和变量：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8vpxst924j30ep02paa5.jpg" alt=""></p>
<ul>
<li>向量<code>u</code>表示流体速度</li>
<li><code>ρ</code>表示流体密度</li>
<li><code>p</code>表示压力，<code>1\ρ ∇p</code>体现了压力对流体的影响</li>
<li>向量<code>g</code>表示重力加速度</li>
<li><code>ν</code>表示运动粘度</li>
<li><code>q</code>表示通过流体传输的模拟量之一（比如温度）</li>
<li><code>t</code>表示时间</li>
</ul>
<hr>
<h1 id="5-对流"><a href="#5-对流" class="headerlink" title="5 对流"></a>5 对流</h1><h2 id="5-1-半拉格朗日对流"><a href="#5-1-半拉格朗日对流" class="headerlink" title="5.1 半拉格朗日对流"></a>5.1 半拉格朗日对流</h2><p>首先要寻找出发点。为了在某<code>向量x</code>处得到<code>q</code>的新值，我们可以找到理论上以<code>向量x</code>结尾的粒子然后得到对应的<code>q</code>值。</p>
<p>我们已经知道了这个向量结尾的粒子在哪，并且这个粒子移动速度为向量<code>u</code>，把我们关注的这个网格点记为向量<code>x_G</code>，那么我们要求的就是<code>(q_G)^(n+1)</code>（这个网格点G在n+1时刻对应的<code>q</code>值）。如果一个旧粒子也是<code>x_G</code>结尾并且它的<code>q</code>值为<code>(q_P)^n</code>，那么时间经过<code>Δt</code>后，<code>(q_G)^(n+1)=(q_P)^n</code>。</p>
<p>就是通过前向欧拉法求解这个出发点：<img src="http://ww1.sinaimg.cn/large/dda38d2bly1g8xwbba2bsj204x00sdfm.jpg" alt="">。但是前向欧拉法是一阶精度的，文中使用的是更高精度的Runge-Kutta方法（龙格-库塔方法）。</p>
<blockquote>
<p>前向欧拉法这个可以看这个：<a href="http://web.mit.edu/10.001/Web/Course_Notes/Differential_Equations_Notes/node3.html" target="_blank" rel="noopener">Forward and Backward Euler Methods</a>，，一点点都看不进去，，总之这个东西是拿来解常微分方程的就是了</p>
</blockquote>
<h2 id="5-2-插值"><a href="#5-2-插值" class="headerlink" title="5.2 插值"></a>5.2 插值</h2><p>大多数情况下这个<code>x_P</code>可能不在网格点上，这样就不能获得确切的值，但是可以通过对附近点的插值来获得近似值。</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g8xnzt5nccj205x01ba9v.jpg" alt=""></p>
<p>影响数值方法稳定性的关键因素是<code>Δt</code>，半拉格朗日对流对<code>Δt</code>无条件稳定，无论粒子从哪到哪，都可以从<code>q</code>的旧值差值得到新的<code>q</code>值，所以<code>q</code>保持有界。</p>
<p>如果只考虑模拟的实时速率，那么<code>Δt</code>可以设置成帧与帧的时间间隔。在大多数情况下需要对<code>Δt</code>进行限制（不能太大），<code>Δt≤3Δx/u_max</code>其中<code>u_max</code>是估计的流体的最大速度。</p>
<p>插值的时候利用上一步的值的加权平均值，平均操作可以平滑或模糊尖锐的特征（这样会有数值耗散），使用简单的半拉格朗日方法的尝试求解不具有粘性的对流方程时，结果看起来像是在模拟具有粘性的流体（因为都被平滑掉了好像粘的流体流不动一样）。</p>
<p>可以用Catmull-Rom插值进行处理，这样可以将精度提高到二阶，并显著降低数值耗散。但是这样的缺点是稳定性不如线性插值。</p>
<h2 id="5-3-MacCormack方法"><a href="#5-3-MacCormack方法" class="headerlink" title="5.3 MacCormack方法"></a>5.3 MacCormack方法</h2><p>半拉格朗日对流对动画非常有用，因为它是无条件稳定的，所以较大的时间步长也可以顺利模拟。但是它会导致不必要的数值平滑化，使水看起来很粘稠或或者烟雾失去细节。</p>
<p>为了获得更高阶的精度，可以使用MacCormack方法。</p>
<p>给定一个量<code>φ</code>，利用前向对流算子<code>A</code>和后向对流算子<code>A^R</code>得到两个中间量，最后进行一个误差分析，得到<code>φ^(N+1)</code>的结果，这个方法可以获得更高的精度。公式描述为：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g8xrxp9ogsj207103k3yf.jpg" alt=""></p>
<p>和5.1的半拉格朗日方法不同，这个MacCormack方法不是无条件稳定的，所以对结果<code>φ^(N+1)</code>要用限制条件进行约束，确保它落在合理范围内。在实践中，也就是要找到最接近采样点的点，并将最终值限制在这些点能获得的最小值和最大值之间。</p>
<h1 id="6-压力求解"><a href="#6-压力求解" class="headerlink" title="6 压力求解"></a>6 压力求解</h1><h2 id="6-1-投影和线性系统求解"><a href="#6-1-投影和线性系统求解" class="headerlink" title="6.1 投影和线性系统求解"></a>6.1 投影和线性系统求解</h2><p>可以分成如下两步：</p>
<ol>
<li>减去压力梯度</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g8xu8lemsqj20e401bjr7.jpg" alt=""></p>
<ol start="2">
<li>确保结果满足流体的不可压缩性以及实心墙边界条件</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g8xubsnkhij20mj04eglu.jpg" alt=""></p>
<p>如果边界是自由表面，此时压力为0（狄利克雷边界条件），如果边界是实心墙，那么流体速度法向分量等于固体速度法向分量，即(14)式。</p>
<p>三个维度差异是：<img src="http://ww1.sinaimg.cn/large/dda38d2bly1g8xuhr3mlvj206301djr7.jpg" alt="">)，通过MAC网格的中心差可以计算(13)式，结合(12)和(13)式可以得到这样的泊松问题：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g8xuspk111j205c01tmwy.jpg" alt=""></p>
<p>如果用MAC网格在二维（三维也同理的）上对(15)式进行数值逼近会得到：（实话实说，，这部分我一点也没看懂）</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g8xuvluozlj20ly03ut8t.jpg" alt=""></p>
<p>通过(16)式可以得到下面几点：</p>
<ul>
<li>如果是自由表面边界处的，直接删去<code>p</code>就可以</li>
<li>如果是实心墙边界处的，删去<code>p</code>然后改改<code>p_(i,j,k)</code>系数啥的</li>
<li>用一个涉及流体和固体速度差的项来增加在右侧测得的负散度</li>
</ul>
<p>用这些乱七八糟的，最后为<code>p</code>的求解创建一个大型线性方程组：<code>Ap=b</code></p>
<p><code>A</code>代表压力系数矩阵，<code>p</code>就是未知的压力值，<code>b</code>就是每个流体单元网格中的负散度组成的向量。</p>
<p>为了解这个方程，使用MICCG(0)（modified incomplete Cholesky<br>conjugate gradient，0级），共轭梯度（CG，conjugate gradient）是一种迭代方法。预处理共轭梯度（PCG，preconditioned conjugate gradient）本质上是相同的算法，但是可以通过一点东西加速迭代过程。</p>
<p>加速是这样的：对于任意可逆矩阵<code>M</code>，<code>Ap=b</code>的解与<code>MAp=Mb</code>相同，如果<code>M</code>是<code>A</code>的倒数，那么<code>MA</code>就是单位矩阵，这样通过CG就可以快速求解<code>p</code>。</p>
<p>接下来需要考虑的就是怎么求<code>M</code>，用线性代数学的Cholesky分解（就是平方根法那个），如果<code>A</code>是实对称正定矩阵就可以用，那么有<code>A=L·L^T</code>。</p>
<p>最后总结一下压力求解的过程：</p>
<ol>
<li>计算在实心墙边界处的负散度</li>
<li>设置压力系数矩阵<code>A</code></li>
<li>预处理矩阵<code>M</code></li>
<li><code>Ap=b</code>求解</li>
<li>根据压力梯度计算新的粒子速度</li>
</ol>
<hr>
<p>今天先学这么点，to be continued……</p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>阅读笔记</tag>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>流体模拟《Fluid Simulation for Computer Graphics 》——从入门到放弃（二）模拟视角/Navier-Stokes流体方程/MAC法</title>
    <url>/2aa198bc/</url>
    <content><![CDATA[<p><a href="https://leflacon.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" target="_blank" rel="noopener">从入门到放弃系列</a></p>
<p>深刻认识到了好好学数值分析的重要性，，所以人生就是【被劝】-【不听】-【踩坑】-【劝人】……</p>
<p>哪里理解错误啥的请指出3Q</p>
<a id="more"></a>

<hr>
<h1 id="1-Simulation-Viewpoints（模拟视角）"><a href="#1-Simulation-Viewpoints（模拟视角）" class="headerlink" title="1 Simulation Viewpoints（模拟视角）"></a>1 Simulation Viewpoints（模拟视角）</h1><p>跟踪运动的流体或可变形固体（连续体）的运动有两种途径：欧拉视角，拉格朗日视角。</p>
<ol>
<li>拉格朗日视角</li>
</ol>
<p>在这种视角下，流体由空间中的无限多个点组成，每个点都标记为一个单独的颗粒，有各自的位置向量，速度向量。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8vpktjumaj30ax078jrx.jpg" alt=""></p>
<ol start="2">
<li>欧拉视角</li>
</ol>
<p>在空间上保持固定点，并且查看这些点所处的流体（速度/温度等）如何随时间变化，这相当于使用固定的网格。在这种视角下，更容易在固定的欧拉网格上对一些流体量的空间导数进行分析及对这些导数进行数值逼近。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8vpvrgduxj30cq08ht9b.jpg" alt=""></p>
<h1 id="2-Fluid-Equations（流体方程）"><a href="#2-Fluid-Equations（流体方程）" class="headerlink" title="2 Fluid Equations（流体方程）"></a>2 Fluid Equations（流体方程）</h1><p>大多数流体由不可压流体的Navier-Stokes方程（纳维一斯托克斯方程）决定：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8vpxst924j30ep02paa5.jpg" alt=""></p>
<h2 id="2-1-Symbols"><a href="#2-1-Symbols" class="headerlink" title="2.1 Symbols"></a>2.1 Symbols</h2><p>向量<code>u</code>表示流体速度，<code>ρ</code>表示流体密度，<code>p</code>表示压力（流体在任何物体上施加的单位面积的力），向量<code>g</code>表示重力加速度，（三维空间里表示为<code>(0,-9.81,0)m/s^2</code>），<code>ν</code>表示运动粘度（用于测量流体的粘性）。</p>
<h2 id="2-2-动量方程"><a href="#2-2-动量方程" class="headerlink" title="2.2 动量方程"></a>2.2 动量方程</h2><p>把上面的(1)式分为三个部分：</p>
<ol>
<li>Material derivative（物质导数）</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8wmwqis7nj30d601jt8q.jpg" alt=""></p>
<p>其中<code>q</code>表示通过流体传输的模拟量之一（比如温度），<code>t</code>表示时间。<code>∂q/∂t</code>就表示了<code>q</code>在固定点变化的速度，这是一种欧拉度量。第二项<code>u⋅∇q</code>纠正多少变化是由于流体流过的差异。</p>
<p>比如在一个模拟空间中，温度在原点处为0，温度变化为<code>T(x)=20x</code>（即向右变热），流体以恒定速度c流动，水分子的温度不变，那么根据拉格朗日视角，温度的物质导数为：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8wgpa0niuj30c904q0sw.jpg" alt=""></p>
<p>也就是说在空间固定处，温度以-20c的恒定速率变化，如果水流速度为0，那么固定点温度不变，如果水以恒定速度<code>c=2</code>向右流动，那么固定点的温度将以<code>-40</code>的速度下降。</p>
<p>我们可以知道在拉格朗日观点下每个水分子的温度都没有变化，因此导数为0，而欧拉视角下导数值取决于流体流动的速度和方向。</p>
<p>当上面说的<code>q</code>是速度时，称为自对流，因为此时速度有两种不同的作用，即流体运动的速度和随着流体平移而变的速度，这使我们得出与动量方程相同的方程：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8whs8kcuwj30bt01f74a.jpg" alt=""></p>
<p>（论文中的对流指由于流体在特定方向上的运动而导致的物质通过流体的传输机制，在流体模拟领域中用于描述模拟量<code>q</code>的物质导数为0）</p>
<ol start="2">
<li>作用在流体上的外力</li>
</ol>
<p>重力加速度g</p>
<ol start="3">
<li>作用在流体上的内力</li>
</ol>
<p>内力是影响流体粒子与附近其他粒子相互作用的两种流体力：</p>
<ul>
<li>第一种：<code>1\ρ ∇p</code>体现了压力对流体的影响。压力可以使流体体积保持稳定且无速度耗散。高压流体区域推动低压流体区域，我们可以通过负压力梯度<code>-∇p</code>来测量粒子处的压力不平衡（因为梯度运算符代表了最陡的上升方向，而高压区域向低压区域推进，因此要在每个点取负压力梯度）。</li>
<li>第二种：第二种内力是流体粘度引起的。粘性流体试图抵抗变形，这种内力试图使这个粒子以周围粒子的平均速度运动，也就是使邻近粒子之间的速度差异最小化。所以<code>∇⋅∇u</code>就是用拉普拉斯算子衡量一个量与周围平均数的差。</li>
</ul>
<h2 id="2-3-不可压缩条件"><a href="#2-3-不可压缩条件" class="headerlink" title="2.3 不可压缩条件"></a>2.3 不可压缩条件</h2><p>真实的流体，甚至是水这样的液体体积也会改变，但通常变化不大。这样的研究对象称为可压缩流，研究起来很复杂，而宏观上的影响又不大，所以就应用层面来说没必要考虑。</p>
<p>所以在流体模拟中一个前提条件是流体体积变化率为0（即不可压缩），也就是前文的(2)式。</p>
<h1 id="3-粘度"><a href="#3-粘度" class="headerlink" title="3 粘度"></a>3 粘度</h1><p>在大多数情况下粘度只有很小的影响，所以也可以不考虑，而归入误差范围。不考虑粘度的Navier-Stokes方程称为欧拉方程，理想的没有粘度的流体称为inviscid，方程是：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8wlqmy93bj30cx031aa4.jpg" alt=""></p>
<p>还有两个边界情况，实心墙和自由表面：</p>
<ul>
<li>实心墙：流体不能流进或流出实心墙，所以速度的法向分量为0，即<img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8wmjwdkxzj302400omx3.jpg" alt="">)。如果是移动的固体的话那么就是固体速度的法向分量<img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8wmjlunmcj305b016gll.jpg" alt=""></li>
<li>自由表面：自由表面是停止对流体建模的地方，在模拟区域外可能存在另一种流体（比如空气）。因为只有压力的差异（理想条件不可压缩体积不变），所以自由表面<code>p=0</code>。</li>
</ul>
<h1 id="4-数值模拟"><a href="#4-数值模拟" class="headerlink" title="4 数值模拟"></a>4 数值模拟</h1><h2 id="4-1-流体算法"><a href="#4-1-流体算法" class="headerlink" title="4.1 流体算法"></a>4.1 流体算法</h2><p>把上面的理想情况（不可压缩无粘度）的Navier-Stokes方程(7)进行进一步拆分，对每一部分分别求解：（拆分依据就是2.2中的物质导数/外力/内力，其中(9)式就是物质导数为0，(10)式那个就是重力方向（y方向）求偏导，(11)式那个就是压力反方向求偏导，不可压缩）</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8wn7mrfwzj30ds0623yu.jpg" alt=""></p>
<p>基础流体算法：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8wn9chd7aj30ev060dgd.jpg" alt=""></p>
<p>前三步说的是，从初始无散度速度0开始；然后时间n=0，1，2，……，也就是<code>t_0,t_1,t_2,...</code>；然后确定一个<code>Δt</code>，也就是<code>t_n到t_(n+1)</code>，后三步就，，0.0应该说的是一个速度，然后算上重力影响后的速度，然后根据时间变化的速度</p>
<h2 id="4-2-MAC法（标记网格法）"><a href="#4-2-MAC法（标记网格法）" class="headerlink" title="4.2 MAC法（标记网格法）"></a>4.2 MAC法（标记网格法）</h2><p>为了使空间离散化，就引入一个叫MAC法的好东西。</p>
<p>引入MAC具体可以看这篇论文：【F. Harlow and J. Welch. “Numerical Calculation of Time-Dependent Viscous Incompressible Flow of Fluid with Free Surface.” Phys. Fluids 8 (1965), 2182–2189.】</p>
<p>，，我是看不动了QWQ，，就看看百度出来的各种介绍吧，，</p>
<p>MAC法：</p>
<ul>
<li>marked-and-cell，标记网格法，一种偏微分方程数值解法</li>
<li>用差分法和标记点相结合求解不可压缩自由表面流动问题</li>
<li>用Navier-Stokes方程</li>
<li>计算区域按照欧拉矩形网格单元划分</li>
<li>压力和速度作为基本未知量</li>
<li>压力定义在格子中心，也就是<code>(i,j)</code></li>
<li>r方向速度分量定义在格子左右边界中点，也就是<code>(i,j)</code>到<code>(i+1,j)</code>的速度是<code>u_(i+1/2,j)</code></li>
<li>y方向速度分量定义在格子上下边界中点，同理，<code>(i,j)</code>到<code>(i,j+1)</code>的速度是<code>v_(i,j+1/2)</code><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8wpbvg3xuj30bn0aojsd.jpg" alt=""></li>
<li>多维也是同理的<img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8wpdkwj03j30d40a9gmf.jpg" alt=""></li>
<li>用差分方法由动量方程和泊松方程分别计算出速度和压力</li>
<li>在网格中布置适量的无质量的标记点，这些点来确定自由表面</li>
<li>位置由拉格朗日坐标表示（欧拉坐标就是固定在空间中的参考坐标，我们一般理解的那种；拉格朗日坐标是嵌在物体质点上，随物体一起运动和变形的坐标，这时候的坐标值就相当于一个质点的姓名，只和那个质点有关，坐标系性质可能会变但是那个质点的坐标值是不随物体的运动或者变形改变的。拉格朗日坐标的优点就是推导公式方便，求导的时候坐标值不变只要对时间求导就好了，用欧拉坐标的话坐标值也会变就得考虑质点的运动）</li>
<li>使用双变量线性插值计算标记点的速度</li>
<li>计算过程中跟踪每个标记点，从而确定自由表面的形状/位置/演变清况</li>
</ul>
<p>既然看到了MAC（标记网格法），就顺便提一下另一个PIC（质点网格法），这个是计算二维非定常可压缩理想流动问题的欧拉－拉格朗日混合方法，特别适用于计算具有多种介质和大变形流动的问题，具体可以自己百度……</p>
<hr>
<p>先结个尾，下一篇继续</p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>阅读笔记</tag>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>流体模拟《Fluid Simulation for Computer Graphics 》——从入门到放弃（一）概述</title>
    <url>/f4430d4f/</url>
    <content><![CDATA[<p>搞个<a href="https://leflacon.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" target="_blank" rel="noopener">从入门到放弃系列</a>记录一下，，入门太难了，，一堆作业还没写，，希望可以学会一点点</p>
<p>前排放上这本77页∑(ﾟДﾟ)硕士论文的下载地址：<a href="https://dspace.library.uu.nl/handle/1874/273891" target="_blank" rel="noopener">《Fluid Simulation for Computer Graphics<br>》—— dr. R. T. Tan</a>，传说中的流体模拟入门书，需要数值分析基础</p>
<p>最后，哪里理解错误啥的请指出3Q</p>
<a id="more"></a>

<hr>
<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h1><p>一个好的流体模型应该易于使用并且产生高度真实的结果。</p>
<p>计算机流体力学（CFD）模拟气体和其他流体（比如水），图形学的流体模拟是CFD的一部分，它和更通用的CFD的主要区别是，图形学只要看起来对实际物理上不那么对也没事。由于捕获流体复杂运动的计算量很大，所以一般都是离线的。</p>
<p>现在主要有两种解决流体方程的基本方法：</p>
<ul>
<li>基于网格的方法（欧拉视角）</li>
<li>基于粒子的方法（拉格朗日视角）</li>
</ul>
<p>通过将网格分辨率或者粒子数减少可以更快，但是这是以质量的降低为代价的，（飞溅和倾覆波之类就没了，因为高度场无法捕捉它们），所以现在研究的重点是在提高效率的基础上提高或保证质量。</p>
<h1 id="2-Related-work"><a href="#2-Related-work" class="headerlink" title="2 Related work"></a>2 Related work</h1><p>欧拉流体模拟的早期工作：（对应的论文就不放了，下同，如果有需要的话可以直接去看原文的参考文献部分）</p>
<ul>
<li>使用有限差分求解Navier-Stokes方程</li>
<li>用于平流的半拉格朗日方法</li>
<li>结合拉格朗日粒子和水平集方法以追踪液体的自由表面</li>
</ul>
<p>流体模拟可以分为四个主要部分：advection（对流），surface tracking（表面跟踪），pressure projection（压力投影）和fluid-solid interaction（流固相互作用）。</p>
<p>以下是各个部分已有的相关工作：（中文字我都认得，，连在一起我啥也不晓得!?(･_･;?）</p>
<h2 id="2-1-advection"><a href="#2-1-advection" class="headerlink" title="2.1 advection"></a>2.1 advection</h2><ul>
<li>一种简单的对流方程离散化的特征方法</li>
<li>半拉格朗日方法，可以无条件保持稳定，最简单的半拉格朗日方法在时空上都是一阶精度（可以通过差值来提高精度，但这样会增加这个方法的复杂性和计算量，尤其是高阶多项式差值需要限制器来避免振荡和整个流体模拟可能的不确定因素）</li>
<li>改善半拉格朗日保真度的一个方法是通过辅助信息，用于模拟烟雾小尺度滚动特征的涡度限制可以用来减轻大量耗散，从而使视觉上错综复杂，尽管它是非物质流（使用涡旋粒子的也可以）</li>
<li>另一个方法是以较高阶的精度追踪粒子，用改进的MacCormack方法可以把半拉格朗日方法提高到二阶精度</li>
</ul>
<h2 id="2-2-surface-tracking"><a href="#2-2-surface-tracking" class="headerlink" title="2.2 surface tracking"></a>2.2 surface tracking</h2><ul>
<li>在水平集方法中，隐式材料的边界/表面由一个标量场的零集给出</li>
<li>为了减小体积损失，在流体表面两侧都增加了粒子以校正水平集</li>
<li>除了水平集外，流体表面的其他表示有：流体体积方法、基于密度的方法、显式三角网格</li>
</ul>
<h2 id="2-3-pressure-projection"><a href="#2-3-pressure-projection" class="headerlink" title="2.3 pressure projection"></a>2.3 pressure projection</h2><ul>
<li>利用重影流体方法来提高自由表面附近压力投影的精度</li>
<li>在许多情况下，压力投影是整个流体模拟中最慢的部分，因为它要在每个时间步长求解一个大型线性系统，处理共轭梯度方法（PCG）常用与有效处理这个问题</li>
<li>欧拉网格的规则性使多网格方法成为PCG的有效替代方法</li>
<li>也可以结合这两种方法，使用一个multigrid V-Cycle作为共轭梯度的前置条件</li>
<li>为了加速多网格方法，修改限制和延伸模版，只考虑粗糙单元表面的速度</li>
</ul>
<h2 id="2-4-fluid-solid-interaction"><a href="#2-4-fluid-solid-interaction" class="headerlink" title="2.4 fluid-solid interaction"></a>2.4 fluid-solid interaction</h2><ul>
<li>流体的复杂有趣的运动通常是由其与固体环境的相互作用引起的，因此正确处理固体边界一直是一个活跃的研究领域</li>
<li>用流体体积分数方法来准确的处理双向刚体相互作用</li>
<li>流体单元以及在压力求解中被刚体占据的单元</li>
<li>将流体运动和一个刚体动量组合成一个线性系统并同时求解（这个方法可扩展到软体-流体相互作用），然后重新公式化以保存动量，最后生成对称系统矩阵</li>
<li>流体与布和薄壳的双向相互作用</li>
<li>使用变分公式能够用亚格子形式精度处理流固相互作用</li>
</ul>
<h2 id="2-5-Other-Approaches"><a href="#2-5-Other-Approaches" class="headerlink" title="2.5 Other Approaches"></a>2.5 Other Approaches</h2><ul>
<li>基于粒子的方法</li>
<li>lattice-Boltzmann（点阵-玻尔兹曼）模型</li>
<li>可以实现实时性能的：管道模型，2D波动方程，浅水方程</li>
<li>高度场方法无法捕捉3D现象，目前只有少数研究者实现了交互速率下的3D流体模拟</li>
<li>为了实现实时性能，将流体限制在没有一般的流固相对作用的较小的矩形内</li>
<li>利用离散余弦变换来加快模拟速度</li>
</ul>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>阅读笔记</tag>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1605 棋盘问题（博弈论）</title>
    <url>/69d43b15/</url>
    <content><![CDATA[<p>1.0 秒 131,072.0 KB 40 分 4级题<br>上帝创造了一个<code>n*m</code>棋盘，每一个格子都只有可能是黑色或者白色的。</p>
<p>亚当和夏娃在玩一个游戏，每次寻找边长为x的正方形，其中每个格子必须为黑色，然后将这些格子染白。</p>
<p>如果谁不能操作了，那么那个人就输了。</p>
<p>亚当喜欢质数。</p>
<p>夏娃喜欢1，但讨厌2。</p>
<p>因此他们规定，x只有可能是非2质数或者是1。</p>
<p>现在他们想知道，如果他们都用最优策略进行游戏，谁会赢。</p>
<p>上帝规定亚当先手。</p>
<hr>
<p>因为只能是1或者非2质数，所以如果能继续的话不管怎么样都是会染掉奇数个格子，所以只要判断黑色格子的奇偶性即可</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        int n,m,c,num&#x3D;0;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;m;j++)&#123;</span><br><span class="line">                scanf(&quot;%d&quot;,&amp;c);</span><br><span class="line">                if(c&#x3D;&#x3D;1)num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(num&amp;1)printf(&quot;yadang\n&quot;);</span><br><span class="line">        else printf(&quot;xiawa\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1714 B君的游戏（Nim博弈，SG函数打表）</title>
    <url>/2714d0a4/</url>
    <content><![CDATA[<p>1.0 秒 131,072.0 KB 40 分 4级题</p>
<p>B君和L君要玩一个游戏。刚开始有n个正整数 𝑎𝑖 。</p>
<p>双方轮流操作。每次操作，选一个正整数x，将其移除，再添加7个数字  𝑥1,𝑥2…𝑥7  。要求对于 𝑥𝑖 ，满足  0&lt;=𝑥𝑖&lt;𝑥  且  𝑥&amp;𝑥𝑖=𝑥𝑖 </p>
<p>注意0不能被选取，所以这个游戏一定会结束，而谁无法操作谁就失败。<br>B君根据自己的经验，认为先手胜率高一点，所以B君是先手。<br>B君想知道自己是否必胜。</p>
<hr>
<p>不会写，，唉，sg值算不来</p>
<p>n个正整数，要满足<code>0&lt;=𝑥𝑖&lt;𝑥且𝑥&amp;𝑥𝑖=𝑥𝑖</code>，那这个问题只和x的二进制的1的个数num有关，设sg[num]表示有num个1的时候的sg函数值，可以看成一个nim博弈，一个数就是一堆石子，这个数的二进制的1的个数就是石子数，把所有子问题的sg函数值异或求解</p>
<p>一开始是必败态0，共可以操作7次，枚举第7-deep次的数剩i个1的情况</p>
<hr>
<p>这是一种思路，然后还看了神仙的另一种思路，还没参透那个结论咋来的ORZ先记录下来mark</p>
<p>b[i]表示有i个1的数字的个数，当所有的b[i]都为偶数的时候，先手必败，先手一次最多可以把8个奇数改为8个偶数，所以当且仅当先手面对的局面有九个或者9的倍数个奇数，那么后手一直跟他博弈剩9的倍数的奇数，先手就输了</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">&#x2F;&#x2F; const int N&#x3D;7e7;</span><br><span class="line">int sg[65]&#x3D;&#123;0,1,2,4,8,16,32,64,128,255,256,512,1024,</span><br><span class="line">    2048,3855,4096,8192,13107,16384,21845,27306,32768,</span><br><span class="line">    38506,65536,71576,92115,101470,131072,138406,172589,</span><br><span class="line">    240014,262144,272069,380556,524288,536169,679601,</span><br><span class="line">    847140,1048576,1072054,1258879,1397519,2005450,</span><br><span class="line">    2097152,2121415,2496892,2738813,3993667,4194304,</span><br><span class="line">    4241896,4617503,5821704,7559873,8388608,8439273,</span><br><span class="line">    8861366,11119275,11973252,13280789,16777216,16844349,</span><br><span class="line">    17102035,19984054,21979742,23734709&#125;;</span><br><span class="line">&#x2F;&#x2F; int vis[N];</span><br><span class="line">&#x2F;&#x2F; void dfs(int numr,int deep,int res,int numl)&#123;</span><br><span class="line">&#x2F;&#x2F;     if(deep&#x3D;&#x3D;0)&#123;</span><br><span class="line">&#x2F;&#x2F;         vis[res]&#x3D;1;</span><br><span class="line">&#x2F;&#x2F;         return;</span><br><span class="line">&#x2F;&#x2F;     &#125;</span><br><span class="line">&#x2F;&#x2F;     for(int i&#x3D;numl;i&lt;numr;i++)&#123;</span><br><span class="line">&#x2F;&#x2F;         dfs(numr,deep-1,res^sg[i],i);</span><br><span class="line">&#x2F;&#x2F;     &#125;</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br><span class="line">&#x2F;&#x2F; void get()&#123;</span><br><span class="line">&#x2F;&#x2F;     sg[0]&#x3D;0;</span><br><span class="line">&#x2F;&#x2F;     int tmp&#x3D;0;</span><br><span class="line">&#x2F;&#x2F;     for(int i&#x3D;1;i&lt;&#x3D;64;i++)&#123;</span><br><span class="line">&#x2F;&#x2F;         memset(vis,0,tmp);</span><br><span class="line">&#x2F;&#x2F;         dfs(i,7,0,0);</span><br><span class="line">&#x2F;&#x2F;         for(int j&#x3D;0;j&lt;N;j++)&#123;</span><br><span class="line">&#x2F;&#x2F;             if(!vis[j])&#123;</span><br><span class="line">&#x2F;&#x2F;                 sg[i]&#x3D;j;</span><br><span class="line">&#x2F;&#x2F;                 break;</span><br><span class="line">&#x2F;&#x2F;             &#125;</span><br><span class="line">&#x2F;&#x2F;         &#125;</span><br><span class="line">&#x2F;&#x2F;         printf(&quot;%d,&quot;,sg[i]);</span><br><span class="line">&#x2F;&#x2F;     &#125;</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    &#x2F;&#x2F; get();</span><br><span class="line">    int n,ans&#x3D;0;</span><br><span class="line">    LL c;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%lld&quot;,&amp;c);</span><br><span class="line">        int num&#x3D;0;</span><br><span class="line">        while(c)&#123;</span><br><span class="line">            num+&#x3D;(c%2);</span><br><span class="line">            c&#x2F;&#x3D;2;</span><br><span class="line">        &#125;</span><br><span class="line">        ans^&#x3D;sg[num];</span><br><span class="line">    &#125;</span><br><span class="line">    if(ans)puts(&quot;B&quot;);</span><br><span class="line">    else puts(&quot;L&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1490 多重游戏（树上博弈）</title>
    <url>/5388f86c/</url>
    <content><![CDATA[<p>1.0 秒 131,072.0 KB 40 分 4级题<br>有一个两人游戏，游戏是这样的，有n个非空串。在游戏的过程是，两个玩家轮流向一个字符串后面加字母，刚开始字符串是空的。每一次操作是向当前字符串后面添加字符，形成的新字符串一定要是这n个串中某一个或几个的前缀，如果无法做到，就输了。</p>
<p>这样的游戏似乎过于简单了，现在对这个游戏进行一下改进，让玩家玩K次这样的游戏，第i次的败者，将会作为第i+1次的先手进行这个游戏。第k次游戏的赢家就是整个游戏的赢家。</p>
<p>现在给定n个字符串和k，问是先手胜还是后手胜。</p>
<hr>
<p>不会写，看了别人的代码，厉害厉害</p>
<p>首先建个trie树</p>
<p>局面可以分为四种情况：先手必胜10/先手必败01/可胜可败11/不能控制00</p>
<p>一开始所有叶节点都是必败，因为没有机会再加字符当前缀了。如果一个节点的所有儿子都是必败01，那么这个节点就是必胜10；如果一个节点所有儿子就是必胜10，那么这个节点就是必败01；如果一个节点的儿子有必胜有必败（可胜可败不影响），那么这个节点是可胜可败11；如果一个节点的儿子都是可胜可败，那么这个节点是不能控制00</p>
<p>树dp，这样状态转移方程就是<code>dp[x]|=dp[ch[x][i]]^3</code>，或上所有儿子取反的结果</p>
<p>如果先手必胜，那么看k的奇偶性；如果先手必败，那下一轮败者还是先手所以First就只能一直败；如果先手可胜可败，那机智的First可以控制局面让最后自己胜；如果先手不能控制，那没办法了最后Second赢</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;100005;</span><br><span class="line">string s[N];</span><br><span class="line">int n,k,ch[N][30],ji&#x3D;1,dp[N];</span><br><span class="line">void insert(string ss)&#123;</span><br><span class="line">    int len&#x3D;ss.length(),u&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;len;i++)&#123;</span><br><span class="line">        int c&#x3D;(int)(ss[i]-&#39;a&#39;);</span><br><span class="line">        if(!ch[u][c])&#123;</span><br><span class="line">            ch[u][c]&#x3D;ji++;</span><br><span class="line">        &#125;</span><br><span class="line">        u&#x3D;ch[u][c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int x)&#123;</span><br><span class="line">    int flag&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;26;i++)&#123;</span><br><span class="line">        if(ch[x][i])&#123;</span><br><span class="line">            flag&#x3D;1;</span><br><span class="line">            dfs(ch[x][i]);</span><br><span class="line">            dp[x]|&#x3D;dp[ch[x][i]]^3;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!flag)dp[x]&#x3D;1;&#x2F;&#x2F;叶节点必败</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);</span><br><span class="line">    memset(ch,0,sizeof(ch));</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">        insert(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(0);</span><br><span class="line">    if(dp[0]&#x3D;&#x3D;2)&#123;</span><br><span class="line">        if(k&amp;1)puts(&quot;First&quot;);</span><br><span class="line">        else puts(&quot;Second&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(dp[0]&#x3D;&#x3D;1)&#123;</span><br><span class="line">        puts(&quot;Second&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(dp[0]&#x3D;&#x3D;3)&#123;</span><br><span class="line">        puts(&quot;First&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        puts(&quot;Second&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1534 棋子游戏（博弈）</title>
    <url>/c884d0d6/</url>
    <content><![CDATA[<p>1.0 秒 131,072.0 KB 20 分 3级题</p>
<p>波雷卡普和瓦西里喜欢简单的逻辑游戏。今天他们玩了一个游戏，这个游戏在一个很大的棋盘上进行，他们每个人有一个棋子。他们轮流移动自己的棋子，波雷卡普先开始。每一步移动中，波雷卡普可以将他的棋子从(x,y) 移动到 (x-1,y) 或者 (x,y-1)。而瓦西里可以将他的棋子从(x,y) 移动到 (x-1,y),(x-1,y-1) 或者 (x,y-1)。当然他们可以选择不移动。</p>
<p>还有一些其它的限制，他们不能把棋子移动到x或y为负的座标，或者移动到已经被对手占据的座标。最先到达（0，0）的人获胜。</p>
<p>现在给定他们棋子的座标，判断一下谁会获胜。</p>
<hr>
<p>P可以向上或向左或不动，V可以向上或向左或向左上或不动，算曼哈顿距离，V有改变奇偶性的机会，但是P可能可以去堵W的路（因为P可以不动一直堵着，那V就不能改变奇偶性了）</p>
<p>所以就是看P能不能堵到，要么比较<code>x1+y1</code>和<code>max(x2,y2)</code>，小的赢（相等的话还是P赢，因为先手先占位子），要么看看(x1,y1)是否在(x2,y2)左上方，能堵到就P赢，不然都是V赢</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int x1,y1,x2,y2;</span><br><span class="line">    cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">    if(x1+y1&lt;&#x3D;max(x2,y2))puts(&quot;Polycarp&quot;);</span><br><span class="line">    else if(x1&lt;&#x3D;x2&amp;&amp;y1&lt;&#x3D;y2)puts(&quot;Polycarp&quot;);</span><br><span class="line">    else puts(&quot;Vasiliy&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1755 除数游戏（博弈）</title>
    <url>/f3789386/</url>
    <content><![CDATA[<p>1.0 秒 131,072.0 KB 20 分 3级题</p>
<p>在除数游戏中，两人轮流行动，初始时有一个整数q，每次行动要写下一个整数，这个整数必须是最近一次出现的整数的“强除数”。所谓一个整数的“强除数”是指除了1和该整数本身以外，可以整除该整数的整数。</p>
<p>当游戏的某一方找不出符合以上条件的整数时，该方取得胜利，游戏结束。</p>
<p>假设游戏双方都采取最好的策略，给出初始数字。计算第一个写数字的人赢，还是第二个写数字的人赢。</p>
<p>样例解释：</p>
<p>在样例一中，数字6的“强除数”是2和3。不管是写哪个数字，下一个人都赢了。<br>在样例二中，6是30的一个“强除数”。写下6后，接下来的过程同上。</p>
<hr>
<p>看因数个数，如果上来就是质数那么1赢，一个因数那1取完1赢，两个因数的话就2赢，两个以上因数不管怎么取最后决定奇偶的权利都在1手中，都是1赢</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">int main()&#123;</span><br><span class="line">    LL n,m;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    m&#x3D;n;</span><br><span class="line">    int ji&#x3D;0;</span><br><span class="line">    for(LL i&#x3D;2;i*i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        while(m%i&#x3D;&#x3D;0)&#123;</span><br><span class="line">            m&#x2F;&#x3D;i;</span><br><span class="line">            ji++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ji&gt;2)break;</span><br><span class="line">    &#125;</span><br><span class="line">    if(m&gt;1)ji++;</span><br><span class="line">    if(ji&#x3D;&#x3D;2)puts(&quot;2&quot;);</span><br><span class="line">    else puts(&quot;1&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1831 小C的游戏（暴力打表，博弈）</title>
    <url>/b3b4cee3/</url>
    <content><![CDATA[<p>1.0 秒 131,072.0 KB 80 分 5级题</p>
<p>小C和小L是好朋友，她们在玩一个游戏。<br>一开始有一个大小为n的石子堆，小C先手。<br>每次可以对这个石子堆拿走一个或者把这个石子堆分成等量的几份并只取其中一份（不能不变或只剩下一个）。<br>如果取走最后一个人的算败，请问这个游戏小C是否能胜。</p>
<hr>
<p>一开始理解错题意了，看了讨论区才知道那个只取一份不是取走一份的意思，是留下那一份的意思。。坑啊</p>
<p>一个一个取的话奇偶性就固定了，所以要看什么时候能分了然后就剩下他的因子，这样就会变成一个子问题的求解</p>
<p>n=1先手败，n=2后手败，n=3先手败，n=4后手败（可以变成n=2但先手会输，决定权在先手），n=5先手败，n=6后手败，n=7后手败（后手只能取掉一个变为n=6）</p>
<p>所以直接从小到大暴力求必胜态和必败态，如果可以一步到先手必败态，那么当前就是先手必胜态，n是1e9，找一下1e4内的规律，可以发现质数必败（2、17除外），合数必胜（16，34，289除外）</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;1005;</span><br><span class="line">int a[N];</span><br><span class="line">void init()&#123;</span><br><span class="line">    a[1]&#x3D;0;a[2]&#x3D;1;</span><br><span class="line">    vector&lt;int&gt; lose;</span><br><span class="line">    for(int i&#x3D;3;i&lt;N;i++)&#123;</span><br><span class="line">        int flag&#x3D;1;</span><br><span class="line">        if(a[i-1]&#x3D;&#x3D;0)&#123;</span><br><span class="line">            a[i]&#x3D;1;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j&#x3D;0;j&lt;lose.size();j++)&#123;</span><br><span class="line">            if(i%lose[j]&#x3D;&#x3D;0)&#123;</span><br><span class="line">                a[i]&#x3D;1;</span><br><span class="line">                flag&#x3D;0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            a[i]&#x3D;0;</span><br><span class="line">            lose.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;1;i&lt;N;i++)&#123;</span><br><span class="line">        if(a[i]&#x3D;&#x3D;0)printf(&quot;%d &quot;,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool isprime(int x)&#123;</span><br><span class="line">    for(int i&#x3D;2;i*i&lt;&#x3D;x;i++)&#123;</span><br><span class="line">        if(x%i&#x3D;&#x3D;0)return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,n;</span><br><span class="line">    &#x2F;&#x2F; init();</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        if(n&#x3D;&#x3D;2||n&#x3D;&#x3D;17)puts(&quot;TAK&quot;);</span><br><span class="line">        else if(n&#x3D;&#x3D;16||n&#x3D;&#x3D;34||n&#x3D;&#x3D;289)puts(&quot;NIE&quot;);</span><br><span class="line">        else if(isprime(n))puts(&quot;NIE&quot;);</span><br><span class="line">        else puts(&quot;TAK&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS下Python的tkinter库Entry输入框无法输入中文问题的原因及解决办法（PS：万圣节🎃快乐！）</title>
    <url>/cb05350b/</url>
    <content><![CDATA[<p>去年万圣节在写聚类，今年万圣节在写检索，人生啊。</p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在macOS下使用tkinter库Entry输入框，无法输入中文，不管怎么样都只能输入英文，只能复制进去中文，交互体验很不好ಥ_ಥ。</p>
<p>我的版本是macOS10.14.2，python3.6.0。</p>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>可以在python的网站找到一篇这样的说明：</p>
<p><a href="https://www.python.org/download/mac/tcltk/" target="_blank" rel="noopener">https://www.python.org/download/mac/tcltk/</a></p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8hunm29suj30gi0atabt.jpg" alt=""></p>
<p>大意是如果在macOS用python3.8+，3.7.2+，3.6.8或2.7.16+，那么无需考虑这个问题就可以使用IDLE或tkinter，讲使用内置的Tcl/Tk8.6。</p>
<p>然而我是python3.6.0，在macOS10.6或更高版本上，需要使用Apple提供的Tcl/Tk8.5，但是他们有严重的错误。所以就会出现tkinter输入框Entry怎么切换输入法都没法输入中文的情况。需要链接到较新版本的Tcl/Tk。</p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>如果需要用IDLE或tkinter，首先不能用macOS自带的python，要自己下个版本合适的python。</p>
<p>然后ActiveState提供了Tcl/Tk的二进制包，该版本与macOS发行版中的Apple提供的二进制包向上兼容，并且通常比其新。此版本的Tcl/Tk包含一些修复程序，用于修复使用tkinter或IDLE可能遇到的一些关键问题。</p>
<p>所以在ActiveState网站下载需要的版本即可。</p>
<p><a href="https://www.activestate.com/products/tcl/downloads/" target="_blank" rel="noopener">https://www.activestate.com/products/tcl/downloads/</a></p>
<p>然后就可以在tkinter的文本框里输入中文啦～</p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>Disentangled Makeup Transfer with Generative Adversarial Network 论文翻译/笔记</title>
    <url>/4be5d779/</url>
    <content><![CDATA[<p>这篇文章提出“分离妆容迁移”，这个DMT模型包含一个身份编码器和一个化妆编码器，分别获取个性化特征和特定图片的妆容风格。不仅能转移一个或多个参考图的妆容到一个素颜图上并控制强度，还能产生一系列基于先行采样的输出。</p>
<p>标题里的“分离”我是google直译的，一开始不太懂，搜了另一些有关“Disentangled”这个词的内容，了解到确实有种叫“disentangled (and an occasional “conventional”) representation learning”的东西，github上专门有人对这一系列的论文做了一个归纳-&gt;<a href="https://github.com/sootlasten/disentangled-representation-papers" target="_blank" rel="noopener">disentangled-representation-papers</a>，mark一下</p>
<hr>
<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h1><p>妆容迁移大概发展史：</p>
<p>图像编辑，基于物理的操作-&gt;深度神经网络-&gt;GAN生成逼真的假图-&gt;局部性迁移（上一篇论文<a href="http://leflacon.github.io/a65f6a37/" target="_blank" rel="noopener">Makeup like a superstar</a>里的那个思想）</p>
<p>现有的妆容迁移主要是一张妆容参考图与一张素颜图之间的迁移，并且大部分输出固定，而事实上还有其他妆容迁移的方案，比如控制化妆样式的强度（插值妆容迁移），混合两个及以上妆容参考图（混合妆容迁移），基于单个素颜图产生各种输出（无参考图，多模式妆容迁移），这篇文章就对这些场景进行了研究。</p>
<p>DMT（分离妆容迁移）是一个可以实现不同化妆品转移的统一的生成式对抗网络，利用身份编码器和化妆解码器来分离给定图片的个人特征和妆容风格，基于这两个输出，进一步采用解码器来重建原始素颜人脸。</p>
<p>还利用了一个判别器来区分真脸图像和假脸图像，这样这个系统不仅可以进行妆容迁移，还可以在没有妆容参考图输入的情况下生成输出。</p>
<p>此外，利用蒙板来提炼妆容迁移的部分，这样不需要迁移的内容将会被很好的保存下来。</p>
<p>以下是效果图，分别对应普通成对妆容迁移，插值妆容迁移，混合妆容迁移，与多模式妆容迁移。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g863mu3i6dj30nr097tgr.jpg" alt=""></p>
<h1 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2 Related Work"></a>2 Related Work</h1><h2 id="Generative-Adversarial-Network-GAN"><a href="#Generative-Adversarial-Network-GAN" class="headerlink" title="Generative Adversarial Network (GAN)"></a>Generative Adversarial Network (GAN)</h2><p>用GAN生成和真脸一样的假脸。</p>
<h2 id="Facial-Makeup-Transfer"><a href="#Facial-Makeup-Transfer" class="headerlink" title="Facial Makeup Transfer"></a>Facial Makeup Transfer</h2><p>妆容迁移。</p>
<p>合并素颜图content层与妆容图style层的方式只能学习图像的全局特征，而局部的特定化妆品没法关注到。</p>
<h2 id="Disentangled-Representation"><a href="#Disentangled-Representation" class="headerlink" title="Disentangled Representation"></a>Disentangled Representation</h2><p>感觉就很妙的一个东西ᶘ ᵒᴥᵒᶅ</p>
<p>将原始输入分解为几个独立的隐藏编码，这样可以学习到不同部分的特点。这个思想在本文中的体现就是：把面部图像分解为个人特征和妆容风格两个独立的部分。</p>
<h2 id="Attention-Mask"><a href="#Attention-Mask" class="headerlink" title="Attention Mask"></a>Attention Mask</h2><p>蒙板是在图到图转化中的一种广泛使用的有效机制。定位关键部分如粉底/眉毛/眼影/口红，保留不相关的部分如头发/衣服/背景。</p>
<h1 id="3-Methodology"><a href="#3-Methodology" class="headerlink" title="3 Methodology"></a>3 Methodology</h1><h2 id="3-1-Disentangled-Makeup-Transfer"><a href="#3-1-Disentangled-Makeup-Transfer" class="headerlink" title="3.1 Disentangled Makeup Transfer"></a>3.1 Disentangled Makeup Transfer</h2><p>首先是这篇文章妆容迁移的实现基础。</p>
<p>对于给定的任何一张图片，无论是素颜图还是妆容图，都可以分解出个人特征和妆容风格两个部分，只需要将个人特征与其他图分解出的的妆容风格结合，就可以实现妆容迁移，就像换装游戏一样。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8659wmq9nj30eb08ejsp.jpg" alt=""></p>
<p>特征编码器Ei，妆容编码器Em，解码器G，判别器D。若x为输入，则特征编码ix=Ei(x)，妆容编码mx=Em(x)。</p>
<p>mx捕捉了x的妆容风格，包括关键的粉底/眉毛/眼影/口红这些化妆品，而ix是其他与化妆无关的信息，比如个人特征/衣服/背景这些。ix与mx相互独立，这满足“Disentangled Representation”的定义，基于ix和mx，利用G来重构图像得到xr，可以靠下面这个Loss来保证不会在编码和解码后丢失任何信息：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g866ib99k6j30e303gwet.jpg" alt=""></p>
<p>算的是曼哈顿距离。</p>
<h2 id="3-2-Pair-wise-Makeup-Transfer"><a href="#3-2-Pair-wise-Makeup-Transfer" class="headerlink" title="3.2 Pair-wise Makeup Transfer"></a>3.2 Pair-wise Makeup Transfer</h2><p>交换两张图的妆容样式。</p>
<p>基于3.1这很好实现，比如把y图上的妆容迁移到x上，可表示为<code>my=Em(y)，xs=G(ix,my)</code></p>
<p>考虑到个人特征保护，说通俗点就是一开始拍照的这个素颜图上的人还得是这个人，x和xs的个人特征要保持一致。因为已经证明了深度神经网络可以有效的获取高级特征，因此利用VGG-16模型比较x和xs在某个隐藏层的激活值。为了保留x的个人特征，使用以下Loss来计算x和xs在VGG-16第l层的不同：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8673s15eqj30aw017jrf.jpg" alt=""></p>
<p>算的是欧式距离。最小化这个值，就能保证得到的xs是保留了x中的高级特征的。</p>
<p>还有一个挑战是y和xs的妆容风格要保持一致，如下图的解析蒙板，由14风部分组成：背景/脸/左眉毛/右眉毛/左眼/右眼/鼻子/上唇/下唇/嘴巴/头发/左耳/右耳/脖子，可以通过训练语义分割模型来实现。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g866qo5paaj30dc06kac1.jpg" alt=""></p>
<p>基于这个蒙板，提取出不同部分来覆盖四个化妆品区域。</p>
<ul>
<li>脸/鼻子/左耳/右耳/脖子：【粉底】</li>
<li>左眉毛/右眉毛：【眉毛】</li>
<li>提取包围两个眼睛的矩形区域，并排除与头发/左眼/右眼/左眉毛/右眉毛重叠的部分：【眼影】</li>
<li>上唇/下唇：【口红】</li>
</ul>
<p>那么妆容迁移就需要xs在每个化妆品区域上与y有相似的颜色分布。为了满足这个条件，一开始对x和y进行直方图匹配，获得一个xy，xy的每个区域有和y共享的颜色分布且保留x的形状信息。然后计算xs和xy的化妆Loss。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g869s53m1ij30ay01kaa4.jpg" alt=""></p>
<p>算的是欧式距离。<code>C = {face, brow, eye, lip}</code>，<code>λ_face</code>, <code>λ_brow</code>,<br><code>λ_eye</code>, <code>λ_lip</code>是把不同区域Loss结合在一起的权重。</p>
<p>然后按照一开始图二的流程，计算<code>(i_x)^s</code>和<code>(m_x)^s</code>。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g86ajtjlhdj308z01n74c.jpg" alt=""></p>
<p>为了保证人脸图像与个人特征/妆容风格编码之间的一一映射关系，利用Identity Makeup Reconstruction Loss（IMRL）：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g86asru30bj30du014dfw.jpg" alt=""></p>
<p>λi和λm分别表示特征和妆容的权重。</p>
<h2 id="3-3-Interpolated-Makeup-Transfer"><a href="#3-3-Interpolated-Makeup-Transfer" class="headerlink" title="3.3 Interpolated Makeup Transfer"></a>3.3 Interpolated Makeup Transfer</h2><p>插值妆容迁移。</p>
<p>通过在3.2中控制参数来实现对妆容强度的控制。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g86ausrp6oj30av01at8q.jpg" alt=""></p>
<h2 id="3-4-Hybrid-Makeup-Transfer"><a href="#3-4-Hybrid-Makeup-Transfer" class="headerlink" title="3.4 Hybrid Makeup Transfer"></a>3.4 Hybrid Makeup Transfer</h2><p>混合妆容迁移。</p>
<p>给k个妆容参考图，获得他们的妆容编码<code>(m_y)^k</code>，然后按照平均分的权重进行妆容迁移。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g86vjd60zbj30a301zwej.jpg" alt=""></p>
<h2 id="3-5-Multi-Modal-Makeup-Transfer"><a href="#3-5-Multi-Modal-Makeup-Transfer" class="headerlink" title="3.5 Multi-Modal Makeup Transfer"></a>3.5 Multi-Modal Makeup Transfer</h2><p>多模态妆容迁移。</p>
<p>在没有妆容参考图的情况下产生输出。如上面的图二所示，从标准正态分布N(0,1)中随机抽取妆容风格m，将m与ix合成获得xf。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g86vpoowzoj30ao0100sr.jpg" alt=""></p>
<h2 id="3-6-Attention-Mask"><a href="#3-6-Attention-Mask" class="headerlink" title="3.6 Attention Mask"></a>3.6 Attention Mask</h2><p>下图M‘为化妆区域，M为生成的蒙板。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g86vunfriwj30ck06qab9.jpg" alt=""></p>
<p>下图为特征编码器Ei，妆容编码器Em，解码器G，判别器D的详细结构，不同颜色代表不同类型的神经层。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g86vti2r7mj30n20ai0un.jpg" alt=""></p>
<h2 id="3-7-Other-Loss-Functions"><a href="#3-7-Other-Loss-Functions" class="headerlink" title="3.7 Other Loss Functions"></a>3.7 Other Loss Functions</h2><h3 id="Adversarial-Loss"><a href="#Adversarial-Loss" class="headerlink" title="Adversarial Loss"></a>Adversarial Loss</h3><p>G生成更逼真的图片来欺骗D</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g86ws7jo9dj30ac01pdfx.jpg" alt=""></p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g86wspvk15j30bh00ywej.jpg" alt=""></p>
<h3 id="KL-Loss"><a href="#KL-Loss" class="headerlink" title="KL Loss"></a>KL Loss</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g86wudsxuhj30c903o3z2.jpg" alt=""></p>
<p>KL这个玩意儿，，我一直都没咋看懂，，</p>
<h3 id="Total-Variation-Loss"><a href="#Total-Variation-Loss" class="headerlink" title="Total Variation Loss"></a>Total Variation Loss</h3><p>为了实现蒙板平滑性。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g86x3pokp5j30bx00z0sr.jpg" alt=""></p>
<h3 id="Full-Objective"><a href="#Full-Objective" class="headerlink" title="Full Objective"></a>Full Objective</h3><p>全部Loss式子如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g86x4a4ov0j30bl02iweo.jpg" alt=""></p>
<h1 id="4-Implementation"><a href="#4-Implementation" class="headerlink" title="4 Implementation"></a>4 Implementation</h1><p>这个项目的github地址：<a href="https://github.com/Honlan/DMT" target="_blank" rel="noopener">https://github.com/Honlan/DMT</a></p>
<p>实在是万分感谢这种开源的东西！！！</p>
<h1 id="5-Experiments"><a href="#5-Experiments" class="headerlink" title="5 Experiments"></a>5 Experiments</h1><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>1,115张素颜图和2,719张分辨率为361×361的化​​妆图</p>
<p>数组集来自：[Li et al., 2018] Tingting Li, Ruihe Qian, Chao Dong, Si Liu,<br>Qiong Yan, Wenwu Zhu, and Liang Lin. Beautygan:<br>Instance-level facial makeup transfer with deep generative<br>adversarial network. In ACM MM, pages 645–653, 2018.</p>
<h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>286x286</p>
<p>β1 = 0.5, β2 = 0.999 </p>
<p>λi = 1, λm = 1, λkl = 0.01, λtv = 0.0001 </p>
<p>λrec = 1, λper = 0.0001, λface = λbrow = λeye = λlip =<br>50, λa = 10</p>
<p>总共训练100 epochs，batch size是1，前50轮的学习速率是0.0002，后50轮线性递减为0。每次都随机选择两张图片训练，化妆的或者没化妆的，随机作为x和y的输入。</p>
<h2 id="妆容迁移比较"><a href="#妆容迁移比较" class="headerlink" title="妆容迁移比较"></a>妆容迁移比较</h2><p>和别的妆容迁移比较：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g873g369rcj30og0c84f7.jpg" alt=""></p>
<ul>
<li>DFM: Digital Face Makeup [Guo and Sim, 2009]，基于图像处理的早期模型</li>
<li>DTN: Deep localized makeup Transfer Network [Liu et al., 2016]，可以转移不同的化妆品</li>
<li>BG: BeautyGAN [Li et al., 2018]，最先进的妆容迁移，训练具有双输入和双输出的发生器（？）</li>
<li>CG: CycleGAN [Zhu et al., 2017]，将化妆和没化妆的部分看为两个区域</li>
<li>ST: Style Transfer [Gatys et al., 2015]，看成content层和style层</li>
<li>DIA: Deep Image Analogy [Liao et al., 2017]，图像类比，匹配从神经网络提取的高级特征</li>
</ul>
<p>DFM，DTN，DIA，CG都带有严重的伪影（severe artifacts），ST和CG无法根据妆容参考图化妆，而BG和DMT都可以正确转移不同的化妆品产生自然的效果，本文的DMT优于BG的地方在于可以转移眉毛并且可以更好的保留无关内容。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g873zegnnaj30b603kwex.jpg" alt=""></p>
<p>后三个比较指标是MSE均方误差，PSNR峰值信噪比，SSIM结构相似性指数，都优于BG，说明DMT重建能力较好。</p>
<hr>
<p>几个比较新的厉害论文，有空瞧瞧，估计是没空了，，，QWQ</p>
<p>[Li et al., 2018] Tingting Li, Ruihe Qian, Chao Dong, Si Liu,<br>Qiong Yan, Wenwu Zhu, and Liang Lin. Beautygan:<br>Instance-level facial makeup transfer with deep generative<br>adversarial network. In ACM MM, pages 645–653, 2018.</p>
<p>[Ma et al., 2018] Liqian Ma, Qianru Sun, Stamatios Georgoulis, Luc Van Gool, Bernt Schiele, and Mario Fritz. Disentangled person image generation. In CVPR, pages 99–<br>108, 2018.</p>
<p>[Lee et al., 2018] Hsin-Ying Lee, Hung-Yu Tseng, Jia-Bin<br>Huang, Maneesh Singh, and Ming-Hsuan Yang. Diverse<br>image-to-image translation via disentangled representations. In ECCV, pages 36–52, 2018.</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>阅读笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Makeup like a superstar: Deep Localized Makeup Transfer Network 论文翻译/笔记</title>
    <url>/a65f6a37/</url>
    <content><![CDATA[<p>论文地址：<a href="https://arxiv.org/abs/1604.07102" target="_blank" rel="noopener">https://arxiv.org/abs/1604.07102</a></p>
<p>逛知乎发现的论文（好像在妆容迁移领域蛮有名的），但我英语太差了专业知识也不够，本文较长，可能有些理解有点问题，望指出</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g74w6ri0uaj30wg07676f.jpg" alt=""></p>
<a id="more"></a>

<hr>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这篇文章提出了新颖的深度局部妆容迁移网络，可以自动推荐一个最适合某女性的妆容并且将妆容综合呈现在她的脸上。提供一张素颜照和一张妆容参考图片，这两张图会在网络中生成素颜照化妆的图片。</p>
<p>我个人理解下来，这个方法还是用CNN结合素颜图的content层和参考图的style层，但它比传统的妆容迁移效果好的主要原因在于它是局部迁移，并且不同的局部采用了不同的迁移方式，这对于妆容中的口红眼影之类的部分可以获得很好的效果。</p>
<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h1><p>提供了两个功能，一是为素颜图提供最适合的妆容；二是把上传的参考图片的底妆，眼影和唇妆迁移到素颜图上。</p>
<h2 id="第一个功能：妆容推荐"><a href="#第一个功能：妆容推荐" class="headerlink" title="第一个功能：妆容推荐"></a>第一个功能：妆容推荐</h2><p>在妆容数据集中寻找一张与素颜图在视觉上相似的脸。相似度通过现成的深度人脸识别网络产生的深度特征之间的欧式距离来衡量。</p>
<h2 id="第二个功能：妆容迁移"><a href="#第二个功能：妆容迁移" class="headerlink" title="第二个功能：妆容迁移"></a>第二个功能：妆容迁移</h2><h3 id="五个标准"><a href="#五个标准" class="headerlink" title="五个标准"></a>五个标准</h3><p>妆容迁移满足五个标准。</p>
<ol>
<li>只考虑了三部分的妆容：底妆，眼影和唇妆。但我们的模型普适性高，容易扩展到其他化妆品上。</li>
<li>不同的化妆品有各自的迁移方式。比如在保持形状方面眼影比底妆重要。</li>
<li>局部性：所有化妆品被局部性的用在对应的面部区域。比如口红涂在嘴唇上。</li>
<li>看起来自然：素颜图与妆容无缝融合。</li>
<li>化妆强度可以控制。</li>
</ol>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>为了满足这五个标准，提出了一个深度局部妆容迁移网络，流程图如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g775l8m5ayj30oh0a2djq.jpg" alt=""></p>
<ol>
<li>素颜照与妆容图的对应基于人脸识别网络。</li>
<li>眼影，底妆，唇妆是经过局部迁移然后进行全局平滑化的。</li>
</ol>
<h3 id="深度局部妆容迁移网络"><a href="#深度局部妆容迁移网络" class="headerlink" title="深度局部妆容迁移网络"></a>深度局部妆容迁移网络</h3><p>这个深度局部妆容迁移网络把参考妆容迁移到素颜图上。</p>
<ol>
<li>首先通过人脸识别网络得到素颜图与妆容图的对应标签图，人脸识别网络基于全卷积网络，加强了上妆的部分并考虑了人脸对称性。识别之后，素颜图局部将对应与妆容参考图对应部分。</li>
<li>不同化妆品（眼影，口红，粉底）对应不同的妆容迁移方式。比如，对眼影来说保持形状最重要，对底妆来说磨皮对重要，因此通过直接改变相应的生成特征来迁移眼影，通过正则化特征图的内积来迁移底妆。</li>
</ol>
<p>和传统的妆容迁移算法相比，传统的方法需要复杂的数据预处理或注释并且结果较差。我们的贡献在于：(1)据我们所知这是第一种基于深度学习框架的妆容迁移方法，可以产生非常自然的效果。可以迁移粉底，眼影和唇彩。可以控制妆容强度。(2)我们提出了一个端到端的深度局部妆容迁移网络，最先建立了面部与化妆品之间的对应关系，再进行妆容迁移。这样相比传统的非局部的妆容迁移效果更自然。</p>
<h1 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2 Related Work"></a>2 Related Work</h1><p>这部分介绍了妆容迁移和最具代表性的深度图像合成相关工作。引用的论文见原文。（好多都看不懂，，用“？0.0”标记了一下，，慢慢来吧）</p>
<h2 id="Facial-Makeup-Studies"><a href="#Facial-Makeup-Studies" class="headerlink" title="Facial Makeup Studies:"></a>Facial Makeup Studies:</h2><ul>
<li>[Guo and Sim, 2009]把素颜图和妆容参考图分成三层，在层与层之间传输信息，缺点是很难把参考妆容warp（？0.0）到素颜图上。</li>
<li>[Scherbaum et al., 2011]用3D模型来辅助化妆，缺点是实际应用中难以采集3D信息。</li>
<li>[Tong et al., 2007]提出“化妆品转移”（要配对还是啥的，反正不实用。。？0.0）</li>
<li>[Liu et al., 2014]提出名为“beauty e-expert”自动妆容推荐和迁移系统。</li>
</ul>
<h2 id="Deep-Image-Synthesis-Methods"><a href="#Deep-Image-Synthesis-Methods" class="headerlink" title="Deep Image Synthesis Methods:"></a>Deep Image Synthesis Methods:</h2><ul>
<li>[Liu et al., 2015;Liang et al.,2015][Dosovitskiy et al., 2015; Dosovitskiy and Brox, 2015]生成CNN模型来生成具有给定对象类型、视点和颜色的图片。</li>
<li>[Simonyan et al., 2013]生成图像，这个图像可视化了网络捕获的类的概念（？0.0）</li>
<li>[Mahendran and Vedaldi, 2015]提供了一个可以把 hand-crafted 和 deep presentations 转化为图像的框架。（。。？0.0啥玩意儿完全看不懂）</li>
<li>[Gatys et al., 2015b]提出了一个基于CNN的parametric texture model，可以合成高质量的自然纹理。</li>
<li>[Goodfellow et al., 2014]生成式对抗网络（大名鼎鼎的GAN），一个生成器一个判别器，生成的图片非常自然。</li>
<li>[Goodfellow et al., 2015]一个简单快速的生成式对抗的方法。增强CNN训练而不是图像合成。</li>
<li>[Kulkarni et al., 2015]深度卷积逆图形网络。（用于学习图像3D渲染还是啥？0.0）</li>
<li>[Cheng et al., 2015]深度学习图像调色。</li>
<li>[Yan et al., 2014]深度学习图像调整。</li>
<li>[Xu et al., 2015]滤镜学习。</li>
<li>[Ren et al., 2015]图像修复。</li>
<li>[Shen et al., 2015]去除阴影。</li>
<li>[Dong et al., 2014]超分辨率。</li>
<li>[Gatys et al., 2015a]这个研究与本文最相似，用CNN来结合一张图的结构层和另一张图的样式层以生成一张新图像。但最大的不同在于本文方法是局部迁移，可以产生更自然的效果。</li>
</ul>
<h1 id="3-Approach"><a href="#3-Approach" class="headerlink" title="3 Approach"></a>3 Approach</h1><p>重头戏来了！！！</p>
<h2 id="3-1-Makeup-Recommendation"><a href="#3-1-Makeup-Recommendation" class="headerlink" title="3.1 Makeup Recommendation"></a>3.1 Makeup Recommendation</h2><p>妆容推荐最重要的标准是个性化。</p>
<p>长得像的人适合类似的妆容。提供一张素颜照，在数据集中找到相似的脸，相似度是比较经过 VGG-Face 人脸识别模型后得到的特征的欧式距离。特征是指两个 l2 标准化 FC-4096 层的串联。VGG-Face 模型基于 VGG-Very-Deep-16 CNN 架构，旨在让化了妆与没化妆的都能被准确识别。提取的特征可以不火到最有区别的人脸结构。最后获得的结果作为把妆容迁移到素颜图上的参考。</p>
<p>下图是每行都是一个推荐的例子，第一列都是素颜图，后四列是参考妆容，说明参考妆容和素颜图有相似的脸型。（其实我没看出来哪里像hhhhhh）</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g78sqcoumtj30c40710wn.jpg" alt=""></p>
<h2 id="3-2-Facial-Parts-vs-Cosmetics-Correspondence"><a href="#3-2-Facial-Parts-vs-Cosmetics-Correspondence" class="headerlink" title="3.2 Facial Parts vs. Cosmetics Correspondence"></a>3.2 Facial Parts vs. Cosmetics Correspondence</h2><p>为了妆容迁移，需要在素颜图的脸部和参考妆容图的脸部的化妆品区域间建立对应关系。大多数对应对可以通过人脸识别的结果获得，比如嘴唇vs口红，但是眼影是例外。因为素颜图没有眼影区域并且人的眼型不同，所以需要把参考图的眼影部分变形。</p>
<h3 id="Face-Parsing"><a href="#Face-Parsing" class="headerlink" title="Face Parsing:"></a>Face Parsing:</h3><p>人脸识别：本文的人脸识别模型基于全卷积网络（FCN），如下图共11个解析标签。网络可以接受任意大小输入，通过有效的推理和学习产生相应大小的输出。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g79sr27feaj30ot03ft9m.jpg" alt=""></p>
<p>在训练人脸识别模型时，更注重和化妆有关的标签。比如和“background”标签相比，“L eye shadow”更重要，所以提出了加权交叉熵损失，是最后一层空间维度的加权和：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g79stbkro4j308f00zwei.jpg" alt=""></p>
<p>其中<code>l&#39;</code>是定义在每个像素上的交叉熵损失。<code>y_ij</code>和<code>p(x_ij,θ)</code>是像素<code>x_ij</code>的真实值<a href="https://www.zhihu.com/question/22464082" target="_blank" rel="noopener">（ground truth）</a>和预测标签，<code>w(y_ij)</code>是权重标签。通过最大化验证集中的F1分数，凭经验设置权重。</p>
<p>由于妆容数据集里的图都是正脸，所以通过人脸检测和对齐预处理。在测试阶段，强制执行对称，并将点p和p镜像对称点的预测置信度改为<code>f(p)</code>，<code>average x_{p,c}=1/2∑(x_{p,c}+x_{f(p),c})</code>。（没看懂？0.0）只有在测试阶段有对称优先，更进一步我们将研究如何在训练前加强结构优先。</p>
<p>下图显示了原始FCN，加权FCN以及对称加权FCN的输出结果。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g796pzyi9dj30c8089mz7.jpg" alt=""></p>
<h3 id="Eye-Shadow-Warping"><a href="#Eye-Shadow-Warping" class="headerlink" title="Eye Shadow Warping"></a>Eye Shadow Warping</h3><p>基于以上人脸识别的结果，脸和底妆的对应关系得以建立，但是素颜图没有眼影，因此需要在素颜图上建立一个眼影遮罩。此外，由于人眼型和眉型的不同，眼影的形状需要稍微变换。更具体地说，在眼睛和眉毛区域获得了八个界标，辅助眼影变形。</p>
<h2 id="3-3-Makeup-Transfer"><a href="#3-3-Makeup-Transfer" class="headerlink" title="3.3 Makeup Transfer"></a>3.3 Makeup Transfer</h2><p>这部分具体介绍如何转移眼影，口红和粉底。并且还要考虑最终结果保持面部结构。</p>
<h3 id="Eye-Shadow-Transfer"><a href="#Eye-Shadow-Transfer" class="headerlink" title="Eye Shadow Transfer"></a>Eye Shadow Transfer</h3><p>眼影需要考虑颜色和形状。下文以左眼影为例。<code>s_r</code>是妆容参考图里左眼影的二进制遮罩，<code>s_b</code>是素颜图经过变形后的的左眼影二进制遮罩。在变形之后，<code>s_r</code>和<code>s_b</code>有相同的形状和大小。眼影转移就是用<code>s_r</code>替代<code>s_b</code>的某一层（conv1-1）的深层特征表示。转移时的loss为<code>R_l(A)</code>：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7bq0dtj19j30d30313yq.jpg" alt=""></p>
<p>其中H，W，C分别代表输入图像的高，宽和通道数。<code>Ω^l : R^(H×W×C) → R^d</code>是人脸识别模型的<code>conv1-1</code>层的<code>d-dim</code>特征表示，A和R分别代表化妆后的图和妆容参考图。<code>s&#39;_r</code>和<code>s&#39;_b</code>是通过卷积特征遮罩将<code>s_r</code>和<code>s_b</code>从数据层映射到<code>conv1-1</code>层获得的。<code>A(s&#39;_b)</code>和<code>R(s&#39;_r)</code>是遮罩<code>s_r</code>和<code>s_b</code>对应的眼影区域。眼影转移的结果如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7bui0ma2uj30dc04iwgt.jpg" alt=""></p>
<h3 id="Lip-Gloss-and-Foundation-Transfer"><a href="#Lip-Gloss-and-Foundation-Transfer" class="headerlink" title="Lip Gloss and Foundation Transfer"></a>Lip Gloss and Foundation Transfer</h3><p>口红转移需要转移颜色和质地。唇釉<code>R_f(A)</code>如下式：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7bume21qaj30cw03bweq.jpg" alt=""></p>
<p>L代表使用的层数，用了五层，包括conv1-1, conv2-1,  conv3-1, conv4-1 and conv5-1。<code>Ω^l</code>矩阵如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7bupmfuezj309101njre.jpg" alt=""></p>
<p><code>N_l</code>是第l层中特征图的数量，<code>(Ω_ij)^l</code>是第l层向量化特征图i和j的内积。</p>
<p>粉底转移的效果图如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7buut6qijj30dl07btbf.jpg" alt=""></p>
<h3 id="Structure-Preservati"><a href="#Structure-Preservati" class="headerlink" title="Structure Preservati"></a>Structure Preservati</h3><p>保持结构</p>
<h3 id="Overall-Makeup-Transfer"><a href="#Overall-Makeup-Transfer" class="headerlink" title="Overall Makeup Transfer"></a>Overall Makeup Transfer</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g82udt5fyvj30ct02774h.jpg" alt=""></p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g82uebgi12j30ay01974c.jpg" alt=""></p>
<p><code>R_l(A)</code>, <code>R_r(A)</code>, <code>R_f(A)</code>, <code>R_up(A)</code>, <code>R_low(A)</code>, <code>R_s(A)</code>分别代表左眼影，右眼影，底妆，上嘴唇，下嘴唇和结构丢失。<code>λ_e</code>, <code>λ_f</code> , <code>λ_l</code> , <code>λ_e</code>来平衡不同化妆品的权重，哪个高对应的妆容就重。</p>
<p>用SGD（随机梯度下降）优化了这个式子：（<code>µ_t</code>是最后几个梯度的加权平均值，衰减因子m=0.9）</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g82uljszroj30br00zwei.jpg" alt=""></p>
<p>妆容轻重图如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g82uhzahuhj30cv0e845g.jpg" alt=""></p>
<h1 id="4-Experiments"><a href="#4-Experiments" class="headerlink" title="4 Experiments"></a>4 Experiments</h1><h2 id="4-1-Experimental-Setting"><a href="#4-1-Experimental-Setting" class="headerlink" title="4.1 Experimental Setting"></a>4.1 Experimental Setting</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g82uqje24fj30dk09cqah.jpg" alt=""></p>
<p>上图是几个主流妆容迁移方法的对比。</p>
<p>原文一堆balabala的话，根据我的理解总结一下就是，以前的方法比如素颜图的内容层和参考图的风格层结合，眼影口红这些都是难以准确表现的，而局部妆容迁移在这一问题上产生了很好的效果。</p>
<p>所以一个人就可以尝试不同的妆容啦～</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g82uxkydbmj30ce06ojun.jpg" alt=""></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>阅读笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS下警告objc[4131]: Class FIFinderSyncExtensionHost is implemented in both问题的原因及解决办法</title>
    <url>/4ee128c1/</url>
    <content><![CDATA[<h1 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h1><p>用python的tkinter库里<s>不知道什么东西</s>的时候报了这个，本质上没有啥影响，程序还是能跑，但是看着<s>有点</s>很难受</p>
<p>我的系统是macOS Mojave 10.14.2</p>
<p><code>objc[4131]: Class FIFinderSyncExtensionHost is implemented in both /System/Library/PrivateFrameworks/FinderKit.framework/FinderKit (0x143d28210) and /System/Library/PrivateFrameworks/FileProvider.framework/OverrideBundles/FinderSyncCollaborationFileProviderOverride.bundle/Contents/MacOS/FinderSyncCollaborationFileProviderOverride (0x15e012dc8). One of the two will be used. Which one is undefined.</code></p>
<h1 id="2-原因"><a href="#2-原因" class="headerlink" title="2.原因"></a>2.原因</h1><p>然后Google一下，发现这个警告不止在pycharm运行python时候有，macos下Java，Qt，Xcode啥的都有人遇到过，并且好多说了是在打开对话框的时候遇到</p>
<p>stackoverflow:<a href="https://stackoverflow.com/questions/46999695/class-fifindersyncextensionhost-is-implemented-in-both-warning-in-xcode-si" target="_blank" rel="noopener">‘Class FIFinderSyncExtensionHost is implemented in both …’ warning in Xcode since update to macOS High Sierra
</a></p>
<p>Github issues:<a href="https://github.com/lionheart/openradar-mirror/issues/17659" target="_blank" rel="noopener">32839314: Class FIFinderSyncExtensionHost implemented twice</a></p>
<p>结论就是：这是苹果的问题，（好像）仅在使用本机文件系统对话框的时候才会发生，警告就是指出一个库里定义了两个相同的class，但是他们通常是相同的所以其实用哪个都不影响程序的正常运行</p>
<h1 id="3-解决办法"><a href="#3-解决办法" class="headerlink" title="3.解决办法"></a>3.解决办法</h1><p>所以我们需要做的就是：There’s nothing you can do about this！什么都不做！<code>_(:з」∠)_</code></p>
<p>仅找到一个在Qt上忽略该警告的解决办法：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7tfyqf7tqj30l808ymy3.jpg" alt=""></p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS下NLTK下载语料库时certificate verify failed(_ssl.c:749)问题的原因及解决办法</title>
    <url>/3bd88164/</url>
    <content><![CDATA[<h1 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h1><p>知道了有nltk这个东西，然后平平常常开始下载语料库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import nltk</span><br><span class="line">nltk.download()</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>然后就跳出来一个并不正常的下载页面QwQ，报错<code>[SSL:CERTIFICATE_VERIFY_FAILED]certificate verify failed(_ssl.c:749)</code></p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7cxidsnefj31400ce0uw.jpg" alt=""></p>
<h1 id="2-原因"><a href="#2-原因" class="headerlink" title="2.原因"></a>2.原因</h1><p>查了一下会出现这个问题是SSL检查时报的错，大意是<code>urllib</code>用了一个嵌入式版本的OpenSSL，而这个版本不在系统证书里。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7cyhfs13gj30kt08ojsy.jpg" alt=""></p>
<p>放上stackoverflow对于这个问题的讨论链接：<a href="https://stackoverflow.com/questions/41348621/ssl-error-downloading-nltk-data" target="_blank" rel="noopener">https://stackoverflow.com/questions/41348621/ssl-error-downloading-nltk-data</a></p>
<h1 id="3-根本原因"><a href="#3-根本原因" class="headerlink" title="3.根本原因"></a>3.根本原因</h1><p>只有在macos下3.6/3.7版本的python上会出现这个错误，和之前遇到过的python下安装pyspider报错本质上是一个原因，就是python3.6开始不再使用苹果提供的OpenSSL库，然后就会导致下图的一系列说明，，（懒得翻译了，，看个大概）</p>
<p>这里也提到了解决办法，就是从第三方certifi安装证书包（a curated bundle of default root certificates）</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7cyx0ls9jj30w703naba.jpg" alt=""></p>
<p>关于这个问题更详细的官方说明可以见这个python issue：<a href="https://bugs.python.org/issue28150" target="_blank" rel="noopener">https://bugs.python.org/issue28150</a></p>
<h1 id="4-解决方法"><a href="#4-解决方法" class="headerlink" title="4.解决方法"></a>4.解决方法</h1><p>网上的一种解决方式是每次都加上禁用SSL检查的语句，但是还有一种更简单粗暴的方法，只要执行下面两句即可解决</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;Applications&#x2F;Python\ 3.6&#x2F;</span><br><span class="line">.&#x2F;Install\ Certificates.command</span><br></pre></td></tr></table></figure>

<p>然后就可以快乐安装语料库了</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7cz805nnfj31300ahn0t.jpg" alt=""></p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS下用sublime写LaTeX并配置自动补全功能</title>
    <url>/d4b45e0b/</url>
    <content><![CDATA[<p>原来大家都有自动补全，，就我一直用TeXShop手打LaTeX，，所以给我最喜欢的sublime也配一个写LaTeX的环境</p>
<hr>
<h1 id="1-安装LaXeT语言环境"><a href="#1-安装LaXeT语言环境" class="headerlink" title="1.安装LaXeT语言环境"></a>1.安装LaXeT语言环境</h1><p><code>shift+commond+p</code>进入框框，输入<code>install package</code></p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7bmekwhxlj30fl01wdfv.jpg" alt=""></p>
<p>然后在框里输入<code>latextools</code>（因为我已经装好这个插件了所以下图里不再显示）</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7bmguayk5j30fk0ay75l.jpg" alt=""></p>
<p>重启sublime，<code>【菜单栏】-【Tools】-【Build System】</code>，就可以发现语言环境里已经有LaTeX了</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7bmi96mmxj30f30e20y2.jpg" alt=""></p>
<h1 id="2-自动补全"><a href="#2-自动补全" class="headerlink" title="2.自动补全"></a>2.自动补全</h1><p>先像上面一个打开install package的框，输入latexcwl然后点它</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7bn5h5fz6j30fn035dg2.jpg" alt=""></p>
<p>这样输入的时候就有快乐补全功能了</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7bn7j8gasj30in0520ty.jpg" alt=""></p>
<h1 id="3-配置pdf预览"><a href="#3-配置pdf预览" class="headerlink" title="3.配置pdf预览"></a>3.配置pdf预览</h1><p>接下来配置 pdf 预览部分，打开 sublime 设置，<code>【sublime text-preference-settings】</code></p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7bmu6gz12j30bi05cq6m.jpg" alt=""></p>
<p>在 user 自定义的部分中设置预览器为 mac 自带的预览 preview</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;viewer&quot;: &quot;preview&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7bmv4lut1j30jh06rabt.jpg" alt=""></p>
<p>现在打开一个<code>.tex</code>文件，就可以用<code>shift+command+b</code>自动编译运行了，会跳出来一个下图所示的编译选项，选择对应的即可，比如有中文所以我选的 XeLaTeX</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7bmz0sgwuj30fm09c0tf.jpg" alt=""></p>
<p>撒花～</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7bn1mjm0qj30yn0e4wje.jpg" alt=""></p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>libgomp.spec： No such file or directory问题的解决方法</title>
    <url>/99a25f14/</url>
    <content><![CDATA[<p>想编译一个openmp程序，报错<code>libgomp.spec: No such file or directory</code></p>
<p>可以参考这个github-issues<a href="https://github.com/dmlc/xgboost/issues/1027" target="_blank" rel="noopener">https://github.com/dmlc/xgboost/issues/1027</a></p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g744ycgh2oj30lp059754.jpg" alt=""></p>
<p>去官网<a href="http://tdm-gcc.tdragon.net/download" target="_blank" rel="noopener">TDM-GCC:Download</a>下一下TDM-GCC然后重装，要勾选openmp这个选项，然后就好了</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g73gvuwsorj30rq0lkdgt.jpg" alt=""></p>
<p>这篇博客好水。。。ORZ</p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>cl 不是内部或外部命令,也不是可运行的程序或批处理文件问题的解决方法</title>
    <url>/11ea15c8/</url>
    <content><![CDATA[<p>Windows10下报错：’cl’ 不是内部或外部命令,也不是可运行的程序或批处理文件</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70lq4vo08j307204a3ya.jpg" alt=""></p>
<p>先输入set检查一下环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70lqmg1yoj30ln0camxh.jpg" alt=""></p>
<p>发现在最后有这个叫VS120COMNTOOLS啥的（不同版本号对应的数字不一样，道理是一样的）</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70lqsaj0bj313303oweg.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VS120COMNTOOLS&#x3D;C:\Program Files (x86)\Microsoft Visual Studio 12.0\Common7\Tools\windir&#x3D;C:\WINDOWS</span><br></pre></td></tr></table></figure>

<p>运行这个环境变量文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call &quot;%VS120COMNTOOLS%&quot;vsvars32.bat</span><br></pre></td></tr></table></figure>

<p>如果没有的话，可以参考stack overflow的这个问题 -&gt;<a href="https://stackoverflow.com/questions/42805662/vsvars32-bat-in-visual-studio-2017" target="_blank" rel="noopener">vsvars32.bat in Visual Studio 2017
</a></p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70lrdspfvj31dg059jri.jpg" alt=""></p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>2019CCPC中国大学生程序设计竞赛-女生专场（重现赛）</title>
    <url>/1d3d3968/</url>
    <content><![CDATA[<p>重现赛地址：<a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2019%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%B3%CC%D0%F2%C9%E8%BC%C6%BE%BA%C8%FC-%C5%AE%C9%FA%D7%A8%B3%A1%A3%A8%D6%D8%CF%D6%C8%FC%A3%A9-%B8%D0%D0%BB%C4%CF%BE%A9%CF%FE%D7%AF%D1%A7%D4%BA&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener">http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2019%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%B3%CC%D0%F2%C9%E8%BC%C6%BE%BA%C8%FC-%C5%AE%C9%FA%D7%A8%B3%A1%A3%A8%D6%D8%CF%D6%C8%FC%A3%A9-%B8%D0%D0%BB%C4%CF%BE%A9%CF%FE%D7%AF%D1%A7%D4%BA&amp;source=1&amp;searchmode=source</a></p>
<a id="more"></a>

<hr>
<h1 id="A-Ticket（hdu6544）"><a href="#A-Ticket（hdu6544）" class="headerlink" title="A.Ticket（hdu6544）"></a>A.Ticket（hdu6544）</h1><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6ahsyyzsmj30qb01h0t2.jpg" alt=""></p>
<p>简单模拟</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	double x,sum&#x3D;0;</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">		scanf(&quot;%lf&quot;,&amp;x);</span><br><span class="line">		if(sum&lt;100)sum+&#x3D;x;</span><br><span class="line">		else if(sum&gt;&#x3D;100&amp;&amp;sum&lt;150)sum+&#x3D;x*0.8;</span><br><span class="line">		else if(sum&gt;&#x3D;150&amp;&amp;sum&lt;400)sum+&#x3D;x*0.5;</span><br><span class="line">		else sum+&#x3D;x;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%.2lf\n&quot;,sum);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-Gcd（hdu6545）"><a href="#B-Gcd（hdu6545）" class="headerlink" title="B.Gcd（hdu6545）"></a>B.Gcd（hdu6545）</h1><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6aht6bin9j30pl0100sy.jpg" alt=""></p>
<p>假设和为<code>sum=(n+1)*n/2</code>，那么最大公约数x满足<code>sum=k*x(k为整数)</code>，枚举sum的因子就可以求k</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">int main()&#123;</span><br><span class="line">	LL n;</span><br><span class="line">	scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">	LL sum&#x3D;(n+1)*n&#x2F;2;</span><br><span class="line">	for(int i&#x3D;2;i&lt;&#x3D;sqrt(sum);i++)&#123;</span><br><span class="line">		if(sum%i&#x3D;&#x3D;0)&#123;</span><br><span class="line">			printf(&quot;%lld\n&quot;,sum&#x2F;i);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-Function（hdu6546）"><a href="#C-Function（hdu6546）" class="headerlink" title="C.Function（hdu6546）"></a>C.Function（hdu6546）</h1><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6ahtabz6cj30c801yglp.jpg" alt=""></p>
<p>一开始分类讨论了半天，不同函数的对称轴位置啥的，最后发现想太麻烦了。。清清爽爽的思路才靠谱啊。。</p>
<p>贪心，首先xi是正整数，所以一开始xi=1，这样m2=n，接着就是要把一些xi增加，用一个优先队列存xi变为xi+1的增量<code>a(x+1)^2+b(x+1)+c-ax^2+bx+c=2ax+a+b</code>，每次取增量最小的，然后把这个函数的xi+2的增量加入优先队列继续，最多也只需要push 1e5 次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;1e5+5;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int a,b,c;</span><br><span class="line">	int x;</span><br><span class="line">	LL change;</span><br><span class="line">	bool operator &lt;(const node &amp;n2)const&#123;</span><br><span class="line">		return change&gt;n2.change;</span><br><span class="line">		&#x2F;&#x2F; 优先队列默认从大到小所以反着来</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt; pq;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,m;</span><br><span class="line">	LL ans&#x3D;0;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">		node tmp;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;,&amp;tmp.a,&amp;tmp.b,&amp;tmp.c);</span><br><span class="line">		ans+&#x3D;(tmp.a+tmp.b+tmp.c);</span><br><span class="line">		tmp.change&#x3D;2*tmp.a+tmp.a+tmp.b;</span><br><span class="line">		tmp.x&#x3D;2;</span><br><span class="line">		pq.push(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	int m2&#x3D;n;</span><br><span class="line">	while(m2&lt;m)&#123;</span><br><span class="line">		node tmp&#x3D;pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		ans+&#x3D;tmp.change;</span><br><span class="line">		tmp.change&#x3D;2*tmp.a*tmp.x+tmp.a+tmp.b;</span><br><span class="line">		tmp.x++;</span><br><span class="line">		pq.push(tmp);</span><br><span class="line">		m2++;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-Tree（hdu6547）"><a href="#D-Tree（hdu6547）" class="headerlink" title="D.Tree（hdu6547）"></a>D.Tree（hdu6547）</h1><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6ahtgkg9rj30ay02maa7.jpg" alt=""></p>
<p>大概是树链剖分板子，不会打也不想打0.0。。待补</p>
<h1 id="E-Checkout（hdu6548）"><a href="#E-Checkout（hdu6548）" class="headerlink" title="E.Checkout（hdu6548）"></a>E.Checkout（hdu6548）</h1><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6ahtjra69j30qi03s75x.jpg" alt=""></p>
<p>不会。。看了民间题解，树形dp，待补</p>
<h1 id="F-String（hdu6549）"><a href="#F-String（hdu6549）" class="headerlink" title="F.String（hdu6549）"></a>F.String（hdu6549）</h1><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6ahtovzsnj30nv01bjrn.jpg" alt=""></p>
<p><s>一开始的思路是这样的：先给原始的段染个色，然后dp，设dp[i][j]为前i个分成j段最少需要修改的次数，一次最多能改l个，状态转移方程为：如果这l个要改，那么要么全改成和前一段一样的，要么全改成和前一段不一样的<code>dp[i][j]=min(dp[cur][j]+1,dp[cur][j-1]+1);</code>，如果这l个本来就和前面那段同色，可以不改<code>dp[i][j]=min(dp[i][j],dp[cur][j]);</code>，或者这l个本来就是一个颜色，也可以不改而多一段<code>dp[i][j]=min(dp[i][j],dp[cur][j-1]);</code></s></p>
<p><s>但是样例那种<code>bab</code>，变中间的就没法处理了。。看了别人的题解写的是判断s[i]和前一个段的前一个段的末尾字母一不一样，一样的话中间那段就可以变了使前后相连，感觉这个dp思路还是有问题。。而且我一直wa。。</s></p>
<p>就是一直wa。。待补</p>
<h1 id="G-Circle（hdu6550）"><a href="#G-Circle（hdu6550）" class="headerlink" title="G.Circle（hdu6550）"></a>G.Circle（hdu6550）</h1><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6ahtx283bj30qa01iglu.jpg" alt=""></p>
<p>另一个点显然加在某两个相邻点的正中间，然后就是普通几何问题，求一下圆心那里三角形的角度然后算三角形面积和</p>
<p>竟然不能用<code>M_PI</code>，会编译错误。。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define pai acos(-1.0)</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	while(scanf(&quot;%d&quot;,&amp;n)!&#x3D;EOF)&#123;</span><br><span class="line">		double alpha&#x3D;2*pai&#x2F;(double)n;</span><br><span class="line">		double s1&#x3D;(double)1&#x2F;2*sin(alpha)*(n-1);</span><br><span class="line">		alpha&#x2F;&#x3D;2;</span><br><span class="line">		double s2&#x3D;sin(alpha);</span><br><span class="line">		printf(&quot;%.6lf\n&quot;,s1+s2);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="H-Clock（hdu6551）"><a href="#H-Clock（hdu6551）" class="headerlink" title="H.Clock（hdu6551）"></a>H.Clock（hdu6551）</h1><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6ahu0w498j30qf02i74z.jpg" alt=""></p>
<p>全化成十二小时的秒然后排个序，要么是一直顺时针/逆时针，要么是先顺时针一下然后逆时针/先逆时针一下然后顺时针，枚举变向的位置暴力即可</p>
<p>本来感觉写着好麻烦。。边界容易错啥的结果一发过了hhhhh快乐</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;1e5;</span><br><span class="line">const int p&#x3D;43200;</span><br><span class="line">int a[N],now;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	int h,m,s;</span><br><span class="line">	scanf(&quot;%d%d%d&quot;,&amp;h,&amp;m,&amp;s);</span><br><span class="line">	now&#x3D;(h*3600+m*60+s)%43200;</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;,&amp;h,&amp;m,&amp;s);</span><br><span class="line">		a[i]&#x3D;(h*3600+m*60+s)%43200;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(a,a+n);</span><br><span class="line">	int ans&#x3D;0;</span><br><span class="line">	if(now&lt;a[0])&#123;</span><br><span class="line">		ans&#x3D;a[n-1]-now;</span><br><span class="line">		ans&#x3D;min(now+p-a[0],ans);</span><br><span class="line">	&#125;</span><br><span class="line">	else if(now&gt;a[n-1])&#123;</span><br><span class="line">		ans&#x3D;p-now+a[n-1];</span><br><span class="line">		ans&#x3D;min(now-a[0],ans);</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		int pos&#x3D;lower_bound(a,a+n,now)-a;</span><br><span class="line">		ans&#x3D;p-now+a[pos-1];</span><br><span class="line">		&#x2F;&#x2F; 先顺后逆</span><br><span class="line">		for(int i&#x3D;pos;i&lt;n-1;i++)&#123;</span><br><span class="line">			int tmp&#x3D;a[i]-now+a[i]+p-a[i+1];</span><br><span class="line">			ans&#x3D;min(ans,tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		ans&#x3D;min(ans,a[n-1]-now+a[n-1]-a[0]);</span><br><span class="line">		&#x2F;&#x2F; 先逆后顺</span><br><span class="line">		for(int i&#x3D;1;i&lt;pos;i++)&#123;</span><br><span class="line">			int tmp&#x3D;now-a[i]+p-a[i]+a[i-1];</span><br><span class="line">			ans&#x3D;min(ans,tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		ans&#x3D;min(ans,now-a[0]+a[n-1]-a[0]);</span><br><span class="line">	&#125;</span><br><span class="line">	double res&#x3D;(double)ans;</span><br><span class="line">	printf(&quot;%.2lf\n&quot;,res*6);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="I-Union（hdu6552）"><a href="#I-Union（hdu6552）" class="headerlink" title="I.Union（hdu6552）"></a>I.Union（hdu6552）</h1><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6atta7mjkj30fd03kwf7.jpg" alt=""></p>
<p>不会，待补</p>
<h1 id="J-Tangram（hdu6553）"><a href="#J-Tangram（hdu6553）" class="headerlink" title="J.Tangram（hdu6553）"></a>J.Tangram（hdu6553）</h1><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6aisd2nr3j30lg0dnju0.jpg" alt=""></p>
<p>一条线最多可以经过6个颜色，第二条线再切一下第一条，最多经过7个颜色，第三条线再切一下前两条，最多经过8个颜色……</p>
<table><tr>
<td><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6at0g0uy8j30ez0f6q76.jpg" width=400></td>
<td><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6at3qqhlxj30f90f242s.jpg" width=400></td>
</tr></table>

<p>所以答案就是<code>7+6+7+8+...=(6+(n+6-1))*n/2</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std; </span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">int main()&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    while(scanf(&quot;%lld&quot;,&amp;n)!&#x3D;EOF)&#123;</span><br><span class="line">        LL ans&#x3D;(6+(n+6-1))*n&#x2F;2;</span><br><span class="line">        ans+&#x3D;7;</span><br><span class="line">        printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="K-Tetris（hdu6554）"><a href="#K-Tetris（hdu6554）" class="headerlink" title="K.Tetris（hdu6554）"></a>K.Tetris（hdu6554）</h1><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6au1i7i5kj30hh04q0tq.jpg" alt=""></p>
<p>构造题</p>
<p>画了几个好像是只有样例那种<code>4*4</code>是可以变成方形的，因为要把多出来的那个包中间才有可能，所以就看看是不是<code>4*4</code>的块的倍数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std; </span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">int ans[4][4]&#x3D;&#123;1,1,1,3,2,1,3,3,2,2,4,3,2,4,4,4&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!&#x3D;EOF)&#123;</span><br><span class="line">        if(n%4&#x3D;&#x3D;0&amp;&amp;m%4&#x3D;&#x3D;0)&#123;</span><br><span class="line">            for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">                for(int j&#x3D;0;j&lt;m;j++)&#123;</span><br><span class="line">                    printf(&quot;%d&quot;,ans[i%4][j%4]);</span><br><span class="line">                &#125;</span><br><span class="line">                printf(&quot;\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else puts(&quot;no response&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>gii生成代码时覆写失败Unable to write the file问题的原因及解决方法（Linux权限位）</title>
    <url>/cd44f702/</url>
    <content><![CDATA[<p>在用Gii生成代码Model Genarator的过程中，因为要生成的活动记录类我之前已经手动添加过一个同名的了，所以就需要overwrite</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4rpkq68c7j31bo0943zx.jpg" alt=""></p>
<p>但是选中了黄色那行最后的overwrite之后，点击Generator却显示Failed，Unable to write the file ‘/opt/lampp/htdocs/advanced/frontend/models/</p>
<p>忘记截图了所以只有留在搜索引擎中的这段错误描述。。</p>
<p>权限不足引起的，因此要修改文件夹的权限</p>
<p>关于Linux的权限位介绍如下：</p>
<table>
<thead>
<tr>
<th>字符表示</th>
<th>八进制</th>
<th>对于文件</th>
<th>对于目录</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>4</td>
<td>读取权限</td>
<td>列出权限</td>
</tr>
<tr>
<td>w</td>
<td>2</td>
<td>写入权限</td>
<td>创建权限</td>
</tr>
<tr>
<td>x</td>
<td>1</td>
<td>执行权限</td>
<td>进入权限</td>
</tr>
<tr>
<td>s</td>
<td>4000</td>
<td>属主权限</td>
<td>-</td>
</tr>
<tr>
<td>s</td>
<td>2000</td>
<td>-</td>
<td>继承权限</td>
</tr>
<tr>
<td>t</td>
<td>1000</td>
<td>-</td>
<td>粘滞位</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">444 r--r--r--</span><br><span class="line">600 rw-------</span><br><span class="line">644 rw-r--r--</span><br><span class="line">666 rw-rw-rw-</span><br><span class="line">700 rwx------</span><br><span class="line">744 rwxr--r--</span><br><span class="line">755 rwxr-xr-x</span><br><span class="line">777 rwxrwxrwx</span><br></pre></td></tr></table></figure>

<p>可以发现其实就是个二进制组合啦，从左到右1-3位数字代表文件所有者的权限，4-6位数字代表同组用户的权限，7-9数字代表其他用户的权限，所以777是最高权限位</p>
<p>需要什么权限就写<code>chmod -R 数字 文件夹路径</code>，我这就开了777</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod -R 777 &#x2F;Users&#x2F;mac&#x2F;.bitnami&#x2F;stackman&#x2F;machines&#x2F;xampp&#x2F;volumes&#x2F;root&#x2F;htdocs&#x2F;advanced</span><br></pre></td></tr></table></figure>

<p>修改权限后就可以正常覆写了，successfully！</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4rpl320tzj31ba09wwfr.jpg" alt=""></p>
]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>yii2 advanced——使用 Gii 生成代码</title>
    <url>/f59d086f/</url>
    <content><![CDATA[<p>本教程全靠乱来。。能运行了我就当它对了，所以如果错了那就是我真的猜错了<a href="https://www.yiichina.com/doc/guide/2.0" target="_blank" rel="noopener">官方文档</a>的意思，可能这东西不这么用，，望指出，感谢m(( _ _ ))m</p>
<a id="more"></a>

<hr>
<h1 id="1-开始gii"><a href="#1-开始gii" class="headerlink" title="1.开始gii"></a>1.开始gii</h1><p>advanced里的Gii模块好像是一开始就默认开启的（说这句话是因为，，我没找到配置文件在哪），所以直接访问<code>http://localhost:8080/advanced/frontend/web/index.php/gii</code>就可以看到了</p>
<p>检查前端的入口脚本<code>advanced/frontend/web/index.php</code>，可以看到有下面这行代码，鉴于这段代码的定义，应用处于开发模式下就可以访问Gii模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">defined(&#39;YII_ENV&#39;) or define(&#39;YII_ENV&#39;, &#39;dev&#39;);</span><br></pre></td></tr></table></figure>

<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4rnw2vxx2j31rc0u0qaw.jpg" alt=""></p>
<h1 id="2-生成活动记录类"><a href="#2-生成活动记录类" class="headerlink" title="2.生成活动记录类"></a>2.生成活动记录类</h1><p>选择<code>Model Generator</code></p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4rnww0y41j30k608mdgg.jpg" alt=""></p>
<p>只要填写第一个输入框，剩下的表单会自动填好，我照官方文档的对了一下好像啥都不用改，所以直接点最后的preview按钮就行</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4ro2e0bfoj30u00vkju6.jpg" alt=""></p>
<p>成功了之后就会是这个样子</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4rpkq68c7j31bo0943zx.jpg" alt=""></p>
<p>然后需要勾选最后的地方再点击generator进行生成（我这里因为之前添加过这个活动记录所以就需要勾选覆写overwrite）</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4rpl320tzj31ba09wwfr.jpg" alt=""></p>
<h1 id="3-生成-CRUD-代码"><a href="#3-生成-CRUD-代码" class="headerlink" title="3.生成 CRUD 代码"></a>3.生成 CRUD 代码</h1><p>CRUD 代表增，查，改，删操作</p>
<p>回到之前的主页，选择Gii中的CRUD Generator来创建CRUD功能</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4rohqzxd2j30jg09kmy2.jpg" alt=""></p>
<p>填写如下表单：</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4romi1bbrj31590u0q6z.jpg" alt=""></p>
<p>成功后预览如下：</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4rp2eod0ej31aw0jkadr.jpg" alt=""></p>
<p>全选然后点击上面的generator按钮，写入成功页面将提示如下：</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4rpxunnoej31bu0h041s.jpg" alt=""></p>
<h1 id="4-运行"><a href="#4-运行" class="headerlink" title="4.运行"></a>4.运行</h1><p>然后访问<code>http://localhost:8080/advanced/frontend/web/index.php/country/index</code></p>
<p>报了这样的错，这个之前遇到过是因为命名空间有误的原因</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4rq0xvr93j327a09smzq.jpg" alt=""></p>
<p>具体写在这篇里面了 -&gt; <a href="">Yii2报错Unknown Class – yii\base\UnknownClassException<br>Unable to find……问题的原因及解决方法</a></p>
<p>运行成功后显示如下：</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4rq8381ptj31i10u0q9a.jpg" alt=""></p>
<p>可以进行数据的增删查改操作，妥</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4rq9tviknj31tu0mkq4p.jpg" alt=""></p>
<p>随便填一个试试</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4rqbyihajj31ti0duq47.jpg" alt=""></p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4rqadjmmuj31ts0ecaby.jpg" alt=""></p>
<p>这个视图可比自己写的好看多了ORZ</p>
]]></content>
      <categories>
        <category>web开发</category>
      </categories>
  </entry>
  <entry>
    <title>Yii2报错Unknown Class yii\base\UnknownClassException Unable to find……问题的原因及解决方法</title>
    <url>/e45aafa1/</url>
    <content><![CDATA[<p>因为用的是advanced版本所以有些东西不知道放哪里，跟着官方文档basic版本的教程来，但是advanced和basic的文件夹架构完全不一样，advanced版本把前端、后端、控制台分离成三个yii应用程序</p>
<p>遇到了几次下面这个问题：</p>
<p>Unknown Class – yii\base\UnknownClassException<br>Unable to find ‘frontend\controllers\CountryController’ in file: /opt/lampp/htdocs/advanced/frontend/controllers/CountryController.php. Namespace missing?</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4rq4osv02j325o0e0n0f.jpg" alt=""></p>
<p>可以大概推测一下是说命名空间有问题，打开<code>advanced/frontend/controllers</code>目录下的其它一些原有的文件，就会发现命名空间写的是<code>namespace frontend\controllers;</code>，而官方文档默认的是<code>namespace app\controllers;</code>，所以只要对应的把app改为frontend就能解决这个问题</p>
<p>如果是用gii自动生成的代码也会有这个问题，手动修改一下就好了</p>
<p>修改后就可以在浏览器正常访问啦</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4rq8381ptj31i10u0q9a.jpg" alt=""></p>
]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>yii2 advanced——使用数据库</title>
    <url>/eb02ef60/</url>
    <content><![CDATA[<p>本教程全靠乱来。。能运行了我就当它对了，所以如果错了那就是我真的猜错了<a href="https://www.yiichina.com/doc/guide/2.0" target="_blank" rel="noopener">官方文档</a>的意思，可能这东西不这么用，，望指出，感谢m(( _ _ ))m</p>
<hr>
<p>创建一个数据表，从中读取数据并显示出来页面</p>
<p>需要配置一个数据连接，创建一个活动记录类，创建一个操作及一个视图</p>
<h1 id="1-准备数据库"><a href="#1-准备数据库" class="headerlink" title="1.准备数据库"></a>1.准备数据库</h1><p><code>http://localhost:8080/phpmyadmin/</code>访问数据库</p>
<p>新建一个名为yii2basic的数据库</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4rhir7kg9j30ua0d2gnk.jpg" alt=""></p>
<p>输入如下sql代码，新建了一个country表并且插入了一些数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;country&#96; (</span><br><span class="line">  &#96;code&#96; CHAR(2) NOT NULL PRIMARY KEY,</span><br><span class="line">  &#96;name&#96; CHAR(52) NOT NULL,</span><br><span class="line">  &#96;population&#96; INT(11) NOT NULL DEFAULT &#39;0&#39;</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO &#96;country&#96; VALUES (&#39;AU&#39;,&#39;Australia&#39;,18886000);</span><br><span class="line">INSERT INTO &#96;country&#96; VALUES (&#39;BR&#39;,&#39;Brazil&#39;,170115000);</span><br><span class="line">INSERT INTO &#96;country&#96; VALUES (&#39;CA&#39;,&#39;Canada&#39;,1147000);</span><br><span class="line">INSERT INTO &#96;country&#96; VALUES (&#39;CN&#39;,&#39;China&#39;,1277558000);</span><br><span class="line">INSERT INTO &#96;country&#96; VALUES (&#39;DE&#39;,&#39;Germany&#39;,82164700);</span><br><span class="line">INSERT INTO &#96;country&#96; VALUES (&#39;FR&#39;,&#39;France&#39;,59225700);</span><br><span class="line">INSERT INTO &#96;country&#96; VALUES (&#39;GB&#39;,&#39;United Kingdom&#39;,59623400);</span><br><span class="line">INSERT INTO &#96;country&#96; VALUES (&#39;IN&#39;,&#39;India&#39;,1013662000);</span><br><span class="line">INSERT INTO &#96;country&#96; VALUES (&#39;RU&#39;,&#39;Russia&#39;,146934000);</span><br><span class="line">INSERT INTO &#96;country&#96; VALUES (&#39;US&#39;,&#39;United States&#39;,278357000);</span><br></pre></td></tr></table></figure>

<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4rimg0blyj30s80mewl7.jpg" alt=""></p>
<h1 id="2-配置数据库连接"><a href="#2-配置数据库连接" class="headerlink" title="2.配置数据库连接"></a>2.配置数据库连接</h1><p>高级版的数据库配置文件为<code>advanced/common/config/main-local.php</code>，这个文件配置了数据库连接的创建和初始化参数，只需要根据自己的需要进行修改即可，比如我上面在phpmyadmin中创建的时候数据库名为yii2basic，所以只要修改dbname那项对应的名字即可</p>
<p>这个配置好的连接可以在应用中通过<code>Yii::$app-&gt;db</code>访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">return [</span><br><span class="line">    &#39;components&#39; &#x3D;&gt; [</span><br><span class="line">        &#39;db&#39; &#x3D;&gt; [</span><br><span class="line">            &#39;class&#39; &#x3D;&gt; &#39;yii\db\Connection&#39;,</span><br><span class="line">            &#39;dsn&#39; &#x3D;&gt; &#39;mysql:host&#x3D;localhost;dbname&#x3D;yii2basic&#39;,</span><br><span class="line">            &#39;username&#39; &#x3D;&gt; &#39;root&#39;,</span><br><span class="line">            &#39;password&#39; &#x3D;&gt; &#39;&#39;,</span><br><span class="line">            &#39;charset&#39; &#x3D;&gt; &#39;utf8&#39;,</span><br><span class="line">        ],</span><br><span class="line">        &#39;mailer&#39; &#x3D;&gt; [</span><br><span class="line">            &#39;class&#39; &#x3D;&gt; &#39;yii\swiftmailer\Mailer&#39;,</span><br><span class="line">            &#39;viewPath&#39; &#x3D;&gt; &#39;@common&#x2F;mail&#39;,</span><br><span class="line">            &#x2F;&#x2F; send all mails to a file by default. You have to set</span><br><span class="line">            &#x2F;&#x2F; &#39;useFileTransport&#39; to false and configure a transport</span><br><span class="line">            &#x2F;&#x2F; for the mailer to send real emails.</span><br><span class="line">            &#39;useFileTransport&#39; &#x3D;&gt; true,</span><br><span class="line">        ],</span><br><span class="line">    ],</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h1 id="3-创建活动记录"><a href="#3-创建活动记录" class="headerlink" title="3.创建活动记录"></a>3.创建活动记录</h1><p>在<code>advanced/frontend/models/Country.php</code>里创建一个继承自活动记录类的类<code>Country</code>，用于代表和读取<code>country</code>表的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace app\models;</span><br><span class="line"></span><br><span class="line">use yii\db\ActiveRecord;</span><br><span class="line">&#x2F;&#x2F; Country类继承自yii&#x2F;db&#x2F;ActiveRecord，什么都不用写，Yii能根据类名去猜测对应的数据表名</span><br><span class="line">class Country extends ActiveRecord</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-创建动作"><a href="#4-创建动作" class="headerlink" title="4.创建动作"></a>4.创建动作</h1><p>在<code>advanced/frontend/controllers/CountryController.php</code>里新建一个控制器<code>CountryController</code>，并在其中创建一个index操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace frontend\controllers;</span><br><span class="line"></span><br><span class="line">use yii\web\Controller;</span><br><span class="line">use yii\data\Pagination;</span><br><span class="line">use app\models\Country;</span><br><span class="line"></span><br><span class="line">class CountryController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public function actionIndex()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; index操作调用了活动记录Country::find()方法</span><br><span class="line">        $query &#x3D; Country::find();</span><br><span class="line">        &#x2F;&#x2F; 查询在yii\data\Pagination对象的帮助下进行分页</span><br><span class="line">        &#x2F;&#x2F; 为sql查询语句设置offset和limit从句，确保每个请求只需返回一页数据</span><br><span class="line">        &#x2F;&#x2F; 在视图中显示一个由页码列表组成的分页器</span><br><span class="line">        $pagination &#x3D; new Pagination([</span><br><span class="line">            &#39;defaultPageSize&#39; &#x3D;&gt; 5,</span><br><span class="line">            &#39;totalCount&#39; &#x3D;&gt; $query-&gt;count(),</span><br><span class="line">        ]);</span><br><span class="line"></span><br><span class="line">        $countries &#x3D; $query-&gt;orderBy(&#39;name&#39;)</span><br><span class="line">            -&gt;offset($pagination-&gt;offset)</span><br><span class="line">            -&gt;limit($pagination-&gt;limit)</span><br><span class="line">            -&gt;all();</span><br><span class="line">        &#x2F;&#x2F; index操作渲染一个名为index的视图，并传递数据和分页信息进去</span><br><span class="line">        return $this-&gt;render(&#39;index&#39;, [</span><br><span class="line">            &#39;countries&#39; &#x3D;&gt; $countries,</span><br><span class="line">            &#39;pagination&#39; &#x3D;&gt; $pagination,</span><br><span class="line">        ]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-创建视图"><a href="#5-创建视图" class="headerlink" title="5.创建视图"></a>5.创建视图</h1><p>在<code>advanced/frontend/views/country</code>下新建<code>index.php</code>视图文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">use yii\helpers\Html;</span><br><span class="line">use yii\widgets\LinkPager;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;!-- 第一部分foreach遍历国家数据并以无需列表渲染出来 --&gt;</span><br><span class="line">&lt;h1&gt;Countries&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;?php foreach ($countries as $country): ?&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        &lt;?&#x3D; Html::encode(&quot;&#123;$country-&gt;name&#125; (&#123;$country-&gt;code&#125;)&quot;) ?&gt;:</span><br><span class="line">        &lt;?&#x3D; $country-&gt;population ?&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&lt;?php endforeach; ?&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line">&lt;!-- 第二部分使用yii\widgets\LinkPager渲染从操作中传来的分页信息，小部件LinkPager显示一个分页按钮的列表 --&gt;</span><br><span class="line">&lt;?&#x3D; LinkPager::widget([&#39;pagination&#39; &#x3D;&gt; $pagination]) ?&gt;</span><br></pre></td></tr></table></figure>

<h1 id="6-运行"><a href="#6-运行" class="headerlink" title="6.运行"></a>6.运行</h1><p>没有错后访问<code>http://localhost:8080/advanced/frontend/web/index.php/country/index</code></p>
<p>妥(OvO)</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4rml7ikjyj31y80hgwgt.jpg" alt=""></p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4rmlf18jhj31vs0hg0v4.jpg" alt=""></p>
]]></content>
      <categories>
        <category>web开发</category>
      </categories>
  </entry>
  <entry>
    <title>yii2 advanced——使用表单（创建模型）</title>
    <url>/fd4c79fa/</url>
    <content><![CDATA[<p>本教程全靠乱来。。能运行了我就当它对了，所以如果错了那就是我真的猜错了<a href="https://www.yiichina.com/doc/guide/2.0" target="_blank" rel="noopener">官方文档</a>的意思，可能这东西不这么用，，望指出，感谢m(( _ _ ))m</p>
<hr>
<p>要实现的是创建一个让用户提交数据的表单页，输入name和email，提交后页面显示用户信息</p>
<p>需要创建一个操作两个视图和一个模型</p>
<h1 id="1-创建模型"><a href="#1-创建模型" class="headerlink" title="1.创建模型"></a>1.创建模型</h1><p>模型类<code>EntryForm</code>代表从用户那请求的数据，在<code>advanced/frontend/models</code>路径下添加<code>EntryForm.php</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace app\models;</span><br><span class="line"></span><br><span class="line">use Yii;</span><br><span class="line">use yii\base\Model;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 继承自基类Model，该基类通常用来表示数据</span><br><span class="line">class EntryForm extends Model</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;name和email两个公共成员，用来存储用户输入的数据</span><br><span class="line">    public $name;</span><br><span class="line">    public $email;</span><br><span class="line">    &#x2F;&#x2F; 一个名为rules()的方法，用来放回数据验证规则的集合</span><br><span class="line">    public function rules()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; name和email是必须的</span><br><span class="line">        &#x2F;&#x2F; email的值必须满足email验证规则</span><br><span class="line">        return [</span><br><span class="line">            [[&#39;name&#39;, &#39;email&#39;], &#39;required&#39;],</span><br><span class="line">            [&#39;email&#39;, &#39;email&#39;],</span><br><span class="line">        ];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-创建动作"><a href="#2-创建动作" class="headerlink" title="2.创建动作"></a>2.创建动作</h1><p>在<code>entry</code>控制器中创建一个entry操作用于新建的模型，下面这段加在<code>advanced/frontend/controllers/EntryController.php</code>里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace frontend\controllers;</span><br><span class="line"></span><br><span class="line">use Yii;</span><br><span class="line">use yii\web\Controller;</span><br><span class="line">use app\models\EntryForm;</span><br><span class="line">class EntryController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public function actionEntry()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建一个EntryForm对象</span><br><span class="line">        $model &#x3D; new EntryForm;</span><br><span class="line">        &#x2F;&#x2F; 尝试从$_POST搜集用户提交的数据，由yii的post()方法</span><br><span class="line">        &#x2F;&#x2F; validate()方法用于确保用户提交的是有效数据</span><br><span class="line">        &#x2F;&#x2F; Yii::$app代表应用实例，是一个全局可访问的单例，也是一个服务定位器，能提供request，response，db等特定功能的组件</span><br><span class="line">        if ($model-&gt;load(Yii::$app-&gt;request-&gt;post()) &amp;&amp; $model-&gt;validate()) &#123;</span><br><span class="line">            &#x2F;&#x2F; 渲染一个名为entry-confirm的视图确认用户输入的数据</span><br><span class="line">            return $this-&gt;render(&#39;entry-confirm&#39;, [&#39;model&#39; &#x3D;&gt; $model]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 无论是初始化显示还是数据验证错误，entry视图渲染输出表单以及验证错误的详细信息</span><br><span class="line">            return $this-&gt;render(&#39;entry&#39;, [&#39;model&#39; &#x3D;&gt; $model]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-创建视图"><a href="#3-创建视图" class="headerlink" title="3.创建视图"></a>3.创建视图</h1><p>和之前的helloworld一个道理，因为在SiteController里创建的操作<code>entry</code>里写了<code>entry</code>和<code>entry-confirm</code>，所以要创建两个视图文件<code>entry</code>和<code>entry-confirm</code></p>
<p><code>advanced/frontend/views/entry/entry-confirm.php</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">use yii\helpers\Html;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;!-- entry-confirm视图显示提交的name和email数据 --&gt;</span><br><span class="line">&lt;p&gt;You have entered the following information:&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;&lt;label&gt;Name&lt;&#x2F;label&gt;: &lt;?&#x3D; Html::encode($model-&gt;name) ?&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;&lt;label&gt;Email&lt;&#x2F;label&gt;: &lt;?&#x3D; Html::encode($model-&gt;email) ?&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>

<p><code>advanced/frontend/views/entry/entry.php</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">use yii\helpers\Html;</span><br><span class="line">use yii\widgets\ActiveForm;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;!-- entry视图显示一个html表单，用ActiveForm生成HTML表单，begin()和end()分别用来渲染表单的开始和关闭标签，field()方法创建输入框，submitButton()方法生成提交按钮 --&gt;</span><br><span class="line">&lt;?php $form &#x3D; ActiveForm::begin(); ?&gt;</span><br><span class="line"></span><br><span class="line">    &lt;?&#x3D; $form-&gt;field($model, &#39;name&#39;) ?&gt;</span><br><span class="line"></span><br><span class="line">    &lt;?&#x3D; $form-&gt;field($model, &#39;email&#39;) ?&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class&#x3D;&quot;form-group&quot;&gt;</span><br><span class="line">        &lt;?&#x3D; Html::submitButton(&#39;Submit&#39;, [&#39;class&#39; &#x3D;&gt; &#39;btn btn-primary&#39;]) ?&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php ActiveForm::end(); ?&gt;</span><br></pre></td></tr></table></figure>

<h1 id="4-运行"><a href="#4-运行" class="headerlink" title="4.运行"></a>4.运行</h1><p>总结一些可能出现的错误：</p>
<ul>
<li>namespace没有写对</li>
<li>因为方法要根据路径找<code>views/控制器ID/视图名.php</code>，所以路径要对应，此外控制器ID，视图名啥的也要对应</li>
</ul>
<p>没错误后访问<code>http://localhost:8080/advanced/frontend/web/index.php/entry/entry</code></p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4qod67034j31ts0f0jso.jpg" alt=""></p>
<p>点击submit一个html列表返回结果</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4qoglv2fjj30kk096wf1.jpg" alt=""></p>
]]></content>
      <categories>
        <category>web开发</category>
      </categories>
  </entry>
  <entry>
    <title>Yii2 advanced安装及hello world（创建操作/创建视图）</title>
    <url>/4fd2fb40/</url>
    <content><![CDATA[<p>本教程全靠乱来。。能运行了我就当它对了，所以如果错了那就是我真的猜错了<a href="https://www.yiichina.com/doc/guide/2.0" target="_blank" rel="noopener">官方文档</a>的意思，可能这东西不这么用，，望指出，感谢m(( _ _ ))m</p>
<hr>
<p>首先Yii2 advanced包括<code>前端frontend/后端backend/控制台console</code>三个独立的应用程序，我做实验用的都是前端，因为我也不晓得要用哪个，先随便玩玩再说</p>
<h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h1><p>通过composer的安装失败了，所以选择通过归档安装</p>
<p>首先在<a href="http://www.yiiframework.com/download/" target="_blank" rel="noopener"> 官网 </a>下载归档文件，我下的是advance，解压后把文件夹拖入能访问web的文件夹中</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4oudpqf4aj31u80hogp9.jpg" alt=""></p>
<p>然后在<code>advanced/frontend/web</code>处打开终端，输入<code>php init</code>，选择0模式，yes，等generate一堆东西就好了</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4oe5svcu5j30v40dwmyx.jpg" alt=""></p>
<p>然后访问<code>http://localhost:8080/advanced/frontend/web/index.php/site/index</code></p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4oe8ncojzj325h0u0gqn.jpg" alt=""></p>
<h1 id="2-无关紧要的url美化"><a href="#2-无关紧要的url美化" class="headerlink" title="2.无关紧要的url美化"></a>2.无关紧要的url美化</h1><p>本来菜鸡的我是不会注意这种东西的。。但是看了官方文档里关于<a href="http://www.digpage.com/urlmanager.html" target="_blank" rel="noopener"> urlmanager </a>的部分发现这个原来在开发中还蛮重要。。说的好有道理那整一个吧</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4o99yetotj30qq01uweu.jpg" alt=""></p>
<p>首先随便点个about，这个url，，从美观上来说有点一言难尽，<code>/advanced/vendor/yiisoft/yii2/web</code>可以找到<code>UrlManager.php</code>这个文件，也就是文档里说的定义urlManager类的地方</p>
<p>搜索<code>enablePrettyUrl</code>，这个属性用于表明urlManager是否启用URL美化功能（默认不启用，但实际使用中，特别是产品环境，一般都会启用），把false改为true即可</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4obmp596ej30xc0bgq5b.jpg" alt=""></p>
<p>地址栏变的清爽了(OvO)</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4obviuacxj30oi01i3yt.jpg" alt=""></p>
<h1 id="3-创建动作"><a href="#3-创建动作" class="headerlink" title="3.创建动作"></a>3.创建动作</h1><p>为了 “Hello”，需要创建一个 <code>say</code> 操作</p>
<blockquote>
<p>「操作」是最终用户可以直接访问并执行的对象。操作被组织在「控制器」中。一个操作的执行结果就是最终用户收到的响应内容。</p>
</blockquote>
<p>在这个路径<code>advanced/frontend/controllers</code>新建<code>HelloController.php</code>文件，用于声明一个操作</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4pbwtt3yzj313g0ny110.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace frontend\controllers;</span><br><span class="line"></span><br><span class="line">use yii\web\Controller;</span><br><span class="line"></span><br><span class="line">class HelloController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; say操作被定义为actionSay方法，Yii使用action前缀区分普通方法和操作，action前缀后面的名称Say被映射为操作的ID</span><br><span class="line">    public function actionSay($message &#x3D; &#39;Hello&#39;)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 该操作方法接受一个默认值是&#39;Hello&#39;的参数$message</span><br><span class="line">        &#x2F;&#x2F; render方法用来渲染一个名为say的视图文件，操作方法会返回渲染结果，结果会被应用接受并显示给最终用户的浏览器</span><br><span class="line">        return $this-&gt;render(&#39;say&#39;, [&#39;message&#39; &#x3D;&gt; $message]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-创建视图"><a href="#4-创建视图" class="headerlink" title="4.创建视图"></a>4.创建视图</h1><p>视图是用来生成相应内容的脚本，创建一个say视图，以便显示从操作方法中传来的message参数</p>
<p>say视图存为<code>advanced/frontend/views/site/say.php</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">use yii\helpers\Html;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;!-- message参数在输出前被HTML-encoded方法处理过，防止来自用户的参数中可能隐含的恶意javaScript代码导致跨站脚本(XSS)攻击 --&gt;</span><br><span class="line">&lt;?&#x3D; Html::encode($message) ?&gt;</span><br></pre></td></tr></table></figure>

<p>上面新建的<code>HelloController.php</code>表明控制器ID是<code>hello</code>，<strong>（yii对ID的处理方式是这样的：ID按小写处理，如果多个单词是AbcBcd这种ID则为abc-bcd）</strong></p>
<p>操作中调用的<code>render()</code>方法将会按<code>views/控制器ID/视图名.php</code>加载php文件，所以实际上say视图就是一个由<code>render()</code>执行的php脚本</p>
<h1 id="5-运行"><a href="#5-运行" class="headerlink" title="5.运行"></a>5.运行</h1><p>访问<code>http://localhost:8080/advanced/frontend/web/index.php/hello/say</code></p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4pc9cw4csj323o08sjs2.jpg" alt=""></p>
]]></content>
      <categories>
        <category>web开发</category>
      </categories>
  </entry>
  <entry>
    <title>axure实战（淘宝登陆页签/京东商城注册表单）</title>
    <url>/45e1704d/</url>
    <content><![CDATA[<p>实战了两个就能比较顺手了，教程来自啥都有的小破站(･_･;<a href="https://www.bilibili.com/video/av13807841" target="_blank" rel="noopener"> 传送门 </a></p>
<p>要说学会了啥，，首先肯定是顺手，然后最有用的我感觉应该是各种交互，其次就是程序员在设计交互的时候一定要想到在用户完成了什么东西的时候表扬一下用户付出的努力233333333</p>
<hr>
<h1 id="1-制作淘宝登陆页签的切换效果（动态面板入门）"><a href="#1-制作淘宝登陆页签的切换效果（动态面板入门）" class="headerlink" title="1.制作淘宝登陆页签的切换效果（动态面板入门）"></a>1.制作淘宝登陆页签的切换效果（动态面板入门）</h1><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kiloav8vj21hk0o215c.jpg" width=600>

<p>上面是卖家秀。。下面是买家秀，丑归丑。。反正是个靠动态面板能切换的玩意儿就是了</p>
<table><tr>
<td><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4kv6n97erj30jw0kqaam.jpg" width=400></td>
<td><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4ll0b8etwj30jk0kimxu.jpg" width=400></td>
</tr></table>

<p>像淘宝登陆这样一个可以切换的框大概就是分成三部分制作</p>
<table><tr>
<td><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4kvakg24dj30dy0i6t9x.jpg" width="260"></td>
<td><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4kva7g9vej30f40pqq4t.jpg" width="260"></td>
<td><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4kvave8umj30be04i3yp.jpg" width="260"></td>
</tr></table>

<ul>
<li>登陆方式标题，一个快速登录一个账户密码登陆，利用动态面板完成两个黑色灰色转换的不同页面</li>
<li>登陆方式内容，同理制作两个页面</li>
<li>切换是靠在标题位置对应设置两个热区，添加单击时的交互来实现的</li>
</ul>
<h1 id="2-制作京东商城注册表单及交互"><a href="#2-制作京东商城注册表单及交互" class="headerlink" title="2.制作京东商城注册表单及交互"></a>2.制作京东商城注册表单及交互</h1><p>买家秀如下：（图缩的有点小了。。可以点开0.0）</p>
<table>
<tr>
<td><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4m0ezoagqj30w80nudh9.jpg" width="400"></td>
<td><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4m0gdc9c8j30yk0ni0ug.jpg" width="400"></td>
</tr>
<tr>
<td><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4m0gsirjdj31040mytaa.jpg" width="400"></td>
<td><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4m0hh784bj30p00ne3zt.jpg" width="400"></td>
</tr>
<tr>
<td><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4m0hpfbwyj30os0ncjsn.jpg" width="400"></td>
<td><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4m0kdvxs3j30i80b0dfy.jpg" width="400"></td>
</tr>
</table>

<p>首先就是基础的一些ui的设计，没啥好说的，添加完元件就是下面这么一个最基本的效果</p>
<img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4li2zkfixj30qc0o8t9w.jpg" width=400>

<p>这只是个<s>轻松愉快</s>的开始，这样一个注册表单的重点还是在于它的交互，看着简单实则。。</p>
<p>但是现在的京东注册表单已经改版了，有一些图片就没法获取到了ORZ，所以我偷工减料了一些效果没有做或者做了丑很多，，的版本</p>
<h2 id="2-1-用户名"><a href="#2-1-用户名" class="headerlink" title="2.1 用户名"></a>2.1 用户名</h2><ul>
<li>如果没有填，那么要显示请输入用户名，提示信息还是利用动态面板来完成</li>
</ul>
<img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4lkwacu3aj30wa094wgf.jpg" height=150>

<p>此外要考虑的情况还有：</p>
<ul>
<li>填的不符合规范，要显示输入格式要求</li>
<li>长度不够，给出提示</li>
<li>用户名被占用（此处没有实现占用后的用户名推荐）</li>
</ul>
<p>本来填写正确还要显示一个对勾✅，以表示对用户的努力的鼓励。。。但是懒得找图了这个图片部分就不做啦</p>
<p>接着对用户名输入文本框设置获取焦点时的对应动作，在用户输入过程中，就显示用户名输入要求的提示，边框为绿色</p>
<p>实现边框颜色的转化思路是这样的，隐藏主面板的边框，然后动态面板设置三个状态：灰色边框/绿色边框/红色边框，然后将该动态面板置于底层，（否则主面板的文本框会被遮挡）这样就可以实现边框颜色的切换了</p>
<p>然后设置失去焦点时的对应动作，这时候要分为多种输入完成的情况所以要对输入框的状态进行判断，这个判断在axure以前的版本中叫「新增条件」</p>
<p>找了我老半天，axure9基本没有什么教程，只能靠自己瞎点</p>
<p>最后在「交互编辑器-启用情形」里找到了「添加情形」</p>
<img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4ls54x921j30j00cg0tv.jpg" width=400>

<p>如果失去焦点前文本框里还是什么都没输入的话，那么失去焦点后框还是应该保持默认的黑色，并且需要隐藏用于显示用户名提示的动态面板；长度小于4的话要提示，大于20可以靠设置元件的最大输入长度来限制；如果用户名被占用（暂且设置一个全局变量来表示某用过的用户名），那么也需要提示；如果以上都满足，那么用户名可用</p>
<img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4lqb8itv0j31ae0iswg4.jpg" height=260>

<p>最终用户名输入框失去焦点时的设置如下：</p>
<table><tr>
<td><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4lx80c2maj30gi0fqq62.jpg" width="400"></td>
<td><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4lx8ada7sj30gc0eqju7.jpg" width="400"></td>
</tr></table>

<p>理清了这么一个逻辑之后，剩下的几个输入框其实都是一些重复的东西，整整顺手就好了</p>
<h2 id="2-2-请设置密码"><a href="#2-2-请设置密码" class="headerlink" title="2.2 请设置密码"></a>2.2 请设置密码</h2><p>这个没照视频里的做，因为我感觉他的逻辑是有问题的。。就自己凭记忆瞎搞了可能有点乱。。或许是这么个架构，不过不知道那些网站的实时输入然后提示密码强度的是怎么整的</p>
<table><tr>
<td><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4lx0oa9ppj30jo0fkabp.jpg" width="260"></td>
<td><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4lx194sxkj30jq0dsjsx.jpg" width="260"></td>
<td><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4lx1ke4bbj30jo0dc75o.jpg" width="260"></td>
</tr></table>

<table><tr>
<td><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4lx2d5wmmj30ja0nm0v7.jpg" width="260"></td>
<td><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4lxi5rjxpj30je0n676v.jpg" width="260"></td>
<td><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4lx3c93lpj30jc0aqmy7.jpg" width="260"></td>
</tr></table>

<h2 id="2-3-请确认密码"><a href="#2-3-请确认密码" class="headerlink" title="2.3 请确认密码"></a>2.3 请确认密码</h2><table><tr>
<td><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4lxiw6qgsj30je09y756.jpg" width="260"></td>
<td><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4lxjb73jmj30jm0kygns.jpg" width="260"></td>
<td><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4lxjn6thfj30je0judhu.jpg" width="260"></td>
</tr></table>

<h2 id="2-4-验证手机"><a href="#2-4-验证手机" class="headerlink" title="2.4 验证手机"></a>2.4 验证手机</h2><table><tr>
<td><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4lxiw6qgsj30je09y756.jpg" width="260"></td>
<td><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4lxjb73jmj30jm0kygns.jpg" width="260"></td>
<td><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4lxjn6thfj30je0judhu.jpg" width="260"></td>
</tr></table>

<h2 id="2-5-服务条款"><a href="#2-5-服务条款" class="headerlink" title="2.5 服务条款"></a>2.5 服务条款</h2><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4ly6tt7uej30ea07edge.jpg" width="260">

<h2 id="2-6-注册按钮"><a href="#2-6-注册按钮" class="headerlink" title="2.6 注册按钮"></a>2.6 注册按钮</h2><p>由于懒，所以验证码和短信验证码的交互就不管他了，判断的时候不考虑这两项</p>
<p>先添加一个注册成功的页面</p>
<img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4lyb91896j30he07smxe.jpg" width="400">

<table><tr>
<td><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4lzukpyunj30je0l00us.jpg" width="260"></td>
<td><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4lzuxh9mnj30ja0kuwgn.jpg" width="260"></td>
<td><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4m0jc21e9j30jg0k2abt.jpg" width="260"></td>
</tr></table>

<h2 id="2-7-注册成功"><a href="#2-7-注册成功" class="headerlink" title="2.7 注册成功"></a>2.7 注册成功</h2><p>设置全局变量</p>
<img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4lzqc0qnpj31hc0fc79h.jpg" height="260">


]]></content>
      <categories>
        <category>web开发</category>
      </categories>
  </entry>
  <entry>
    <title>关于ipic图床(微博图床)在本地显示图片但github-page上不显示图片的问题</title>
    <url>/1b080ead/</url>
    <content><![CDATA[<p>这个问题。。困扰了我几个月！！！！！可以看到其中关于图片的响应都报错了，今天终于解决了呜呜呜TAT</p>
<p><code>Failed to load resource: the server responded with a status of 403 ()</code></p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4kp6x2oaaj32800sencb.jpg" alt=""></p>
<a id="more"></a>

<p>我一直使用的图床工具是ipic，我的ipic没有设置图床，用的就是默认的微博图床，微博图床还是很稳定的，但是从某一天开始图片在本地可以显示，但是在github-page上就不显示了</p>
<p>但是如果在本地预览后再上传，就可以显示一两天，但其实这是因为浏览器缓存问题，营造了显示成功的假象，如果把缓存清了照样显示不了，同理如果换台电脑打开也是显示不了的</p>
<p>看了很多有关图床的说明，首先新浪的图床还是好的，但是不显示是因为从某一天开始微博的图片不允许外部引用了，这对于我的几百张图片来说！！！而且还有好多公式啦操作步骤啦之类的图片来说，就是disaster。。！！那么如何解决呢？</p>
<h1 id="1-no-referrer"><a href="#1-no-referrer" class="headerlink" title="1.no-referrer"></a>1.no-referrer</h1><p>因为微博图床做了<font size="5px" color="#f5a3a2"> 防盗链 </font>ORZ，也就是说图片只有在微博能显示，别的网站来微博就不给你显示，那么不告诉微博我是谁不就行了</p>
<p>所以第一种解决方法是在网页的<code>&lt;head&gt;</code>里加上一句<code>&lt;meta name=”referrer” content=”no-referrer” /&gt;</code>，但是这样是会影响全站的，并不是一个可靠的方法，因为别的需要知道我是谁的请求也没法知道我是谁了</p>
<p>那么有没有别的修改referrer的方法呢？可以直接修改图片的属性，写为如下的形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;”https:&#x2F;&#x2F;ws1.sinaimg.cn&#x2F;……” referrerpolicy&#x3D;”no-referrer”&gt;</span><br></pre></td></tr></table></figure>

<p>但是这对于使用markdown的来说，    图片基本上都是用这个格式写的<code>![]()</code>，改的工程量还是太大了，或许可以写一个脚本来统一改，但是几百个<code>md</code>被我改崩了可咋整。。。</p>
<h1 id="2-iframe"><a href="#2-iframe" class="headerlink" title="2.iframe"></a>2.iframe</h1><p>网上搜了还可以用<code>&lt;iframe&gt;</code>标签来做，在里面内嵌图片，原理和上面的差不多，也是微博可以不知道请求的域名是谁，这个方法我没实际试过不知道行不行</p>
<h1 id="3-http"><a href="#3-http" class="headerlink" title="3.http"></a>3.http</h1><p>然后发现我利用chrome插件上传的图片上传后竟然可以在浏览器显示，于是探寻出了第三种方法：</p>
<p>利用chrome的微博图床插件上传图片是有http和https的选项的，如果利用http，那么图床前面就是<code>ww1.sinaimg.cn</code>的格式，ww后数字可变，如果利用https上传那么就是<code>ws1.sinaimg.cn</code>，虽然不是很清楚具体原因，但是多次实验发现http的图片就可以正常响应，而https无法响应，所以可以整个更换一遍把所有https的都重新上传为http的</p>
<p>后来在网上搜索相关资料的时候看见也有人使用的是这种方法，但是并没有解释原因0.0</p>
<h1 id="4-图床"><a href="#4-图床" class="headerlink" title="4.图床"></a>4.图床</h1><p>最后一种方法，就是自己建个图床或者使用一些付费图床啥的了</p>
<hr>
<p>http上传的我手都麻了。。。但是终于可以显示了，快乐(≧▽≦)用手机试了一下，改前和改后，妥得很</p>
<table><tr>
<td><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4lg5euwanj30ku0n8q4b.jpg" width=300></td>
<td><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4lg5ro4wrj30ku0pzaek.jpg" width=300></td>
</tr></table>

<p>然后还发现我现在使用的ipic1.6.8版本默认是上传到http的，也就是<code>ww1.sinaimg.cn</code>格式的，又可以快乐快捷键啦</p>
<p>所以最后还是要夸一下ipic，因为真的很好用，电脑快捷键截图然后快捷键上传就可以直接复制md格式的连接，而且免费，使用感太好了，感谢制作组带来这么方便的软件٩(˃̶͈̀௰˂̶͈́)و</p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>bzoj1041 [HAOI2008]圆上的整点</title>
    <url>/d8688d86/</url>
    <content><![CDATA[<p>神奇数论 -&gt; <a href="https://www.bilibili.com/video/av12131743/" target="_blank" rel="noopener">https://www.bilibili.com/video/av12131743/</a></p>
<p>记录一下大概视频里的思路就是：</p>
<ul>
<li><code>a^2+b^2=r^2=(a+bi)(a-bi)</code></li>
<li>所以有一对共轭复数就会有整点，对数x2对应交换方法数，然后1，-1，i，-i方向都可以，所以要再乘4</li>
<li>用到一个结论4m+1型素数可以被分解为两个不同的高斯素数，4m+3型不可分解</li>
<li>特殊情况是2，2可以分解的素数但是因为它的两个共轭复数刚好成90度所以没有什么用处不能形成整点</li>
</ul>
<p>所以最后就是个分解质因数的题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">int main()&#123;</span><br><span class="line">	LL n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	LL ans&#x3D;4;</span><br><span class="line">	for(int i&#x3D;2;i*i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		if(i%4&#x3D;&#x3D;1)&#123;</span><br><span class="line">			int num&#x3D;0;</span><br><span class="line">			while(n%i&#x3D;&#x3D;0)&#123;</span><br><span class="line">				n&#x2F;&#x3D;i;</span><br><span class="line">				num++;</span><br><span class="line">			&#125;</span><br><span class="line">			ans*&#x3D;(num*2+1);</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			while(n%i&#x3D;&#x3D;0)n&#x2F;&#x3D;i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(n&gt;1&amp;&amp;n%4&#x3D;&#x3D;1)ans*&#x3D;3;</span><br><span class="line">	if(n&#x3D;&#x3D;0)ans&#x3D;1;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>Html+CSS+jQuery实现的有趣的方块掉落</title>
    <url>/586bfea5/</url>
    <content><![CDATA[<p>前排放超越妹妹效果图！</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kov4dcfuj21rc0u0wp6.jpg" alt=""></p>
<a id="more"></a>

<p>再放动态超越妹妹效果图！（视频加速了，录屏的画的没有截图那个好看嘤嘤嘤）</p>
<p><a href="https://v.youku.com/v_show/id_XNDI0ODIzNzczNg==.html?spm=a2h3j.8428770.3416059.1" target="_blank" rel="noopener">https://v.youku.com/v_show/id_XNDI0ODIzNzczNg==.html?spm=a2h3j.8428770.3416059.1</a></p>
<p>教程来自油管： <a href="https://www.youtube.com/watch?reload=9&amp;v=oagol6iTXP4&amp;feature=youtu.be" target="_blank" rel="noopener">https://www.youtube.com/watch?reload=9&amp;v=oagol6iTXP4&amp;feature=youtu.be</a></p>
<p>代码很简单一个<code>index.html</code>，一个<code>style.css</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">	margin: 0;</span><br><span class="line">	padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">.container&#123;</span><br><span class="line">	width: 100%;</span><br><span class="line">	height: 100%;</span><br><span class="line">	background: url(cymm.jpg);</span><br><span class="line">	background-size: cover;</span><br><span class="line">	overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.container span&#123;</span><br><span class="line">	display: inline-flex;</span><br><span class="line">	width: 9.7%;</span><br><span class="line">	height: 40px;</span><br><span class="line">	background: #ffffff;</span><br><span class="line">	border: 1px solid rgba(0,0,0,.2);</span><br><span class="line">	box-sizing: border-box;</span><br><span class="line">	box-shadow: 0 2px 5px rgba(0,0,0,1);</span><br><span class="line">&#125;</span><br><span class="line">.container span.fall&#123;</span><br><span class="line">	z-index: 1000;</span><br><span class="line">	background: #f00000;</span><br><span class="line">	transition: 0.2s;</span><br><span class="line">	pointer-events: none;</span><br><span class="line">	animation: fall 2s linear forwards;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes fall&#123;</span><br><span class="line">	0%</span><br><span class="line">	&#123;</span><br><span class="line">		transform: translateY(0) rotate(0deg);</span><br><span class="line">	&#125;</span><br><span class="line">	100%</span><br><span class="line">	&#123;</span><br><span class="line">		transform: translateY(1000px) rotate(0deg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Surprise!&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;style.css&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:code.jquery.com&#x2F;jquery-3.4.1.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    function getRandomColor() &#123;</span><br><span class="line">        var rand &#x3D; Math.floor(Math.random() * 0xFFFFFF).toString(16);</span><br><span class="line">        if (rand.length &#x3D;&#x3D; 6) &#123;</span><br><span class="line">            return rand;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return getRandomColor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    $(document).ready(function() &#123;</span><br><span class="line">        $(&quot;span&quot;).mouseover(function() &#123;</span><br><span class="line">            var color &#x3D; getRandomColor();</span><br><span class="line">            $(this).css(&quot;background&quot;, &quot;#&quot; + color);</span><br><span class="line">            &#x2F;&#x2F; console.log(color);</span><br><span class="line">            $(this).addClass(&quot;fall&quot;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>这个简直就是撩妹好东西，到时候整一个随机粉红色的给过生日的小基友嘻嘻嘻(≧▽≦)</p>
]]></content>
      <categories>
        <category>web开发</category>
      </categories>
  </entry>
  <entry>
    <title>AndriodStudio编译很久很久Gradle build running的解决办法</title>
    <url>/af3e9e68/</url>
    <content><![CDATA[<p>好久没用android studio了，然后在新电脑上装了个，编译hello world要半天，一直卡在下载Gradle build running的地方。。这不科学。。停还不行只能强退</p>
<p>然后才发现我的IP被墙了，，所以下很慢很慢很慢很慢，，（赶紧再去整一个），所以如果没有快乐上网的话怎么解决这个问题呢</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kow94uygj20kq07w0ti.jpg" alt=""></p>
<a id="more"></a>

<p>进入<code>/Users/mac/AndroidStudioProjects/HelloWorld2/gradle/wrapper</code>路径下查看<code>gradle-wrapper.properties</code>中说的要安装的Gradle的版本和路径，比如我的如下，是5.1.1的</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kow96tbcj20v4046ta3.jpg" alt=""></p>
<p>然后就进入上图显示的路径下：<code>/Users/mac/.gradle/wrapper/dists/gradle-5.1.1-all/“一堆乱序字符”</code>，可以看见里面有没下完的东西，删了它们</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kow9504sj20om09wt9o.jpg" alt=""></p>
<p>进入官网<code>http://services.gradle.org/distributions/</code>直接下载对应版本的gradle，（没有快乐上网的情况下虽然下载也很慢，但是至少是可以下下来的）下完后放入之前删掉的地方</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kowjy6trj20im09qwf7.jpg" alt=""></p>
<p>再编译一下东西就自己齐全了</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kowk0rbsj20qa0a6q47.jpg" alt=""></p>
<p>然后就可以玩耍了(OvO)</p>
<p>然而这个解决方法只是暂时的，因为开发的时候还是要下很多包，所以还是快乐上网根治问题啦</p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始的chrome插件 —— hello extensions</title>
    <url>/1138bf8d/</url>
    <content><![CDATA[<p>不会的东西就会觉得很厉害，会了之后会觉得这个东西更厉害了(OvO)，那么就从hello extensions开始</p>
<hr>
<p>快乐官方文档 -&gt; <a href="https://developer.chrome.com/extensions" target="_blank" rel="noopener">https://developer.chrome.com/extensions</a></p>
<p>每个扩展都有一个<code>manifest.json</code>，其中前四行是基本，分别是扩展名，扩展描述，版本号，还有一个必须写的并且必须写2的0.0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;name&quot;: &quot;Hello Extensions&quot;,</span><br><span class="line">	&quot;description&quot; : &quot;Base Level Extension&quot;,</span><br><span class="line">	&quot;version&quot;: &quot;1.0&quot;,</span><br><span class="line">	&quot;manifest_version&quot;: 2,</span><br><span class="line">	&quot;browser_action&quot;: &#123;</span><br><span class="line">	  &quot;default_popup&quot;: &quot;hello.html&quot;,</span><br><span class="line">	  &quot;default_icon&quot;: &quot;hello_extensions.png&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;commands&quot;: &#123;</span><br><span class="line">	  &quot;_execute_browser_action&quot;: &#123;</span><br><span class="line">	    &quot;suggested_key&quot;: &#123;</span><br><span class="line">	      &quot;default&quot;: &quot;Ctrl+Shift+F&quot;,</span><br><span class="line">	      &quot;mac&quot;: &quot;MacCtrl+Shift+F&quot;</span><br><span class="line">	    &#125;,</span><br><span class="line">	    &quot;description&quot;: &quot;Opens hello.html&quot;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以再加很多东西，<a href="https://developer.chrome.com/extensions/browserAction" target="_blank" rel="noopener"> browserAction </a>可以把插件对应的图标放在浏览器地址栏右侧，点图标可以有一些操作，比如上面是一个弹出文件<code>hello.html</code>，<code>commands</code>这段是一个快捷键的设置，不是必须的</p>
<p>hello.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;Hello Extensions&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>有这两个文件和一个icon后就开始添加插件</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kox8infqj20is09q755.jpg" alt=""></p>
<p>从chrome「右上角三个点-更多工具-扩展程序」打开扩展程序页面，或者直接访问<code>chrome://extensions/</code></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kox8kkmaj21400rqn15.jpg" alt=""></p>
<p>点击加载已解压的扩展程序，选中刚刚那个放三个东西的文件夹</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kox8ieh5j20n406eq3k.jpg" alt=""></p>
<p>如果没有啥写错的地方的话就会有一个扩展程序啦</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4koxmkgifj20oi09c0tp.jpg" alt=""></p>
<p>在左上角点击就会有一个popup</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4koxmkszvj209806iglu.jpg" alt=""></p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
  </entry>
  <entry>
    <title>bzoj1059 [ZJOI2007]矩阵游戏（二分图最大匹配）</title>
    <url>/f1269118/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kovmivy5j20qn0bqaed.jpg" alt=""></p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">0 0</span><br><span class="line">0 1</span><br><span class="line">3</span><br><span class="line">0 0 1</span><br><span class="line">0 1 0</span><br><span class="line">1 0 0</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure>

<p>【数据规模】</p>
<p>对于100%的数据，N ≤ 200</p>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>本来以为是个模拟一下猜结论的题。。结果是个二分图最大匹配ORZ。。妙啊是我见的少了</p>
<p>因为同行（或同列）的点不管怎么变换还是同行（或同列），所以问题转化为能不能找到n个不同行也不同列的点</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std; </span><br><span class="line"></span><br><span class="line">const int N&#x3D;205;</span><br><span class="line">vector&lt;int&gt;g[N&lt;&lt;1];</span><br><span class="line">int match[N&lt;&lt;1];</span><br><span class="line">bool vis[N&lt;&lt;1];</span><br><span class="line">bool dfs(int x)&#123;</span><br><span class="line">    for(int i&#x3D;0;i&lt;g[x].size();i++)&#123;</span><br><span class="line">        int v&#x3D;g[x][i];</span><br><span class="line">        if(!vis[v])&#123;</span><br><span class="line">            vis[v]&#x3D;true;</span><br><span class="line">            if(match[v]&#x3D;&#x3D;-1||dfs(match[v]))&#123;</span><br><span class="line">                match[v]&#x3D;x;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        int a,ans&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;N;i++)g[i].clear();</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;n;j++)&#123;</span><br><span class="line">                scanf(&quot;%d&quot;,&amp;a);</span><br><span class="line">                if(a)&#123;</span><br><span class="line">                    g[i].push_back(j+N);</span><br><span class="line">                    g[j+N].push_back(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memset(match,-1,sizeof(match));</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            memset(vis,false,sizeof(vis));</span><br><span class="line">            if(dfs(i))ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ans&#x3D;&#x3D;n)puts(&quot;Yes&quot;);</span><br><span class="line">        else puts(&quot;No&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>bzoj1191 [HNOI2006]超级英雄Hero（二分图最大匹配）</title>
    <url>/550df37c/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kovmi9gbj20qi0dl441.jpg" alt=""></p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 6 </span><br><span class="line">3 2</span><br><span class="line">2 0 </span><br><span class="line">0 3 </span><br><span class="line">0 4</span><br><span class="line">3 2</span><br><span class="line">3 2</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>二分图最大匹配，匈牙利算法</p>
<p>明明很水。。然后wa了，，这才发现题读少了得过了一题才能做下一题，所以如果当前已经没法匹配了就需要break</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std; </span><br><span class="line"></span><br><span class="line">const int N&#x3D;1005;</span><br><span class="line">vector&lt;int&gt;g[N&lt;&lt;1];</span><br><span class="line">int match[N&lt;&lt;1];</span><br><span class="line">bool vis[N&lt;&lt;1];</span><br><span class="line">bool dfs(int x)&#123;</span><br><span class="line">    for(int i&#x3D;0;i&lt;g[x].size();i++)&#123;</span><br><span class="line">        int v&#x3D;g[x][i];</span><br><span class="line">        if(!vis[v])&#123;</span><br><span class="line">            vis[v]&#x3D;true;</span><br><span class="line">            if(match[v]&#x3D;&#x3D;-1||dfs(match[v]))&#123;</span><br><span class="line">                match[v]&#x3D;x;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,ans&#x3D;0;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    int a,b;</span><br><span class="line">    for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">        g[i].push_back(a+N);g[a+N].push_back(i);</span><br><span class="line">        g[i].push_back(b+N);g[b+N].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    memset(match,-1,sizeof(match));</span><br><span class="line">    for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">        memset(vis,false,sizeof(vis));</span><br><span class="line">        if(dfs(i))ans++;</span><br><span class="line">        else break;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>bzoj1270 [BeijingWc2008]雷涛的小猫（dp）</title>
    <url>/6f905954/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kot1c6l3j20o10ilq98.jpg" alt=""></p>
<a id="more"></a>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kot1bkhxj20dy0g1mys.jpg" alt=""></p>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>ans[i]为跳到高度i最多能有几个柿子，dp[j]表示当前在高度i且在第j颗树最多有几个柿子</p>
<p>根据高度从上往下dp，每层都可以跳到别的树</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std; </span><br><span class="line"></span><br><span class="line">const int N&#x3D;5005;</span><br><span class="line">int dp[N],ans[N],a[N][N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,h,d,num,tmp;</span><br><span class="line">    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;h,&amp;d);</span><br><span class="line">    memset(a,0,sizeof(a));</span><br><span class="line">    memset(dp,0,sizeof(dp));</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;num);</span><br><span class="line">        while(num--)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;tmp);</span><br><span class="line">            a[i][tmp]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;h;i&gt;0;i--)&#123;</span><br><span class="line">        if(i+d&lt;&#x3D;h)&#123;</span><br><span class="line">            for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;</span><br><span class="line">                dp[j]&#x3D;max(dp[j],ans[i+d])+a[j][i];</span><br><span class="line">                ans[i]&#x3D;max(ans[i],dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;</span><br><span class="line">                dp[j]+&#x3D;a[j][i];</span><br><span class="line">                ans[i]&#x3D;max(ans[i],dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans[1]);</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS下运行x.sh脚本报错permission denied权限不够的解决办法</title>
    <url>/b7b0d9f3/</url>
    <content><![CDATA[<p>运行一个<code>x.sh</code>脚本报错<code>permission denied</code></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4koq01ptjj208m00sa9y.jpg" alt=""></p>
<a id="more"></a>

<p>给777，即最高权限，然后就可以运行该脚本了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 777 build-libevent.sh</span><br><span class="line">.&#x2F;build-libevent.sh</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4koq02g99j20fn02d3yv.jpg" alt=""></p>
<hr>
<p>非常感谢评论里大佬的提醒٩(˃̶͈̀௰˂̶͈́)و，这里补充Linux权限位相关的信息如下：</p>
<table>
<thead>
<tr>
<th>字符表示</th>
<th>八进制</th>
<th>对于文件</th>
<th>对于目录</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>4</td>
<td>读取权限</td>
<td>列出权限</td>
</tr>
<tr>
<td>w</td>
<td>2</td>
<td>写入权限</td>
<td>创建权限</td>
</tr>
<tr>
<td>x</td>
<td>1</td>
<td>执行权限</td>
<td>进入权限</td>
</tr>
<tr>
<td>s</td>
<td>4000</td>
<td>属主权限</td>
<td>-</td>
</tr>
<tr>
<td>s</td>
<td>2000</td>
<td>-</td>
<td>继承权限</td>
</tr>
<tr>
<td>t</td>
<td>1000</td>
<td>-</td>
<td>粘滞位</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">444 r--r--r--</span><br><span class="line">600 rw-------</span><br><span class="line">644 rw-r--r--</span><br><span class="line">666 rw-rw-rw-</span><br><span class="line">700 rwx------</span><br><span class="line">744 rwxr--r--</span><br><span class="line">755 rwxr-xr-x</span><br><span class="line">777 rwxrwxrwx</span><br></pre></td></tr></table></figure>

<p>可以发现其实就是个二进制组合啦，从左到右1-3位数字代表文件所有者的权限，4-6位数字代表同组用户的权限，7-9数字代表其他用户的权限，所以777是最高权限位</p>
<p>所以其实没有必要给777权限，如果只是要执行这个代码的话，应该是只要给执行对应的权限1就可以啦</p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>bzoj1303 [CQOI2009]中位数图（思维）</title>
    <url>/f16eb349/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kosoeakyj20vd0gr778.jpg" alt=""></p>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>记录b的位置，因为肯定要包括b在内，所以从b分别向左右拓展，最暴力的思路就是枚举区间的左右端点，当然这是过不了的</p>
<p>然后想左边部分加右边部分和b在什么情况下才是合法的，就是如果左边多了几个比b大的数，那么右边就要多多少个比b小的数，反之同理</p>
<p>所以只要求得左边多x个比b大（小）的数的情况数，然后左右一乘累加就是答案</p>
<p>用一个sum，大于b就+1，小于b就-1，直接用数值就能表示大于/小于的个数</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std; </span><br><span class="line"></span><br><span class="line">const int N&#x3D;1e5+5;</span><br><span class="line">int a[N],l[N&lt;&lt;1],r[N&lt;&lt;1];</span><br><span class="line">int main()&#123; </span><br><span class="line">	int n,b,cur,sum&#x3D;0,ans&#x3D;0;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;n,&amp;b);</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">		if(a[i]&#x3D;&#x3D;b)cur&#x3D;i;</span><br><span class="line">	&#125;</span><br><span class="line">	memset(l,0,sizeof(l));</span><br><span class="line">	memset(r,0,sizeof(r));</span><br><span class="line">	l[n]&#x3D;r[n]&#x3D;1;</span><br><span class="line">	for(int i&#x3D;cur-1;i&gt;&#x3D;1;i--)&#123;</span><br><span class="line">		if(a[i]&lt;b)sum++;</span><br><span class="line">		else sum--;</span><br><span class="line">		l[sum+n]++;</span><br><span class="line">	&#125;</span><br><span class="line">	sum&#x3D;0;</span><br><span class="line">	for(int i&#x3D;cur+1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		if(a[i]&gt;b)sum++;</span><br><span class="line">		else sum--;</span><br><span class="line">		r[sum+n]++;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;0;i&lt;&#x3D;2*n;i++)ans+&#x3D;l[i]*r[i];</span><br><span class="line">	printf(&quot;%d\n&quot;,ans);</span><br><span class="line">	return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>bzoj1192 (HNOI2006)鬼谷子的钱袋（思维）</title>
    <url>/f16eb349/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kou3qavpj21400fjgr2.jpg" alt=""></p>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>在已有能力下能付任何钱，其实只要有111111的二进制，就啥数都能表示了，所以就是找到刚好小于等于这个数的最小的11111（即2^x-1），然后如果剩下有多就再放单独一个袋子，不会重复</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std; </span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">int main()&#123; </span><br><span class="line">	LL m,num&#x3D;1;</span><br><span class="line">	scanf(&quot;%lld&quot;,&amp;m);</span><br><span class="line">	int i;</span><br><span class="line">	for(i&#x3D;1;i&lt;&#x3D;31;i++)&#123;</span><br><span class="line">		if(m&gt;&#x3D;num-1&amp;&amp;m&lt;num*2-1)&#123;</span><br><span class="line">			m-&#x3D;(num-1);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		else num*&#x3D;2;</span><br><span class="line">	&#125;</span><br><span class="line">	if(m)printf(&quot;%d\n&quot;,i);</span><br><span class="line">	else printf(&quot;%d\n&quot;,i-1);</span><br><span class="line">	return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>hexo next主题下添加基于leancloud的文章阅读次数排名页面</title>
    <url>/71f70113/</url>
    <content><![CDATA[<p>想加个文章阅读次数排名的页面</p>
<a id="more"></a>

<hr>
<p>在文件夹终端输入下面代码，新生成一个名为<code>rank</code>的页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo hexo new page rank</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4koqi8mu6j20c0018t8q.jpg" alt=""></p>
<p>然后在<code>/source/rank/index.md</code>中，改成下面代码：</p>
<p>这是基于leancloud的阅读量统计，所以填一下自己的leancloud_appid和appkey</p>
<p>然后后面的content那个变量，你想显示啥自己改就行，超链接改一下</p>
<p>我显示了15条，然后顺便把这个页面的评论功能关了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: rank</span><br><span class="line">comments: false</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;rank&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn1.lncld.net&#x2F;static&#x2F;js&#x2F;av-core-mini-0.6.4.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;AV.initialize(&quot;填你的appid&quot;, &quot;填你的appkey&quot;);&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">  var time&#x3D;0</span><br><span class="line">  var title&#x3D;&quot;&quot;</span><br><span class="line">  var url&#x3D;&quot;&quot;</span><br><span class="line">  var query &#x3D; new AV.Query(&#39;Counter&#39;);</span><br><span class="line">  query.notEqualTo(&#39;id&#39;,0);</span><br><span class="line">  query.descending(&#39;time&#39;);</span><br><span class="line">  query.limit(15);</span><br><span class="line">  query.find().then(function (todo) &#123;</span><br><span class="line">    for (var i&#x3D;0;i&lt;15;i++)&#123;</span><br><span class="line">      var result&#x3D;todo[i].attributes;</span><br><span class="line">      time&#x3D;result.time;</span><br><span class="line">      title&#x3D;result.title;</span><br><span class="line">      url&#x3D;result.url;</span><br><span class="line">      var content&#x3D;&quot;&lt;p&gt;&quot;+&quot;&lt;font color&#x3D;#a7a7e5&gt;&quot;+&quot;🌸 Time number: &quot;+&quot;&lt;&#x2F;font&gt;&quot;+&quot;&lt;font color&#x3D;#f1a8ce&gt;&quot;+time+&quot;次  &quot;+&quot;&lt;&#x2F;font&gt;&quot;+&quot;&lt;a href&#x3D;&#39;&quot;+&quot;https:&#x2F;&#x2F;leflacon.github.io&quot;+url+&quot;&#39;&gt;&quot;+title+&quot;&lt;&#x2F;a&gt;&quot;+&quot;&lt;&#x2F;p&gt;&quot;;</span><br><span class="line">      document.getElementById(&quot;rank&quot;).innerHTML+&#x3D;content</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, function (error) &#123;</span><br><span class="line">    console.log(&quot;error&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>然后在主题配置文件里<code>/themes/next/_config.yml</code>，找到menu，在菜单栏添加上这个页面即可</p>
<p>图标可以在这个图标库里获取<code>http://www.fontawesome.com.cn/faicons/</code></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4koqpwm7jj20aw026t8q.jpg" alt=""></p>
<p>预览效果如图：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4koqpxml2j20nw0am3zo.jpg" alt=""></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 551 (Div. 2)（A-F）（三视图/贪心/树形dp/交互题/二分/期望dp）</title>
    <url>/10785838/</url>
    <content><![CDATA[<h1 id="A-Serval-and-Bus（模拟）"><a href="#A-Serval-and-Bus（模拟）" class="headerlink" title="A. Serval and Bus（模拟）"></a>A. Serval and Bus（模拟）</h1><p>n个公交车，si第一班，然后每隔di来下一班，一个人t时刻到车站，问他能上的第一班车是啥</p>
<p>暴力模拟一下就过了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;105;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int s,d,id;</span><br><span class="line">&#125;a[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,t;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;n,&amp;t);</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;,&amp;a[i].s,&amp;a[i].d);</span><br><span class="line">		a[i].id&#x3D;i;</span><br><span class="line">	&#125;</span><br><span class="line">	int tmp&#x3D;t;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">			while(a[i].s&lt;tmp)&#123;</span><br><span class="line">				a[i].s+&#x3D;a[i].d;</span><br><span class="line">			&#125;</span><br><span class="line">			if(a[i].s&#x3D;&#x3D;tmp)&#123;</span><br><span class="line">				printf(&quot;%d&quot;,a[i].id);</span><br><span class="line">				return 0;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		tmp&#x3D;a[1].s;</span><br><span class="line">		for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">			tmp&#x3D;min(tmp,a[i].s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-Serval-and-Toy-Bricks（几何）"><a href="#B-Serval-and-Toy-Bricks（几何）" class="headerlink" title="B. Serval and Toy Bricks（几何）"></a>B. Serval and Toy Bricks（几何）</h1><p>给了三视图，求可能的三维状态</p>
<p>以顶视图为基础，cij上的只有顶视图为1才有可能有方块，那些顶视图为1的点只要行和列取最小即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;105;</span><br><span class="line">int a[N],b[N],c[N][N];</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,m,h;</span><br><span class="line">	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;h);</span><br><span class="line">	memset(a,0,sizeof(a));</span><br><span class="line">	memset(b,0,sizeof(b));</span><br><span class="line">	memset(c,0,sizeof(c));</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;b[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		for(int j&#x3D;1;j&lt;&#x3D;m;j++)&#123;</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;c[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		for(int j&#x3D;1;j&lt;&#x3D;m;j++)&#123;</span><br><span class="line">			if(c[i][j]!&#x3D;0)&#123;</span><br><span class="line">				c[i][j]&#x3D;min(a[j],b[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		for(int j&#x3D;1;j&lt;m;j++)&#123;</span><br><span class="line">			printf(&quot;%d &quot;,c[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;,c[i][m]);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-Serval-and-Parenthesis-Sequence（贪心）"><a href="#C-Serval-and-Parenthesis-Sequence（贪心）" class="headerlink" title="C. Serval and Parenthesis Sequence（贪心）"></a>C. Serval and Parenthesis Sequence（贪心）</h1><p>给一个由<code>()?</code>三种元素组成的序列，<code>?</code>的位置可以填<code>()</code>这两种，要求组成一个合法的括号序列，并且它的任何前缀都不是合法的括号序列，可以的话输出任意一种方法</p>
<p>贪心，把<code>(</code>尽可能的往前填，所以要满足条件的话只需要从前往后填<code>(</code>直到<code>(</code>的个数达到<code>n/2</code>个，这样的构造方法一定可以满足前缀不合法</p>
<p>然后填好利用前缀和判断是否合法即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;300005;</span><br><span class="line">string s;</span><br><span class="line">int a[N],sum[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	cin&gt;&gt;s;</span><br><span class="line">	if(n&amp;1)&#123;</span><br><span class="line">		puts(&quot;:(&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	int l&#x3D;0;</span><br><span class="line">	sum[0]&#x3D;0;</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">		if(s[i]&#x3D;&#x3D;&#39;(&#39;)&#123;</span><br><span class="line">			a[i+1]&#x3D;1;</span><br><span class="line">			l++;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(s[i]&#x3D;&#x3D;&#39;)&#39;)a[i+1]&#x3D;-1;</span><br><span class="line">		else a[i+1]&#x3D;0;</span><br><span class="line">	&#125;</span><br><span class="line">	if(l&gt;n&#x2F;2)&#123;</span><br><span class="line">		puts(&quot;:(&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		if(l&#x3D;&#x3D;n&#x2F;2)break;</span><br><span class="line">		if(a[i]&#x3D;&#x3D;0)&#123;</span><br><span class="line">			a[i]&#x3D;1;</span><br><span class="line">			l++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(l&lt;n&#x2F;2)&#123;</span><br><span class="line">		puts(&quot;:(&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		if(a[i]&#x3D;&#x3D;0)a[i]&#x3D;-1;</span><br><span class="line">		sum[i]&#x3D;sum[i-1]+a[i];</span><br><span class="line">		if(sum[i]&lt;&#x3D;0&amp;&amp;i!&#x3D;n)&#123;</span><br><span class="line">			puts(&quot;:(&quot;);</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(sum[n]!&#x3D;0)&#123;</span><br><span class="line">		puts(&quot;:(&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		if(a[i]&#x3D;&#x3D;1)printf(&quot;(&quot;);</span><br><span class="line">		else printf(&quot;)&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-Serval-and-Rooted-Tree（树形dp-思维）"><a href="#D-Serval-and-Rooted-Tree（树形dp-思维）" class="headerlink" title="D. Serval and Rooted Tree（树形dp+思维）"></a>D. Serval and Rooted Tree（树形dp+思维）</h1><p>B参数写反了半天才调对，写到D都没多少时间了TAT</p>
<p>给一个树，节点有两种类型，0代表取子节点的权值最小值，1代表取子节点的权值的最大值，一共有k个叶子节点，可以给这些叶子节点赋值1-k，每个数用一次，求最后根节点可以获得的最大值</p>
<p>对于叶子结点来说，赋值之后只有部分叶子节点的值能传到根节点，所以要让那些能传到根节点的叶子结点获得尽可能大的值</p>
<p>树形dp，dp[i]表示编号为i的节点表示到这个位置要消耗的数的个数（也就是能传上的来的数的个数），要求k所以要记录一下叶子结点的个数，然后从上往下，分两种情况讨论，如果是max节点，那么要取dp[i]尽可能小的子节点，那样消耗的数少才可能获得大的值，如果是min节点，那么所有可能到儿子节点的都可能到父亲节点，求和</p>
<p>最后答案就是<code>叶子数-dp[1]+1</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;3e5+5;</span><br><span class="line">const int INF&#x3D;0x3f3f3f3f;</span><br><span class="line">int num[N],dp[N],ji&#x3D;0;</span><br><span class="line">vector&lt;int&gt; g[N];</span><br><span class="line">void dfs(int u)&#123;</span><br><span class="line">	if(g[u].size()&#x3D;&#x3D;0)&#123;</span><br><span class="line">		dp[u]&#x3D;1;</span><br><span class="line">		ji++;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	int v,tmp&#x3D;0;</span><br><span class="line">	if(num[u]&#x3D;&#x3D;1)&#123;</span><br><span class="line">		for(int i&#x3D;0;i&lt;g[u].size();i++)&#123;</span><br><span class="line">			v&#x3D;g[u][i];</span><br><span class="line">			dfs(v);</span><br><span class="line">			tmp+&#x3D;dp[v];</span><br><span class="line">			dp[u]&#x3D;min(dp[u],dp[v]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		for(int i&#x3D;0;i&lt;g[u].size();i++)&#123;</span><br><span class="line">			v&#x3D;g[u][i];</span><br><span class="line">			dfs(v);</span><br><span class="line">			tmp+&#x3D;dp[v];</span><br><span class="line">		&#125;</span><br><span class="line">		dp[u]&#x3D;tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,u;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;num[i]);</span><br><span class="line">		if(num[i])dp[i]&#x3D;INF;</span><br><span class="line">		else dp[i]&#x3D;0;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;u);</span><br><span class="line">		g[u].push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(1);</span><br><span class="line">	printf(&quot;%d\n&quot;,ji-dp[1]+1);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E-Serval-and-Snake（交互题-二分）"><a href="#E-Serval-and-Snake（交互题-二分）" class="headerlink" title="E. Serval and Snake（交互题+二分）"></a>E. Serval and Snake（交互题+二分）</h1><p><code>n*n</code>网格里有一条长度k的不交叉的蛇，可以询问任意矩形，2019次以内，返回值为矩形边界穿过几个蛇身，求蛇头蛇尾在哪</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4korbpc47j20d90d8gml.jpg" alt=""></p>
<p>首先如果不是蛇头或者蛇尾的话，一般的深结点会有两个边界，所以如果当前矩形穿过蛇身个数为奇数，那么可以肯定这个矩形内包含了蛇头蛇尾，如果是偶数，那么有两种情况，一种不包含头尾，一种头尾全包含</p>
<p>所以对除了最后一列以外的每一列查询，最后一列的结果可以由前面结果推出，因为所有列和为偶</p>
<p>如果两列为奇数，即头和尾在不同列中，那么只需要对那两列二分分别找到头尾即可</p>
<p>如果头和尾在同一列，那么对所有行操作，可以得到头和尾一定在某两行，因为两个同列，所以只需要再对其中一行二分，这种是最坏的情况，次数是<code>999+999+10=2008</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;1005;</span><br><span class="line">int n,num[N],ans[4],ji&#x3D;0;</span><br><span class="line">void ask(int x1,int y1,int x2,int y2)&#123;</span><br><span class="line">    cout&lt;&lt;&#39;?&#39;&lt;&lt;&quot; &quot;&lt;&lt;x1&lt;&lt;&quot; &quot;&lt;&lt;y1&lt;&lt;&quot; &quot;&lt;&lt;x2&lt;&lt;&quot; &quot;&lt;&lt;y2&lt;&lt;endl;</span><br><span class="line">    fflush(stdout);</span><br><span class="line">&#125;</span><br><span class="line">void search_row(int col)&#123;</span><br><span class="line">    int l&#x3D;1,r&#x3D;n,m,res,tmp;</span><br><span class="line">    while(l&lt;&#x3D;r)&#123;</span><br><span class="line">        m&#x3D;(l+r)&gt;&gt;1;</span><br><span class="line">        ask(1,col,m,col);</span><br><span class="line">        cin&gt;&gt;res;</span><br><span class="line">        if(res&amp;1)&#123;</span><br><span class="line">            r&#x3D;m-1;</span><br><span class="line">            tmp&#x3D;m;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            l&#x3D;m+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[ji++]&#x3D;tmp;</span><br><span class="line">    ans[ji++]&#x3D;col;</span><br><span class="line">&#125;</span><br><span class="line">void search_col(int row)&#123;</span><br><span class="line">    int l&#x3D;1,r&#x3D;n,m,res,tmp;</span><br><span class="line">    while(l&lt;&#x3D;r)&#123;</span><br><span class="line">        m&#x3D;(l+r)&gt;&gt;1;</span><br><span class="line">        ask(row,1,row,m);</span><br><span class="line">        cin&gt;&gt;res;</span><br><span class="line">        if(res&amp;1)&#123;</span><br><span class="line">            r&#x3D;m-1;</span><br><span class="line">            tmp&#x3D;m;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            l&#x3D;m+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[ji++]&#x3D;row;</span><br><span class="line">    ans[ji++]&#x3D;tmp;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    int tmp&#x3D;0;</span><br><span class="line">    for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">        ask(1,i,n,i);</span><br><span class="line">        cin&gt;&gt;num[i];</span><br><span class="line">        tmp+&#x3D;num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    num[n]&#x3D;(tmp&amp;1);</span><br><span class="line">    vector&lt;int&gt; v;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        if(num[i]&amp;1)v.push_back(i); </span><br><span class="line">    &#125;</span><br><span class="line">    if(v.size()&#x3D;&#x3D;2)&#123;</span><br><span class="line">        search_row(v[0]);</span><br><span class="line">        search_row(v[1]);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        tmp&#x3D;0;</span><br><span class="line">        for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">            ask(i,1,i,n);</span><br><span class="line">            cin&gt;&gt;num[i];</span><br><span class="line">            tmp+&#x3D;num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        num[n]&#x3D;(tmp&amp;1);</span><br><span class="line">        v.clear();</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">            if(num[i]&amp;1)v.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        search_col(v[0]);</span><br><span class="line">        ans[2]&#x3D;v[1];ans[3]&#x3D;ans[1];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;!&quot;&lt;&lt;&quot; &quot;&lt;&lt;ans[0]&lt;&lt;&quot; &quot;&lt;&lt;ans[1]&lt;&lt;&quot; &quot;&lt;&lt;ans[2]&lt;&lt;&quot; &quot;&lt;&lt;ans[3]&lt;&lt;endl;</span><br><span class="line">    fflush(stdout);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="F-Serval-and-Bonus-Problem（期望dp）"><a href="#F-Serval-and-Bonus-Problem（期望dp）" class="headerlink" title="F. Serval and Bonus Problem（期望dp）"></a>F. Serval and Bonus Problem（期望dp）</h1><p>给一个长度为l的段，在这个段里随机选两个点可以得到一个区间，n次随机，得到n个区间，计算这n个区间至少被k个区间覆盖的区间的期望总长度</p>
<p>首先是实数，所以选2n个点，可以认为没有重合，并且实数范围内，长度为l可以直接考虑长度为1先</p>
<p>然后被k个区间覆盖的间隔的期望总长度，其实也就是一个随机点P，落在合法区间上的概率，所以问题转化为，2n+1个点（包括P），如何选定一个P点以及n个区间，求P被至少k个区间覆盖的概率</p>
<p>期望dp，<code>dp[i][j][x]</code>表示前i个点，还有j个点没有配对，P有没有选定（x=0表示还没选P，x=1选了）</p>
<p>状态转移方程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前点作为区间右端点：dp[i][j][x]-&gt;dp[i+1][j-1][x]</span><br><span class="line">当前点作为区间左端点：dp[i][j][x]-&gt;dp[i+1][j+1][x]</span><br><span class="line">当前点选为P点：dp[i][j][0]-&gt;dp[i+1][j][1]</span><br></pre></td></tr></table></figure>

<p>选P点的时候要求<code>j≥k</code>，那么可以保证P一定被k个区间覆盖</p>
<p>那么dp[2n+1][0][1]就是合法方法数，但是这其实是算多了的，因为一些顺序问题（感觉没有搞的很清楚，先跟着官方题解思路走吧mark）</p>
<p>对于选定的某个线段来说，它的左右端点又可以交换，这要乘上<code>2^n</code>种方法，这n个线段的顺序也可以交换，再乘上<code>n!</code></p>
<p>选点的顺序的方法数共有<code>(2n+1)!</code>种，这是无关的，要除掉</p>
<p>所以最后答案是：<code>dp[2n+1][0][1]*n!*2^n/(2n+1)!</code>，模意义下的除法再注意用一下逆元即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int p&#x3D;998244353;</span><br><span class="line">const int N&#x3D;2005;</span><br><span class="line">LL dp[N&lt;&lt;1][N][2];</span><br><span class="line">int n,k,l;</span><br><span class="line">LL qpow(LL a,LL b)&#123;</span><br><span class="line">    LL ans&#x3D;1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            ans&#x3D;(ans*a)%p;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        b&gt;&gt;&#x3D;1;</span><br><span class="line">        a&#x3D;a*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;k,&amp;l);</span><br><span class="line">	memset(dp,0,sizeof(dp));</span><br><span class="line">	dp[0][0][0]&#x3D;1;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;2*n+1;i++)&#123;</span><br><span class="line">		for(int j&#x3D;0;j&lt;&#x3D;n;j++)&#123;</span><br><span class="line">			for(int x&#x3D;0;x&lt;&#x3D;1;x++)&#123;</span><br><span class="line">				if(dp[i-1][j][x])&#123;</span><br><span class="line">					&#x2F;&#x2F;i作为右端点，前j个没配对的任意一个都可以和i匹配</span><br><span class="line">					if(j)</span><br><span class="line">						dp[i][j-1][x]&#x3D;(dp[i][j-1][x]+dp[i-1][j][x]*j)%p;</span><br><span class="line">					&#x2F;&#x2F;i作为左端点，没配对的个数更新为j+1</span><br><span class="line">					dp[i][j+1][x]&#x3D;(dp[i][j+1][x]+dp[i-1][j][x])%p;</span><br><span class="line">					&#x2F;&#x2F;选P</span><br><span class="line">					if(j&gt;&#x3D;k&amp;&amp;!x)</span><br><span class="line">						dp[i][j][1]&#x3D;(dp[i][j][1]+dp[i-1][j][x])%p;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	LL ans&#x3D;1;</span><br><span class="line">	for(int i&#x3D;n+1;i&lt;&#x3D;2*n+1;i++)&#123;</span><br><span class="line">		ans&#x3D;(ans*i)%p;</span><br><span class="line">	&#125;</span><br><span class="line">	ans&#x3D;(dp[2*n+1][0][1]*qpow(ans,p-2))%p;</span><br><span class="line">	ans&#x3D;(ans*qpow(2,n))%p;</span><br><span class="line">	ans&#x3D;(ans*l)%p;</span><br><span class="line">	printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>数论</tag>
        <tag>dp</tag>
        <tag>二分</tag>
        <tag>cf</tag>
      </tags>
  </entry>
  <entry>
    <title>bzoj2467 (中山市选2010)生成树（生成树定理/找规律）</title>
    <url>/f16eb349/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4korn2a4wj21400i7n1d.jpg" alt=""></p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><h4 id="方法一：生成树定理"><a href="#方法一：生成树定理" class="headerlink" title="方法一：生成树定理"></a>方法一：生成树定理</h4><p>按照题意建图，然后高斯消元跑生成树定理</p>
<p><a href="https://leflacon.github.io/9548c271" target="_blank" rel="noopener">生成树的计数及其应用（矩阵树/基尔霍夫矩阵/拉普拉斯算子）
</a></p>
<p>我的编号方式如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4korn2nj1j20dx0chmxy.jpg" alt=""></p>
<p>然后陷入wa中，我感觉是取模有问题0.0，但是这里的高斯消元是辗转相减，已经是模意义下的消元了，并没有除法，而且这种样例过了图肯定就建对了，，最后发现。。消元减的时候忘取模了TATwa了一晚上我是ju啊</p>
<h4 id="方法二：思维"><a href="#方法二：思维" class="headerlink" title="方法二：思维"></a>方法二：思维</h4><p>除了直接用生成树定理，看了别人的题解这个题还有一种做法，快乐找规律！</p>
<p>考虑这个什么五角星圈要怎么才能变成一棵树，首先没个五边形都是一个需要断开的环，如果每个五边形都断一条边的话，不管怎么断（可以模拟一下断中间和断外圈边的情况），最后还是会产生一个环，需要再断一条边</p>
<p>考虑两种特殊情况，一种是所有五边形都断内圈的边，那么最后外围刚好一圈环，任意断一个即可；另一种是所有五边形都断外面的边，那么最后内圈刚好一个环，任意断一个即可</p>
<p>推广到一般情况，n-1个五边形随便断一条边，剩下最后一个五边形必须断两条边，其中一条边必须在内圈（因为断一个五边形的两个外圈边是不可能的，就不连通了）</p>
<p>所以最后的方法数就是<code>n*4*5^(n-1)</code>，n是选一个断两条边的五边形，4是那个五边形断的另一条外圈边有四种情况，<code>5^(n-1)</code>是剩下五边形任意断一条边</p>
<p>推完公式的代码可真好写啊TAT</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p>【生成树定理】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;405;</span><br><span class="line">int a[N][N];</span><br><span class="line">int gauss(int x)&#123;</span><br><span class="line">	int res&#x3D;1;</span><br><span class="line">	for(int i&#x3D;0;i&lt;x;i++)&#123;</span><br><span class="line">		for(int j&#x3D;i+1;j&lt;x;j++)&#123;</span><br><span class="line">			while(a[j][i])&#123;</span><br><span class="line">				int t&#x3D;a[i][i]&#x2F;a[j][i];</span><br><span class="line">				for(int k&#x3D;i;k&lt;x;k++)&#123;</span><br><span class="line">					a[i][k]&#x3D;(a[i][k]-t*a[j][k])%2007;</span><br><span class="line">					int tmp&#x3D;a[i][k];</span><br><span class="line">					a[i][k]&#x3D;a[j][k];</span><br><span class="line">					a[j][k]&#x3D;tmp;</span><br><span class="line">				&#125;</span><br><span class="line">				res&#x3D;-res;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; res*&#x3D;a[i][i];</span><br><span class="line">		res&#x3D;(res*a[i][i])%2007;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; return abs(res);</span><br><span class="line">	return (res+2007)%2007;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int t;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		int n;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">		int num&#x3D;4*n;</span><br><span class="line">		memset(a,0,sizeof(a));</span><br><span class="line">		for(int i&#x3D;0;i&lt;n-1;i++)&#123;</span><br><span class="line">			a[i][i]++;a[i+1][i+1]++;</span><br><span class="line">			a[i][i+1]--;a[i+1][i]--;</span><br><span class="line">		&#125;</span><br><span class="line">		a[0][0]++;a[n-1][n-1]++;</span><br><span class="line">		a[0][n-1]--;a[n-1][0]--;</span><br><span class="line">		for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">			a[i][i]++;a[n+3*i][n+3*i]++;</span><br><span class="line">			a[i][n+3*i]--;a[n+3*i][i]--;</span><br><span class="line">			a[n+3*i][n+3*i]++;a[n+3*i+1][n+3*i+1]++;</span><br><span class="line">			a[n+3*i][n+3*i+1]--;a[n+3*i+1][n+3*i]--;</span><br><span class="line">			a[n+3*i+1][n+3*i+1]++;a[n+3*i+2][n+3*i+2]++;</span><br><span class="line">			a[n+3*i+1][n+3*i+2]--;a[n+3*i+2][n+3*i+1]--;</span><br><span class="line">			a[n+3*i+2][n+3*i+2]++;a[(i+1)%n][(i+1)%n]++;</span><br><span class="line">			a[n+3*i+2][(i+1)%n]--;a[(i+1)%n][n+3*i+2]--;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;,gauss(num-1));</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【快速幂】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const LL p&#x3D;2007;</span><br><span class="line">LL qpow(LL a,LL b)&#123;</span><br><span class="line">    LL ans&#x3D;1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            ans&#x3D;(ans*a)%p;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        b&gt;&gt;&#x3D;1;</span><br><span class="line">        a&#x3D;a*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int t;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		int n;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">		LL res&#x3D;(n*4*qpow(5,n-1))%p;</span><br><span class="line">		printf(&quot;%lld\n&quot;,res);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>bzoj1002 [FJOI2007]轮状病毒（生成树定理+java高精度）</title>
    <url>/c514331a/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kotky8xgj20lh0i0jtu.jpg" alt=""></p>
<a id="more"></a>

<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行有1个正整数n</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>计算出的不同的n轮状病毒数输出</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">16</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>就是给一个图求生成树个数，按照题意建图即可</p>
<p><a href="https://leflacon.github.io/9548c271" target="_blank" rel="noopener">生成树的计数及其应用（矩阵树/基尔霍夫矩阵/拉普拉斯算子）
</a></p>
<p>但是c++结果会爆LL，过不了，需要java高精度一下（过不了的没有高精度的c++也放在下面了）</p>
<p>此外，我看网上的题解可以推出一个递推式：<code>f[n]=f[n-1]*3-f[n-2] +2</code>，好像是找规律和斐波那契有点关系，不知道咋推的，有空再想吧mark（不过应该是不会想了(@/ω＼@)。。。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p>【java】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.math.BigInteger;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">        int n;</span><br><span class="line">        n&#x3D;cin.nextInt();</span><br><span class="line">        n&#x3D;n+1;</span><br><span class="line">        BigInteger[][] a&#x3D;new BigInteger[105][105];</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;n;j++)&#123;</span><br><span class="line">                a[i][j]&#x3D;BigInteger.ZERO;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">            a[0][0]&#x3D;a[0][0].add(BigInteger.ONE);</span><br><span class="line">            a[i][i]&#x3D;a[i][i].add(BigInteger.ONE);</span><br><span class="line">            a[0][i]&#x3D;a[0][i].subtract(BigInteger.ONE);</span><br><span class="line">            a[i][0]&#x3D;a[i][0].subtract(BigInteger.ONE);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;1;i&lt;n-1;i++)&#123;</span><br><span class="line">            a[i][i]&#x3D;a[i][i].add(BigInteger.ONE);</span><br><span class="line">            a[i+1][i+1]&#x3D;a[i+1][i+1].add(BigInteger.ONE);</span><br><span class="line">            a[i][i+1]&#x3D;a[i][i+1].subtract(BigInteger.ONE);</span><br><span class="line">            a[i+1][i]&#x3D;a[i+1][i].subtract(BigInteger.ONE);</span><br><span class="line">        &#125;</span><br><span class="line">        a[1][1]&#x3D;a[1][1].add(BigInteger.ONE);</span><br><span class="line">        a[n-1][n-1]&#x3D;a[n-1][n-1].add(BigInteger.ONE);</span><br><span class="line">        a[1][n-1]&#x3D;a[1][n-1].subtract(BigInteger.ONE);</span><br><span class="line">        a[n-1][1]&#x3D;a[n-1][1].subtract(BigInteger.ONE);</span><br><span class="line">        BigInteger res&#x3D;BigInteger.ONE;</span><br><span class="line">        for(int i&#x3D;0;i&lt;n-1;i++)&#123;</span><br><span class="line">            for(int j&#x3D;i+1;j&lt;n-1;j++)&#123;</span><br><span class="line">                while(!a[j][i].equals(BigInteger.ZERO))&#123;</span><br><span class="line">                    BigInteger t&#x3D;a[i][i].divide(a[j][i]);</span><br><span class="line">                    for(int k&#x3D;i;k&lt;n-1;k++)&#123;</span><br><span class="line">                        a[i][k]&#x3D;a[i][k].subtract(a[j][k].multiply(t));</span><br><span class="line">                        BigInteger tmp&#x3D;a[i][k];</span><br><span class="line">                        a[i][k]&#x3D;a[j][k];</span><br><span class="line">                        a[j][k]&#x3D;tmp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res&#x3D;BigInteger.ZERO.subtract(res);</span><br><span class="line">            &#125;</span><br><span class="line">            res&#x3D;res.multiply(a[i][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res&#x3D;res.abs();</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【c++】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;105;</span><br><span class="line">LL a[N][N];</span><br><span class="line">LL gauss(int x)&#123;</span><br><span class="line">	LL res&#x3D;1;</span><br><span class="line">	for(int i&#x3D;0;i&lt;x;i++)&#123;</span><br><span class="line">		for(int j&#x3D;i+1;j&lt;x;j++)&#123;</span><br><span class="line">			while(a[j][i])&#123;</span><br><span class="line">				LL t&#x3D;a[i][i]&#x2F;a[j][i];</span><br><span class="line">				for(int k&#x3D;i;k&lt;x;k++)&#123;</span><br><span class="line">					a[i][k]-&#x3D;(t*a[j][k]);</span><br><span class="line">					LL tmp&#x3D;a[i][k];</span><br><span class="line">					a[i][k]&#x3D;a[j][k];</span><br><span class="line">					a[j][k]&#x3D;tmp;</span><br><span class="line">				&#125;</span><br><span class="line">				res&#x3D;-res;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		res*&#x3D;a[i][i];</span><br><span class="line">	&#125;</span><br><span class="line">	return fabs(res);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	n++;</span><br><span class="line">	for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">		a[0][0]++;a[i][i]++;</span><br><span class="line">		a[0][i]--;a[i][0]--;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;1;i&lt;n-1;i++)&#123;</span><br><span class="line">		a[i][i]++;a[i+1][i+1]++;</span><br><span class="line">		a[i][i+1]--;a[i+1][i]--;</span><br><span class="line">	&#125;</span><br><span class="line">	a[1][1]++;a[n-1][n-1]++;</span><br><span class="line">	a[1][n-1]--;a[1][n-1]--;</span><br><span class="line">	printf(&quot;%lld\n&quot;,gauss(n-1));</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA10766 Organising the Organisation（生成树定理）</title>
    <url>/851cc78c/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kopgxfv2j20mv0g743s.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kopgybvvj20my0inad8.jpg" alt=""></p>
<h3 id="INPUT"><a href="#INPUT" class="headerlink" title="INPUT"></a>INPUT</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 5 2</span><br><span class="line">3 1</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">1 4</span><br><span class="line">5 3</span><br><span class="line">4 1 1 </span><br><span class="line">1 4</span><br><span class="line">3 0 2</span><br></pre></td></tr></table></figure>

<h3 id="OUTPUT"><a href="#OUTPUT" class="headerlink" title="OUTPUT"></a>OUTPUT</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">8</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>如题中的图，除总经理外，所有员工有且只有一个领导，其中a，b互不能为领导，总经理编号确定，求员工分级方案</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>就是求生成树，但加了一些限制条件，ab间不能连边，而定好的根跟生成树的个数无关，所以按照这些限制建图然后用生成树定理跑一下即可</p>
<p><a href="https://leflacon.github.io/9548c271" target="_blank" rel="noopener">生成树的计数及其应用（矩阵树/基尔霍夫矩阵/拉普拉斯算子）
</a></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;55;</span><br><span class="line">LL a[N][N],g[N][N];</span><br><span class="line">LL gauss(int x)&#123;</span><br><span class="line">	LL res&#x3D;1;</span><br><span class="line">	for(int i&#x3D;0;i&lt;x;i++)&#123;</span><br><span class="line">		for(int j&#x3D;i+1;j&lt;x;j++)&#123;</span><br><span class="line">			while(a[j][i])&#123;</span><br><span class="line">				LL t&#x3D;a[i][i]&#x2F;a[j][i];</span><br><span class="line">				for(int k&#x3D;i;k&lt;x;k++)&#123;</span><br><span class="line">					a[i][k]-&#x3D;(t*a[j][k]);</span><br><span class="line">					LL tmp&#x3D;a[i][k];</span><br><span class="line">					a[i][k]&#x3D;a[j][k];</span><br><span class="line">					a[j][k]&#x3D;tmp;</span><br><span class="line">				&#125;</span><br><span class="line">				res&#x3D;-res;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		res*&#x3D;a[i][i];</span><br><span class="line">	&#125;</span><br><span class="line">	return fabs(res);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,m,k,u,v;</span><br><span class="line">	while(scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k)!&#x3D;EOF)&#123;</span><br><span class="line">		memset(a,0,sizeof(a));</span><br><span class="line">		memset(g,0,sizeof(g));</span><br><span class="line">		while(m--)&#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">			u--;v--;</span><br><span class="line">			g[u][v]&#x3D;g[v][u]&#x3D;1;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">			for(int j&#x3D;0;j&lt;n;j++)&#123;</span><br><span class="line">				if(!g[i][j])&#123;</span><br><span class="line">					a[i][i]++;</span><br><span class="line">					a[i][j]--;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%lld\n&quot;,gauss(n-1));</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>spoj HIGH - Highways（生成树定理）</title>
    <url>/e1b63b73/</url>
    <content><![CDATA[<p>In some countries building highways takes a lot of time… Maybe that’s because there are many possiblities to construct a network of highways and engineers can’t make up their minds which one to choose. Suppose we have a list of cities that can be connected directly. Your task is to count how many ways there are to build such a network that between every two cities there exists exactly one path. Two networks differ if there are two cities that are connected directly in the first case and aren’t in the second case. At most one highway connects two cities. No highway connects a city to itself. Highways are two-way.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input begins with the integer t, the number of test cases (equal to about 1000). Then t test cases follow. The first line of each test case contains two integers, the number of cities (1&lt;=n&lt;=12) and the number of direct connections between them. Each next line contains two integers a and b, which are numbers of cities that can be connected. Cities are numbered from 1 to n. Consecutive test cases are separated with one blank line.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>The number of ways to build the network, for every test case in a separate line. Assume that when there is only one city, the answer should be 1. The answer will fit in a signed 64-bit integer.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h3 id="Sample-input"><a href="#Sample-input" class="headerlink" title="Sample input:"></a>Sample input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">4 5</span><br><span class="line">3 4</span><br><span class="line">4 2</span><br><span class="line">2 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line"></span><br><span class="line">2 1</span><br><span class="line">2 1</span><br><span class="line"></span><br><span class="line">1 0</span><br><span class="line"></span><br><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 1</span><br></pre></td></tr></table></figure>

<h3 id="Sample-output"><a href="#Sample-output" class="headerlink" title="Sample output:"></a>Sample output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给一个无向图，求生成树（任意两点间有且只有一条最短路）的个数</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>裸的生成树定理：<a href="https://leflacon.github.io/9548c271" target="_blank" rel="noopener">生成树的计数及其应用（矩阵树/基尔霍夫矩阵/拉普拉斯算子）
</a></p>
<p>这里的高斯消元用的是辗转相减的方法，这样可以避免除法可能产生的精度问题</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;15;</span><br><span class="line">LL a[N][N];</span><br><span class="line">LL gauss(int x)&#123;</span><br><span class="line">	LL res&#x3D;1;</span><br><span class="line">	for(int i&#x3D;0;i&lt;x;i++)&#123;</span><br><span class="line">		for(int j&#x3D;i+1;j&lt;x;j++)&#123;</span><br><span class="line">			while(a[j][i])&#123;</span><br><span class="line">				LL t&#x3D;a[i][i]&#x2F;a[j][i];</span><br><span class="line">				for(int k&#x3D;i;k&lt;x;k++)&#123;</span><br><span class="line">					a[i][k]-&#x3D;(t*a[j][k]);</span><br><span class="line">					LL tmp&#x3D;a[i][k];</span><br><span class="line">					a[i][k]&#x3D;a[j][k];</span><br><span class="line">					a[j][k]&#x3D;tmp;</span><br><span class="line">				&#125;</span><br><span class="line">				res&#x3D;-res;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		res*&#x3D;a[i][i];</span><br><span class="line">	&#125;</span><br><span class="line">	return fabs(res);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int t,n,m,u,v;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">		memset(a,0,sizeof(a));</span><br><span class="line">		while(m--)&#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">			u--;v--;</span><br><span class="line">			a[u][u]++;a[v][v]++;&#x2F;&#x2F;度数矩阵</span><br><span class="line">			a[u][v]--;a[v][u]--;&#x2F;&#x2F;邻接矩阵</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%lld\n&quot;,gauss(n-1));</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>生成树的计数及其应用（矩阵树/基尔霍夫矩阵/拉普拉斯算子）</title>
    <url>/9548c271/</url>
    <content><![CDATA[<p>学个论文，，因为bzoj1002不会做，，不会暴搜打表只好学正解了ಥ_ಥ，，论文里的证明看的半懂不懂。。(´；ω；｀)不看了</p>
<a id="more"></a>

<hr>
<h1 id="1-生成树定理"><a href="#1-生成树定理" class="headerlink" title="1.生成树定理"></a>1.生成树定理</h1><p>对于一个图G来说，G的<strong>「度数矩阵」</strong><code>D[G]</code>是一个<code>n*n</code>的矩阵，当<code>i≠j</code>时，<code>dij=0</code>，当<code>i=j</code>时，dij等于vi的度数</p>
<p>G的<strong>「邻接矩阵」</strong><code>A[G]</code>是一个<code>n*n</code>的矩阵，如果vi，vj之间有边直接相连，<code>dij=1</code>，否则为0</p>
<p>G的<strong>「Kirchhoff矩阵」</strong>（基尔霍夫矩阵/拉普拉斯算子）<code>C[G]</code>为<code>C[G]=D[G]-A[G]</code></p>
<p>如果G是一棵树，那么它的基尔霍夫矩阵C的任一个n-1阶主子式的行列式均为1</p>
<p><font size="3" color=#1357ff><strong>「Matrix-Tree定理」（生成树定理）</strong>：G的所有不同的生成树的个数等于其基尔霍夫矩阵<code>C[G]</code>任何一个n-1阶主子式的行列式的绝对值</font></p>
<blockquote>
<p>n-1阶主子式是对于r(1≤r≤n)，将C[G]的第r行，第r列同时去掉后得到的新矩阵，表示为：<img src="https://ws2.sinaimg.cn/large/006tNc79ly1g2smrbnwx1j301a00sjr5.jpg" alt=""></p>
</blockquote>
<p>证明可长了，，见论文，总之巧妙之处就是<font size="5" color=#a7a3ff>把图转化为矩阵的模型</font>，再利用一些数学知识</p>
<p>这种<font size="5" color=#d2a3ff>模型转化的思想</font>还是很受用的</p>
<h1 id="2-应用"><a href="#2-应用" class="headerlink" title="2.应用"></a>2.应用</h1><p>两个模版题</p>
<p><a href="https://leflacon.github.io/e1b63b73" target="_blank" rel="noopener">spoj HIGH - Highways（生成树定理）</a></p>
<p><a href="https://leflacon.github.io/851cc78c" target="_blank" rel="noopener">UVA10766 Organising the Organisation（生成树定理）
</a></p>
<p>然后作者给出了另一个问题：</p>
<p>如果给定一个图，某些边必选，那么生成树个数是多少</p>
<p>有必选边那么把必选边缩成一个点，建个新图，然后在新图上来一次生成树定理，可行</p>
<p>其他题：</p>
<p><a href="https://leflacon.github.io/c514331a" target="_blank" rel="noopener">bzoj1002 FJOI2007 轮状病毒（生成树定理+java高精度）</a></p>
<p><a href="https://leflacon.github.io/f16eb349" target="_blank" rel="noopener">bzoj2467: [中山市选2010]生成树（生成树定理/找规律）</a></p>
<hr>
<p>最后放上论文地址 -&gt; <a href="https://wenku.baidu.com/view/872eb02de2bd960590c677c6.html" target="_blank" rel="noopener">生成树的计数及其应用</a></p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>bzoj1003 (ZJOI2006)物流运输（dp+最短路）</title>
    <url>/ad83609f/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kooz9qjtj20rg0e3dlh.jpg" alt=""></p>
<a id="more"></a>

<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 5 10 8</span><br><span class="line">1 2 1</span><br><span class="line">1 3 3</span><br><span class="line">1 4 2</span><br><span class="line">2 3 2</span><br><span class="line">2 4 4</span><br><span class="line">3 4 1</span><br><span class="line">3 5 2</span><br><span class="line">4 5 2</span><br><span class="line">4</span><br><span class="line">2 2 3</span><br><span class="line">3 1 1             </span><br><span class="line">3 3 3</span><br><span class="line">4 4 5</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">32</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;前三天走1-4-5，后两天走1-3-5，这样总成本为(2+2)*3+(3+2)*2+10&#x3D;32</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给一个带权无向图，编号为1-m，每天都要从1-m，费用为路径长度，某些天不能到某个点上，每次改变1-m的路线都需要额外费用e</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>看似图论实则还要来下dp，妙啊妙啊</p>
<p>首先ok[i][j]表示第i天编号j能否经过，1不能</p>
<p>要从1到m肯定是优先走最短路，如果最短路走不了就需要改变路径，所以先用dijkstra跑<code>n^2</code>次预处理出cost[i][j]，表示[i,j]天可以实现的最短路，每次跑之前更新一下vis数组</p>
<p>dp[i]表示前i天的最小费用，初始化<code>dp[i]=cost[1][i]*i</code>，如果cost是inf的话，那么dp也初始化为inf</p>
<p>状态转移的原则就是，换路花费小就换，状态转移方程是：<code>dp[i]=min(dp[j]+cost[j+1][i]*(i-j)+k)</code></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line">const int M&#x3D;25;</span><br><span class="line">const int N&#x3D;105;</span><br><span class="line">int dp[M],g[M][M],ok[N][N],cost[N][N],vis[M],dis[M];</span><br><span class="line">int n,m,k,e,d;</span><br><span class="line">void update(int l,int r)&#123;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">		for(int j&#x3D;l;j&lt;&#x3D;r;j++)&#123;</span><br><span class="line">			if(ok[j][i])&#123;</span><br><span class="line">				vis[i]&#x3D;1;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int dijkstra()&#123;</span><br><span class="line">	dis[1]&#x3D;0;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">		int tmp&#x3D;0;</span><br><span class="line">		for(int j&#x3D;1;j&lt;&#x3D;m;j++)&#123;</span><br><span class="line">			if(!vis[j]&amp;&amp;dis[j]&lt;dis[tmp])tmp&#x3D;j;</span><br><span class="line">		&#125;</span><br><span class="line">		if(tmp&#x3D;&#x3D;m||tmp&#x3D;&#x3D;0)return dis[tmp];</span><br><span class="line">		vis[tmp]&#x3D;1;</span><br><span class="line">		for(int j&#x3D;1;j&lt;&#x3D;m;j++)&#123;</span><br><span class="line">			if(!vis[j])</span><br><span class="line">				dis[j]&#x3D;min(dis[j],dis[tmp]+g[tmp][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return dis[m];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;k,&amp;e);</span><br><span class="line">	memset(g,INF,sizeof(g));</span><br><span class="line">	memset(ok,0,sizeof(ok));</span><br><span class="line">	int u,v,w;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;e;i++)&#123;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);</span><br><span class="line">		g[u][v]&#x3D;g[v][u]&#x3D;w;</span><br><span class="line">	&#125;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;d);</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;d;i++)&#123;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);</span><br><span class="line">		for(int j&#x3D;v;j&lt;&#x3D;w;j++)</span><br><span class="line">			ok[j][u]&#x3D;1;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		for(int j&#x3D;i;j&lt;&#x3D;n;j++)&#123;</span><br><span class="line">			memset(vis,0,sizeof(vis));</span><br><span class="line">			memset(dis,INF,sizeof(dis));</span><br><span class="line">			update(i,j);</span><br><span class="line">			cost[i][j]&#x3D;dijkstra();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dp[0]&#x3D;-k;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		if(cost[1][i]!&#x3D;INF)</span><br><span class="line">			dp[i]&#x3D;cost[1][i]*i;</span><br><span class="line">		else dp[i]&#x3D;cost[1][i];</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		for(int j&#x3D;0;j&lt;i;j++)&#123;</span><br><span class="line">			if(cost[j+1][i]!&#x3D;INF)</span><br><span class="line">				dp[i]&#x3D;min(dp[i],dp[j]+cost[j+1][i]*(i-j)+k);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; cout&lt;&lt;dp[i]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d\n&quot;,dp[n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow学习记录（二）MNIST手写数字识别（softmax回归）</title>
    <url>/37d812ca/</url>
    <content><![CDATA[<h1 id="1-MNIST介绍及下载"><a href="#1-MNIST介绍及下载" class="headerlink" title="1.MNIST介绍及下载"></a>1.MNIST介绍及下载</h1><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kohvr1guj20gi0a1abr.jpg" alt=""></p>
<a id="more"></a>

<p>wiki的介绍：<a href="https://en.wikipedia.org/wiki/MNIST_database" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/MNIST_database</a></p>
<p>这是MNIST的官网，在里面可以获取这个数据集：<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">http://yann.lecun.com/exdb/mnist/</a></p>
<p>把下面这四个下下来放一个文件夹里就好了</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kohvreuoj20ee02naag.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kohvs3iij20cm04q74l.jpg" alt=""></p>
<p>比如下图就是四张手写数字图片，在MNIST中一个手写数字被保存为二维矩阵的形式，<code>28*28=784</code></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4koia5cpfj20h804y0t2.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4koia8c86j20vy0cmgn8.jpg" alt=""></p>
<p>接下来要利用这个数据集训练一个模型用于预测手写的数字</p>
<p>每一个MNIST数据单元由两部分组成：一张包含手写数字的图片和一个对应的标签，训练数据集的图片是<code>mnist.train.images</code>，训练数据集的标签是<code>mnist.train.labels</code></p>
<p>在MNIST训练数据集中图片是一个[60000,784]的张量，第一个维度代表引图片，第二个维度代表每张图片中的像素点，在此张量里的每一个元素，都表示某张图片里的某个像素的强度值，值介于0和1之间</p>
<p>MNIST数据集的标签是介于0到9的数字，用来描述给定图片里表示的数字，标签数据是<code>&quot;one-hot vectors&quot;</code>，一个<code>one-hot</code>向量除了某一位的数字是1以外其余各维度数字都是0，<code>mnist.train.labels</code>是一个[60000,10]的数字矩阵</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4koia6hejj20c300nmx1.jpg" alt=""></p>
<h1 id="2-构建模型——softmax回归-softmax-regression"><a href="#2-构建模型——softmax回归-softmax-regression" class="headerlink" title="2.构建模型——softmax回归(softmax regression)"></a>2.构建模型——softmax回归(softmax regression)</h1><p>训练利用一个简单数学模型，softmax回归，它可以用来给不同的对象分配概率</p>
<p>对训练集中的图片的每种数字的像素点进行加权求和，就可以得到一张给定图片属于某个特定数字类的证据</p>
<p>如下图：红色代表负数权值，蓝色代表正数权值</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4koiqk449j20vt0fztap.jpg" alt=""></p>
<p>计算过程如图：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kok26xuej20750220sl.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4koiqnuo2j22340u0dr9.jpg" alt=""></p>
<p>这个计算可以利用矩阵优化</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kokp5tnrj223n0han3f.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kolxixwsj220w0hs44a.jpg" alt=""></p>
<p>最终得到：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kom5i7b5j206401cjr7.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kom5jukpj20fh030gly.jpg" alt=""></p>
<h1 id="3-cost-loss"><a href="#3-cost-loss" class="headerlink" title="3.cost/loss"></a>3.cost/loss</h1><p>需要一个指标用于评判模型的好坏，成本cost或者损失loss，然后要做的就是最小化这个指标</p>
<p>这里用的损失函数是“交叉熵”，可以衡量测试结果的不准确性，公式如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kom5irpej206d021mx0.jpg" alt=""></p>
<p>tensorflow可以使用反向传播算法来确定权重修改是如何影响loss值的，然后这里tensorflow用梯度下降算法以0.01的学习速率最小化交叉熵</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4komnf9djj20gs042t98.jpg" alt=""></p>
<h1 id="4-代码"><a href="#4-代码" class="headerlink" title="4.代码"></a>4.代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 导入</span><br><span class="line">import tensorflow as tf</span><br><span class="line">import os</span><br><span class="line">from tensorflow.examples.tutorials.mnist import input_data</span><br><span class="line"></span><br><span class="line"># 忽略警告</span><br><span class="line">os.environ[&#39;TF_CPP_MIN_LOG_LEVEL&#39;] &#x3D; &#39;3&#39;</span><br><span class="line">old_v &#x3D; tf.logging.get_verbosity()</span><br><span class="line">tf.logging.set_verbosity(tf.logging.ERROR)</span><br><span class="line"></span><br><span class="line">mnist &#x3D; input_data.read_data_sets(&quot;MNIST_data&quot;, one_hot&#x3D;True)</span><br><span class="line"></span><br><span class="line"># x占位符，表示输入值，张量的形状是[None，784]，表示任意多张图，每一张图展平成784维的向量</span><br><span class="line">x &#x3D; tf.placeholder(tf.float32, [None, 784])</span><br><span class="line"># W权重值，b偏置量，一个Variable代表一个可修改的张量，用全为零的张量来初始化W和b</span><br><span class="line">W &#x3D; tf.Variable(tf.zeros([784, 10]))</span><br><span class="line">b &#x3D; tf.Variable(tf.zeros([10]))</span><br><span class="line"># 预测</span><br><span class="line">y &#x3D; tf.nn.softmax(tf.matmul(x, W) + b)</span><br><span class="line"></span><br><span class="line"># 实际</span><br><span class="line">y_ &#x3D; tf.placeholder(tf.float32, [None, 10])</span><br><span class="line"># 计算交叉熵，首先用tf.log计算y的每个元素的对数</span><br><span class="line"># 然后把y_的每一个元素和tf.log(y)的对应元素相乘</span><br><span class="line"># 最后，用tf.reduce_sum计算张量的所有元素的总和</span><br><span class="line">cross_entropy &#x3D; tf.reduce_mean(-tf.reduce_sum(y_ * tf.log(y), reduction_indices&#x3D;[1]))</span><br><span class="line"></span><br><span class="line"># TensorFlow用梯度下降算法以0.01的学习速率最小化交叉熵</span><br><span class="line">train_step &#x3D; tf.train.GradientDescentOptimizer(0.01).minimize(cross_entropy)</span><br><span class="line"></span><br><span class="line"># 初始化创建的变量</span><br><span class="line">init &#x3D; tf.global_variables_initializer()</span><br><span class="line"># 在一个Session里面启动模型，并初始化变量</span><br><span class="line">sess &#x3D; tf.Session()</span><br><span class="line">sess.run(init)</span><br><span class="line"></span><br><span class="line"># 模型循环训练1000次，每次随机抓取训练数据中的100个批处理数据点</span><br><span class="line">for i in range(1000):</span><br><span class="line">    batch_xs, batch_ys &#x3D; mnist.train.next_batch(100)</span><br><span class="line"></span><br><span class="line">    sess.run(train_step, feed_dict&#x3D;&#123;x: batch_xs, y_: batch_ys&#125;)</span><br><span class="line"></span><br><span class="line"># tf.equal 来检测预测是否真实标签匹配</span><br><span class="line">correct_prediction &#x3D; tf.equal(tf.argmax(y, 1), tf.argmax(y_, 1))</span><br><span class="line"># 把bool转换成float，然后取平均值，eg：[True, False, True, True]-&gt;[1,0,1,1]取平均值后得到0.75</span><br><span class="line">accuracy &#x3D; tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</span><br><span class="line"># 计算所学习到的模型在测试数据集上面的正确率</span><br><span class="line">print(sess.run(accuracy, feed_dict&#x3D;&#123;x: mnist.test.images, y_: mnist.test.labels&#125;))</span><br></pre></td></tr></table></figure>

<p>本地循环1000次的效果：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4komnfo04j209v037mxf.jpg" alt=""></p>
<p>在colab上跑循环10000次的效果：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4komnf7o3j20cu02ogm0.jpg" alt=""></p>
<p>此外，如果把梯度下降速率从0.01改大为0.5，训练效果变好了0.0</p>
<hr>
<p>最后。。图大都从官方盗的。。就不注明出处了ORZ</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>Python导入MNIST如何忽略显示的warning（logging设置）</title>
    <url>/2b571d71/</url>
    <content><![CDATA[<h1 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h1><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kooar5yrj20ce04d0sy.jpg" alt=""></p>
<p>输出是这样的：</p>
<p>一堆WARNING。。虽然也能导入，，但是太影响美观了，，看着难受</p>
<p>一般情况下python忽略警告的方法就是通过<code>os</code>设置一下</p>
<p>但是我明明设置了<code>os.environ[&#39;TF_CPP_MIN_LOG_LEVEL&#39;] = &#39;3&#39;</code>来忽略警告（1是默认的，显示所有信息/2是只显示error和warning/3是只显示warning）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WARNING:tensorflow:From &#x2F;Users&#x2F;mac&#x2F;PycharmProjects&#x2F;123&#x2F;tf.py:10: read_data_sets (from tensorflow.contrib.learn.python.learn.datasets.mnist) is deprecated and will be removed in a future version.</span><br><span class="line">Instructions for updating:</span><br><span class="line">Please use alternatives such as official&#x2F;mnist&#x2F;dataset.py from tensorflow&#x2F;models.</span><br><span class="line">Extracting MNIST_data&#x2F;train-images-idx3-ubyte.gz</span><br><span class="line">WARNING:tensorflow:From &#x2F;Users&#x2F;mac&#x2F;Library&#x2F;Python&#x2F;3.6&#x2F;lib&#x2F;python&#x2F;site-packages&#x2F;tensorflow&#x2F;contrib&#x2F;learn&#x2F;python&#x2F;learn&#x2F;datasets&#x2F;mnist.py:260: maybe_download (from tensorflow.contrib.learn.python.learn.datasets.base) is deprecated and will be removed in a future version.</span><br><span class="line">Instructions for updating:</span><br><span class="line">Please write your own downloading logic.</span><br><span class="line">WARNING:tensorflow:From &#x2F;Users&#x2F;mac&#x2F;Library&#x2F;Python&#x2F;3.6&#x2F;lib&#x2F;python&#x2F;site-packages&#x2F;tensorflow&#x2F;contrib&#x2F;learn&#x2F;python&#x2F;learn&#x2F;datasets&#x2F;mnist.py:262: extract_images (from tensorflow.contrib.learn.python.learn.datasets.mnist) is deprecated and will be removed in a future version.</span><br><span class="line">Instructions for updating:</span><br><span class="line">Please use tf.data to implement this functionality.</span><br><span class="line">Extracting MNIST_data&#x2F;train-labels-idx1-ubyte.gz</span><br><span class="line">WARNING:tensorflow:From &#x2F;Users&#x2F;mac&#x2F;Library&#x2F;Python&#x2F;3.6&#x2F;lib&#x2F;python&#x2F;site-packages&#x2F;tensorflow&#x2F;contrib&#x2F;learn&#x2F;python&#x2F;learn&#x2F;datasets&#x2F;mnist.py:267: extract_labels (from tensorflow.contrib.learn.python.learn.datasets.mnist) is deprecated and will be removed in a future version.</span><br><span class="line">Instructions for updating:</span><br><span class="line">Please use tf.data to implement this functionality.</span><br><span class="line">WARNING:tensorflow:From &#x2F;Users&#x2F;mac&#x2F;Library&#x2F;Python&#x2F;3.6&#x2F;lib&#x2F;python&#x2F;site-packages&#x2F;tensorflow&#x2F;contrib&#x2F;learn&#x2F;python&#x2F;learn&#x2F;datasets&#x2F;mnist.py:110: dense_to_one_hot (from tensorflow.contrib.learn.python.learn.datasets.mnist) is deprecated and will be removed in a future version.</span><br><span class="line">Instructions for updating:</span><br><span class="line">Please use tf.one_hot on tensors.</span><br><span class="line">Extracting MNIST_data&#x2F;t10k-images-idx3-ubyte.gz</span><br><span class="line">WARNING:tensorflow:From &#x2F;Users&#x2F;mac&#x2F;Library&#x2F;Python&#x2F;3.6&#x2F;lib&#x2F;python&#x2F;site-packages&#x2F;tensorflow&#x2F;contrib&#x2F;learn&#x2F;python&#x2F;learn&#x2F;datasets&#x2F;mnist.py:290: DataSet.__init__ (from tensorflow.contrib.learn.python.learn.datasets.mnist) is deprecated and will be removed in a future version.</span><br><span class="line">Instructions for updating:</span><br><span class="line">Please use alternatives such as official&#x2F;mnist&#x2F;dataset.py from tensorflow&#x2F;models.</span><br><span class="line">Extracting MNIST_data&#x2F;t10k-labels-idx1-ubyte.gz</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kooasfz1j20hp0a076y.jpg" alt=""></p>
<p>我的环境是<code>mac OS Mojave + Python3.6</code></p>
<h1 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2.解决办法"></a>2.解决办法</h1><p>可能是因为以前的tensorflow学习代码太老了。。有些用法更新了所以才会报这些警告，一种方法是用官方文档给出的新的用法，另一种方法就是设置logging，这里用了第二种。。</p>
<p>如下添加中间那两句即可：</p>
<p>关于logging的介绍 -&gt; <a href="https://www.tensorflow.org/api_docs/python/tf/logging" target="_blank" rel="noopener">https://www.tensorflow.org/api_docs/python/tf/logging</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 导入</span><br><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line">old_v &#x3D; tf.logging.get_verbosity()</span><br><span class="line">tf.logging.set_verbosity(tf.logging.ERROR)</span><br><span class="line"></span><br><span class="line">from tensorflow.examples.tutorials.mnist import input_data</span><br><span class="line"></span><br><span class="line">mnist &#x3D; input_data.read_data_sets(&quot;MNIST_data&quot;, one_hot&#x3D;True)</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kooarj9rj209h02j3yr.jpg" alt=""></p>
<p>参考自stack overflow里的这个解决 -&gt; <a href="https://stackoverflow.com/questions/49901806/tensorflow-importing-mnist-warnings" target="_blank" rel="noopener">Tensorflow importing mnist warnings</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow学习记录（一）基本用法（交互式使用，简单计数器，fetch，feed）</title>
    <url>/b3220ac0/</url>
    <content><![CDATA[<h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h1><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 导入</span><br><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line"># 创建源op</span><br><span class="line"># 1*2矩阵</span><br><span class="line">m1&#x3D;tf.constant([[3.,3.]])</span><br><span class="line"># 2*1矩阵</span><br><span class="line">m2&#x3D;tf.constant([[2.],[2.]])</span><br><span class="line"></span><br><span class="line"># 创建matmul op，m1m2作为输入</span><br><span class="line">product&#x3D;tf.matmul(m1,m2)</span><br><span class="line"></span><br><span class="line"># 启动图</span><br><span class="line">sess&#x3D;tf.Session()</span><br><span class="line"></span><br><span class="line"># 返回值是一个&#39;numpy.ndarray&#39;对象</span><br><span class="line">result&#x3D;sess.run(product)</span><br><span class="line">print(result)</span><br><span class="line"># 输出结果为 [[12.]]</span><br><span class="line"></span><br><span class="line"># 任务完成，关闭会话，close以释放资源</span><br><span class="line">sess.close()</span><br><span class="line"></span><br><span class="line"># 也可以利用with不显式的释放资源</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">	result&#x3D;sess.run([product])</span><br><span class="line">	print(result)</span><br><span class="line"># 输出结果为 [array([[12.]], dtype&#x3D;float32)]</span><br><span class="line"></span><br><span class="line"># 指定某个gpu或者cpu来执行</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">	with tf.device(&quot;&#x2F;cpu:1&quot;):</span><br><span class="line">		result&#x3D;sess.run([product])</span><br><span class="line">		print(result)</span><br></pre></td></tr></table></figure>

<h1 id="2-交互式使用"><a href="#2-交互式使用" class="headerlink" title="2.交互式使用"></a>2.交互式使用</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进入一个交互式tensorflow会话</span><br><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line">sess&#x3D;tf.InteractiveSession()</span><br><span class="line"></span><br><span class="line">x&#x3D;tf.Variable([1.0,2.0])</span><br><span class="line">a&#x3D;tf.constant([3.0,3.0])</span><br><span class="line"></span><br><span class="line"># 使用初始化器初始化x</span><br><span class="line">x.initializer.run()</span><br><span class="line"></span><br><span class="line"># 添加一个减法op，运行该op输出结果</span><br><span class="line"># sub&#x3D;tf.subtract(x,a)sub已经停用，改为subtract</span><br><span class="line">sub&#x3D;tf.subtract(x,a)</span><br><span class="line">print(sub.eval())</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4koneekcgj204b00ymwz.jpg" alt=""></p>
<h1 id="3-实现一个简单计数器"><a href="#3-实现一个简单计数器" class="headerlink" title="3.实现一个简单计数器"></a>3.实现一个简单计数器</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line"># 创建一个变量，初始化为标量0</span><br><span class="line">state&#x3D;tf.Variable(0,name&#x3D;&quot;counter&quot;)</span><br><span class="line"></span><br><span class="line"># 创建一个op，+1功能</span><br><span class="line">one&#x3D;tf.constant(1)</span><br><span class="line">new_value&#x3D;tf.add(state,one)</span><br><span class="line">update&#x3D;tf.assign(state,new_value)</span><br><span class="line"></span><br><span class="line"># op初始化</span><br><span class="line"># init_op&#x3D;tf.initialize_all_variables()已经停用</span><br><span class="line">init_op&#x3D;tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line"># 启动图，运行op</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">	sess.run(init_op)</span><br><span class="line">	# state初始值</span><br><span class="line">	print(sess.run(state))</span><br><span class="line">	for _ in range(3):</span><br><span class="line">		# 运行op，更新state，并输出</span><br><span class="line">		sess.run(update)</span><br><span class="line">		# print(sess.run(state))</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4konef677j208604lmx9.jpg" alt=""></p>
<h1 id="4-fetch"><a href="#4-fetch" class="headerlink" title="4.fetch"></a>4.fetch</h1><p>传入多个<code>tensor</code>，就可以取回多个<code>tensor</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建常数op</span><br><span class="line">input1&#x3D;tf.constant(3.0)</span><br><span class="line">input2&#x3D;tf.constant(2.0)</span><br><span class="line">input3&#x3D;tf.constant(5.0)</span><br><span class="line"></span><br><span class="line"># 加</span><br><span class="line">intermed&#x3D;tf.add(input2,input3)</span><br><span class="line"># 乘</span><br><span class="line"># mul &#x3D; tf.mul(input1, intermed)mul已经停用，改为multiply</span><br><span class="line">mul&#x3D;tf.multiply(input1,intermed)</span><br><span class="line"></span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">	result&#x3D;sess.run([mul,intermed])</span><br><span class="line">	print(result)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4koneeskij2080025aa1.jpg" alt=""></p>
<h1 id="5-feed机制"><a href="#5-feed机制" class="headerlink" title="5.feed机制"></a>5.feed机制</h1><p><code>feed</code>使用一个<code>tensor</code>值临时替换一个操作的输出结果，可以提供<code>feed</code>数据作为<code>run()</code>调用的参数，<code>feed</code>只在调用它的方法内有效，方法结束，<code>feed</code>就会消失</p>
<p>使用<code>tf.placeholder()</code>为feed操作创建占位符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 为feed操作创建占位符</span><br><span class="line">input1&#x3D;tf.placeholder(tf.float32)</span><br><span class="line">input2&#x3D;tf.placeholder(tf.float32)</span><br><span class="line"></span><br><span class="line">output&#x3D;tf.multiply(input1,input2)</span><br><span class="line"></span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">	print(sess.run([output],feed_dict&#x3D;&#123;input1:[7.],input2:[2.]&#125;))</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4konrogolj20dm01rq30.jpg" alt=""></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>51nod 1393 0和1相等串（前缀和，思维）</title>
    <url>/9ae375e2/</url>
    <content><![CDATA[<p>1 秒  131,072 KB 20 分 3 级题</p>
<p>给定一个0-1串，请找到一个尽可能长的子串，其中包含的0与1的个数相等。</p>
<a id="more"></a>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>一个字符串，只包含01，长度不超过1000000。</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>一行一个整数，最长的0与1的个数相等的子串的长度。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1011</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>好妙一个题</p>
<p>01串都是骗人的，把所有0变成-1，那么其实是个前缀和的题，如果<code>sum[i]==0</code>或者<code>sum[i]==sum[j]</code>，那么就存在01串个数相等的情况</p>
<p>用一个数组vis存某个sum最先出现的位置即可</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;1e6+5;</span><br><span class="line">int a[N],sum[N],vis[N*2];</span><br><span class="line">int main()&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    sum[0]&#x3D;0;</span><br><span class="line">    int ans&#x3D;0;</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;s.length();i++)&#123;</span><br><span class="line">        if(s[i-1]&#x3D;&#x3D;&#39;0&#39;)a[i-1]&#x3D;-1;</span><br><span class="line">        else a[i-1]&#x3D;1;</span><br><span class="line">        sum[i]&#x3D;sum[i-1]+a[i-1];</span><br><span class="line">        if(vis[sum[i]+N])&#123;</span><br><span class="line">            ans&#x3D;max(ans,i-vis[sum[i]+N]);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            vis[sum[i]+N]&#x3D;i;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum[i]&#x3D;&#x3D;0)ans&#x3D;i;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>51nod 1285 山峰和分段（思维）</title>
    <url>/a6cffa18/</url>
    <content><![CDATA[<p>用一个长度为N的整数数组A，描述山峰和山谷的高度。山峰需要满足如下条件， 0 &lt; P &lt; N - 1 且 A[P - 1] &lt; A[P] &gt; A[P + 1]。</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kofs1cwqj208u04hjrd.jpg" alt=""></p>
<p>以上图为例，高度为：1 5 3 4 3 4 1 2 3 4 6 2。<br>现在要将整个山分为K段，要求每段的点数都一样，且每段中都至少存在一个山峰，问最多可以分为多少段。</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第1行：一个数N，表示数组的长度(1 &lt;= N &lt;= 50000)。<br>第2 - N + 1行：每行1个数Ai(1 &lt;= Ai &lt;= 10^9)。</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出最多可以将山分为多少段。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12</span><br><span class="line">1</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>根据山峰的定义，扫一遍可以判断出所有山峰，用一个vis数组存好，接着就是要确定k，使山峰尽可能分散在不同区间内</p>
<p>首先k肯定是大于等于3的，判断某个k是否合法，只需要判断区间中有没有点是山峰即可，在遇到区间头的时候重置一下flag，遇到区间尾的时候判断一下该区间是否合法</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;5e4+5;</span><br><span class="line">LL a[N];</span><br><span class="line">int check[N],n;</span><br><span class="line">bool ok(int k)&#123;</span><br><span class="line">    int flag&#x3D;0; </span><br><span class="line">    for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">        if(i%k&#x3D;&#x3D;0)&#123;</span><br><span class="line">            flag&#x3D;0;</span><br><span class="line">            if(check[i])flag&#x3D;1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(i%k&#x3D;&#x3D;k-1)&#123;</span><br><span class="line">            if(check[i])flag&#x3D;1;</span><br><span class="line">            if(flag&#x3D;&#x3D;0)return false;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            if(check[i])flag&#x3D;1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    memset(check,0,sizeof(check));</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%lld&quot;,&amp;a[i]);</span><br><span class="line">    for(int i&#x3D;1;i&lt;n-1;i++)&#123;</span><br><span class="line">        if(a[i]&gt;a[i-1]&amp;&amp;a[i]&gt;a[i+1])&#123;</span><br><span class="line">            check[i]&#x3D;1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int len&#x3D;3;</span><br><span class="line">    while(len&lt;&#x3D;n)&#123;</span><br><span class="line">        if(n%len&#x3D;&#x3D;0&amp;&amp;ok(len))break;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!ok(len))puts(&quot;0&quot;);</span><br><span class="line">    else printf(&quot;%d\n&quot;,(int)(n&#x2F;len));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>51nod 1276 岛屿的数量（思维）</title>
    <url>/76493566/</url>
    <content><![CDATA[<p>1 秒  131,072 KB 20 分 3 级题</p>
<p>有N个岛连在一起形成了一个大的岛屿，如果海平面上升超过某些岛的高度时，则这个岛会被淹没。原本的大岛屿则会分为多个小岛屿，如果海平面一直上升，则所有岛都会被淹没在水下。<br>给出N个岛的高度。然后有Q个查询，每个查询给出一个海平面的高度H，问当海平面高度达到H时，海上共有多少个岛屿。例如：<br>岛屿的高度为：{2, 1, 3, 2, 3}, 查询为：{0, 1, 3, 2}。<br>当海面高度为0时，所有的岛形成了1个岛屿。<br>当海面高度为1时，岛1会被淹没，总共有2个岛屿{2} {3, 2, 3}。<br>当海面高度为3时，所有岛都会被淹没，总共0个岛屿。<br>当海面高度为2时，岛0, 1, 3会被淹没，总共有2个岛屿{3} {3}。</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第1行：2个数N, Q中间用空格分隔，其中N为岛的数量，Q为查询的数量(1 &lt;= N, Q &lt;= 50000)。<br>第2 - N + 1行，每行1个数，对应N个岛屿的高度(1 &lt;= A[i] &lt;= 10^9)。<br>第N + 2 - N + Q + 1行，每行一个数，对应查询的海平面高度(1 &lt;= Q[i] &lt;= 10^9)。</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出共Q行，对应每个查询的岛屿数量。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 4</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">0</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>题意就是求大于某个数的区间个数，一开始往数据结构上想了。。但是维护啥完全没有思路啊</p>
<p>看了讨论区才有点明白0.0思维题，妙啊妙啊</p>
<p>就是要想到：对于121型的来说，如果顶峰2被淹了，那么岛屿数-1，对于212型的来说，如果底峰1被淹了，那么岛屿数+1</p>
<p>所以离线做，存好所有询问并从小到大排，记录所有岛屿的位置，然后按高低排序，对于某个岛屿，比较他左右两个岛屿即可，用一个vis[i]表示第i号岛屿有没有被淹，如果一个岛屿两边岛屿都被淹，那么淹了这个岛屿之后岛屿数减一，如果一个岛屿两边岛屿都没有被淹，那么淹了这个岛屿之后岛屿数加一，其他情况岛屿不变，注意最左和最右的两个需要特殊处理一下</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;5e4+5;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int h;</span><br><span class="line">    int pos;</span><br><span class="line">&#125;a[N],q[N];</span><br><span class="line">int res[N],vis[N];</span><br><span class="line">bool cmp(node n1,node n2)&#123;</span><br><span class="line">    return n1.h&lt;n2.h;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,qq;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;qq);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i].h);</span><br><span class="line">        a[i].pos&#x3D;i;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;0;i&lt;qq;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;q[i].h);</span><br><span class="line">        q[i].pos&#x3D;i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a,a+n,cmp);</span><br><span class="line">    sort(q,q+qq,cmp);</span><br><span class="line">    int cur&#x3D;0,ans&#x3D;1;</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    for(int i&#x3D;0;i&lt;qq;i++)&#123;</span><br><span class="line">        while(a[cur].h&lt;&#x3D;q[i].h&amp;&amp;cur&lt;n)&#123;</span><br><span class="line">            if(a[cur].pos&#x3D;&#x3D;0)&#123;</span><br><span class="line">                if(vis[1])ans--;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(a[cur].pos&#x3D;&#x3D;n-1)&#123;</span><br><span class="line">                if(vis[n-2])ans--;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(vis[a[cur].pos-1]&amp;&amp;vis[a[cur].pos+1])</span><br><span class="line">                    ans--;</span><br><span class="line">                else if((!vis[a[cur].pos-1])&amp;&amp;(!vis[a[cur].pos+1]))</span><br><span class="line">                    ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[a[cur].pos]&#x3D;1;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        res[q[i].pos]&#x3D;ans;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;0;i&lt;qq;i++)&#123;</span><br><span class="line">        printf(&quot;%d\n&quot;,res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>51nod 1272 最大距离（贪心）</title>
    <url>/79f86570/</url>
    <content><![CDATA[<p>1 秒  131,072 KB 20 分 3 级题</p>
<p>给出一个长度为N的整数数组A，对于每一个数组元素，如果他后面存在大于等于该元素的数，则这两个数可以组成一对。每个元素和自己也可以组成一对。例如：{5, 3, 6, 3, 4, 2}，可以组成11对，如下（数字为下标）：<br>(0,0), (0, 2), (1, 1), (1, 2), (1, 3), (1, 4), (2, 2), (3, 3), (3, 4), (4, 4), (5, 5)。其中(1, 4)是距离最大的一对，距离为3。</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第1行：1个数N，表示数组的长度(2 &lt;= N &lt;= 50000)。<br>第2 - N + 1行：每行1个数，对应数组元素Ai(1 &lt;= Ai &lt;= 10^9)。</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出最大距离。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>先记录一下每个数的位置pos，然后按照数字大小排序，大小相同的位置小的在前面，这样前面的数一定比后面的小，就可以O(n)扫一遍更新最大距离</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;5e4+5;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int v,pos;</span><br><span class="line">&#125;a[N];</span><br><span class="line">bool cmp(node n1,node n2)&#123;</span><br><span class="line">    return (n1.v&#x3D;&#x3D;n2.v)?n1.pos&lt;n2.pos:n1.v&lt;n2.v;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i].v);</span><br><span class="line">        a[i].pos&#x3D;i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a,a+n,cmp);</span><br><span class="line">    int cur&#x3D;n-1,ans&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        if(a[i].pos&lt;cur)cur&#x3D;a[i].pos;</span><br><span class="line">        else ans&#x3D;max(ans,a[i].pos-cur);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1270 数组的最大代价（dp）</title>
    <url>/30019b4a/</url>
    <content><![CDATA[<p>1 秒  131,072 KB 20 分 3 级题<br>数组A包含N个元素A1, A2……AN。数组B包含N个元素B1, B2……BN。并且数组A中的每一个元素Ai，都满足1 &lt;= Ai &lt;= Bi。数组A的代价定义如下：</p>
<a id="more"></a>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kog63rshj204601hglf.jpg" alt=""></p>
<p>（公式表示所有两个相邻元素的差的绝对值之和）<br>给出数组B，计算可能的最大代价S。</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第1行：1个数N，表示数组的长度(1 &lt;= N &lt;= 50000)。<br>第2 - N+1行：每行1个数，对应数组元素Bi(1 &lt;= Bi &lt;= 10000)。</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出最大代价S。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">10</span><br><span class="line">1</span><br><span class="line">10</span><br><span class="line">1</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">36</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>要使绝对值最大，a[i]要么取最小的1，要么取最大的b[i]，dp[i][0/1]分别表示取到第i个数，取1或者取b[i]</p>
<p>可以写出状态转移方程，总共四种情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][0]&#x3D;max(dp[i-1][0],dp[i-1][1]+b[i-1]-1);</span><br><span class="line">dp[i][1]&#x3D;max(dp[i-1][0]+b[i]-1,dp[i-1][1]+abs(b[i-1]-b[i]));</span><br></pre></td></tr></table></figure>

<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;5e4+5;</span><br><span class="line">int b[N],dp[N][2];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;b[i]);</span><br><span class="line">    dp[0][0]&#x3D;0;</span><br><span class="line">    int ans&#x3D;0;</span><br><span class="line">    for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">        dp[i][0]&#x3D;max(dp[i-1][0],dp[i-1][1]+b[i-1]-1);</span><br><span class="line">        dp[i][1]&#x3D;max(dp[i-1][0]+b[i]-1,dp[i-1][1]+abs(b[i-1]-b[i]));</span><br><span class="line">        ans&#x3D;max(dp[i][0],dp[i][1]);</span><br><span class="line">        &#x2F;&#x2F; cout&lt;&lt;ans&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1268 和为K的组合（bfs）</title>
    <url>/f2eae8bb/</url>
    <content><![CDATA[<p>1 秒  131,072 KB 20 分 3 级题</p>
<p>给出N个正整数组成的数组A，求能否从中选出若干个，使他们的和为K。如果可以，输出：”Yes”，否则输出”No”。</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第1行：2个数N, K, N为数组的长度, K为需要判断的和(2 &lt;= N &lt;= 20，1 &lt;= K &lt;= 10^9).<br>第2 - N + 1行：每行1个数，对应数组的元素A[i] (1 &lt;= A[i] &lt;= 10^6)</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>如果可以，输出：”Yes”，否则输出”No”。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 13</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>n=20，bfs</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;25;</span><br><span class="line">int a[N],n,k;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    vector&lt;int&gt; sum;</span><br><span class="line">    sum.push_back(0);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        int sz&#x3D;sum.size();</span><br><span class="line">        for(int j&#x3D;0;j&lt;sz;j++)&#123;</span><br><span class="line">            if(sum[j]+a[i]&#x3D;&#x3D;k)&#123;</span><br><span class="line">                puts(&quot;Yes&quot;);</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(sum[j]+a[i]&lt;k)&#123;</span><br><span class="line">                sum.push_back(sum[j]+a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;No&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1247 可能的路径（数论，思维）</title>
    <url>/ca5b30d3/</url>
    <content><![CDATA[<p>1 秒  131,072 KB 20 分 3 级题</p>
<p>在一个无限大的二维网格上，你站在(a,b)点上，下一步你可以移动到(a + b, b), (a, a + b), (a - b, b), 或者 (a, a - b)这4个点。<br>给出起点坐标(a,b)，以及终点坐标(x,y)，问你能否从起点移动到终点。如果可以，输出”Yes”，否则输出”No”。<br>例如：(1,1) 到 (2,3)，(1,1) -&gt; (2,1) -&gt; (2,3)。</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第1行：一个数T，表示输入的测试数量(1 &lt;= T &lt;= 5000)<br>第2 - T + 1行：每行4个数，a, b, x, y，中间用空格分隔(1 &lt;= a, b, x, y &lt;= 10^18)</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出共T行，每行对应1个结果，如果可以，输出”Yes”，否则输出”No”。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 1 2 3</span><br><span class="line">2 1 2 3</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>好难。。模拟出奇迹。。先乱走看看有没有什么可用的结论</p>
<p>如果<code>(a,b)-&gt;(a+b,b)</code>，那么有<code>(a+b,b)-&gt;(a,b)</code>.<br>如果<code>(a,b)-&gt;(a,a+b)</code>，那么有<code>(a,a+b)-&gt;(2a+b,a+b)-&gt;(2a+b,a)-&gt;(a+b,a)-&gt;(a+b,b)-&gt;(a,b)</code>.<br>如果<code>(a,b)-&gt;(a-b,b)</code>，那么有<code>(a-b,b)-&gt;(a,b)</code>.<br>如果<code>(a,b)-&gt;(a,a-b)</code>，那么有<code>(a,a-b)-&gt;(a,b)</code>.   </p>
<p>可以得到不管从哪走都可以回到原点(a,b)，所以可以推出结论一：“路径可逆”</p>
<p>如果<code>(a,b)-&gt;(a+b,b)-&gt;(a+b,a)-&gt;(b,a)</code>，所以可以推出结论二：“<code>(a,b)-&gt;(b,a)</code>可行”</p>
<p><code>(a,b)-&gt;(a+b,a)-&gt;(2a+b,a)-&gt;(3a+b,a)-&gt;...-&gt;(na+b,a)</code>即<code>(na+b,a)-&gt;...-&gt;(a,b)-&gt;...-&gt;(b,a)</code>，数论一下，也就是<code>(a,b)-&gt;...-&gt;(a%b,b)</code></p>
<p>同理，<code>(a,b)-&gt;(a,a+b)-&gt;(a,2a+b)-&gt;...-&gt;(a,na+b)</code>即<code>(a,na+b)-&gt;...-&gt;(a,b%a)</code></p>
<p>记<code>c=gcd(a,b)</code>，<code>(a,b)-&gt;(c,c)</code></p>
<p>所以最终如果<code>gcd(a,b)==gcd(x,y)</code>，那么就可达</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">LL gcd(LL a,LL b)&#123;</span><br><span class="line">    return b&#x3D;&#x3D;0?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        LL a,b,x,y;</span><br><span class="line">        scanf(&quot;%lld%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;x,&amp;y);</span><br><span class="line">        if(gcd(a,b)&#x3D;&#x3D;gcd(x,y))puts(&quot;Yes&quot;);</span><br><span class="line">        else puts(&quot;No&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1246 罐子和硬币（思维）</title>
    <url>/f82cf35b/</url>
    <content><![CDATA[<p>1 秒  131,072 KB 20 分 3 级题</p>
<p>有n个罐子，有k个硬币，每个罐子可以容纳任意数量的硬币。罐子是不透明的，你可以把这k个硬币任意分配到罐子里。然后罐子被打乱顺序，你从外表无法区别罐子。最后罐子被编上号1-n。每次你可以询问某个罐子，如果该罐子里有硬币，则你可以得到1个（但你不知道该罐子中还有多少硬币），如果该罐子是空的，你得不到任何硬币，但会消耗1次询问的机会。你最终要得到至少c枚硬币（c &lt;= k)，问题是给定n,k,c，由你来选择一种分配方式，使得在最坏情况下，询问的次数最少，求这个最少的次数。</p>
<p>例如：有3个罐子，10个硬币，需要得到7个硬币，(n = 3, k = 10, c = 7)。<br>你可以将硬币分配为：3 3 4，然后对于每个罐子询问2次，可以得到6个硬币，再随便询问一个罐子，就可以得到7个硬币了。</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>输入3个数：n,k,c (1 &lt;= n &lt;= 10^9, 1 &lt;= c &lt;= k &lt;= 10^9)。</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出最坏情况下所需的最少询问次数。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 2 2</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>一开始想分配策略没有思路，题也没咋读懂。。还是看讨论区去了。。</p>
<p>然后才明白题意是这样：虽然你不知道哪个罐子是哪个，但是你知道是怎么分配的，所以拿的时候也不是随机的是有策略的</p>
<p>比如考虑一种<code>k%n==0</code>的特殊情况，这时候每个罐子平均分到<code>k/n</code>个硬币，所以其实每个罐子都一样，相当于你知道每个罐子里有多少硬币，要多少拿多少就是了次数就是c</p>
<p>而一般情况下，无法实现所有硬币平均分配，有些罐子里的硬币不一样，就有可能会拿到空罐子，消耗次数</p>
<p>最少的询问次数，除了成功拿到硬币的c次之外，就是询问空罐子的次数</p>
<p>n个罐子，需要拿c个硬币，设一个变量x，如果每个罐子都能放x及x以上个，并且<code>n*x≥c</code>，那么每个罐子依次拿，最后可以在不询问空罐子的情况下拿到k个，所以就是倒过来求一下这个x</p>
<p>上面这个不等式可以得到<code>x&gt;(c-1)/n</code>，那么<code>x=(c-1)/n+1</code>，总共k个硬币，每个罐子x个最优，如果确实能装好x个，则不用询问空罐子，如果装不好，那么一部分瓶子还是装x个，另一部分空着，最差情况下所有空着或者可能拿空的瓶子都会被访问一次，然后剩下的直接依次取即可，此时空瓶子的个数为<code>n-k/x</code></p>
<p>所以综合一下答案就是<code>ans=c+max(0,n-k/((c-1)/n+1))</code>，机智O(1)</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,k,c;</span><br><span class="line">    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;k,&amp;c);</span><br><span class="line">    printf(&quot;%d\n&quot;,c+max(0,n-k&#x2F;((c-1)&#x2F;n+1)));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>51nod 1163 最高的奖励（贪心+优先队列）</title>
    <url>/58d4c007/</url>
    <content><![CDATA[<p>1 秒  131,072 KB 20 分 3 级题</p>
<p>有N个任务，每个任务有一个最晚结束时间以及一个对应的奖励。在结束时间之前完成该任务，就可以获得对应的奖励。完成每一个任务所需的时间都是1个单位时间。有时候完成所有任务是不可能的，因为时间上可能会有冲突，这需要你来取舍。求能够获得的最高奖励。</p>
<a id="more"></a>

<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第1行：一个数N，表示任务的数量(2 &lt;= N &lt;= 50000).<br>第2 - N + 1行，每行2个数，中间用空格分隔，表示任务的最晚结束时间E[i]以及对应的奖励W[i]。(1 &lt;= E[i] &lt;= 10^9，1 &lt;= W[i] &lt;= 10^9)</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出能够获得的最高奖励。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">4 20</span><br><span class="line">2 60</span><br><span class="line">4 70</span><br><span class="line">3 40</span><br><span class="line">1 30</span><br><span class="line">4 50</span><br><span class="line">6 10</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">230</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>完成一个任务需要一单位时间，所以就把所有任务按时间排序，每次把当前权值存入一个优先队列，如果没有冲突（当前入队的大小和a[i].e比较），那么就更新ans，如果冲突，就抛弃当前最小的</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;5e4+5;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int e,w;</span><br><span class="line">&#125;a[N];</span><br><span class="line">bool cmp(node n1,node n2)&#123;</span><br><span class="line">    return n1.e&#x3D;&#x3D;n2.e?n1.w&gt;n2.w:n1.e&lt;n2.e;</span><br><span class="line">&#125;</span><br><span class="line">LL ans&#x3D;0;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d%d&quot;,&amp;a[i].e,&amp;a[i].w);</span><br><span class="line">    sort(a,a+n,cmp);</span><br><span class="line">    priority_queue&lt;int,vector&lt;int &gt;,greater&lt;int&gt; &gt;pq;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        if(a[i].e&gt;pq.size())&#123;</span><br><span class="line">            ans+&#x3D;a[i].w;</span><br><span class="line">            pq.push(a[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            ans+&#x3D;a[i].w;</span><br><span class="line">            pq.push(a[i].w);</span><br><span class="line">            ans-&#x3D;pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1127 最短的包含字符串（尺取法）</title>
    <url>/646ba6e2/</url>
    <content><![CDATA[<p>1 秒  131,072 KB 20 分 3 级题</p>
<p>给出一个字符串，求该字符串的一个子串s，s包含A-Z中的全部字母，并且s是所有符合条件的子串中最短的，输出s的长度。如果给出的字符串中并不包括A-Z中的全部字母，则输出No Solution。</p>
<a id="more"></a>

<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第1行，1个字符串。字符串的长度 &lt;= 100000。</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出包含A-Z的最短子串s的长度。如果没有符合条件的子串，则输出No Solution。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BVCABCDEFFGHIJKLMMNOPQRSTUVWXZYZZ</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">28</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>设置两个游标l,r，判断[l,r]是否包含26个字母，枚举r，向右移动l，然后不断更新最小答案，感觉和以前做的一个扩圈缩圈的题很像 -&gt; <a href="https://leflacon.github.io/fa5f812b" target="_blank" rel="noopener">CTU 2017 G.Ice cream samples（乱搞一通）</a></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF&#x3D;0x3f3f3f3f;</span><br><span class="line">int a[26];</span><br><span class="line">string s;</span><br><span class="line">bool ok()&#123;</span><br><span class="line">    for(int i&#x3D;0;i&lt;26;i++)</span><br><span class="line">        if(a[i]&#x3D;&#x3D;0)return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    memset(a,0,sizeof(a));</span><br><span class="line">    int n&#x3D;s.length(),l&#x3D;0,ans&#x3D;INF;</span><br><span class="line">    for(int r&#x3D;0;r&lt;n;r++)&#123;</span><br><span class="line">        a[(int)(s[r]-&#39;A&#39;)]++;</span><br><span class="line">        while(ok())&#123;</span><br><span class="line">            ans&#x3D;min(r-l+1,ans);</span><br><span class="line">            a[(int)(s[l]-&#39;A&#39;)]--;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ans&#x3D;&#x3D;INF)puts(&quot;No Solution&quot;);</span><br><span class="line">    else printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1117 聪明的木匠（贪心+优先队列）</title>
    <url>/3d674689/</url>
    <content><![CDATA[<p>1 秒  131,072 KB 20 分 3 级题</p>
<p>一位老木匠需要将一根长的木棒切成N段。每段的长度分别为L1,L2,……,LN（1 &lt;= L1,L2,…,LN &lt;= 1000，且均为整数）个长度单位。我们认为切割时仅在整数点处切且没有木材损失。<br>木匠发现，每一次切割花费的体力与该木棒的长度成正比，不妨设切割长度为1的木棒花费1单位体力。例如：若N=3，L1 = 3,L2 = 4,L3 = 5，则木棒原长为12，木匠可以有多种切法，如：先将12切成3+9.，花费12体力，再将9切成4+5，花费9体力，一共花费21体力；还可以先将12切成4+8，花费12体力，再将8切成3+5，花费8体力，一共花费20体力。显然，后者比前者更省体力。<br>那么，木匠至少要花费多少体力才能完成切割任务呢？</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第1行：1个整数N(2 &lt;= N &lt;= 50000)<br>第2 - N + 1行：每行1个整数Li(1 &lt;= Li &lt;= 1000)。</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出最小的体力消耗。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">19</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>贪心，每次选取最小的两个结合</p>
<p>可以用优先队列实现</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,c,ans&#x3D;0;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    priority_queue&lt;int,vector&lt;int &gt;,greater&lt;int&gt; &gt;pq;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;c);</span><br><span class="line">        pq.push(c);</span><br><span class="line">    &#125;</span><br><span class="line">    while(pq.size()!&#x3D;1)&#123;</span><br><span class="line">        int a&#x3D;pq.top();pq.pop();</span><br><span class="line">        int b&#x3D;pq.top();pq.pop();</span><br><span class="line">        pq.push(a+b);</span><br><span class="line">        ans+&#x3D;(a+b);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1116 K进制下的大数（数论）</title>
    <url>/f2e82f72/</url>
    <content><![CDATA[<p>1 秒  131,072 KB 20 分 3 级题</p>
<p>有一个字符串S，记录了一个大数，但不知这个大数是多少进制的，只知道这个数在K进制下是K - 1的倍数。现在由你来求出这个最小的进制K。<br>例如：给出的数是A1A，有A则最少也是11进制，然后发现A1A在22进制下等于4872,4872 mod 21 = 0，并且22是最小的，因此输出k = 22(大数的表示中A对应10，Z对应35)。</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>输入大数对应的字符串S。S的长度小于10^5。</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出对应的进制K，如果在2 - 36范围内没有找到对应的解，则输出No Solution。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A1A</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">22</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>这个数记为x，因为是个k进制数，所以可表示为如下多项式：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4koeghmuqj20ci00yq2u.jpg" alt=""></p>
<p>化简成这样就可以发现，x满足的条件是k-1整除x的数位和</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4koegfk9jj204p00ywea.jpg" alt=""></p>
<p>枚举k即可</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    int b&#x3D;2,sum&#x3D;0,tmp;</span><br><span class="line">    for(int i&#x3D;0;i&lt;s.length();i++)&#123;</span><br><span class="line">        if(s[i]&gt;&#x3D;&#39;0&#39;&amp;&amp;s[i]&lt;&#x3D;&#39;9&#39;)</span><br><span class="line">            tmp&#x3D;(int)(s[i]-&#39;0&#39;);</span><br><span class="line">        else</span><br><span class="line">            tmp&#x3D;(int)(s[i]-&#39;A&#39;+10);</span><br><span class="line">        sum+&#x3D;tmp;</span><br><span class="line">        if(tmp+1&gt;b)b&#x3D;tmp+1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int k&#x3D;b;k&lt;&#x3D;36;k++)&#123;</span><br><span class="line">        if(sum%(k-1)&#x3D;&#x3D;0)&#123;</span><br><span class="line">            printf(&quot;%d\n&quot;,k);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;No Solution&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1101 换零钱（dp）</title>
    <url>/13d6a7d/</url>
    <content><![CDATA[<p>1 秒  131,072 KB 20 分 3 级题</p>
<p>N元钱换为零钱，有多少不同的换法？币值包括1 2 5分，1 2 5角，1 2 5 10 20 50 100元。<br>例如：5分钱换为零钱，有以下4种换法：<br>1、5个1分<br>2、1个2分3个1分<br>3、2个2分1个1分<br>4、1个5分<br>(由于结果可能会很大，输出Mod 10^9 + 7的结果)</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>输入1个数N，N = 100表示1元钱。(1 &lt;= N &lt;= 100000)</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出Mod 10^9 + 7的结果</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>先统一一下单位，有1，2，5，10，20，50，100，200，500，1000，2000，5000，10000分，即记为数组a[i]</p>
<p>dp[j]表示j分钱的方法，那么状态转移方程是：<code>dp[j]=∑dp[j-a[i]]</code>，求出用某种面值能得到的<code>1～n</code>的钱的方法数，如果倒过来求的话就会出现重复，比如<code>1+2/2+1</code></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;1e5+5;</span><br><span class="line">const int p&#x3D;1e9+7;</span><br><span class="line">int a[13]&#x3D;&#123;1,2,5,10,20,50,100,200,500,1000,2000,5000,10000&#125;;</span><br><span class="line">int dp[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    memset(dp,0,sizeof(dp));</span><br><span class="line">    dp[0]&#x3D;1;</span><br><span class="line">    for(int i&#x3D;0;i&lt;13;i++)&#123;</span><br><span class="line">        for(int j&#x3D;a[i];j&lt;&#x3D;n;j++)&#123;</span><br><span class="line">            dp[j]&#x3D;(dp[j]+dp[j-a[i]])%p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,dp[n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1100 斜率最大（思维）</title>
    <url>/e9237fc5/</url>
    <content><![CDATA[<p>1 秒  131,072 KB 20 分 3 级题</p>
<p>平面上有N个点，任意2个点确定一条直线，求出所有这些直线中，斜率最大的那条直线所通过的两个点。</p>
<a id="more"></a>

<p>（点的编号为1-N，如果有多条直线斜率相等，则输出所有结果，按照点的X轴坐标排序，正序输出。数据中所有点的X轴坐标均不相等，且点坐标为随机。）</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第1行，一个数N，N为点的数量。(2 &lt;= N &lt;= 10000)<br>第2 - N + 1行：具体N个点的坐标，X Y均为整数(-10^9 &lt;= X,Y &lt;= 10^9)</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>每行2个数，中间用空格分隔。分别是起点编号和终点编号（起点的X轴坐标 &lt; 终点的X轴坐标）</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2</span><br><span class="line">6 8</span><br><span class="line">4 4</span><br><span class="line">5 4</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 2</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>纸上模拟一下</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4koeybmknj209t08idfu.jpg" alt=""></p>
<p>可以发现，如果有x1&lt;x2&lt;x3，对应三个点p1p2p3，那么最大斜率一定不会是p1p3的连线，如果不是三点共线的情况，如果存在一条p1p2斜率小于p1p3，那么一定会有p2p3斜率大于p1p3，反之同理</p>
<p>所以只需要把所有点按照x轴排个序，比较所有相邻点对的斜率即可</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;1e5+5;</span><br><span class="line">const int INF&#x3D;0x3f3f3f3f;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x,y;</span><br><span class="line">    int id;</span><br><span class="line">&#125;a[N];</span><br><span class="line">bool cmp(node a1,node a2)&#123;</span><br><span class="line">    return a1.x&lt;a2.x;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;a[i].x,&amp;a[i].y);</span><br><span class="line">        a[i].id&#x3D;i+1;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a,a+n,cmp);</span><br><span class="line">    double ans&#x3D;(double)-INF,tmp;</span><br><span class="line">    int cur;</span><br><span class="line">    for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">        tmp&#x3D;(double)(a[i].y-a[i-1].y)&#x2F;(a[i].x-a[i-1].x);</span><br><span class="line">        if(tmp&gt;ans)&#123;</span><br><span class="line">            ans&#x3D;tmp;</span><br><span class="line">            cur&#x3D;i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d %d\n&quot;,a[cur-1].id,a[cur].id);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1099 任务执行顺序（贪心，思维）</title>
    <url>/69cd4ee/</url>
    <content><![CDATA[<p>1 秒  131,072 KB 20 分 3 级题</p>
<p>有N个任务需要执行，第i个任务计算时占R[i]个空间，而后会释放一部分，最后储存计算结果需要占据O[i]个空间（O[i] &lt; R[i]）。</p>
<a id="more"></a>

<p>例如：执行需要5个空间，最后储存需要2个空间。给出N个任务执行和存储所需的空间，问执行所有任务最少需要多少空间。</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第1行：1个数N，表示任务的数量。（2 &lt;= N &lt;= 100000)<br>第2 - N + 1行：每行2个数R[i]和O[i]，分别为执行所需的空间和存储所需的空间。(1 &lt;= O[i] &lt; R[i] &lt;= 10000)</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出执行所有任务所需要的最少空间。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20</span><br><span class="line">14 1</span><br><span class="line">2 1</span><br><span class="line">11 3</span><br><span class="line">20 4</span><br><span class="line">7 5</span><br><span class="line">6 5</span><br><span class="line">20 7</span><br><span class="line">19 8</span><br><span class="line">9 4</span><br><span class="line">20 10</span><br><span class="line">18 11</span><br><span class="line">12 6</span><br><span class="line">13 12</span><br><span class="line">14 9</span><br><span class="line">15 2</span><br><span class="line">16 15</span><br><span class="line">17 15</span><br><span class="line">19 13</span><br><span class="line">20 2</span><br><span class="line">20 1</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">135</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>我一开始想的是综合考虑，无论如何，最终占据的空间一定是∑o[i]，所以优先考虑那些任务执行空间大的先执行，执行空间相同的则存储空间小的优先，然后模拟一遍求得最大值</p>
<p>但是只过了一部分数据</p>
<p>换个思路，其实这个题和 <a href="https://leflacon.github.io/5bde1263" target="_blank" rel="noopener">51nod 1097 拼成最小的数（贪心）</a> 的思路是一样的，要排序只需要考虑两个任务的先后顺序，如果<code>a1.o+a2.r&lt;a1.r+a2.o</code>，那么就先执行a1</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;1e5+5;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int r,o;</span><br><span class="line">&#125;a[N];</span><br><span class="line">bool cmp(node a1,node a2)&#123;</span><br><span class="line">    return a1.o+a2.r&lt;a1.r+a2.o;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d%d&quot;,&amp;a[i].r,&amp;a[i].o);</span><br><span class="line">    sort(a,a+n,cmp);</span><br><span class="line">    int ans&#x3D;0,tmp&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        ans&#x3D;max(ans,tmp+a[i].r);</span><br><span class="line">        tmp+&#x3D;a[i].o;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1098 最小方差（前缀和）</title>
    <url>/493cd694/</url>
    <content><![CDATA[<p>1 秒  131,072 KB 20 分 3 级题</p>
<p>若x1,x2,x3……xn的平均数为k。<br>则方差<code>s^2 = 1/n * [(x1-k)^2+(x2-k)^2+.......+(xn-k)^2]</code><br>方差即偏离平方的均值，称为标准差或均方差，方差描述波动程度。<br>给出M个数，从中找出N个数，使这N个数方差最小。</p>
<a id="more"></a>

<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第1行：2个数M,N，(M &gt; N, M &lt;= 10000)<br>第2 - M + 1行：M个数的具体值(0 &lt;= Xi &lt;= 10000)</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出最小方差 * N的整数部分。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>因为方差反应的一个数据波动大小，所以肯定要先排个序</p>
<p>先展开</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s^2&#x3D;1&#x2F;n*[(x1-k)^2+(x2-k)^2+...+(xn-k)^2]</span><br><span class="line">&#x3D;1&#x2F;n*[(x1^2+...+xn^2)-2*k*(x1+...+xn)+n*k^2]</span><br><span class="line"></span><br><span class="line">代入k&#x3D;(x1+...+xn)&#x2F;n得</span><br><span class="line"></span><br><span class="line">s^2&#x3D;1&#x2F;n*[(x1^2+...+xn^2)-2&#x2F;n*(x1+...+xn)^2+1&#x2F;n*(x1+...xn)^2]</span><br><span class="line">&#x3D;1&#x2F;n*[(x1^2+...+xn^2)-1&#x2F;n*(x1+...+xn)^2]</span><br></pre></td></tr></table></figure>

<p>所以就是利用前缀和直接求</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;10005;</span><br><span class="line">const LL INF&#x3D;1e15;</span><br><span class="line">LL a[N],sum[N],pow_sum[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%lld&quot;,&amp;a[i]);</span><br><span class="line">    sort(a,a+n);</span><br><span class="line">    sum[0]&#x3D;pow_sum[0]&#x3D;0;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        sum[i]&#x3D;sum[i-1]+a[i-1];</span><br><span class="line">        pow_sum[i]&#x3D;pow_sum[i-1]+a[i-1]*a[i-1];</span><br><span class="line">    &#125;</span><br><span class="line">    double ans&#x3D;(double)INF,tmp&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i+m&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        tmp&#x3D;pow_sum[i+m]-pow_sum[i]-(double)(sum[i+m]-sum[i])*(sum[i+m]-sum[i])&#x2F;m;</span><br><span class="line">        ans&#x3D;min(tmp,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld&quot;,(LL)ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1097 拼成最小的数（贪心）</title>
    <url>/5bde1263/</url>
    <content><![CDATA[<p>1 秒  131,072 KB 20 分 3 级题</p>
<p>设有n个正整数，将它们联接成一排，组成一个最小的多位整数。</p>
<a id="more"></a>

<p>例如：<br>n=2时，2个整数32，321连接成的最小整数为：32132，<br>n=4时，4个整数55，31，312, 33 联接成的最小整数为：312313355</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第1行：1个数N。(2 &lt;= N &lt;= 10000)<br>第2 - N + 1行：每行1个正整数。(1 &lt;= A[i] &lt;= 10^9)</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出拼在一起的最小整数。由于数据量太大，请以1000个字符为单位，输出到一行里，最终剩余的不足1000个字符的部分，输出到单独1行。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">55</span><br><span class="line">31</span><br><span class="line">312</span><br><span class="line">33</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">312313355</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>贪心排个序 只要<code>a1+a2&lt;a2+a1</code>那么a1就排在前面</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;10005;</span><br><span class="line">string a[N];</span><br><span class="line">bool cmp(string a1,string a2)&#123;</span><br><span class="line">    return a1+a2&lt;a2+a1;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    sort(a,a+n,cmp);</span><br><span class="line">    int num&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        for(int j&#x3D;0;j&lt;a[i].length();j++)&#123;</span><br><span class="line">            printf(&quot;%c&quot;,a[i][j]);</span><br><span class="line">            num++;</span><br><span class="line">            if(num&#x3D;&#x3D;1000)&#123;</span><br><span class="line">                printf(&quot;\n&quot;);</span><br><span class="line">                num&#x3D;0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1096 距离之和最小</title>
    <url>/6f2824be/</url>
    <content><![CDATA[<p>1 秒  131,072 KB 20 分 3 级题</p>
<p>X轴上有N个点，求X轴上一点使它到这N个点的距离之和最小，输出这个最小的距离之和。</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第1行：点的数量N。(2 &lt;= N &lt;= 10000)</p>
<p>第2 - N + 1行：点的位置。（-10^9 &lt;= P[i] &lt;= 10^9)</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出最小距离之和</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">-1</span><br><span class="line">-3</span><br><span class="line">0</span><br><span class="line">7</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>因为找到某个点num之后，值就是∑abs(a[i]-num)，所以num就是中位数</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;10005;</span><br><span class="line">LL a[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%lld&quot;,&amp;a[i]);</span><br><span class="line">    sort(a,a+n);</span><br><span class="line">    LL num;</span><br><span class="line">    if(n&amp;1)num&#x3D;a[n&#x2F;2];</span><br><span class="line">    else num&#x3D;a[n&#x2F;2-1];</span><br><span class="line">    LL ans&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)ans+&#x3D;abs(a[i]-num);</span><br><span class="line">    printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>51nod 1065 最小正子段和（前缀和，思维）</title>
    <url>/669e1786/</url>
    <content><![CDATA[<p>1 秒  131,072 KB 20 分 3 级题</p>
<p>N个整数组成的序列a[1],a[2],a[3],…,a[n]，从中选出一个子序列（a[i],a[i+1],…a[j]），使这个子序列的和&gt;0，并且这个和是所有和&gt;0的子序列中最小的。</p>
<p>例如：4，-1，5，-2，-1，2，6，-2。-1，5，-2，-1，序列和为1，是最小的。</p>
<a id="more"></a>

<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第1行：整数序列的长度N（2 &lt;= N &lt;= 50000)</p>
<p>第2 - N+1行：N个整数</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出最小正子段和。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">4</span><br><span class="line">-1</span><br><span class="line">5</span><br><span class="line">-2</span><br><span class="line">-1</span><br><span class="line">2</span><br><span class="line">6</span><br><span class="line">-2</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>最小正子段和，一开始以为是跟最小子段和一样的水水的dp，然而并不是，结果相互有影响的，所以从暴力开始想</p>
<p>先来个前缀和，接着如果直接枚举[i,j]区间的话是O(n^2)的，可以通过排序优化到O(nlogn)</p>
<p>思路是：记录一下前缀和初始位置pos，然后按前缀和大小从小到大排序，排好之后，对于某个i来说，如果<code>pos[i]&lt;pos[i+1]</code>那么这两个前缀和中间就存在一个子段和，O(n)扫一遍即可</p>
<p>证明为什么只需要考虑i和i+1个：假设排好序的三个前缀和分别是ABC，也就是<code>A.sum&lt;B.sum&lt;C.sum</code>，如果<code>A.pos&lt;B.pos</code>，那么AB可以组合，之中存在一个正子段和，那么就不需要考虑C了，因为AB的组合一定优于AC；如果<code>A.pos&gt;B.pos</code>，即AB不能组合，那么如果BC可以组合，BC一定优于AC，也无需考虑AC</p>
<p>所以排完序之后只需要考虑相邻的两个</p>
<p>之前wa了一次，因为没有考虑两个前缀和相等的情况，这时候答案会出现错误的0，要排除这种情况</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const LL INF&#x3D;0x3f3f3f3f;</span><br><span class="line">const int N&#x3D;50005;</span><br><span class="line">LL a[N];</span><br><span class="line">struct node&#123;</span><br><span class="line">	LL s;</span><br><span class="line">	int pos;</span><br><span class="line">&#125;sum[N];</span><br><span class="line">bool cmp(node n1,node n2)&#123;</span><br><span class="line">	return n1.s&lt;n2.s;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    sum[0].s&#x3D;0;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">    	scanf(&quot;%lld&quot;,&amp;a[i]);</span><br><span class="line">    	sum[i].s&#x3D;sum[i-1].s+a[i];</span><br><span class="line">    	sum[i].pos&#x3D;i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(sum+1,sum+n+1,cmp);</span><br><span class="line">    LL ans&#x3D;INF;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">    	&#x2F;&#x2F; cout&lt;&lt;sum[i].s&lt;&lt;&quot; &quot;;</span><br><span class="line">    	if(sum[i].s&gt;0)</span><br><span class="line">    		ans&#x3D;min(ans,sum[i].s);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">    	if(sum[i].pos&lt;sum[i+1].pos&amp;&amp;sum[i].s!&#x3D;sum[i+1].s)&#123;</span><br><span class="line">    		ans&#x3D;min(ans,sum[i+1].s-sum[i].s);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1035 最长的循环节（循环小数定理）</title>
    <url>/4d078eb9/</url>
    <content><![CDATA[<p>正整数k的倒数1/k，写为10进制的小数如果为无限循环小数，则存在一个循环节，求&lt;=n的数中，倒数循环节长度最长的那个数，假如存在多个最优的答案，输出所有答案中最大的那个数。</p>
<p>1/6= 0.1(6) 循环节长度为1.<br>1/7= 0.(142857) 循环节长度为6.<br>1/9= 0.(1)  循环节长度为1.  </p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>输入n（10 &lt;= n &lt;= 1000)</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出&lt;=n的数中倒数循环节长度最长的那个数</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>需要用到一个关于循环小数的定理</p>
<p>「定理1」：如果<code>1≤b&lt;a</code>，a没有2或5的质因数，并且a与b互质，那么b/a的循环节位数恰好等于：<code>min{e ∈ N:10^e≡1(mod a)}</code></p>
<p>所以最大循环节长度就是<code>≤n</code>的数所能求得的最大的e，对于那些包含2或5因子的数，把2或5除掉即可</p>
<p>证明见这篇 -&gt; <a href="https://leflacon.github.io/9ad49ad6" target="_blank" rel="noopener">循环小数及其位数的有趣性质及详细定理证明</a></p>
<p>「定理2」：如果<code>1≤b&lt;a</code>，a没有2或5的质因数，并且a与b互质，那么b/a的循环节位数必整除<code>φ(a)</code></p>
<p>还可以利用定理二继续优化，因为求出的e必整除<code>φ(a)</code>，所以根据欧拉函数枚举e也可</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n,ans&#x3D;0,res&#x3D;1;</span><br><span class="line">int get(int x)&#123;</span><br><span class="line">	int tmp&#x3D;10%x,e&#x3D;1;</span><br><span class="line">	while(tmp!&#x3D;1)&#123;</span><br><span class="line">		tmp&#x3D;(tmp*10)%x;</span><br><span class="line">		e++;</span><br><span class="line">	&#125;</span><br><span class="line">	return e;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		int a&#x3D;i;</span><br><span class="line">		while(a%2&#x3D;&#x3D;0)a&#x2F;&#x3D;2;</span><br><span class="line">		while(a%5&#x3D;&#x3D;0)a&#x2F;&#x3D;5;</span><br><span class="line">		if(a!&#x3D;1)&#123;</span><br><span class="line">			int e&#x3D;get(a);</span><br><span class="line">			if(e&gt;ans)&#123;</span><br><span class="line">				ans&#x3D;e;</span><br><span class="line">				res&#x3D;i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d\n&quot;,res);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>循环小数及其位数的有趣性质及详细定理证明</title>
    <url>/9ad49ad6/</url>
    <content><![CDATA[<p>最近什么都学不进去。。明明有很多事要干但是又什么都不想干。。Σ（ﾟдﾟlll）！是焦虑的感觉！所以不如学论文好了。。要是学不会就会更焦虑，然后就真的更焦虑了。。</p>
<hr>
<p>学一篇有关循环小数的一些性质的论文，我不知道循环节那个点应该如何打出来，太麻烦了，所以下文小数括号里的部分表示循环节</p>
<a id="more"></a>

<h1 id="1-分数和循环小数的互化"><a href="#1-分数和循环小数的互化" class="headerlink" title="1.分数和循环小数的互化"></a>1.分数和循环小数的互化</h1><p>如果是分数化成循环小数就是小学除法，如果是循环小数化成分数就是解方程，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#x2F;7&#x3D;0.(142857)</span><br><span class="line"></span><br><span class="line">x&#x3D;0.(142857)</span><br><span class="line">1000000x&#x3D;142857+x</span><br><span class="line">999999x&#x3D;142857</span><br><span class="line">x&#x3D;1&#x2F;7</span><br></pre></td></tr></table></figure>

<h1 id="2-一个奇妙的性质"><a href="#2-一个奇妙的性质" class="headerlink" title="2.一个奇妙的性质"></a>2.一个奇妙的性质</h1><p>观察以下几个循环节位数为偶数的数，假设循环节长度为2n，那么可以发现，前后分成两段，第k个数和第k+n个数的和永远等于9！？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#x2F;7&#x3D;0.(142 857)</span><br><span class="line">1&#x2F;13&#x3D;0.(076 923)</span><br><span class="line">1&#x2F;17&#x3D;0.(0588 2352 9411 7647)</span><br><span class="line">1&#x2F;73&#x3D;0.(0136 9863)</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kod7469bj205i05i0sr.jpg" alt=""></p>
<p>上面的性质不是偶然，而是必然，下文将通过一些数论知识证明</p>
<h1 id="3-定理1"><a href="#3-定理1" class="headerlink" title="3.定理1"></a>3.定理1</h1><h2 id="3-1-定理1的提出"><a href="#3-1-定理1的提出" class="headerlink" title="3.1.定理1的提出"></a>3.1.定理1的提出</h2><p>同余的概念是：如果n可以整除(a-b)，那么在模n下，a与b同余，比如，<code>(5-(-2))/7=1</code>，<code>5≡−2(mod 7)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#x2F;97 &#x3D; 0.(0103 0927 8350 5154 6391</span><br><span class="line">7525 7731 9587 6288 6597</span><br><span class="line">9381 4432 9896 9072 1649</span><br><span class="line">4845 3608 2474 2268 0412</span><br><span class="line">3711 3402 0618 5567)</span><br></pre></td></tr></table></figure>

<p>对于上面这样一个96位循环节的数：97是质数，96是位数，那么96可以整除(97-1)</p>
<p>抛出如下结论，<font size="3" color=#5959ff>「定理0」：如果p是质数，q是<code>1/p</code>的循环节的位数，那么q可以整除(p-1)</font></p>
<p>更一般的，有<font size="3" color=#5959ff>「定理1」：如果<code>1≤b&lt;a</code>，a没有2或5的质因数，并且a与b互质，那么b/a的循环节位数恰好等于：<code>min{e ∈ N:10^e≡1(mod a)}</code></font></p>
<p>例如，<code>10^6≡1(mod 91)</code>，因此<code>69/91</code>的循环节位数必定<code>≤6</code>，那么如果已经检查过<code>e=1,2,3,4,5</code>的情况并且<code>10^e</code>和1在模91下不同余，那么就可以确定<code>69/91</code>恰好有六位循环节</p>
<p>那么如果碰到一个a包含了2或5的因数该如何处理呢？</p>
<p>比如<code>489/235</code>，把分母中2或5的因数提出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">489&#x2F;235&#x3D;489&#x2F;(5*47)&#x3D;(2*489)&#x2F;(10*47)&#x3D;(1&#x2F;10)*(978&#x2F;47)&#x3D;(1&#x2F;10)*(20+38&#x2F;47)</span><br><span class="line"></span><br><span class="line">由此转换可知，489&#x2F;235的循环节和38&#x2F;47是一样的</span><br></pre></td></tr></table></figure>

<h2 id="3-2-定理1的证明"><a href="#3-2-定理1的证明" class="headerlink" title="3.2.定理1的证明"></a>3.2.定理1的证明</h2><p>现在来证明定理1：</p>
<p>设<code>d=min{e ∈ N:10^e≡1(mod a)}</code>，如果a/b有r位的循环节，即<code>b/a=0.s1s2...sk(c1c2...cr)</code>，按照第一点小数转分数的方法，两边同时乘以<code>10^r</code>，然后移项会得到<code>(10^r-1)b/a=(10^r)*(0.s1s2...sk)</code>，两边再同时乘以<code>10^s</code>，可以得到<code>(10^s)*(10^r-1)b/a</code>必定是个正整数，那么就存在一个m，使<code>10^s(10^r−1)b=am</code>成立</p>
<p>因为ab互质，a与10也互质，那么由这个式子得a一定可以整除<code>10^r-1</code>，也就是<code>10^r≡1(mod a)</code>，那么根据一开始假设的关于d的定义，可知<code>d≤r</code></p>
<p>另一方面，由d的定义又可得：a整除<code>10^d-1</code>，所以a整除<code>b(10^d-1)</code>，那么存在一个q，使<code>(10^d−1)b=aq</code>成立，移项得：<code>10^d*b=aq+b</code></p>
<p>因为<code>1≤b&lt;a</code>，所以b是<code>10^d*b/a</code>的余数，b是整数，可知<code>d≥循环节位数r</code>（这里论文里的符号应该是写反了，我就擅自修改了，如果我的理解没错的话）</p>
<p>综上所述，<code>d≤r，d≥r</code>，那么d=r，即循环节位数等于：<code>min{e ∈ N:10^e≡1(mod a)}</code></p>
<h1 id="4-定理2"><a href="#4-定理2" class="headerlink" title="4.定理2"></a>4.定理2</h1><p><font size="3" color=#5959ff>「定理2」：如果<code>1≤b&lt;a</code>，a没有2或5的质因数，并且a与b互质，那么b/a的循环节位数必整除<code>φ(a)</code></font></p>
<p>这里的<code>φ(a)</code>是欧拉函数</p>
<p>证明利用欧拉定理：(下图是论文中的证明，就一句话。。什么乘法群的秩我太菜了一时半会儿没有领会0.0)</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kod77nd6j208003174f.jpg" alt=""></p>
<blockquote>
<p>欧拉函数<code>φ(n)</code>是小于或等于n的正整数中与n互质的数的数目</p>
<p>欧拉定理：若n,a为正整数，且n,a互素（即gcd(a,n)=1），则<code>a^φ(n)≡1(mod n)</code></p>
</blockquote>
<p>证明如下：</p>
<p>因为由定理1已知循环节位数等于：<code>d=min{e ∈ N:10^e≡1(mod a)}</code>，即<code>10^d≡1(mod a)</code>，且d是满足这个式子的最小值，由欧拉定理，因为10与a互质，所以有<code>10^φ(a)≡1(mod a)</code>，所以d整除<code>φ(a)</code>成立</p>
<h1 id="5-定理3"><a href="#5-定理3" class="headerlink" title="5.定理3"></a>5.定理3</h1><p><font size="3" color=#5959ff>「定理3」：如果<code>n,m≥3</code>，2与5都不整除mn，并且n与m是互质的正整數,则<code>1/mn</code>的循环小数位数是<code>1/m</code>与<code>1/n</code>循环小数位数的最小公倍数</font></p>
<p>论文里又是一句话证明。。头秃</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kod740ngj208101jdfr.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kodnnssvj203c02zglf.jpg" alt=""></p>
<p>证明：</p>
<p>首先<code>1/m</code>的循环小数位数就是<code>n/m</code>的循环小数位数，同理<code>1/n</code>的循环小数位数就是<code>m/n</code>的循环小数位数，由定理1可知<code>1/m</code>的循环小数位数是<code>e1=min{e ∈ N:10^e≡1(mod m)}</code>，同理有<code>1/n</code>的循环小数位数是<code>e2=min{e ∈ N:10^e≡1(mod n)}</code>，<code>1/mn</code>的循环小数位数是<code>e3=min{e ∈ N:10^e≡1(mod mn)}</code></p>
<p>然后要证e3是e1与e2的最小公倍数，不会证了不想证了。。先放着吧mark</p>
<h1 id="6-Artin猜想"><a href="#6-Artin猜想" class="headerlink" title="6.Artin猜想"></a>6.Artin猜想</h1><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kodnpbhcj20fg07oabe.jpg" alt=""></p>
<p>由表可以发现，<code>1/p</code>的循环节位数恰好是<code>p−1</code>的质数很多，例如，p=7,17,19,23,29,47,59,61……</p>
<p>oeis上收录了这个数列：<a href="http://oeis.org/search?q=7%2C17%2C19%2C23%2C29%2C47%2C59%2C61&amp;language=english&amp;go=Search" target="_blank" rel="noopener">http://oeis.org/search?q=7%2C17%2C19%2C23%2C29%2C47%2C59%2C61&amp;language=english&amp;go=Search</a></p>
<p>Artin猜想：是不是有无穷多的质数p使得1/p的循环节恰有p−1位?这种质数的数目能否有个比较精确的估计?</p>
<p>结论与证明如下：</p>
<p>设p是奇质数，如果<code>1/p</code>有d位循环节，利用定理1可以证明：<code>1/p^2</code>的循环节位数是d或者dp，同理，若<code>1/p^n</code>的循环节位数是<code>dp^m(0≤m&lt;n)</code>，则<code>1/p^(n+1)</code>的循环节位数是<code>dp^m</code>或<code>dp^(m+1)</code></p>
<h1 id="7-证明和为9的奇妙性质"><a href="#7-证明和为9的奇妙性质" class="headerlink" title="7.证明和为9的奇妙性质"></a>7.证明和为9的奇妙性质</h1><p>回到第二点的那个奇妙的性质：假设循环节长度为2n，前后分成两段，第k个数和第k+n个数的和永远等于9</p>
<p>证明如下：（好像没有很严谨的证明，但是论文里的大致就是这个意思，意会意会( ? _ ? )）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">比如24&#x2F;91，10^6≡1(mod 91)，10^3≡−1(mod 91)，</span><br><span class="line">91整除(10^3+1), 91也整除24*(10^3+1)&#x3D;24+24000</span><br><span class="line"></span><br><span class="line">24&#x2F;91&#x3D;0.(263 736)</span><br><span class="line">24000&#x2F;91&#x3D;n+0.(736 263)</span><br><span class="line">24&#x2F;91+24000&#x2F;91&#x3D;1</span><br><span class="line"></span><br><span class="line">那么这两个数相加只能是0.9999999999999999……</span><br><span class="line"></span><br><span class="line">所以必然会有和为9的性质</span><br></pre></td></tr></table></figure>

<h1 id="8-定理5"><a href="#8-定理5" class="headerlink" title="8.定理5"></a>8.定理5</h1><p><font size="3" color=#5959ff>「定理5」：如果<code>p≥7</code>是个质数，n与m是任意正整数且p不整除m，则m/p^n的循环节有偶数位，将此循环节分成前后两段，则此两段之对应项的和皆为9</font></p>
<h1 id="9-summary"><a href="#9-summary" class="headerlink" title="9.summary"></a>9.summary</h1><p>后面就随便看看了。。还有一些例题。。先这样吧，其实最重要的就是定理一，几个例子大都用到了定理一的结论</p>
<p>总结一下这几个定理：</p>
<p><font size="3" color=#1357ff>1.如果<code>1≤b&lt;a</code>，a没有2或5的质因数，并且a与b互质，那么b/a的循环节位数恰好等于：<code>min{e ∈ N:10^e≡1(mod a)}</code></font><br></p>
<p><font size="3" color=#1357ff>2.如果<code>1≤b&lt;a</code>，a没有2或5的质因数，并且a与b互质，那么b/a的循环节位数必整除<code>φ(a)</code></font><br></p>
<p><font size="3" color=#1357ff>3.如果<code>n,m≥3</code>，2与5都不整除mn，并且n与m是互质的正整數,则<code>1/mn</code>的循环小数位数是<code>1/m</code>与<code>1/n</code>循环小数位数的最小公倍数</font><br></p>
<p><font size="3" color=#1357ff>4.设p是奇质数，如果<code>1/p</code>有d位循环节，<code>1/p^2</code>的循环节位数是d或者dp；若<code>1/p^n</code>的循环节位数是<code>dp^m(0≤m&lt;n)</code>，则<code>1/p^(n+1)</code>的循环节位数是<code>dp^m</code>或<code>dp^(m+1)</code></font><br></p>
<p><font size="3" color=#1357ff>5.如果<code>p≥7</code>是个质数，n与m是任意正整数且p不整除m，则m/p^n的循环节有偶数位，将此循环节分成前后两段，则此两段之对应项的和皆为9</font><br></p>
<hr>
<p>最后放上论文出处：<a href="https://w3.math.sinica.edu.tw/math_media/d253/25311.pdf" target="_blank" rel="noopener">循环小数 康明昌</a></p>
<br>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS下进行Verilog仿真（Sublime Text3配置verilog代码环境）</title>
    <url>/f15c0cd9/</url>
    <content><![CDATA[<p>sublime text3 夸就完事了 多么小巧强大又好看的ide啊 </p>
<a id="more"></a>

<hr>
<h1 id="1-在sublime-text3中安装Package-Control"><a href="#1-在sublime-text3中安装Package-Control" class="headerlink" title="1.在sublime text3中安装Package Control"></a>1.在sublime text3中安装Package Control</h1><p>没装Package Control的先去装一个，我之前装过了，操作如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4koa9prkgj201g00ogld.jpg" alt="">或者「View-show console」打开命令行，输入如下代码即可</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4koa9qn48j207o03fglp.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import urllib.request,os; pf &#x3D; &#39;Package Control.sublime-package&#39;; ipp &#x3D; sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &#39;wb&#39;).write(urllib.request.urlopen( &#39;http:&#x2F;&#x2F;sublime.wbond.net&#x2F;&#39; + pf.replace(&#39; &#39;,&#39;%20&#39;)).read())</span><br></pre></td></tr></table></figure>

<p>要是无法通过代码安装成功的话还有手动安装的方法，见官网 -&gt; <a href="https://packagecontrol.io/installation#st3" target="_blank" rel="noopener">https://packagecontrol.io/installation#st3</a></p>
<p>安装好了就可以在「preferences」下找到如下最后两个选项</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4koa9tuuvj20bh092wfh.jpg" alt=""></p>
<h1 id="2-下载安装Verilog编译器Icarus-Verilog"><a href="#2-下载安装Verilog编译器Icarus-Verilog" class="headerlink" title="2.下载安装Verilog编译器Icarus Verilog"></a>2.下载安装Verilog编译器Icarus Verilog</h1><p>提供两种方法，一种是通过brew安装，只需要命令行输入下面这句即可，<code>brew install icarus-verilog</code>，另一种是通过源代码编译安装，具体如下：</p>
<p>下载地址：<a href="https://sourceforge.net/projects/iverilog/" target="_blank" rel="noopener">https://sourceforge.net/projects/iverilog/</a></p>
<p>Icarus Verilog是一个开源的Verilog编译器，支持IEEE-1364 Verilog HDL，包括IEEE1364-2005 plus扩展</p>
<p>下载完后解压，在解压出的文件夹处打开终端，从源代码处编译安装Icarus Verilog</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4koarfmbsj208k08yjrz.jpg" alt=""></p>
<p>依次输入：（ps：第二步需要不少时间。。）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure</span><br><span class="line">make</span><br><span class="line">make check</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>如下，安装完成</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4koardv65j20fq0a3tcb.jpg" alt=""></p>
<p>然后在命令行输入<code>iverilog</code>检测一下，如果显示如下图：<code>no source files</code>，那么我们就可以顺利用它编译verilog源文件了，否则的话需要在<code>~/.bash_profile</code>里自行配置一下环境变量</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4koarfkyrj20f004pgm9.jpg" alt=""></p>
<h1 id="3-安装波形查看软件Scansion"><a href="#3-安装波形查看软件Scansion" class="headerlink" title="3.安装波形查看软件Scansion"></a>3.安装波形查看软件Scansion</h1><p>mac OS下用来看vcd文件的</p>
<p>下载链接：<a href="http://www.logicpoet.com/downloads/" target="_blank" rel="noopener">http://www.logicpoet.com/downloads/</a></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kob8zl0gj20l30abjt8.jpg" alt=""></p>
<p>一个安装包，一路快乐安装即可</p>
<h1 id="4-在sublime-text3中配置Verilog语法环境"><a href="#4-在sublime-text3中配置Verilog语法环境" class="headerlink" title="4.在sublime text3中配置Verilog语法环境"></a>4.在sublime text3中配置Verilog语法环境</h1><p>在sublime<code>command+shift+p</code>打开package control界面</p>
<p>输入<code>install</code>然后回车，没出来不要急，状态栏是在动的</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kob8yyj0j207x00ljr7.jpg" alt=""></p>
<p>等待片刻，会出现如下界面，继续在框中输入verilog，然后选择<code>Verilog</code>也就是第一项，回车</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kob8ywwzj20gl09hab9.jpg" alt=""></p>
<p>然后就可以拥有verilog的语法环境了，选择语法环境的步骤如下：</p>
<p>「view-syntax(语法)-verilog」</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kobox22hj20gc0msdhx.jpg" alt=""></p>
<h1 id="5-尝试编译verilog代码"><a href="#5-尝试编译verilog代码" class="headerlink" title="5.尝试编译verilog代码"></a>5.尝试编译verilog代码</h1><p><s>写</s>(chao)一段verilog代码，代码来自：<a href="http://www.shintaku.xyz/posts/verilog/" target="_blank" rel="noopener">Mac上进行Verilog仿真</a></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4koboihz5j20ir098gmk.jpg" alt=""></p>
<p>「123.v」</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module vaddsws( vra, vrb, vrt, sat );</span><br><span class="line"></span><br><span class="line">input  [31 : 0] vra;</span><br><span class="line">input  [31 : 0] vrb;</span><br><span class="line">output [31 : 0] vrt;</span><br><span class="line">output          sat;</span><br><span class="line"></span><br><span class="line">wire   [31 : 0] sum;</span><br><span class="line">wire   [31 : 0] vrt;</span><br><span class="line">wire            sat;</span><br><span class="line"></span><br><span class="line">assign &#123;sat, sum&#125;	&#x3D; vra + vrb;</span><br><span class="line">assign vrt &#x3D; (vra[31]^vrb[31]) ? sum : (vra[31]&amp;&amp;vrb[31] ? (sum[31] ? sum : 32&#39;h80000000) : (sum[31] ? 32&#39;h7fffffff : sum));</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>

<p>「a.v」</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;timescale 1ns&#x2F;100ps</span><br><span class="line">&#96;include &quot;123.v&quot;</span><br><span class="line"></span><br><span class="line">module vaddsws_tb;</span><br><span class="line"></span><br><span class="line">reg	[31: 0]	vra;</span><br><span class="line">reg	[31: 0]	vrb;</span><br><span class="line">wire	[31: 0]	vrt;</span><br><span class="line">wire	sat;</span><br><span class="line"></span><br><span class="line">initial</span><br><span class="line">begin</span><br><span class="line">	$dumpfile(&quot;test.vcd&quot;);</span><br><span class="line">	$dumpvars(0, vaddsws_tb);</span><br><span class="line">	assign vra&#x3D;32&#39;hffffffff;</span><br><span class="line">	assign vrb&#x3D;32&#39;hffffffff;</span><br><span class="line">	#100</span><br><span class="line">	assign vra&#x3D;32&#39;h01234567;</span><br><span class="line">	assign vrb&#x3D;32&#39;h76543210;</span><br><span class="line">	#100</span><br><span class="line">	$finish;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">vaddsws add( .vra(vra), .vrb(vrb), .vrt(vrt), .sat(sat) );</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>

<p>然后把<code>123.v</code>和<code>a.v</code>放入一个文件夹，然后在该文件夹终端输入<code>iverilog -o b.vvp a.v</code>，编译成功后文件夹内就会出现一个<code>b.vvp</code>，如图：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kobohkq1j208d02t744.jpg" alt=""></p>
<p>然后在命令行输入<code>./b.vvp</code>（名字可以不对应），就会多一个如下图的文件，用来看波形的</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4koc5uhw0j20b902w747.jpg" alt=""></p>
<p>然后继续输入<code>open -a Scansion test.vcd</code>，用Scansion查看波形</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4koc5vvizj20xq0gd0v6.jpg" alt=""></p>
<p>完结撒花～学verilog去了</p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu1542 Atlantis（矩形面积并，扫描线）</title>
    <url>/473aafff/</url>
    <content><![CDATA[<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>There are several ancient Greek texts that contain descriptions of the fabled island Atlantis. Some of these texts even include maps of parts of the island. But unfortunately, these maps describe different regions of Atlantis. Your friend Bill has to know the total area for which maps exist. You (unwisely) volunteered to write a program that calculates this quantity.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input file consists of several test cases. Each test case starts with a line containing a single integer n (1&lt;=n&lt;=100) of available maps. The n following lines describe one map each. Each of these lines contains four numbers x1;y1;x2;y2 (0&lt;=x1&lt;x2&lt;=100000;0&lt;=y1&lt;y2&lt;=100000), not necessarily integers. The values (x1; y1) and (x2;y2) are the coordinates of the top-left resp. bottom-right corner of the mapped area.</p>
<p>The input file is terminated by a line containing a single 0. Don’t process it.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, your program should output one section. The first line of each section must be “Test case #k”, where k is the number of the test case (starting with 1). The second one must be “Total explored area: a”, where a is the total explored area (i.e. the area of the union of all rectangles in this test case), printed exact to two digits to the right of the decimal point.</p>
<p>Output a blank line after each test case.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">10 10 20 20</span><br><span class="line">15 15 25 25.5</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test case #1</span><br><span class="line">Total explored area: 180.00</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>求矩形面积并</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>快乐扫描线</p>
<p>还没写过扫描线。。这次写一下</p>
<p>从下向上扫，那么对x轴建立线段树，只需要考虑矩形与x轴平行的边，入边1出边-1，线段树维护一个cover数组，表示x轴的被覆盖情况，每次被覆盖的长度乘离下一条要扫到位置的垂直距离，就是ans的增量</p>
<p>wa了一下午最后发现多组数据我漏了一个clear()。。gg</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define lson l,m,rt&lt;&lt;1</span><br><span class="line">#define rson m+1,r,rt&lt;&lt;1|1</span><br><span class="line">const int N&#x3D;2005;</span><br><span class="line">double cover[N&lt;&lt;2];</span><br><span class="line">int num[N&lt;&lt;2],n;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int flag;</span><br><span class="line">    double l,r,h;</span><br><span class="line">&#125;tmp;</span><br><span class="line">vector&lt;node&gt; a;</span><br><span class="line">vector&lt;double&gt; vx;</span><br><span class="line">bool cmp(node n1,node n2)&#123;</span><br><span class="line">    return n1.h&lt;n2.h;</span><br><span class="line">&#125;</span><br><span class="line">void pushup(int l,int r,int rt)&#123;</span><br><span class="line">    if(num[rt])cover[rt]&#x3D;vx[r+1]-vx[l];</span><br><span class="line">    else if(l&#x3D;&#x3D;r)cover[rt]&#x3D;0;</span><br><span class="line">    else cover[rt]&#x3D;cover[rt&lt;&lt;1]+cover[rt&lt;&lt;1|1];</span><br><span class="line">&#125;</span><br><span class="line">void update(int L,int R,int flag,int l,int r,int rt)&#123;</span><br><span class="line">    if(l&gt;&#x3D;L&amp;&amp;r&lt;&#x3D;R)&#123;</span><br><span class="line">        num[rt]+&#x3D;flag;</span><br><span class="line">        pushup(l,r,rt);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int m&#x3D;(l+r)&gt;&gt;1;</span><br><span class="line">    if(L&lt;&#x3D;m)update(L,R,flag,lson);</span><br><span class="line">    if(R&gt;m)update(L,R,flag,rson);</span><br><span class="line">    pushup(l,r,rt);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int cas&#x3D;1;</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)&#123;</span><br><span class="line">        double x1,y1,x2,y2;</span><br><span class="line">        a.clear();</span><br><span class="line">        vx.clear();</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            scanf(&quot;%lf%lf%lf%lf&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">            vx.push_back(x1);</span><br><span class="line">            vx.push_back(x2);</span><br><span class="line">            tmp.l&#x3D;x1;tmp.r&#x3D;x2;tmp.h&#x3D;y2;tmp.flag&#x3D;1;</span><br><span class="line">            a.push_back(tmp);</span><br><span class="line">            tmp.h&#x3D;y1;tmp.flag&#x3D;-1;</span><br><span class="line">            a.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        int ji&#x3D;vx.size();</span><br><span class="line">        sort(vx.begin(),vx.end());</span><br><span class="line">        sort(a.begin(),a.end(),cmp);</span><br><span class="line">        vx.erase(unique(vx.begin(),vx.end()),vx.end());&#x2F;&#x2F;去重stl</span><br><span class="line">        int jii&#x3D;vx.size();</span><br><span class="line">        &#x2F;&#x2F; cout&lt;&lt;ji&lt;&lt;&quot; &quot;&lt;&lt;jii&lt;&lt;endl;</span><br><span class="line">        memset(cover,0,sizeof(cover));</span><br><span class="line">        memset(num,0,sizeof(num));</span><br><span class="line">        double ans&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;ji-1;i++)&#123;</span><br><span class="line">            int l&#x3D;lower_bound(vx.begin(),vx.end(),a[i].l)-vx.begin();</span><br><span class="line">            int r&#x3D;lower_bound(vx.begin(),vx.end(),a[i].r)-vx.begin()-1;</span><br><span class="line">            &#x2F;&#x2F; cout&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">            if(l&lt;&#x3D;r)update(l,r,a[i].flag,0,jii-1,1);</span><br><span class="line">            ans+&#x3D;cover[1]*(a[i+1].h-a[i].h);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Test case #%d\n&quot;,cas++);</span><br><span class="line">        printf(&quot;Total explored area: %.2lf\n\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">2</span><br><span class="line">10 10 20 20</span><br><span class="line">15 15 25 25.5</span><br><span class="line">0</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>cf 101 B. Buses（离散化，树状数组，dp）</title>
    <url>/e29034bf/</url>
    <content><![CDATA[<p>传送门：<a href="https://codeforces.com/contest/101/problem/B" target="_blank" rel="noopener">https://codeforces.com/contest/101/problem/B</a></p>
<a id="more"></a>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko8tr9buj20om0ffdkd.jpg" alt=""></p>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>坐车，从0到n站，给出m辆车，起点终点分别为si，ti，上车后只能在该车终点下车，上车前可以在该车任意站点上车，求方法数</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>n范围1e9所以一开始离散化一下并去掉重复的，然后按照终点位置从小到大排序</p>
<p>dp[i]记为到i的方法数，因为上车后只能在该车终点下车，上车前可以在该车任意站点上车这一条件，所以如果要坐第i辆车，那么方法数就是到<code>[si,ti-1]</code>这段的方法数之和，二分找到区间位置，用树状数组优化一下状态转移</p>
<p>此外，如果si=0，那么从0处没有到达的方式，但是有一种上车的方式，要加上1</p>
<p>套的树状数组模版忘了改while(x&lt;=n)的那个n。。以至于数组快开爆炸了都还是re。。太真实了</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int p&#x3D;1e9+7;</span><br><span class="line">const int N&#x3D;1e5+5;</span><br><span class="line">int n,m,ji,tree[N&lt;&lt;2],num[N&lt;&lt;2];</span><br><span class="line">struct node&#123;</span><br><span class="line">    int s,t;</span><br><span class="line">&#125;a[N];</span><br><span class="line">bool cmp(node a,node b)&#123;</span><br><span class="line">    return (a.t&#x3D;&#x3D;b.t)?a.s&lt;b.s:a.t&lt;b.t;</span><br><span class="line">&#125;</span><br><span class="line">int lowbit(int x)&#123;</span><br><span class="line">    return x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line">void add(int x,int val)&#123;</span><br><span class="line">    while(x&lt;&#x3D;ji)&#123;</span><br><span class="line">        &#x2F;&#x2F; tree[x]+&#x3D;val;</span><br><span class="line">        tree[x]&#x3D;(tree[x]+val)%p;</span><br><span class="line">        x+&#x3D;lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int query(int x)&#123;</span><br><span class="line">    int res&#x3D;0;</span><br><span class="line">    while(x&gt;0)&#123;</span><br><span class="line">        &#x2F;&#x2F; res+&#x3D;tree[x];</span><br><span class="line">        res&#x3D;(res+tree[x])%p;</span><br><span class="line">        x-&#x3D;lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    ji&#x3D;0;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;a[i].s,&amp;a[i].t);</span><br><span class="line">        num[ji++]&#x3D;a[i].s;</span><br><span class="line">        num[ji++]&#x3D;a[i].t;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(num,num+ji);</span><br><span class="line">    int jii&#x3D;1;</span><br><span class="line">    for(int i&#x3D;1;i&lt;ji;i++)&#123;</span><br><span class="line">        if(num[i]!&#x3D;num[i-1])num[jii++]&#x3D;num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ji&#x3D;jii;</span><br><span class="line">    &#x2F;&#x2F; cout&lt;&lt;ji&lt;&lt;endl;</span><br><span class="line">    sort(a+1,a+m+1,cmp);</span><br><span class="line">    LL ans&#x3D;0;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">        int l&#x3D;lower_bound(num,num+ji,a[i].s)-num;</span><br><span class="line">        int r&#x3D;lower_bound(num,num+ji,a[i].t)-num;</span><br><span class="line">        &#x2F;&#x2F; cout&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">        LL tmp&#x3D;0;</span><br><span class="line">        if(a[i].s&#x3D;&#x3D;0)tmp++;</span><br><span class="line">        tmp+&#x3D;query(r-1)-query(l-1);</span><br><span class="line">        tmp&#x3D;(tmp+p)%p;</span><br><span class="line">        &#x2F;&#x2F; cout&lt;&lt;r&lt;&lt;&quot; &quot;&lt;&lt;tmp&lt;&lt;endl;</span><br><span class="line">        add(r,tmp);</span><br><span class="line">        if(a[i].t&#x3D;&#x3D;n)ans&#x3D;query(r)-query(r-1);</span><br><span class="line">    &#125;</span><br><span class="line">    ans&#x3D;(ans+p)%p;</span><br><span class="line">    printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>poj2828 Buy Tickets（线段树，单点更新）</title>
    <url>/52ae22f8/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko8tr3j1j213y0g5dlw.jpg" alt=""></p>
<a id="more"></a>

<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">0 77</span><br><span class="line">1 51</span><br><span class="line">1 33</span><br><span class="line">2 69</span><br><span class="line">4</span><br><span class="line">0 20523</span><br><span class="line">1 19243</span><br><span class="line">1 3890</span><br><span class="line">0 31492</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">77 33 69 51</span><br><span class="line">31492 20523 3890 19243</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>n个数，每次插入到新序列的第i个位置，求最后的序列顺序</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>和冬令营的一个dp有一样的思想，都是从最后的结果开始切入，前面乱七八糟的插入不能确定位置，但是可以知道最后一个插入的人的位置是确定的</p>
<p>num[i]表示的是一个结点对应的空格数，如果第j个人插在第i个位置后面，那么前面一定有了i个人，得有i个空格，照这个规则用线段树维护空格数即可</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define lson l,m,rt&lt;&lt;1</span><br><span class="line">#define rson m+1,r,rt&lt;&lt;1|1</span><br><span class="line">const int N&#x3D;2e5+5;</span><br><span class="line">int num[N&lt;&lt;2],lazy[N&lt;&lt;2],n;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int val,pos;</span><br><span class="line">&#125;a[N];</span><br><span class="line">void pushup(int l,int r,int rt)&#123;</span><br><span class="line">    if(l!&#x3D;r)num[rt]&#x3D;num[rt&lt;&lt;1]+num[rt&lt;&lt;1|1];</span><br><span class="line">&#125;</span><br><span class="line">void build(int l,int r,int rt)&#123;</span><br><span class="line">    if(l&#x3D;&#x3D;r)&#123;</span><br><span class="line">        num[rt]&#x3D;1;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int m&#x3D;(l+r)&gt;&gt;1;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">    pushup(l,r,rt);</span><br><span class="line">&#125;</span><br><span class="line">void update(int p,int sc,int l,int r,int rt)&#123;</span><br><span class="line">    if(l&#x3D;&#x3D;r)&#123;</span><br><span class="line">        num[rt]&#x3D;0;</span><br><span class="line">        lazy[rt]&#x3D;sc;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int m&#x3D;(l+r)&gt;&gt;1;</span><br><span class="line">    if(p&lt;&#x3D;num[rt&lt;&lt;1])update(p,sc,lson);</span><br><span class="line">    else update(p-num[rt&lt;&lt;1],sc,rson);</span><br><span class="line">    pushup(l,r,rt);</span><br><span class="line">&#125;</span><br><span class="line">void query(int l,int r,int rt)&#123;</span><br><span class="line">    if(l&#x3D;&#x3D;r)&#123;</span><br><span class="line">        if(n&#x3D;&#x3D;1)</span><br><span class="line">            printf(&quot;%d\n&quot;,lazy[rt]);</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;%d &quot;,lazy[rt]);</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        int m&#x3D;(l+r)&gt;&gt;1;</span><br><span class="line">        query(lson);</span><br><span class="line">        query(rson);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;n)!&#x3D;EOF)&#123;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;a[i].pos,&amp;a[i].val);</span><br><span class="line">            a[i].pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        build(1,n,1);</span><br><span class="line">        for(int i&#x3D;n;i&gt;&#x3D;1;i--)</span><br><span class="line">            update(a[i].pos,a[i].val,1,n,1);</span><br><span class="line">        query(1,n,1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客next主题添加自定义字体comic neue</title>
    <url>/7167e0bc/</url>
    <content><![CDATA[<p>想要添加一个可爱的字体，选了这个<a href="http://comicneue.com/" target="_blank" rel="noopener">http://comicneue.com/</a></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko6eja2bj20uc0fa77d.jpg" alt=""></p>
<a id="more"></a>

<p>先下载解压，然后把Web文件夹下的所有内容放入这个路径中<code>themes/next/source/fonts</code></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko6ejm7pj20ft065wep.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko6encinj20hf0bgac3.jpg" alt=""></p>
<p>然后<code>themes/next/source/css/_custom/custom.styl</code>在这个官方专门给用户进行自定义美化的文件中加入如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;字体</span><br><span class="line">@font-face &#123;</span><br><span class="line">  font-family: &#39;Comic Neue&#39;;</span><br><span class="line">  src: url(&#39;&#x2F;fonts&#x2F;ComicNeue-Light.eot&#39;);</span><br><span class="line">  src: url(&#39;&#x2F;fonts&#x2F;ComicNeue-Light.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Light.woff2&#39;) format(&#39;woff2&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Light.woff&#39;) format(&#39;woff&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Light.ttf&#39;)  format(&#39;truetype&#39;);</span><br><span class="line">  font-weight: 300;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@font-face &#123;</span><br><span class="line">  font-family: &#39;Comic Neue&#39;;</span><br><span class="line">  src: url(&#39;&#x2F;fonts&#x2F;ComicNeue-Light-Oblique.eot&#39;);</span><br><span class="line">  src: url(&#39;&#x2F;fonts&#x2F;ComicNeue-Light-Oblique.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Light-Oblique.woff2&#39;) format(&#39;woff2&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Light-Oblique.woff&#39;) format(&#39;woff&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Light-Oblique.ttf&#39;)  format(&#39;truetype&#39;);</span><br><span class="line">  font-weight: 300;</span><br><span class="line">  font-style: oblique;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@font-face &#123;</span><br><span class="line">  font-family: &#39;Comic Neue&#39;;</span><br><span class="line">  src: url(&#39;&#x2F;fonts&#x2F;ComicNeue-Regular.eot&#39;);</span><br><span class="line">  src: url(&#39;&#x2F;fonts&#x2F;ComicNeue-Regular.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Regular.woff2&#39;) format(&#39;woff2&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Regular.woff&#39;) format(&#39;woff&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Regular.ttf&#39;)  format(&#39;truetype&#39;);</span><br><span class="line">  font-weight: 400;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@font-face &#123;</span><br><span class="line">  font-family: &#39;Comic Neue&#39;;</span><br><span class="line">  src: url(&#39;&#x2F;fonts&#x2F;ComicNeue-Regular-Oblique.eot&#39;);</span><br><span class="line">  src: url(&#39;&#x2F;fonts&#x2F;ComicNeue-Regular-Oblique.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Regular-Oblique.woff2&#39;) format(&#39;woff2&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Regular-Oblique.woff&#39;) format(&#39;woff&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Regular-Oblique.ttf&#39;)  format(&#39;truetype&#39;);</span><br><span class="line">  font-weight: 400;</span><br><span class="line">  font-style: oblique;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@font-face &#123;</span><br><span class="line">  font-family: &#39;Comic Neue&#39;;</span><br><span class="line">  src: url(&#39;&#x2F;fonts&#x2F;ComicNeue-Bold.eot&#39;);</span><br><span class="line">  src: url(&#39;&#x2F;fonts&#x2F;ComicNeue-Bold.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Bold.woff2&#39;) format(&#39;woff2&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Bold.woff&#39;) format(&#39;woff&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Bold.ttf&#39;)  format(&#39;truetype&#39;);</span><br><span class="line">  font-weight: 700;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@font-face &#123;</span><br><span class="line">  font-family: &#39;Comic Neue&#39;;</span><br><span class="line">  src: url(&#39;&#x2F;fonts&#x2F;ComicNeue-Bold-Oblique.eot&#39;);</span><br><span class="line">  src: url(&#39;&#x2F;fonts&#x2F;ComicNeue-Bold-Oblique.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Bold-Oblique.woff2&#39;) format(&#39;woff2&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Bold-Oblique.woff&#39;) format(&#39;woff&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Bold-Oblique.ttf&#39;)  format(&#39;truetype&#39;);</span><br><span class="line">  font-weight: 700;</span><br><span class="line">  font-style: oblique;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@font-face &#123;</span><br><span class="line">  font-family: &#39;Comic Neue Angular&#39;;</span><br><span class="line">  src: url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Light.eot&#39;);</span><br><span class="line">  src: url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Light.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Light.woff2&#39;) format(&#39;woff2&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Light.woff&#39;) format(&#39;woff&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Light.ttf&#39;)  format(&#39;truetype&#39;);</span><br><span class="line">  font-weight: 300;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@font-face &#123;</span><br><span class="line">  font-family: &#39;Comic Neue Angular&#39;;</span><br><span class="line">  src: url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Light-Oblique.eot&#39;);</span><br><span class="line">  src: url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Light-Oblique.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Light-Oblique.woff2&#39;) format(&#39;woff2&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Light-Oblique.woff&#39;) format(&#39;woff&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Light-Oblique.ttf&#39;)  format(&#39;truetype&#39;);</span><br><span class="line">  font-weight: 300;</span><br><span class="line">  font-style: oblique;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@font-face &#123;</span><br><span class="line">  font-family: &#39;Comic Neue Angular&#39;;</span><br><span class="line">  src: url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Regular.eot&#39;);</span><br><span class="line">  src: url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Regular.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Regular.woff2&#39;) format(&#39;woff2&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Regular.woff&#39;) format(&#39;woff&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Regular.ttf&#39;)  format(&#39;truetype&#39;);</span><br><span class="line">  font-weight: 400;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@font-face &#123;</span><br><span class="line">  font-family: &#39;Comic Neue Angular&#39;;</span><br><span class="line">  src: url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Regular-Oblique.eot&#39;);</span><br><span class="line">  src: url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Regular-Oblique.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Regular-Oblique.woff2&#39;) format(&#39;woff2&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Regular-Oblique.woff&#39;) format(&#39;woff&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Regular-Oblique.ttf&#39;)  format(&#39;truetype&#39;);</span><br><span class="line">  font-weight: 400;</span><br><span class="line">  font-style: oblique;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@font-face &#123;</span><br><span class="line">  font-family: &#39;Comic Neue Angular&#39;;</span><br><span class="line">  src: url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Bold.eot&#39;);</span><br><span class="line">  src: url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Bold.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Bold.woff2&#39;) format(&#39;woff2&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Bold.woff&#39;) format(&#39;woff&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Bold.ttf&#39;)  format(&#39;truetype&#39;);</span><br><span class="line">  font-weight: 700;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@font-face &#123;</span><br><span class="line">  font-family: &#39;Comic Neue Angular&#39;;</span><br><span class="line">  src: url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Bold-Oblique.eot&#39;);</span><br><span class="line">  src: url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Bold-Oblique.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Bold-Oblique.woff2&#39;) format(&#39;woff2&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Bold-Oblique.woff&#39;) format(&#39;woff&#39;),</span><br><span class="line">       url(&#39;&#x2F;fonts&#x2F;ComicNeue-Angular-Bold-Oblique.ttf&#39;)  format(&#39;truetype&#39;);</span><br><span class="line">  font-weight: 700;</span><br><span class="line">  font-style: oblique;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后进入主题配置文件<code>themes/next/_config.yml</code></p>
<p>搜索font，可以得到如下部分：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko6s9vtwj20kh0jy40u.jpg" alt=""></p>
<p>我想把标题和文章中的字体都设置成这个，那么只需要在family后面加上即可：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko6s9r6zj20a205bweo.jpg" alt=""></p>
<p>然后<code>hexo clean</code> <code>hexo s</code>一下就可以看效果啦</p>
<hr>
<p>字体参考自这里，超级可爱ᶘ ᵒᴥᵒᶅ -&gt; <a href="https://milktea.info/2019/01/25/ComicNeue/" target="_blank" rel="noopener">https://milktea.info/2019/01/25/ComicNeue/</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS下mysql安装完后commmand not found的解决办法</title>
    <url>/436ccaaf/</url>
    <content><![CDATA[<p>安装就是搞个安装包快乐安装</p>
<p>安装完后试一下命令行，会出现<code>command not found</code></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko4f670oj205y00vwec.jpg" alt=""></p>
<a id="more"></a>

<p>还是一样的问题，因为mysql环境变量没有配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure>
<p>在最后加入一行：</p>
<p>光标移动到要插入的地方然后<code>:i</code>，然后输入下面这段话，然后esc退出输入，然后<code>:wq</code>保存并退出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH&#x3D;$&#123;PATH&#125;:&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko4f5fdvj2087018dfo.jpg" alt=""></p>
<p>然后回到终端更新一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure>

<p>然后就可以快乐玩耍了</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko4f6ryfj20fb073myq.jpg" alt=""></p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>运行tensorflow出现「Your CPU supports instructions that this TensorFlow binary was not compiled to use SSE4.1 SSE4.2 AVX AVX2 FMA」问题的原因及解决办法</title>
    <url>/91dee705/</url>
    <content><![CDATA[<p><a href="https://leflacon.github.io/861530ae/" target="_blank" rel="noopener">macOS下tensorflow的下载和安装（通过anaconda）</a></p>
<p>首先我安装的是通过anaconda安装的CPU版本的tensorflow</p>
<a id="more"></a>

<h1 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h1><p>运行tensorflow时遇到了这样的问题：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko7cqxpsj20fp02rjs3.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Your CPU supports instructions that this TensorFlow binary was not compiled to use: SSE4.1 SSE4.2 AVX AVX2 FMA</span><br><span class="line"></span><br><span class="line">Creating new thread pool with default inter op setting: 4. Tune using inter_op_parallelism_threads for best performance.</span><br></pre></td></tr></table></figure>

<p>翻译一下就是，你的CPU支持<code>SSE4.1 SSE4.2 AVX AVX2 FMA</code>这些拓展，但是无法编译使用</p>
<p>这个不是错误，只是一个警告，告诉你如果从源代码安装tensorflow，那么tensorflow会跑得更快</p>
<h1 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h1><p>先科普一番</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SSE4 (Streaming SIMD Extensions 4)是IntelCore微体系结构和AMDK10（K8L）中所使用的SIMDCPU指令集</span><br><span class="line">AVX指令集（英语：Advanced Vector Extensions，即高级向量扩展指令集）是x86架构处理器中的指令集，被英特尔和AMD的处理器所支持</span><br><span class="line">FMA指令集（英语：Fused-Multiply-Add，即积和熔加运算）是x86架构微处理器上的指令集。FMA指令集是128位元和256位元的流式单指令流多资料流扩充集（SSE）指令集，以进行积和熔加运算。</span><br></pre></td></tr></table></figure>

<p>那么为什么会出现这样的问题呢？</p>
<p>在stackoverflow里找到了答案：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko7cqp2oj20kr074769.jpg" alt=""></p>
<p>翻译一下就是，很可能你没有利用源代码的方式安装tensorflow，这意味着你安装了别人预先构建的未针对你的体系结构进行优化的二进制文件，这个警告就是想告诉你：你有这些指令集，但是因为二进制文件没有用他们编译，所以这些指令集都用不了</p>
<p>如果用上这些拓展的话，显然会加快计算</p>
<h1 id="3-解决"><a href="#3-解决" class="headerlink" title="3.解决"></a>3.解决</h1><h2 id="3-1忽略警告"><a href="#3-1忽略警告" class="headerlink" title="3.1忽略警告"></a>3.1忽略警告</h2><p>第一种解决方法是直接忽略警告，这种方法简单粗暴，但是实际上并没有解决问题</p>
<p>在代码中加入如下两句即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os </span><br><span class="line">os.environ[&#39;TF_CPP_MIN_LOG_LEVEL&#39;] &#x3D; &#39;2&#39;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">hello &#x3D; tf.constant(&#39;Hello,tensorflow&#39;) </span><br><span class="line">sess &#x3D; tf.Session()</span><br><span class="line">print(sess.run(hello))</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko7crbifj209102edfw.jpg" alt=""></p>
<h2 id="3-2用源代码安装tensorflow"><a href="#3-2用源代码安装tensorflow" class="headerlink" title="3.2用源代码安装tensorflow"></a>3.2用源代码安装tensorflow</h2><p>第二种方法就是<s>麻烦的</s>用源代码安装tensorflow</p>
<p>这样就可以自己编译这些二进制文件以利用上面那串指令集</p>
<p>但是不管再怎么快，CPU也远远快不过GPU，所以不如就照第一种方法凑合着用吧</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko7zff66j20j204i3zj.jpg" alt=""></p>
<p>参考自stackoverflow的这个问题 -&gt; <a href="https://stackoverflow.com/questions/41293077/how-to-compile-tensorflow-with-sse4-2-and-avx-instructions" target="_blank" rel="noopener">How to compile Tensorflow with SSE4.2 and AVX instructions?
</a></p>
<p><a href="https://www.tensorflow.org/install/source" target="_blank" rel="noopener">从源代码构建 TensorFlow pip 软件包并将其安装在 macOS 上</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS下tensorflow的下载和安装（通过anaconda）</title>
    <url>/861530ae/</url>
    <content><![CDATA[<p>开头一些说明：</p>
<p>首先，mac使用这种方法安装的话，后续可能会遇到一点不痛不痒的小警告，但是跑起来是没有问题的，而通过源代码安装则不会出现指令集无法编译的问题（build from source）<a href="https://www.tensorflow.org/install/source" target="_blank" rel="noopener">从源代码构建 TensorFlow pip 软件包并将其安装在 macOS 上</a></p>
<a id="more"></a>

<p>但是另一方面，通过anaconda安装的方式更为简单，而通过源代码安装据说要编译好久。并且就算通过源代码安装可以利用一些指令集来加速CPU，但是大佬拿出了快乐GPU，CPU就不够看了</p>
<p>此外，再放上官方文档给出的安装方法 -&gt; <a href="https://www.tensorflow.org/install" target="_blank" rel="noopener">安装 TensorFlow</a></p>
<p>如果是用pycharm的话，，在preference里直接装会更简单粗暴</p>
<hr>
<p>利用anaconda安装的大致流程如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko2ue35zj20dp03z0sx.jpg" alt=""></p>
<h1 id="1-安装anaconda"><a href="#1-安装anaconda" class="headerlink" title="1.安装anaconda"></a>1.安装anaconda</h1><p><a href="https://leflacon.github.io/436ccaaf" target="_blank" rel="noopener">macOS下下载anaconda和下载完后commmand not found的解决办法</a></p>
<h1 id="2-建立一个叫tensorflow的conda计算环境"><a href="#2-建立一个叫tensorflow的conda计算环境" class="headerlink" title="2.建立一个叫tensorflow的conda计算环境"></a>2.建立一个叫tensorflow的conda计算环境</h1><p>根据对应版本的python</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda create -n tensorflow python&#x3D;3.6</span><br></pre></td></tr></table></figure>

<h1 id="3-激活tensorflow环境"><a href="#3-激活tensorflow环境" class="headerlink" title="3.激活tensorflow环境"></a>3.激活tensorflow环境</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source activate tensorflow</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko2uenzjj206d00zjr8.jpg" alt=""></p>
<h1 id="4-在该环境中安装tensorflow"><a href="#4-在该环境中安装tensorflow" class="headerlink" title="4.在该环境中安装tensorflow"></a>4.在该环境中安装tensorflow</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda install tensorflow</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko2udz63j20ao01ejrb.jpg" alt=""></p>
<h1 id="5-尝试运行tensorflow"><a href="#5-尝试运行tensorflow" class="headerlink" title="5.尝试运行tensorflow"></a>5.尝试运行tensorflow</h1><p>激活名为tensorflow的环境之后，打开一个python终端</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko3mf2pkj20e1021dg5.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">hello &#x3D; tf.constant(&#39;Hello,tensorflow&#39;)</span><br><span class="line">sess &#x3D; tf.Session()</span><br><span class="line">print(sess.run(hello))</span><br></pre></td></tr></table></figure>

<p>如果能成功输出那么就ok了</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko3wirmkj205e00t745.jpg" alt=""></p>
<p>如果遇到<code>Your CPU supports instructions that this TensorFlow binary was not compiled to use: SSE4.1 SSE4.2 AVX AVX2 FMA</code>这类的问题，请参考 -&gt; <a href="https://leflacon.github.io/91dee705" target="_blank" rel="noopener">运行tensorflow出现「Your CPU supports instructions that this TensorFlow binary was not compiled to use: SSE4.1 SSE4.2 AVX AVX2 FMA」问题的原因及解决办法</a></p>
<h1 id="6-关闭conda环境"><a href="#6-关闭conda环境" class="headerlink" title="6.关闭conda环境"></a>6.关闭conda环境</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source deactivate</span><br></pre></td></tr></table></figure>

<p>要使用tensorflow的时候激活环境即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source activate tensorflow</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS下下载anaconda和安装完后commmand not found的解决办法</title>
    <url>/436ccaaf/</url>
    <content><![CDATA[<h1 id="1-下载安装"><a href="#1-下载安装" class="headerlink" title="1.下载安装"></a>1.下载安装</h1><p>在官网选择对应版本的anaconda下载，然后打开安装包安装</p>
<p><a href="https://www.anaconda.com/distribution/#macos" target="_blank" rel="noopener">https://www.anaconda.com/distribution/#macos</a></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko58jqcej20rr0d2jsu.jpg" alt=""></p>
<h2 id="2-commmand-not-found"><a href="#2-commmand-not-found" class="headerlink" title="2.commmand not found"></a>2.commmand not found</h2><p>下载完后命令行无法识别<code>conda</code></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko5g7aarj206700vdfo.jpg" alt=""></p>
<p>遇到次数多了就会解决这类问题了，和之前的pyspider一样，就是环境变量没有配置好</p>
<p>终端输入<code>vi ~/.bash_profile</code></p>
<p>然后如果没有的话就在环境变量里加一句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH&#x3D;&quot;&#x2F;Users&#x2F;mac&#x2F;anaconda3&#x2F;bin:$PATH&quot;</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko5g996gj208s00g3yd.jpg" alt=""></p>
<p>回到终端输入<code>source ~/.bash_profile</code>，刷新环境变量</p>
<p>然后再在终端输入<code>conda</code>指令，就可以成功识别啦</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko5g71eyj20e204gaai.jpg" alt=""></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu4109 Instrction Arrangement（拓扑排序求关键路径）</title>
    <url>/8679af82/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko1k04g6j213m0dg77n.jpg" alt=""></p>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给n个指令和m个依赖关系，x完成后z毫秒才运行y，每完成一个指令只要1毫秒，求最短时间</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>裸的拓扑排序求关键路径</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;1005;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int next,w;</span><br><span class="line">&#125;tmp;</span><br><span class="line">vector&lt;node&gt; g[N];</span><br><span class="line">int d[N],ans[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,u,v,w;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!&#x3D;EOF)&#123;</span><br><span class="line">        memset(d,0,sizeof(d));</span><br><span class="line">        memset(ans,0,sizeof(ans));</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)g[i].clear();</span><br><span class="line">        while(m--)&#123;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            tmp.next&#x3D;v;</span><br><span class="line">            tmp.w&#x3D;w;</span><br><span class="line">            g[u].push_back(tmp);</span><br><span class="line">            d[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;拓扑排序</span><br><span class="line">        queue&lt;int&gt;q;</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            if(d[i]&#x3D;&#x3D;0)&#123;</span><br><span class="line">                q.push(i);</span><br><span class="line">                ans[i]&#x3D;1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            u&#x3D;q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            for(int i&#x3D;0;i&lt;g[u].size();i++)&#123;</span><br><span class="line">                v&#x3D;g[u][i].next;</span><br><span class="line">                d[v]--;</span><br><span class="line">                if(d[v]&#x3D;&#x3D;0)q.push(v);</span><br><span class="line">                ans[v]&#x3D;max(ans[v],ans[u]+g[u][i].w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int res&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)res&#x3D;max(res,ans[i]);</span><br><span class="line">        printf(&quot;%d\n&quot;,res);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>poj2823 Sliding Window（deque双端队列，模拟）</title>
    <url>/666b36a2/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko12cih2j213m0dg77n.jpg" alt=""></p>
<a id="more"></a>

<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8 3</span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1 -3 -3 -3 3 3</span><br><span class="line">3 3 5 5 6 7</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给一个长为n的数组，一个长为k的滑动的窗体，从左至右每次窗体向右移动一位，求被框住部分的最大值和最小值</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>维护两个队列，每次要在末尾插入一个新数字之前，对最大值队列来说，如果这个数大于当前末尾的数，那么就pop末尾，对最小值队列来说，如果这个数小于当前末尾的数，就pop末尾</p>
<p>直接用deque给T了。。那老实写个手动双端队列吧。。然后又T了。。加了个读入优化。。然后还是T了。。然后有加了一些有的没的优化。。还是T了。。最后把G++改成了C++。。过了???( ゜-゜)???</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;1e6+5;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int pos,val;</span><br><span class="line">&#125;max_q[N],min_q[N];</span><br><span class="line">int ans_min[N],ans_max[N],min_l,min_r,max_l,max_r;</span><br><span class="line">void read(int &amp;x)&#123;</span><br><span class="line">    int f&#x3D;1;x&#x3D;0;char s&#x3D;getchar();</span><br><span class="line">    while(s&lt;&#39;0&#39;||s&gt;&#39;9&#39;)&#123;if(s&#x3D;&#x3D;&#39;-&#39;)f&#x3D;-1;s&#x3D;getchar();&#125;</span><br><span class="line">    while(s&gt;&#x3D;&#39;0&#39;&amp;&amp;s&lt;&#x3D;&#39;9&#39;)&#123;x&#x3D;x*10+s-&#39;0&#39;;s&#x3D;getchar();&#125;</span><br><span class="line">    x*&#x3D;f;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,k,x;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);</span><br><span class="line">    max_l&#x3D;min_l&#x3D;max_r&#x3D;min_r&#x3D;1;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;k-1;i++)&#123;</span><br><span class="line">        read(x);</span><br><span class="line">        while(max_l&lt;max_r&amp;&amp;max_q[max_r-1].val&lt;&#x3D;x)max_r--;</span><br><span class="line">        while(min_l&lt;min_r&amp;&amp;min_q[min_r-1].val&gt;&#x3D;x)min_r--;</span><br><span class="line">        max_q[max_r].pos&#x3D;i;max_q[max_r++].val&#x3D;x;</span><br><span class="line">        min_q[min_r].pos&#x3D;i;min_q[min_r++].val&#x3D;x;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;k;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        if(max_l&lt;max_r&amp;&amp;max_q[max_l].pos&lt;i-k+1)max_l++;</span><br><span class="line">        if(min_l&lt;min_r&amp;&amp;min_q[min_l].pos&lt;i-k+1)min_l++;</span><br><span class="line">        read(x);</span><br><span class="line">        while(max_l&lt;max_r&amp;&amp;max_q[max_r-1].val&lt;&#x3D;x)max_r--;</span><br><span class="line">        while(min_l&lt;min_r&amp;&amp;min_q[min_r-1].val&gt;&#x3D;x)min_r--;</span><br><span class="line">        max_q[max_r].pos&#x3D;i;max_q[max_r++].val&#x3D;x;</span><br><span class="line">        min_q[min_r].pos&#x3D;i;min_q[min_r++].val&#x3D;x;</span><br><span class="line">        ans_max[i]&#x3D;max_q[max_l].val;</span><br><span class="line">        ans_min[i]&#x3D;min_q[min_l].val;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;k;i&lt;n;i++)printf(&quot;%d &quot;,ans_min[i]);</span><br><span class="line">    printf(&quot;%d\n&quot;,ans_min[n]);</span><br><span class="line">    for(int i&#x3D;k;i&lt;n;i++)printf(&quot;%d &quot;,ans_max[i]);</span><br><span class="line">    printf(&quot;%d\n&quot;,ans_max[n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>T掉的deque</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">    int pos,val;</span><br><span class="line">&#125;tmp;</span><br><span class="line">const int N&#x3D;1e6;</span><br><span class="line">int ans_min[N],ans_max[N];</span><br><span class="line">deque&lt;node&gt;max_q,min_q;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,k;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;k-1;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;tmp.val);</span><br><span class="line">        tmp.pos&#x3D;i;</span><br><span class="line">        while(!max_q.empty()&amp;&amp;max_q.back().val&lt;&#x3D;tmp.val)</span><br><span class="line">            max_q.pop_back();</span><br><span class="line">        while(!min_q.empty()&amp;&amp;min_q.back().val&gt;&#x3D;tmp.val)</span><br><span class="line">            min_q.pop_back();</span><br><span class="line">        max_q.push_back(tmp);</span><br><span class="line">        min_q.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;k;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        while(!max_q.empty()&amp;&amp;max_q.front().pos&lt;i-k+1)</span><br><span class="line">            max_q.pop_front();</span><br><span class="line">        while(!min_q.empty()&amp;&amp;min_q.front().pos&lt;i-k+1)</span><br><span class="line">            min_q.pop_front();</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;tmp.val);</span><br><span class="line">        while(!max_q.empty()&amp;&amp;max_q.back().val&lt;&#x3D;tmp.val)</span><br><span class="line">            max_q.pop_back();</span><br><span class="line">        while(!min_q.empty()&amp;&amp;min_q.back().val&gt;&#x3D;tmp.val)</span><br><span class="line">            min_q.pop_back();</span><br><span class="line">        tmp.pos&#x3D;i;</span><br><span class="line">        max_q.push_back(tmp);</span><br><span class="line">        min_q.push_back(tmp);</span><br><span class="line">        ans_max[i]&#x3D;max_q.front().val;</span><br><span class="line">        ans_min[i]&#x3D;min_q.front().val;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;k;i&lt;n;i++)printf(&quot;%d &quot;,ans_min[i]);</span><br><span class="line">    printf(&quot;%d\n&quot;,ans_min[n]);</span><br><span class="line">    for(int i&#x3D;k;i&lt;n;i++)printf(&quot;%d &quot;,ans_max[i]);</span><br><span class="line">    printf(&quot;%d\n&quot;,ans_max[n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>bzoj3688 折线统计/sjtu1123（树状数组优化dp）</title>
    <url>/27bf595a/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko1k0sxej20os0fm404.jpg" alt=""></p>
<p><code>n&lt;=50000, k&lt;=10</code></p>
<a id="more"></a>

<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>有拐点，显然状态分割</p>
<p><code>dp[k][i][0/1]</code>表示[1,i]中的一些点组成的集合f(S)=k，且最后一段以i结尾，最后一段上升记为1，下降记为0</p>
<p>状态转移方程如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko1jzhrfj20e104zt8y.jpg" alt=""></p>
<p>求和部分用树状数组优化一下</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;1e5;</span><br><span class="line">const int p&#x3D;1e5+7;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x,y;</span><br><span class="line">&#125;a[N];</span><br><span class="line">int n,k,dp[12][N+5][2],tree[12][N+5][2];</span><br><span class="line">bool cmp(node a1,node a2)&#123;</span><br><span class="line">    return a1.x&lt;a2.x;</span><br><span class="line">&#125;</span><br><span class="line">int lowbit(int x)&#123;</span><br><span class="line">    return x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line">void add(int x,int kk,int op,int val)&#123;</span><br><span class="line">    while(x&lt;&#x3D;N)&#123;</span><br><span class="line">        tree[kk][x][op]&#x3D;(val+tree[kk][x][op])%p;</span><br><span class="line">        x+&#x3D;lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int query(int x,int kk,int op)&#123;</span><br><span class="line">    int res&#x3D;0;</span><br><span class="line">    while(x&gt;0)&#123;</span><br><span class="line">        res&#x3D;(res+tree[kk][x][op])%p;</span><br><span class="line">        x-&#x3D;lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)scanf(&quot;%d%d&quot;,&amp;a[i].x,&amp;a[i].y);</span><br><span class="line">    sort(a+1,a+n+1,cmp);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        dp[0][i][0]&#x3D;dp[0][i][1]&#x3D;1;</span><br><span class="line">        add(a[i].y,0,0,1);</span><br><span class="line">        add(a[i].y,0,1,1);</span><br><span class="line">        for(int kk&#x3D;1;kk&lt;&#x3D;k;kk++)&#123;</span><br><span class="line">            dp[kk][i][0]&#x3D;(dp[kk][i][0]+query(a[i].y-1,kk,0)+</span><br><span class="line">                query(a[i].y-1,kk-1,1))%p;</span><br><span class="line">            dp[kk][i][1]&#x3D;(((dp[kk][i][1]+query(N,kk,1)-query(a[i].y,kk,1)</span><br><span class="line">                +query(N,kk-1,0)-query(a[i].y,kk-1,0))%p)+p)%p;</span><br><span class="line">            add(a[i].y,kk,0,dp[kk][i][0]);</span><br><span class="line">            add(a[i].y,kk,1,dp[kk][i][1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans&#x3D;0;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">        ans&#x3D;(ans+dp[k][i][0]+dp[k][i][1])%p;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P1121 环状最大两段子段和（dp）</title>
    <url>/12cc27af/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko26rjhlj20kj0audgv.jpg" alt=""></p>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>如果是线性一段最大子段和，就利用<code>dp[r]=max(dp[r−1],0)+a[r]</code>，如果某段累计小于0就不要了</p>
<p>如果是线性一段最大子段和，就利用<code>dp[r]=min(dp[r−1],0)+a[r]</code>，如果某段累计大于0就不要了</p>
<p>如果是环状一段最大子段和，那么有两种情况，要么没有跨过分界点，就是原来的线性最大子段和，要么跨过分界点，那么反过来想，剩下的部分将是线性最小子段和（还有一种思路是数组加倍）</p>
<p>如果是线性两段最大子段和，那么必定会有一个分界点可以把序列分成两段，所以O(n)枚举分界点，分别求出[1,i]和[i+1,n]这两段的最大子段和，记f[i]为[1,i]的最大子段和，直接求即可，记g[i]为[i+1,n]的最大子段和，反着求即可</p>
<p>这题是环状两段最大子段和，有两种情况，要么两段最大子段和都没有跨过分界点，要么其中一个最大子段和跨过了分界点，前者直接按上面线性两段求即可，后者情况下，其实就是线性两段最小子段和，那么按照线性两段的做法就解决了</p>
<p><code>f_min[i]</code>为[1,i]的最小子段和，<code>f_max[i]</code>为[1,i]的最大子段和，<code>g_min[i]</code>为[i+1,n]的最小子段和，<code>g_max[i]</code>为[i+1,n]的最大子段和</p>
<p>然后wa在其中一组数据。。最后发现求结果的时候还有一点点小坑ಥ_ಥ，直接求出两段最小子段和minn和两段最大子段和maxx，然后比较sum-minn和maxx的大小是有点小问题的，比如下面这两个例子：<code>3 -1 -2 -3</code>，最小两段是-6，最大两段是-3，sum-minn=0，就会出现什么都不取是最大的情况</p>
<p>数据比较弱。。可能会非法的只取一个数没考虑也过了。。比如<code>3 -1 -3 9</code>，应该输出8，后来改了下重交了一遍，最后加一些特判即可</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;2e5+5;</span><br><span class="line">const int INF&#x3D;0x3f3f3f3f;</span><br><span class="line">int a[N],minn,maxx,g_min[N],g_max[N],f_min[N],f_max[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,sum&#x3D;0,ans;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">        sum+&#x3D;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    minn&#x3D;maxx&#x3D;f_min[1]&#x3D;f_max[1]&#x3D;a[1];</span><br><span class="line">    for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        minn&#x3D;min(minn,0)+a[i];</span><br><span class="line">        maxx&#x3D;max(maxx,0)+a[i];</span><br><span class="line">        f_min[i]&#x3D;min(f_min[i-1],minn);</span><br><span class="line">        f_max[i]&#x3D;max(f_max[i-1],maxx);</span><br><span class="line">    &#125;</span><br><span class="line">    minn&#x3D;maxx&#x3D;g_min[n]&#x3D;g_max[n]&#x3D;a[n];</span><br><span class="line">    for(int i&#x3D;n-1;i&gt;&#x3D;1;i--)&#123;</span><br><span class="line">        minn&#x3D;min(minn,0)+a[i];</span><br><span class="line">        maxx&#x3D;max(maxx,0)+a[i];</span><br><span class="line">        g_min[i]&#x3D;min(g_min[i+1],minn);</span><br><span class="line">        g_max[i]&#x3D;max(g_max[i+1],maxx);</span><br><span class="line">    &#125;</span><br><span class="line">    maxx&#x3D;-INF,minn&#x3D;INF;</span><br><span class="line">    for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">        minn&#x3D;min(minn,f_min[i]+g_min[i+1]);</span><br><span class="line">        maxx&#x3D;max(maxx,f_max[i]+g_max[i+1]);</span><br><span class="line">    &#125;</span><br><span class="line">    if(maxx&gt;sum-minn)ans&#x3D;maxx;</span><br><span class="line">    else if(sum&#x3D;&#x3D;minn)ans&#x3D;maxx;</span><br><span class="line">    else&#123;</span><br><span class="line">        ans&#x3D;sum-minn;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">            if(ans&#x3D;&#x3D;a[i])ans&#x3D;maxx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Pyspider+Python快乐下载百度图片</title>
    <url>/2da046f6/</url>
    <content><![CDATA[<h1 id="1-Pyspider安装"><a href="#1-Pyspider安装" class="headerlink" title="1.Pyspider安装"></a>1.Pyspider安装</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install pyspider</span><br><span class="line">或（根据版本来）</span><br><span class="line">pip3 install pyspider</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>安装过程中可能出现的问题 -&gt; <a href="https://leflacon.github.io/5e90e18e/" target="_blank" rel="noopener">macOS下安装Python第三方库报错“Command “python setup.py egg_info” failed with error code 1”的解决办法（附如何卸载自己安装的python）</a></p>
<p>如果要使用网页的动态解析，那么还需要安装phantomjs</p>
<h1 id="2-启动Pyspider"><a href="#2-启动Pyspider" class="headerlink" title="2.启动Pyspider"></a>2.启动Pyspider</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyspider</span><br><span class="line">或</span><br><span class="line">pyspider all</span><br></pre></td></tr></table></figure>

<p>然后访问<code>http://localhost:5000/</code></p>
<p>运行可能出现的问题 -&gt; <a href="https://leflacon.github.io/7bbef420/" target="_blank" rel="noopener">macOS下安装Pyspider和安装完成后command not found的解决办法（包括python环境变量配置）</a></p>
<h1 id="3-入门教程"><a href="#3-入门教程" class="headerlink" title="3.入门教程"></a>3.入门教程</h1><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knyrzgdkj20m80aiac9.jpg" alt=""></p>
<p>官方项目地址 -&gt; <a href="https://github.com/binux/pyspider" target="_blank" rel="noopener">https://github.com/binux/pyspider</a></p>
<p>官方入门教程 -&gt; <a href="http://docs.pyspider.org/en/latest/Quickstart/" target="_blank" rel="noopener">http://docs.pyspider.org/en/latest/Quickstart/</a></p>
<h2 id="3-1新建项目"><a href="#3-1新建项目" class="headerlink" title="3.1新建项目"></a>3.1新建项目</h2><p>启动pyspider之后就可以开始新建项目了，WebUI如下图：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knyrtewjj2140099dgx.jpg" alt=""></p>
<p>pyspider所有代码都可以在WebUI里完成，点击最右边<code>create</code>创建一个新项目</p>
<p>随便写个项目名，下面的URL就是要爬取的网页，当然可以先不写，直接在代码里写上</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knyrtmgjj20hq0a9gm6.jpg" alt=""></p>
<p>然后就可以进入编辑区了（左边是输出区，右边是代码区）</p>
<p>run的作用是「单步调试」</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knzn6z82j21400jcgoq.jpg" alt=""></p>
<h2 id="3-2代码区"><a href="#3-2代码区" class="headerlink" title="3.2代码区"></a>3.2代码区</h2><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knztk0ntj20eg09fdgx.jpg" alt=""></p>
<p><code>def on_start(self)</code>是脚本的入口点，如果按<code>run</code>就会调用它</p>
<p><code>self.crawl(&#39;__START_URL__&#39;, callback=self.index_page)</code>是这里最重要的API，添加一个爬取新任务，<code>__START_URL__</code>处输入要爬取的网站，通过<code>self.crawl</code>的参数进行详细设置</p>
<p><code>def index_page(self, response)</code>得到一个<code>Response</code>对象，<code>response.doc</code>是一个<code>pyquery</code>对象，它具有类似<code>jQuery</code>的API来选择要提取的元素</p>
<p><code>def detail_page(self, response)</code>返回一个dict对象作为结果，结果将默认被捕获到<code>resultdb</code>中</p>
<h2 id="3-3运行脚本"><a href="#3-3运行脚本" class="headerlink" title="3.3运行脚本"></a>3.3运行脚本</h2><h3 id="1）-保存脚本"><a href="#1）-保存脚本" class="headerlink" title="1）.保存脚本"></a>1）.保存脚本</h3><p>以下脚本参考自 -&gt; <a href="https://blog.csdn.net/u013919836/article/details/68066715" target="_blank" rel="noopener">https://blog.csdn.net/u013919836/article/details/68066715</a></p>
<p>url就是输入百度搜索词之后的url</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- encoding: utf-8 -*-</span><br><span class="line"># Created on 2019-02-06 23:19:59</span><br><span class="line"># Project: square_face</span><br><span class="line"></span><br><span class="line">from pyspider.libs.base_handler import *</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">#图片存放目录</span><br><span class="line">DIR_PATH &#x3D; &quot;&#x2F;Users&#x2F;mac&#x2F;Desktop&#x2F;project&#x2F;square_face&quot;</span><br><span class="line"></span><br><span class="line">class Handler(BaseHandler):</span><br><span class="line">    crawl_config &#x3D; &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">   	 #这里改为要爬取的url</span><br><span class="line">        self.base_url &#x3D; &quot;https:&#x2F;&#x2F;image.baidu.com&#x2F;search&#x2F;index?tn&#x3D;baiduimage&amp;ipn&#x3D;r&amp;ct&#x3D;201326592&amp;cl&#x3D;2&amp;lm&#x3D;-1&amp;st&#x3D;-1&amp;fm&#x3D;result&amp;fr&#x3D;&amp;sf&#x3D;1&amp;fmq&#x3D;1549435927208_R&amp;pv&#x3D;&amp;ic&#x3D;&amp;nc&#x3D;1&amp;z&#x3D;&amp;hd&#x3D;&amp;latest&#x3D;&amp;copyright&#x3D;&amp;se&#x3D;1&amp;showtab&#x3D;0&amp;fb&#x3D;0&amp;width&#x3D;&amp;height&#x3D;&amp;face&#x3D;0&amp;istype&#x3D;2&amp;ie&#x3D;utf-8&amp;word&#x3D;%E6%96%B9%E8%84%B8&quot;</span><br><span class="line">        self.dir_path &#x3D; DIR_PATH</span><br><span class="line">        self.tool &#x3D; Tool()</span><br><span class="line"></span><br><span class="line">    @every(minutes&#x3D;24 * 60)</span><br><span class="line">    def on_start(self):</span><br><span class="line">        #validate_cert:是否验证SSL；fetch_type：为了支持JS</span><br><span class="line">        self.crawl(self.base_url, callback&#x3D;self.index_page, validate_cert&#x3D;False, fetch_type&#x3D;&quot;js&quot;)</span><br><span class="line"></span><br><span class="line">    @config(age&#x3D;10 * 24 * 60 * 60)</span><br><span class="line">    def index_page(self, response):</span><br><span class="line">        count &#x3D; 1</span><br><span class="line">        #获取图片详情链接标签列表</span><br><span class="line">        for each in response.doc(&#39;.imgbox a&#39;).items():</span><br><span class="line">            url &#x3D; each.attr.href</span><br><span class="line">            #进入图片详情页</span><br><span class="line">            self.crawl(url, callback&#x3D;self.detail_page,validate_cert&#x3D;False, fetch_type&#x3D;&quot;js&quot;,save&#x3D;&#123;&quot;count&quot;:count&#125;)</span><br><span class="line">            count +&#x3D;1</span><br><span class="line"></span><br><span class="line">    @config(priority&#x3D;2)</span><br><span class="line">    def detail_page(self, response):</span><br><span class="line">        #获取图片标签</span><br><span class="line">        imgElem &#x3D; response.doc(&quot;.currentImg&quot;)</span><br><span class="line">        #获取图片地址</span><br><span class="line">        imgUrl &#x3D; imgElem.attr.src</span><br><span class="line">        if imgUrl:</span><br><span class="line">            #获取图片文件后缀</span><br><span class="line">            extension &#x3D; self.tool.get_extension(imgUrl)</span><br><span class="line">            #拼接图片名</span><br><span class="line">            file_name &#x3D; str(response.save[&quot;count&quot;]) + &quot;.&quot; + extension</span><br><span class="line">            self.crawl(imgUrl,callback&#x3D;self.save_img,save&#x3D;&#123;&quot;file_name&quot;:file_name&#125;,validate_cert&#x3D;False)</span><br><span class="line"></span><br><span class="line">    #保存图片</span><br><span class="line">    def save_img(self,response):</span><br><span class="line">        content &#x3D; response.content</span><br><span class="line">        file_name &#x3D; response.save[&quot;file_name&quot;]</span><br><span class="line">        file_path &#x3D; self.dir_path + os.path.sep + file_name</span><br><span class="line">        self.tool.save_img(content,file_path)</span><br><span class="line"></span><br><span class="line">#工具类    </span><br><span class="line">class Tool:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.dir &#x3D; DIR_PATH</span><br><span class="line">        #创建文件夹（如果不存在）</span><br><span class="line">        if not os.path.exists(self.dir):                         </span><br><span class="line">            os.makedirs(self.dir)                                         </span><br><span class="line">    #保存图片</span><br><span class="line">    def save_img(self,content,path):</span><br><span class="line">        f &#x3D; open(path,&quot;wb&quot; )</span><br><span class="line">        f.write(content)</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line">    #获取url后缀名</span><br><span class="line">    def get_extension(self,url):                            </span><br><span class="line">        extension &#x3D; url.split(&quot;.&quot;)[-1]</span><br><span class="line">        return extension</span><br></pre></td></tr></table></figure>

<h3 id="2）-返回dashboard找到项目"><a href="#2）-返回dashboard找到项目" class="headerlink" title="2）.返回dashboard找到项目"></a>2）.返回dashboard找到项目</h3><h3 id="3）-将状态改为DEBUG或者RUNNING"><a href="#3）-将状态改为DEBUG或者RUNNING" class="headerlink" title="3）.将状态改为DEBUG或者RUNNING"></a>3）.将状态改为<code>DEBUG</code>或者<code>RUNNING</code></h3><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko0bxusmj209w04raa5.jpg" alt=""></p>
<h3 id="4）-按下run按钮"><a href="#4）-按下run按钮" class="headerlink" title="4）.按下run按钮"></a>4）.按下<code>run</code>按钮</h3><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko0bxq86j20ki0380sw.jpg" alt=""></p>
<p>然后就坐着随便干点啥等待收图吧∠( ᐛ 」∠)＿</p>
<h2 id="3-4删除项目"><a href="#3-4删除项目" class="headerlink" title="3.4删除项目"></a>3.4删除项目</h2><p>将项目名前的<code>group</code>改为<code>delete</code></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko0bxstgj20fl01q749.jpg" alt=""></p>
<p>状态改为<code>stop</code></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4ko0pbaj1j208u038q2x.jpg" alt=""></p>
<p>24小时后就自动删除啦</p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Hello 2019（A-D，F）</title>
    <url>/9bc57035/</url>
    <content><![CDATA[<h1 id="A-Gennady-and-a-Card-Game"><a href="#A-Gennady-and-a-Card-Game" class="headerlink" title="A. Gennady and a Card Game"></a>A. Gennady and a Card Game</h1><p><a href="https://codeforces.com/contest/1097/problem/A" target="_blank" rel="noopener">https://codeforces.com/contest/1097/problem/A</a></p>
<a id="more"></a>

<p>题意：输入一对（两个）字符，然后输入五对字符，如果前一个字符或者后一个字符任意有一个出现，就输出YES</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    char c;</span><br><span class="line">    char a&#x3D;getchar(),b&#x3D;getchar();</span><br><span class="line">    getchar();</span><br><span class="line">    int t&#x3D;10,flag&#x3D;0;</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">    	if(t&amp;1)&#123;</span><br><span class="line">    		c&#x3D;getchar();</span><br><span class="line">    		if(c&#x3D;&#x3D;a)flag&#x3D;1;</span><br><span class="line">    	&#125;</span><br><span class="line">    	else&#123;</span><br><span class="line">    		c&#x3D;getchar();</span><br><span class="line">    		if(c&#x3D;&#x3D;b)flag&#x3D;1;</span><br><span class="line">    		getchar();</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag)puts(&quot;YES&quot;);</span><br><span class="line">    else puts(&quot;NO&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-Petr-and-a-Combination-Lock（dfs）"><a href="#B-Petr-and-a-Combination-Lock（dfs）" class="headerlink" title="B. Petr and a Combination Lock（dfs）"></a>B. Petr and a Combination Lock（dfs）</h1><p><a href="https://codeforces.com/contest/1097/problem/B" target="_blank" rel="noopener">https://codeforces.com/contest/1097/problem/B</a></p>
<p>题意：在360度的盘上，旋转n次，一次ai度，可以顺时针旋转也可以逆时针，问最后有没有可能回到0度的位置</p>
<p>就是问有没有可能求和得到<code>(∑ai)/2</code>，n=15，暴力dfs枚举之</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int a[16],n,flag&#x3D;0;</span><br><span class="line">void dfs(int m,int sum)&#123;</span><br><span class="line">	&#x2F;&#x2F; cout&lt;&lt;m&lt;&lt;&quot; &quot;&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">	if(m&#x3D;&#x3D;n)&#123;</span><br><span class="line">		if(sum%360&#x3D;&#x3D;0)flag&#x3D;1;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(m+1,sum+a[m]);</span><br><span class="line">	dfs(m+1,sum-a[m]);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    dfs(0,0);</span><br><span class="line">    if(flag)puts(&quot;YES&quot;);</span><br><span class="line">	else puts(&quot;NO&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-Yuhao-and-a-Parenthesis（stack）"><a href="#C-Yuhao-and-a-Parenthesis（stack）" class="headerlink" title="C. Yuhao and a Parenthesis（stack）"></a>C. Yuhao and a Parenthesis（stack）</h1><p><a href="https://codeforces.com/contest/1097/problem/C" target="_blank" rel="noopener">https://codeforces.com/contest/1097/problem/C</a></p>
<p>题意：给n个不合法括号序列，两两配对，最多能产生几个合法括号序列。举例，合法：<code>&quot;(())()&quot;, &quot;()&quot; and &quot;(()(()))&quot;</code> ，不合法： <code>&quot;)(&quot;, &quot;(()&quot; and &quot;(()))(&quot;</code></p>
<p>每个括号序列都可以用栈把已经合法的部分除去，用正数表示右括号个数，负数表示左括号个数，<code>()()</code>这种就是0，<code>()())))</code>这种就是3，<code>()(((</code>这种记为-3，<code>)(</code>这种不可能合法的不用管它，最后配对一下就好了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;5e5+5;</span><br><span class="line">string s;</span><br><span class="line">int a[N*2],ans&#x3D;0;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    memset(a,0,sizeof(a));</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">    	cin&gt;&gt;s;</span><br><span class="line">    	int sum&#x3D;0;</span><br><span class="line">    	stack&lt;char&gt;ss;</span><br><span class="line">    	int l&#x3D;0,r&#x3D;0;</span><br><span class="line">    	for(int j&#x3D;0;j&lt;s.length();j++)&#123;</span><br><span class="line">    		if(s[j]&#x3D;&#x3D;&#39;(&#39;)&#123;</span><br><span class="line">    			ss.push(s[j]);</span><br><span class="line">    			l++;</span><br><span class="line">    		&#125;</span><br><span class="line">    		else&#123;</span><br><span class="line">    			if(!ss.empty()&amp;&amp;ss.top()&#x3D;&#x3D;&#39;(&#39;)&#123;</span><br><span class="line">    				ss.pop();</span><br><span class="line">    				l--;</span><br><span class="line">    			&#125;</span><br><span class="line">    			else&#123;</span><br><span class="line">    				ss.push(s[j]);</span><br><span class="line">    				r++;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	if(r&#x3D;&#x3D;0)sum&#x3D;-l;</span><br><span class="line">    	else if(l&#x3D;&#x3D;0)sum&#x3D;r;</span><br><span class="line">    	else continue;</span><br><span class="line">    	if(sum&lt;&#x3D;0)a[-sum]++;</span><br><span class="line">    	else a[sum+N]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;0;i&lt;N;i++)&#123;</span><br><span class="line">    	int num&#x3D;min(a[i],a[i+N]);</span><br><span class="line">    	ans+&#x3D;num;</span><br><span class="line">    &#125;</span><br><span class="line">    ans+&#x3D;(a[0]&#x2F;2);</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-Makoto-and-a-Blackboard（期望dp，积性函数）"><a href="#D-Makoto-and-a-Blackboard（期望dp，积性函数）" class="headerlink" title="D. Makoto and a Blackboard（期望dp，积性函数）"></a>D. Makoto and a Blackboard（期望dp，积性函数）</h1><p><a href="https://codeforces.com/contest/1097/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1097/problem/D</a></p>
<p>题意：一个数n，一个次数k，每次可以把n用他的因子代替，求k次之后n的期望，比如n=6，k=1，答案就是<code>(1+2+3+6)/4=3</code>，要求最后分母用逆元处理</p>
<blockquote>
<p>【积性函数】—— 以下摘自wiki</p>
<p>在数论中，积性函数是指一个定义域为正整数n 的算术函数f(n)，有如下性质：f(1) = 1，且当a 和b 互质时，f(ab) = f(a) f(b)。</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knoi3cnpj20w60cvq5h.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knoi3qubj20v303ddgg.jpg" alt=""></p>
</blockquote>
<p>这是个积性函数，根据上图性质，就会有它的期望是它质因子期望的乘积，那么就可以快乐dp了，对某质因子p考虑，<code>dp[i][j]</code>代表i次操作后x^j这个数的概率</p>
<p>状态转移方程：<code>k范围[0,j]，dp[i+1][k]+=dp[i][j]/j+1</code>，即<code>0≤k≤j,dp[i+1][k]+=dp[i][j]*inv[j+1]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;1e4+5;</span><br><span class="line">const int p&#x3D;1e9+7;</span><br><span class="line">LL dp[N][62],n,kk,inv[62];</span><br><span class="line">LL qpow(LL a,LL b)&#123;</span><br><span class="line">	LL res&#x3D;1;</span><br><span class="line">	a%&#x3D;p;</span><br><span class="line">	while(b)&#123;</span><br><span class="line">		if(b&amp;1)res&#x3D;(res*a)%p;</span><br><span class="line">		a&#x3D;(a*a)%p;</span><br><span class="line">		b&gt;&gt;&#x3D;1;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line">LL get_dp(LL x,LL y)&#123;</span><br><span class="line">	memset(dp,0,sizeof(dp));</span><br><span class="line">	dp[0][y]&#x3D;1;</span><br><span class="line">	for(int i&#x3D;0;i&lt;kk;i++)&#123;</span><br><span class="line">		for(int j&#x3D;0;j&lt;&#x3D;y;j++)&#123;</span><br><span class="line">			if(dp[i][j])</span><br><span class="line">				for(int k&#x3D;0;k&lt;&#x3D;j;k++)</span><br><span class="line">					dp[i+1][k]&#x3D;(dp[i+1][k]+(dp[i][j]*inv[j+1])%p)%p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	LL num&#x3D;1,res&#x3D;0;</span><br><span class="line">	for(int i&#x3D;0;i&lt;&#x3D;y;i++)&#123;</span><br><span class="line">		res&#x3D;(res+num*dp[kk][i]%p)%p;</span><br><span class="line">		num&#x3D;(num*x)%p;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	inv[1]&#x3D;1;</span><br><span class="line">	for(int i&#x3D;2;i&lt;61;i++)inv[i]&#x3D;qpow(i,p-2);</span><br><span class="line">	scanf(&quot;%lld%lld&quot;,&amp;n,&amp;kk);</span><br><span class="line">	LL ans&#x3D;1;</span><br><span class="line">	for(LL i&#x3D;2;i*i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		int num&#x3D;0;</span><br><span class="line">		while(n%i&#x3D;&#x3D;0)&#123;</span><br><span class="line">			num++;</span><br><span class="line">			n&#x2F;&#x3D;i;</span><br><span class="line">		&#125;</span><br><span class="line">		if(num)ans&#x3D;(ans*get_dp(i,num)%p)%p;</span><br><span class="line">		&#x2F;&#x2F; if(num)cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;num&lt;&lt;&quot; &quot;&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">	if(n&gt;1)ans&#x3D;(ans*get_dp(n,1)%p)%p;</span><br><span class="line">	printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E-Egor-and-an-RPG-game（LIS）"><a href="#E-Egor-and-an-RPG-game（LIS）" class="headerlink" title="E. Egor and an RPG game（LIS）"></a>E. Egor and an RPG game（LIS）</h1><p><a href="https://codeforces.com/contest/1097/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1097/problem/E</a></p>
<p>题意：给一个长为n的序列，需要把它分成几个非空子序列，每个子序列都是单调的（递增或递减），f(n)是满足所有长度为n的排列都能分成上述序列的最小k值，（也就是长度为n的排列最多分成k个子序列），要求最后分成的序列至多为f(n)个，并输出一种方案</p>
<p>先考虑f(n)，对于n个数的任意排列来说，最差的情况也就是k最大的时候，先一个数字在两个倒序再三个倒序再四个倒序……比如10个数就是<code>1，3，2，6，5，4，10，9，8，7</code>，这样共需要<code>k(k+1)/2≥n</code>，k是满足此条件的最小的k，也就是要求的f(n)</p>
<p>然后开始考虑一种方案，不会了。。先mark</p>
<h1 id="F-Alex-and-a-TV-Show（莫比乌斯反演-bitset）"><a href="#F-Alex-and-a-TV-Show（莫比乌斯反演-bitset）" class="headerlink" title="F. Alex and a TV Show（莫比乌斯反演+bitset）"></a>F. Alex and a TV Show（莫比乌斯反演+bitset）</h1><p><a href="https://codeforces.com/contest/1097/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1097/problem/F</a></p>
<p>题意：维护n个集合，有四种操作</p>
<p>1）1 x v：将第x个集合变成{v}<br>2）2 x y z：将第x个集合变成<code>第y个集合∪第z个集合</code><br>3）3 x y z：将第x个集合变成<code>第y个集合×第z个集合</code>，<code>×</code>是y集合中的任意元素a和z集合中的任意元素b产生的<code>gcd(a,b)</code>组成的集合（有重复）<br>4）4 x v：查询第x个集合中数字v出现的奇偶性</p>
<p>首先只要求奇偶性，所以可以想到对于每一个集合维护一个bitset，第i位表示数字i作为因子在某集合出现次数的奇偶性，那么1）就是<code>√v</code>处理一遍因子，2）就是两个二进制异或一下，3）就是两个二进制数与一下</p>
<p>然后考虑4）怎么求，因为bitset第i位表示数字i作为因子在某集合出现次数的奇偶性，所以显然是个莫比乌斯反演</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knp2dwg2j209r04wgls.jpg" alt=""></p>
<p>这里记f(d)为某集合中数字d的出现次数，g(n)表示某集合因子n出现的次数，那么反演会得到：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knp7b8s2j2095067jrw.jpg" alt=""></p>
<p>然后就可以做了，此外对于奇偶性的影响，mu是+1-1都一样，所以都换成1，<code>mu_[n][d]</code>用来存<code>mu([d/n])</code>，这样<code>mu_[n]</code>就可以直接与<code>a[x]&amp;mu_[y]</code>得到要求的f(y)，也就是第x个集合中数字y出现的次数，相当清爽</p>
<p>最后。。被7000卡了半天。。求mu的时候上限用的N然后一直T，改成7000之后好了。。明明本地可以出结果的0.0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;bitset&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;7005;</span><br><span class="line">int n,q,mu[N],prime[N],vis[N];</span><br><span class="line">bitset&lt;N&gt;a[100005],mu_[N],num[N];</span><br><span class="line">void mobius()&#123;</span><br><span class="line">    memset(vis,false,sizeof(vis));</span><br><span class="line">    mu[1]&#x3D;1;</span><br><span class="line">    int ji&#x3D;0;</span><br><span class="line">    for(int i&#x3D;2;i&lt;&#x3D;7000;i++)&#123;</span><br><span class="line">        if(!vis[i])&#123;</span><br><span class="line">            prime[ji++]&#x3D;i;</span><br><span class="line">            mu[i]&#x3D;-1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j&#x3D;0;j&lt;ji;j++)&#123;</span><br><span class="line">            if(i*prime[j]&gt;7000)break;</span><br><span class="line">            vis[i*prime[j]]&#x3D;true;</span><br><span class="line">            if(i%prime[j]&#x3D;&#x3D;0)&#123;</span><br><span class="line">                mu[i*prime[j]]&#x3D;0;break;</span><br><span class="line">            &#125;</span><br><span class="line">            else mu[i*prime[j]]&#x3D;-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;n,&amp;q);</span><br><span class="line">	mobius();</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;7000;i++)&#123;</span><br><span class="line">    	for(int j&#x3D;i;j&lt;&#x3D;7000;j+&#x3D;i)&#123;</span><br><span class="line">    		mu_[i][j]&#x3D;mu[j&#x2F;i]!&#x3D;0;</span><br><span class="line">    		num[j][i]&#x3D;1;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	int op,x,y,z;</span><br><span class="line">	string s;</span><br><span class="line">	while(q--)&#123;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;,&amp;op,&amp;x,&amp;y);</span><br><span class="line">		if(op&#x3D;&#x3D;1)a[x]&#x3D;num[y];</span><br><span class="line">		else if(op&#x3D;&#x3D;2)&#123;</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;z);</span><br><span class="line">			a[x]&#x3D;a[y]^a[z];</span><br><span class="line">		&#125;</span><br><span class="line">		else if(op&#x3D;&#x3D;3)&#123;</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;z);</span><br><span class="line">			a[x]&#x3D;a[y]&amp;a[z];</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			if((a[x]&amp;mu_[y]).count()&amp;1)putchar(&#39;1&#39;);</span><br><span class="line">			else putchar(&#39;0&#39;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="G-Vladislav-and-a-Great-Legend"><a href="#G-Vladislav-and-a-Great-Legend" class="headerlink" title="G. Vladislav and a Great Legend"></a>G. Vladislav and a Great Legend</h1><p><a href="https://codeforces.com/contest/1097/problem/G" target="_blank" rel="noopener">https://codeforces.com/contest/1097/problem/G</a></p>
<h1 id="H-Mateusz-and-an-Infinite-Sequence"><a href="#H-Mateusz-and-an-Infinite-Sequence" class="headerlink" title="H. Mateusz and an Infinite Sequence"></a>H. Mateusz and an Infinite Sequence</h1><p><a href="https://codeforces.com/contest/1097/problem/H" target="_blank" rel="noopener">https://codeforces.com/contest/1097/problem/H</a></p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>dp</tag>
        <tag>搜索</tag>
        <tag>cf</tag>
      </tags>
  </entry>
  <entry>
    <title>Mixed Content ”The page at &#39;xxxdomain&#39; was loaded over HTTPS, but requested an insecure script &#39;xxx&#39;.This request has been blocked.the content must be served over HTTPS“ 的解决办法</title>
    <url>/128c2cae/</url>
    <content><![CDATA[<p>本来是给博客加了个JQuery+Html5实现的3D雪花飞舞特效。。因为gif的雪花太辣鸡了。。想着过年装修一下的。。</p>
<p>这是教程原文 -&gt; <a href="https://www.yaxi.net/2016-12-28/1211.html" target="_blank" rel="noopener">JQuery+Html5实现超真实3D雪花飞舞特效</a></p>
<p>然后本地预览啥的都没问题，效果贼满意</p>
<center><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fzs6ryc7eig30dc08wx6p.gif" width = "600
" height = "250" ></center>

<p>但是上传后啥特效都没有。。跑去控制台一看。。果然出问题了</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knt17divj20fd03ewf2.jpg" alt=""></p>
<p><code>Mixed Content: The page at &#39;xxx_domain&#39; was loaded over HTTPS, but requested an insecure script &#39;http://apps.bdimg.com/libs/jquery/1.7.2/jquery.min.js&#39;. This request has been blocked; the content must be served over HTTPS.</code></p>
<p>翻译一下就是，这个页面是通过https加载的，但是请求了一个不安全的脚本jquery，所以这个请求被阻止了，内容必须通过https提供</p>
<p>下图是原先的代码：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knt19ov5j20er08pt9r.jpg" alt=""></p>
<p>顺便这段要放在<code>&lt;body&gt;</code>里的最后，但又要在<code>&lt;footer&gt;</code>前面。。不知道为啥。。原作者是说“将如下代码放入<body>后即可，推荐放在底部，不影响别的内容加载”，然后我试了几次得到了这个结果，别的位置都显示不了。。</p>
<p>上文说到http请求jquery库不安全，所以在代码中直接改成https，可以访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;http:&#x2F;&#x2F;apps.bdimg.com&#x2F;libs&#x2F;jquery&#x2F;1.7.2&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">+</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;apps.bdimg.com&#x2F;libs&#x2F;jquery&#x2F;1.7.2&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>这种方法。。简单粗暴有效（我最终使用的就是这种简单粗暴有效的方法∠( ᐛ 」∠)＿）</p>
<p>还有一种方法是在页面的<code>&lt;head&gt;</code>中加上一句话，可以自动把不安全的http请求转化为https请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv&#x3D;&quot;Content-Security-Policy&quot; content&#x3D;&quot;upgrade-insecure-requests&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>其他还有<code>CSP设置upgrade-insecure-requests</code>的方法，不是很懂。。具体见这篇博客 -&gt; <a href="https://www.cnblogs.com/hustskyking/p/upgrade-insecure-requests.html" target="_blank" rel="noopener">https://www.cnblogs.com/hustskyking/p/upgrade-insecure-requests.html</a>）</p>
<p>然后上传一下就成功下雪啦<code>(((o(*ﾟ▽ﾟ*)o)))</code></p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>❄️ 宇宙よりも遠い場所</title>
    <url>/a2936721/</url>
    <content><![CDATA[<center>

<p>比宇宙更远的地方</p>
<center><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knuovq0ej20ci0goad2.jpg" width = "270
" height = "360" ></center>

</center>

<a id="more"></a>

<center>

<p>这部番！吹就完事了！！全是小天使！！！吃了安利没有错过真是太好了TAT</p>
</center>

<hr>
<center>

<p>开始尝试没做过的事情时 我总是在想万一做不好该怎么办 失败的话会很不爽吧 会后悔吧…</p>
</center>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knup0bpqj20w20i3gpu.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knuozwx5j20w10i3di5.jpg" alt=""></p>
<center>

<p>那…要不要一起去？</p>
</center>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knvtsdbej20w50i3jv1.jpg" alt=""></p>
<center>

<p>乘上与平时方向相反的电车 为了去看未曾见过的风景</p>
</center>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knvzx8xpj20w00i1acv.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knw66sgvj20w40i1q6m.jpg" alt=""></p>
<center>

<p>当你无法回头的时候 才是真正的旅途</p>
</center>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knw69nf3j20w00i1td6.jpg" alt=""></p>
<center>

<p>人性中是有恶意的 不要以恶意去应对恶意 昂首挺胸吧</p>
</center>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knw69bgsj20w20i20wk.jpg" alt=""></p>
<center>

<p>选项一直都有 但是我们选择了这里 是我们自己选择的</p>
</center>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knwlhp46j20w60i30v1.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knwlikegj20w40i2q5b.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knwlikasj20w40i440w.jpg" alt=""></p>
<center>

<p>令时针转动最快的就是忙碌的工作</p>
</center>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knwy21i9j20vy0i141o.jpg" alt=""></p>
<center>

<p>我想和无拘无束的人去什么都没有的地方</p>
</center>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knwy331cj20vz0i1q7f.jpg" alt=""></p>
<center>

<p>但是 只有内心的想法才能突破现实中的不讲道理 令不可能成为可能 推动自己前进</p>
</center>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knx6s6a3j20vz0i2q6p.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knx6snz7j20w10i2adn.jpg" alt=""></p>
<hr>
<center><font size="12" color=#5959ff>J</font><font size="12" color=#a5b2ff>’</font><font size="8" color=#8888fd>a</font><font size="8" color=#7762fd>i</font><font size="8" color=#f1a8ce>m</font><font size="8" color=#a97afd>e </font><font size="8" color=#a7a7f5>m</font><font size="8" color=#628dfd>a </font><font size="8" color=#6363ff>v</font><font size="8" color=#8e64ff>i</font><font size="8" color=#ffafc7>e</font></center>

<hr>
]]></content>
      <categories>
        <category>love&amp;peace</category>
      </categories>
  </entry>
  <entry>
    <title>51nod 1533 一堆的堆 / cf 538 F. A Heap of Heaps（树状数组+思维）</title>
    <url>/b176e6f8/</url>
    <content><![CDATA[<p><a href="https://www.51nod.com/Challenge/Problem.html#!#problemId=1533" target="_blank" rel="noopener">https://www.51nod.com/Challenge/Problem.html#!#problemId=1533</a></p>
<p><a href="https://codeforces.com/problemset/problem/538/F" target="_blank" rel="noopener">https://codeforces.com/problemset/problem/538/F</a></p>
<a id="more"></a>

<p>2 秒  131,072 KB 80 分 5 级题</p>
<p>现在有一个长度为n的数组 𝑎1, 𝑎2, …, 𝑎𝑛 。然后对于k从1到 n-1分别对该数组建k叉堆。现在要统计对于每一个k叉堆，里面有多少结点是不满足最小堆的性质的。即值比父亲的要小的结点有多少个。</p>
<p>k叉堆的定义是这样的：数组的下标从1到n编号，对于某一个编号为v的结点，他的k个儿子编号是 𝑘(𝑣 − 1) + 2, …, 𝑘𝑣 + 1 （如果其中某些编号超出n，那些编号就不要）。在k叉堆中，除了根以外，每一个结点都有一个父亲。p(v)表示结点v的父亲。那么一个非根结点不满足最小堆性质当且仅当 𝑎𝑣 &lt; 𝑎𝑝(𝑣) </p>
<p>样例解释：</p>
<p>下面四个图分别对应k=1,2,3,4的情况。</p>
<p>非法结点用红色标记。</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knxt25nqj200u07at8k.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knxt28aqj2092044t8n.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kny3q8eaj204c044jr9.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kny3q7f4j20ao02kt8n.jpg" alt=""></p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>单组测试数据。<br>第一行有一个整数 n (2≤n≤2*10^5)。<br>第二行有n个用空格分开的整数a1, …, an (-10^9≤ai≤10^9)。</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出n-1个数字，第k个数字代表k叉堆中不满足最小堆性质的结点数目 （k=1, 2, …, n-1）。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 5 4 3 2</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2 1 0</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>给一个数组建完全k叉树，k范围[1,n-1]，问每个k对应的不满足最小堆性质的结点个数</p>
<p>用树状数组的很巧妙的题，好不容易才豁然开朗别人的代码（据说主席树也可以苟一苟，但是我不会主席数啊0.0）</p>
<p>如果对每个结点暴力统计它的儿子是不是比他小，时间肯定不允许，所以要想怎么快速求出一个点几个儿子比他大</p>
<p>先对数组先排个序，这样从小的数开始处理，（一样大的一批处理），一个节点对应的儿子区间是<code>[min(n,kv+1),k(v-1)+2]</code>，小的数后面肯定是大的数，不可能会出现非法节点，然后处理完小的数之后维护树状数组，对小的数对应的权重单点修改+1，这样在后面处理大的数的时候询问就会算上这些更新后的权重了</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;2e5+5;</span><br><span class="line">int n,tree[N],ans[N];</span><br><span class="line">struct node&#123;</span><br><span class="line">	int num,value;</span><br><span class="line">&#125;a[N];</span><br><span class="line">bool cmp(node a,node b)&#123;</span><br><span class="line">	return a.value&lt;b.value;</span><br><span class="line">&#125;</span><br><span class="line">int lowbit(int x)&#123;</span><br><span class="line">	return x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line">void add(int x,int val)&#123;</span><br><span class="line">	while(x&lt;&#x3D;n)&#123;</span><br><span class="line">		tree[x]+&#x3D;val;</span><br><span class="line">		x+&#x3D;lowbit(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int query(int x)&#123;</span><br><span class="line">	int res&#x3D;0;</span><br><span class="line">	while(x&gt;0)&#123;</span><br><span class="line">		res+&#x3D;tree[x];</span><br><span class="line">		x-&#x3D;lowbit(x);</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		a[i].num&#x3D;i;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;a[i].value);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(a+1,a+n+1,cmp);</span><br><span class="line">	memset(tree,0,sizeof(tree));</span><br><span class="line">	memset(ans,0,sizeof(ans));</span><br><span class="line">	int u&#x3D;1,p;</span><br><span class="line">	while(u&lt;&#x3D;n)&#123;</span><br><span class="line">		p&#x3D;u;</span><br><span class="line">		while(p&lt;&#x3D;n&amp;&amp;a[p].value&#x3D;&#x3D;a[u].value)p++;</span><br><span class="line">		for(int j&#x3D;u;j&lt;p;j++)&#123;</span><br><span class="line">			int v&#x3D;a[j].num;</span><br><span class="line">			for(int k&#x3D;1;k&lt;&#x3D;n-1&amp;&amp;k*(v-1)+2&lt;&#x3D;n;k++)&#123;</span><br><span class="line">				ans[k]+&#x3D;query(min(n,k*v+1))-query(k*(v-1)+1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int j&#x3D;u;j&lt;p;j++)add(a[j].num,1);</span><br><span class="line">		u&#x3D;p;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;1;i&lt;n-1;i++)printf(&quot;%d &quot;,ans[i]);</span><br><span class="line">	printf(&quot;%d\n&quot;,ans[n-1]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>cf</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1556 Color the ball（树状数组）</title>
    <url>/e7eed6b5/</url>
    <content><![CDATA[<p>Time Limit: 9000/3000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>N个气球排成一排，从左到右依次编号为1,2,3….N.每次给定2个整数a b(a &lt;= b),lele便为骑上他的“小飞鸽”牌电动车从气球a开始到气球b依次给每个气球涂一次颜色。但是N次以后lele已经忘记了第I个气球已经涂过几次颜色了，你能帮他算出每个气球被涂过几次颜色吗？</p>
<a id="more"></a>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>每个测试实例第一行为一个整数N,(N &lt;= 100000).接下来的N行，每行包括2个整数a b(1 &lt;= a &lt;= b &lt;= N)。<br>当N = 0，输入结束。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>每个测试实例输出一行，包括N个整数，第I个数代表第I个气球总共被涂色的次数。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">3 3</span><br><span class="line">3</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">0</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 1 1</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>基本区间修改+单点查询</p>
<p>树状数组区间修改就是用下差分思想，维护差分数组</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;1e5+5;</span><br><span class="line">int n,a,b;</span><br><span class="line">int tree[N];</span><br><span class="line">int lowbit(int x)&#123;</span><br><span class="line">	return x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line">void add(int x,int val)&#123;</span><br><span class="line">	while(x&lt;&#x3D;n)&#123;</span><br><span class="line">		tree[x]+&#x3D;val;</span><br><span class="line">		x+&#x3D;lowbit(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int query(int x)&#123;</span><br><span class="line">	int res&#x3D;0;</span><br><span class="line">	while(x&gt;0)&#123;</span><br><span class="line">		res+&#x3D;tree[x];</span><br><span class="line">		x-&#x3D;lowbit(x);</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)&#123;</span><br><span class="line">		memset(tree,0,sizeof(tree));</span><br><span class="line">		for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">			add(a,1);</span><br><span class="line">			add(b+1,-1);</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i&#x3D;0;i&lt;n-1;i++)printf(&quot;%d &quot;,query(i+1));</span><br><span class="line">		printf(&quot;%d\n&quot;,query(n));</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS Mojave 10.14 无法安装brew缺少Command Line Tools for Xcode的解决办法</title>
    <url>/5f155707/</url>
    <content><![CDATA[<p>重装系统真是。。好大好大好大好大宇宙无敌大的工程。。是我天真了。。再也不乱来了。。</p>
<hr>
<h1 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h1><p>首先我的版本是 Xcode 10.1</p>
<p>如果按照以前的方法安装brew</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;</span><br></pre></td></tr></table></figure>

<p>就会一直卡在这句话<code>Downloading Command Line Tools (macOS Mojave version 10.14) for Xcode</code>，然后接着就Failed了，<br><code>Error downloading Command Line Tools (macOS Mojave version 10.14) for Xcode:</code></p>
<p>因为Xcode的新版本不自动安装Command Line Tools了</p>
<h1 id="问题解决："><a href="#问题解决：" class="headerlink" title="问题解决："></a>问题解决：</h1><p>试了很多很多方法都没有到点子上。。最后在一个偏僻的犄角旮旯里发现一个很简单的解决方法。。记录一下</p>
<p>既然通过安装brew它自己不能顺便成功装好Command Line Tools，那么就自己去装一个吧0.0</p>
<p>打开Xcode，然后如下图「Xcode」-「Open Developer Tool」-「More Developer Tools」…</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kntv7sx9j20c5088my9.jpg" alt=""></p>
<p>登陆appleID之后下自己对应版本的Command Line Tools就好了</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kntv8ntij20pe0du77n.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kntv8519j20hd0c60tt.jpg" alt=""></p>
<p>安装完成后重新输入原来的话安装brew</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;</span><br></pre></td></tr></table></figure>

<p>现在成功啦～</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knu7fqvjj20ff04tmxv.jpg" alt=""></p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>分治思想实现log(2n)求两个长度为n的递增数组合并后的中位数</title>
    <url>/3287ce43/</url>
    <content><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>设A、B是两个长度为n的整型数据的有序顺序表，如果把这2n个整数全部排序，位于第n个位置的整数称为中位数。试编写一个时间复杂度为O(log2n)的算法，求A和B的中位数，写出算法思路并用代码实现它。。</p>
<a id="more"></a>

<h2 id="思路：分治"><a href="#思路：分治" class="headerlink" title="思路：分治"></a>思路：分治</h2><p>根据题意长度为n的数组，第n/2个数为其中位数，那么对于<code>A[0,n-1]</code>,<code>B[0,n-1]</code>，找出<code>A[(n-1)/2]</code>和<code>B[(n-1)/2]</code>，如果<code>A[(n-1)/2]=B[(n-1)/2]</code>，那么中位数就是这个数，如果<code>A[(n-1)/2]&lt;B[(n-1)/2]</code>，那么中位数一定出现在<code>A[(n-1)/2,n-1]</code>或<code>B[0,(n-1)/2]</code>两个区间内，反之如果<code>A[(n-1)/2]&gt;B[(n-1)/2]</code>，那么中位数一定出现在<code>A[0,(n-1)/2]</code>或<code>B[(n-1)/2,n-1]</code>两个区间内，然后继续递归</p>
<p>注意最后return的处理，多模拟几个n为奇偶的情况，如果两个区间都为1，那么取小的那个，如果区间和为3，比较一下取三个数中中间的那个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int a[233],b[233];</span><br><span class="line">int find(int a1,int a2,int b1,int b2)&#123;</span><br><span class="line">    if(a1&#x3D;&#x3D;a2&amp;&amp;b1&#x3D;&#x3D;b2)return a[a1]&lt;b[b1]?a[a1]:b[b1];</span><br><span class="line">    else if(a1&#x3D;&#x3D;a2)&#123;</span><br><span class="line">        int x&#x3D;a[a1],y&#x3D;b[b1],z&#x3D;b[b2];</span><br><span class="line">        if(x&lt;y)return y;</span><br><span class="line">        else if(x&gt;z)return z;</span><br><span class="line">        else return x;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(b1&#x3D;&#x3D;b2)&#123;</span><br><span class="line">        int x&#x3D;a[a1],y&#x3D;a[a2],z&#x3D;b[b1];</span><br><span class="line">        if(z&lt;x)return x;</span><br><span class="line">        else if(z&gt;y)return y;</span><br><span class="line">        else return z;</span><br><span class="line">    &#125;</span><br><span class="line">    int ma&#x3D;(a1+a2)&#x2F;2,mb&#x3D;(b1+b2)&#x2F;2;</span><br><span class="line">    if(a[ma]&#x3D;&#x3D;b[mb])return a[ma];</span><br><span class="line">    else if(a[ma]&lt;b[mb])</span><br><span class="line">        return find(ma,a2,b1,mb);</span><br><span class="line">    else</span><br><span class="line">        return find(a1,ma,mb,b2);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int i,j,k,n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)cin&gt;&gt;b[i];</span><br><span class="line">    int ans&#x3D;find(0,n-1,0,n-1);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Good Bye 2018（A-D，F）</title>
    <url>/ad11db5c/</url>
    <content><![CDATA[<h1 id="A-New-Year-and-the-Christmas-Ornament（贪心）"><a href="#A-New-Year-and-the-Christmas-Ornament（贪心）" class="headerlink" title="A. New Year and the Christmas Ornament（贪心）"></a>A. New Year and the Christmas Ornament（贪心）</h1><p><a href="https://codeforces.com/contest/1091/problem/A" target="_blank" rel="noopener">https://codeforces.com/contest/1091/problem/A</a></p>
<p>题意：给三个数<code>y,b,r</code>，要求<code>y&#39;,b&#39;,r&#39;``(y&#39;≤y,b&#39;≤b,r&#39;≤r)</code>，三个数以公差为1递增，求最大的和</p>
<p>最大的总共就<code>y*3+3,b*3,r*3-3</code>三种情况，取其中最小的那个就是合法的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int y,b,r;</span><br><span class="line">    scanf(&quot;%d%d%d&quot;,&amp;y,&amp;b,&amp;r);</span><br><span class="line">    printf(&quot;%d\n&quot;,min(y*3+3,min(b*3,r*3-3)));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-New-Year-and-the-Treasure-Geolocation（思维）"><a href="#B-New-Year-and-the-Treasure-Geolocation（思维）" class="headerlink" title="B. New Year and the Treasure Geolocation（思维）"></a>B. New Year and the Treasure Geolocation（思维）</h1><p><a href="https://codeforces.com/contest/1091/problem/B" target="_blank" rel="noopener">https://codeforces.com/contest/1091/problem/B</a></p>
<p>题意：有n个坐标<code>(xi,yi)</code>，有n种方向<code>(ai,bi)</code>，每个坐标对应一个方向，最后使所有配对好的<code>(xi+ai,yi+bi)</code>都为同一点</p>
<p>因为最后都是<code>(xi+ai,yi+bi)</code>这个点，所以<code>ansx=[∑(xi+ai)]/n,ansy=[∑(yi+bi)]/n</code></p>
<p>要开LL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">int main()&#123;</span><br><span class="line">    LL ansx&#x3D;0,ansy&#x3D;0;</span><br><span class="line">    int n,x,y;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;2*n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);</span><br><span class="line">        ansx+&#x3D;x;</span><br><span class="line">        ansy+&#x3D;y;</span><br><span class="line">    &#125;</span><br><span class="line">    ansx&#x2F;&#x3D;n;</span><br><span class="line">    ansy&#x2F;&#x3D;n;</span><br><span class="line">    printf(&quot;%lld %lld\n&quot;,ansx,ansy);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-New-Year-and-the-Sphere-Transmission"><a href="#C-New-Year-and-the-Sphere-Transmission" class="headerlink" title="C. New Year and the Sphere Transmission"></a>C. New Year and the Sphere Transmission</h1><p><a href="https://codeforces.com/contest/1091/problem/C" target="_blank" rel="noopener">https://codeforces.com/contest/1091/problem/C</a></p>
<p>题意：n个人编号[1,n]围一圈然后传球，从1开始传，顺时针传给第k<code>（k≤n）</code>个人，最后传到1号手里终止，这个过程编号的累加和记为fun value，升序输出所有合法的k对应的fun value</p>
<p>对于某个n，因为<code>k≤n</code>，所以能回到1号的合法k就是n的因数，求一下和排个序就好了，等差数列求和公式<code>Sn=(首项+尾项)*项数/2</code></p>
<p>要开LL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">int main()&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    vector&lt;LL&gt; v,ans;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;1;i*i&lt;n;i++)&#123;</span><br><span class="line">        if(n%i&#x3D;&#x3D;0)&#123;</span><br><span class="line">            v.push_back(i);</span><br><span class="line">            v.push_back(n&#x2F;i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int tmp&#x3D;sqrt(n);</span><br><span class="line">    if(tmp*tmp&#x3D;&#x3D;n)v.push_back(tmp);</span><br><span class="line">    for(auto it:v)&#123;</span><br><span class="line">        int an&#x3D;n-it+1;</span><br><span class="line">        ans.push_back((1+an)*(n&#x2F;it)&#x2F;2);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ans.begin(),ans.end());</span><br><span class="line">    for(auto it:ans)printf(&quot;%lld &quot;,it);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-New-Year-and-the-Permutation-Concatenation（推公式，全排列）"><a href="#D-New-Year-and-the-Permutation-Concatenation（推公式，全排列）" class="headerlink" title="D. New Year and the Permutation Concatenation（推公式，全排列）"></a>D. New Year and the Permutation Concatenation（推公式，全排列）</h1><p><a href="https://codeforces.com/contest/1091/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1091/problem/D</a></p>
<p>题意：给一个n，n的所有全排列依次存入序列p，比如<code>n=3</code>,<code>p=[1,2,3,1,3,2,2,1,3,2,3,1,3,1,2,3,2,1]</code>，共<code>n*n!</code>个数，相邻n个求和，问和等于<code>n*(n+1)/2</code>的有几个</p>
<p>首先直接全排列好的一组肯定是可以的，然后就是考虑前一组的后半部分和后一组的前半部分拼一拼可以满足要求的情况</p>
<p>next_permutation()生成下一个排列的方式如图：先找到最长递减后缀，共k个数，然后第n-k个数与后面k个数比较，找到其中大于a[n-k]且最小的数和n-k交换，然后新的后面k个数从小到大排</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knppw81aj20j606g3z3.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    int s[10];</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)s[i]&#x3D;i+1;</span><br><span class="line">    sort(s,s+n);</span><br><span class="line">    do&#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)printf(&quot;%d&quot;,s[i]);</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;while(next_permutation(s,s+n));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后继续推导，如果存在一个长度为k的递减后缀，比如<code>12(543)</code>，k=3，下一个是<code>13(245)</code>，连起来<code>12(543)13245</code>，如果前面部分刚好是那个递减后缀，因为后面3被往前提到第n-k个位置了，所以3重复了，<code>12[(543)13]245</code>这样的情况就无法满足条件，但是<code>1[2(543)1]3245</code>这样前面不限于那三个就是可以的</p>
<p>所以不满足条件的，就是前面部分刚好取了长度为k的递减后缀的</p>
<p>长度为k的递减后缀产生的排列总共有<img src="https://ws3.sinaimg.cn/large/006tNbRwly1fys9vq2yujj303y00qmwx.jpg" alt="">种，k范围<code>[1,n-1]</code>，当k=n时，已经全部都是递减了没法取，所以相当于每个多减了1，共n-1个，最后要加回n-1</p>
<p>求和种数总共有<code>n*n!-n-1</code>种，就是序列中总共有<code>n*n!</code>个数，顺次n个可以为一组，最后的n-1个没法再往后搭配，所以要减掉</p>
<p>最后答案就是<img src="https://ws3.sinaimg.cn/large/006tNbRwly1fys9uycy1dj30cq00sjr6.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const LL p&#x3D;998244353;</span><br><span class="line">const int N&#x3D;1e6+5;</span><br><span class="line">LL f[N],cal[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">    f[0]&#x3D;1;cal[n]&#x3D;1;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)f[i]&#x3D;(f[i-1]*i)%p;</span><br><span class="line">    for(int i&#x3D;n-1;i&gt;&#x3D;1;i--)cal[i]&#x3D;(cal[i+1]*(i+1))%p;</span><br><span class="line">    LL ans&#x3D;(f[n]*n)%p;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n-1;i++)ans&#x3D;(ans-cal[i]+p)%p;</span><br><span class="line">    printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E-New-Year-and-the-Acquaintance-Estimation"><a href="#E-New-Year-and-the-Acquaintance-Estimation" class="headerlink" title="E. New Year and the Acquaintance Estimation"></a>E. New Year and the Acquaintance Estimation</h1><p><a href="https://codeforces.com/contest/1091/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1091/problem/E</a></p>
<p>题意：给n个点，已知每个点度数为ai，现在添加第n+1个点，要使这个n+1个点构成的图是简单图，求第n+1个点可能的度数</p>
<p>题目里还给了个链接 -&gt; <a href="https://en.wikipedia.org/wiki/Graph_realization_problem" target="_blank" rel="noopener">Graph realization problem</a>，链接里面还给了个定理 -&gt; <a href="https://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93Gallai_theorem" target="_blank" rel="noopener">Erdős-Gallai定理</a></p>
<p>待补。。</p>
<h1 id="F-New-Year-and-the-Mallard-Expedition（思维，贪心）"><a href="#F-New-Year-and-the-Mallard-Expedition（思维，贪心）" class="headerlink" title="F. New Year and the Mallard Expedition（思维，贪心）"></a>F. New Year and the Mallard Expedition（思维，贪心）</h1><p><a href="https://codeforces.com/contest/1091/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1091/problem/F</a></p>
<p>题意：线形地图，有三种地形：Grass，Water和Lava，给定n个地形段长度和类型。从1出发到n，有三种行动方式：swim（只能在water），walk（只能在grass），fly（可以在任何地形），swim一米3秒，walk一米5秒，fly一米1秒。还有一个耐力值，初始为0，swim或者walk一米获得1耐力值，swim一米消耗1耐力值，耐力值不能为负。最后求到达n所需的最短时间</p>
<p>很有意思的题 ᶘ ᵒᴥᵒᶅ ，学了别人代码里的一个妙妙的贪心处理思路：</p>
<p>因为有耐力值这个东西搞的事情变得麻烦了，所以分解这三种行动方式，来保证耐力值非负</p>
<p>1.swim0.5米获得0.5耐力值，然后fly0.5米消耗0.5耐力值，2s/m</p>
<p>2.walk0.5米获得0.5耐力值，然后fly0.5米消耗0.5耐力值，3s/m</p>
<p>3.遇到lava，只能靠fly，要在前面的水或者草地里往后或者往前的磨蹭，直到获得足够的耐力值</p>
<p>3.1）如果在水里磨蹭：先往后swim0.5米再往前swim0.5米获得1耐力值，然后fly1米消耗1耐力值，4s/m</p>
<p>3.2）如果在草地磨蹭，先往后walk0.5米再往前walk0.5m获得1耐力值，然后fly1米消耗1耐力值，6s/m</p>
<p>这四种情况分别记为<code>v[0],v[1],v[2],v[3]</code></p>
<p>v[0]表示一段water可以获得2s/m的里程为v[0]米，v[1]表示一段grass可以获得3s/m的里程为v[1]米，v[2],v[3]分别对应在水里无限磨蹭和在草地无限磨蹭，可以获得的4s/m和6s/m的里程数是无限的</p>
<p>只要对water和grass更新里程数，然后按照顺序贪心的用掉这些里程数就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const LL INF&#x3D;1e18;</span><br><span class="line">const int N&#x3D;1e5+5;</span><br><span class="line">LL l[N],v[]&#x3D;&#123;0,0,0,0&#125;,cost[]&#x3D;&#123;2,3,4,6&#125;;</span><br><span class="line">char s[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%lld&quot;,&amp;l[i]);</span><br><span class="line">    scanf(&quot;%s&quot;,s);</span><br><span class="line">    LL ans&#x3D;0,len,flag&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        len&#x3D;l[i];</span><br><span class="line">        if(s[i]&#x3D;&#x3D;&#39;W&#39;)&#123;</span><br><span class="line">            v[0]+&#x3D;2*len;</span><br><span class="line">            v[2]&#x3D;INF;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(s[i]&#x3D;&#x3D;&#39;G&#39;)&#123;</span><br><span class="line">            v[1]+&#x3D;2*len;</span><br><span class="line">            v[3]&#x3D;INF;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j&#x3D;0;j&lt;4&amp;&amp;len!&#x3D;0;j++)&#123;</span><br><span class="line">            LL tmp&#x3D;min(v[j],len);</span><br><span class="line">            ans+&#x3D;cost[j]*tmp;</span><br><span class="line">            v[j]-&#x3D;tmp;</span><br><span class="line">            len-&#x3D;tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="G-New-Year-and-the-Factorisation-Collaboration"><a href="#G-New-Year-and-the-Factorisation-Collaboration" class="headerlink" title="G. New Year and the Factorisation Collaboration"></a>G. New Year and the Factorisation Collaboration</h1><p><a href="https://codeforces.com/contest/1091/problem/G" target="_blank" rel="noopener">https://codeforces.com/contest/1091/problem/G</a></p>
<h1 id="H-New-Year-and-the-Tricolore-Recreation"><a href="#H-New-Year-and-the-Tricolore-Recreation" class="headerlink" title="H. New Year and the Tricolore Recreation"></a>H. New Year and the Tricolore Recreation</h1><p><a href="https://codeforces.com/contest/1091/problem/H" target="_blank" rel="noopener">https://codeforces.com/contest/1091/problem/H</a></p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>数论</tag>
        <tag>cf</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello 2019</title>
    <url>/2019/</url>
    <content><![CDATA[<hr>
<center>

<p>❤️ 2019 ❤️</p>
</center>

<center><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knr02lq4j20iw0i376r.jpg" width = "200
" height = "200" ></center>

<a id="more"></a>

<center>

<p>立一些可能要倒要倒的flag</p>
</center>

<p>1）不挂科</p>
<p>2）学个logic pro x（ &lt;_&lt; 有钱了再去买个正版。。）</p>
<p>3）不要停留在五十音了。。</p>
<p>4）佛系搞项，然后就可以变强，现实是先把初审过了再说</p>
<p>5）有没有人社会实践带上我TAT嘤嘤嘤</p>
<p>6）ACM加油</p>
<p>7）想想十二月的惨状，六级是肯定要再来的。。而且之前报的口语班学的都忘光了。。</p>
<p>8）多看书，18年看的书好少啊，怀念高二高三夜自修和某炮偷偷看书的快乐时光@Charlotte</p>
<p>9）那个不知道是谁的奇人，19年要向他靠拢，世间竟有如此奇人啊啊啊啊啊啊啊啊啊啊</p>
<p>10）19年也超级喜欢杨超越</p>
<p>11）少喝酒。。喝不来。。</p>
<p>12）控制体重？？</p>
<p>13）长高？？哦不对可能是。。不长矮</p>
<p>14）to be continued…</p>
<center>

<p>我好像。。需要<s>一点啊不</s>很多行动力，天天做梦是不可能的。。</p>
<p>最后，有些不知道怎么写下来的事真的不知道我能做到哪一步，但是选择了就没有退路了，只能说。。2019！加油吧！٩(˃̶͈̀௰˂̶͈́)و</p>
</center>

<p>2019.01.01 新年第一天就。。买了好多东西。。 我决定再立一个flag 少剁手。。等这一波快递到了。。我就把淘宝藏起来嘤嘤嘤</p>
<p>2019.01.29 从玉环回天津了，看完了logic pro x一个入门教程，woc里面的鼓简直太牛逼了好吧，但是感觉有个ipad的话敲钢琴确实棒很多，可是他的钢琴一次能按的音域还是好窄呀</p>
<p>这个学期没挂科，也就是说不挂科的成就达成了1/2😂</p>
<p>2019.01.31 项目实在是太有趣了</p>
<p>2019.02.01 超越实在是太仙女了</p>
<p>补完了《比宇宙更远的地方》，看到小泽渊给妈妈的信从从信箱里涌上来的时候，爆哭啊啊啊啊啊TAT</p>
<p>2019.02.02 希望住在教工宿舍的这几天可以吧英文的廊桥遗梦看完0.0，大一运动会的时候买的了。。结果一直没看。。</p>
<p>快要会背五十音的小诗了，但是感觉发音怪怪的0.0，比起这个，好像英语更十万火急迫在眉睫时不我待一点TAT，听不懂神仙训练营的英语可咋整</p>
<p>2019.04.10 </p>
<p>没想到不知不觉就已经过去了1/3年，好像什么也没干，机器学习算是入门了一丢丢一丢丢那么少的一丢丢吧，日语开始时态了，学不下去了。。加油加油，还是学日语歌有意思ᶘ ᵒᴥᵒᶅ</p>
<p>8号开始做计划了，这样好像每天就不会得过且过吧</p>
<p>今天开始，不说脏话了，以前年轻觉得有些只是语气助词，就是为了发泄一下情绪，但是其实换个角度看是不一样的，要向我的idol学习：<a href="https://www.zhihu.com/question/307187029/answer/572315428" target="_blank" rel="noopener">https://www.zhihu.com/question/307187029/answer/572315428</a>，要是以后弱小可怜又无助了就看这篇（今天英语课看哭了。。）</p>
<p>哦对，结果还是没有看廊桥遗梦。。</p>
<hr>
<center><font size="12" color=#5959ff>J</font><font size="12" color=#a5b2ff>’</font><font size="8" color=#8888fd>a</font><font size="8" color=#7762fd>i</font><font size="8" color=#f1a8ce>m</font><font size="8" color=#a97afd>e </font><font size="8" color=#a7a7f5>m</font><font size="8" color=#628dfd>a </font><font size="8" color=#6363ff>v</font><font size="8" color=#8e64ff>i</font><font size="8" color=#ffafc7>e</font></center>

<hr>
]]></content>
      <categories>
        <category>love&amp;peace</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>poj 1738 An old Stone Game（GarsiaWachs算法）</title>
    <url>/6e50cfa7/</url>
    <content><![CDATA[<p>Time Limit: 5000MS        Memory Limit: 30000K</p>
<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>There is an old stone game.At the beginning of the game the player picks n(1&lt;=n&lt;=50000) piles of stones in a line. The goal is to merge the stones in one pile observing the following rules: </p>
<p>At each step of the game,the player can merge two adjoining piles to a new pile.The score is the number of stones in the new pile.</p>
<p>You are to write a program to determine the minimum of the total score. </p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input contains several test cases. The first line of each test case contains an integer n, denoting the number of piles. The following n integers describe the number of stones in each pile at the beginning of the game. </p>
<p>The last test case is followed by one zero. </p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case output the answer on a single line.You may assume the answer will not exceed 1000000000.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">100</span><br><span class="line">3</span><br><span class="line">3 4 3</span><br><span class="line">4</span><br><span class="line">1 1 1 1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">17</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>线性石子合并</p>
<p><a href="https://leflacon.github.io/7a2374a/" target="_blank" rel="noopener">51nod 1023 石子归并 V3（GarsiaWachs算法）</a></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;50005;</span><br><span class="line">int stone[N],n,t;</span><br><span class="line">LL ans;</span><br><span class="line">void join(int k)&#123;</span><br><span class="line">    int sum&#x3D;stone[k]+stone[k-1];</span><br><span class="line">    ans+&#x3D;sum;</span><br><span class="line">    for(int i&#x3D;k;i&lt;t-1;i++)stone[i]&#x3D;stone[i+1];</span><br><span class="line">    t--;</span><br><span class="line">    int j;</span><br><span class="line">    for(j&#x3D;k-1;j&gt;0&amp;&amp;stone[j-1]&lt;sum;j--)stone[j]&#x3D;stone[j-1];</span><br><span class="line">    stone[j]&#x3D;sum;</span><br><span class="line">    while(j&gt;&#x3D;2&amp;&amp;stone[j]&gt;&#x3D;stone[j-2])&#123;</span><br><span class="line">        int d&#x3D;t-j;</span><br><span class="line">        join(j-1);</span><br><span class="line">        j&#x3D;t-d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)&#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;stone[i]);</span><br><span class="line">        ans&#x3D;0;t&#x3D;1;</span><br><span class="line">        for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">            stone[t++]&#x3D;stone[i];</span><br><span class="line">            while(t&gt;&#x3D;3&amp;&amp;stone[t-3]&lt;&#x3D;stone[t-1])join(t-2);</span><br><span class="line">        &#125;</span><br><span class="line">        while(t&gt;1)join(t-1);</span><br><span class="line">        printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>51nod 1023 石子归并 V3（GarsiaWachs算法）</title>
    <url>/7a2374a/</url>
    <content><![CDATA[<p><a href="https://www.51nod.com/Challenge/Problem.html#!#problemId=1023" target="_blank" rel="noopener">https://www.51nod.com/Challenge/Problem.html#!#problemId=1023</a></p>
<p>2 秒  131,072 KB 7 级题</p>
<p>N堆石子摆成一条线。现要将石子有次序地合并成一堆。规定每次只能选相邻的2堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的代价。计算将N堆石子合并成一堆的最小代价。</p>
<p>例如： 1 2 3 4，有不少合并方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 3 4 &#x3D;&gt; 3 3 4(3) &#x3D;&gt; 6 4(9) &#x3D;&gt; 10(19)</span><br><span class="line">1 2 3 4 &#x3D;&gt; 1 5 4(5) &#x3D;&gt; 1 9(14) &#x3D;&gt; 10(24)</span><br><span class="line">1 2 3 4 &#x3D;&gt; 1 2 7(7) &#x3D;&gt; 3 7(10) &#x3D;&gt; 10(20)</span><br></pre></td></tr></table></figure>

<p>括号里面为总代价可以看出，第一种方法的代价最低，现在给出n堆石子的数量，计算最小合并代价。</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第1行：N（2 &lt;= N &lt;= 50000)</p>
<p>第2 - N + 1：N堆石子的数量（1 &lt;= A[i] &lt;= 10000）</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出最小合并代价</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">19</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>排成线，n=50000，如果用之前1022的<a href="https://leflacon.github.io/7f353e7f/" target="_blank" rel="noopener">四边形不等式优化</a>做。。数组都开不下啊。。一下子就MLE了</p>
<p>这时候就需要学一个相当厉害的东西，叫<strong>「GarsiaWachs算法」</strong>（ᶘ ᵒᴥᵒᶅ名字看起来就很厉害）</p>
<p><strong>步骤如下：</strong></p>
<blockquote>
<p>设序列是<code>stone[]</code>（其中<code>stone[-1]</code>和<code>stone[n]</code>是正无穷），从左往右，找一个k使<code>stone[k-1]&lt;=stone[k+1]</code></p>
<p>然后合并<code>stone[k]</code>和<code>stone[k-1]</code>，记下这个和sum，从当前位置开始向左找第一个满足<code>stone[j]&gt;sum</code>的j，把sum插到j后面</p>
<p>重复上述步骤，直到只剩下一堆石子</p>
</blockquote>
<p><strong>证明：（具体的不会证。。真的不会证。。下面只是意会。。）</strong></p>
<p>先从最简单的情况开始</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设n&#x3D;3，stone[0]&#x3D;a,stone[1]&#x3D;b,stone[c]&#x3D;c</span><br><span class="line"></span><br><span class="line">那么要么先合并前两堆，要么先合并后两堆</span><br><span class="line"></span><br><span class="line">合并前两堆 ans1&#x3D;a+b+(a+b+c)</span><br><span class="line">合并后两堆 ans2&#x3D;b+c+(a+b+c)</span><br><span class="line"></span><br><span class="line">ans1-ans2&#x3D;a-c</span><br><span class="line"></span><br><span class="line">所以先合并前两堆还是先合并后两堆其实只要看a和c的关系</span><br></pre></td></tr></table></figure>

<p>所以可以推广到其他子情况，也就是如果遇到上面说的<code>stone[k-1]&lt;=stone[k+1]</code>情况，就合并前两堆，即<code>stone[k]</code>和<code>stone[k-1]</code></p>
<p>然后得到的和sum为什么要插到向左第一个大于它的数stone[j]后面呢？ </p>
<p>（画了个鸡肋的图如下）</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knrh5cbhj20ox0bcdh3.jpg" alt=""></p>
<p>把[j+1,k-2]那段看成整体，叫x好了，stone[j]&gt;sum，那么sum移到j后面，不管怎样肯定是sum和x先合并，而不是stone[j]和x先合并，所以不会影响最终结果</p>
<p>复杂度o(n^2)，可以用平衡树优化到o(nlogn)，但是这题这样做直接o(n^2)是可过的，代码其实我不是很会。。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;50005;</span><br><span class="line">int stone[N],n,t;</span><br><span class="line">LL ans&#x3D;0;</span><br><span class="line">void join(int k)&#123;</span><br><span class="line">    int sum&#x3D;stone[k]+stone[k-1];</span><br><span class="line">    ans+&#x3D;sum;</span><br><span class="line">    for(int i&#x3D;k;i&lt;t-1;i++)stone[i]&#x3D;stone[i+1];</span><br><span class="line">    t--;</span><br><span class="line">    int j;</span><br><span class="line">    for(j&#x3D;k-1;j&gt;0&amp;&amp;stone[j-1]&lt;sum;j--)stone[j]&#x3D;stone[j-1];</span><br><span class="line">    stone[j]&#x3D;sum;</span><br><span class="line">    while(j&gt;&#x3D;2&amp;&amp;stone[j]&gt;&#x3D;stone[j-2])&#123;</span><br><span class="line">        int d&#x3D;t-j;</span><br><span class="line">        join(j-1);</span><br><span class="line">        j&#x3D;t-d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;stone[i]);</span><br><span class="line">    t&#x3D;1;</span><br><span class="line">    for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">        stone[t++]&#x3D;stone[i];</span><br><span class="line">        while(t&gt;&#x3D;3&amp;&amp;stone[t-3]&lt;&#x3D;stone[t-1])join(t-2);</span><br><span class="line">    &#125;</span><br><span class="line">    while(t&gt;1)join(t-1);</span><br><span class="line">    printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>51nod 1022 石子归并 V2（划分dp，四边形不等式优化）</title>
    <url>/7f353e7f/</url>
    <content><![CDATA[<p><a href="https://www.51nod.com/Challenge/Problem.html#!#problemId=1022" target="_blank" rel="noopener">https://www.51nod.com/Challenge/Problem.html#!#problemId=1022</a><br>1 秒  131,072 KB 6 级题</p>
<p>N堆石子摆成一个环。现要将石子有次序地合并成一堆。规定每次只能选相邻的2堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的代价。计算将N堆石子合并成一堆的最小代价。</p>
<p>例如： 1 2 3 4，有不少合并方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 3 4 &#x3D;&gt; 3 3 4(3) &#x3D;&gt; 6 4(9) &#x3D;&gt; 10(19)</span><br><span class="line">1 2 3 4 &#x3D;&gt; 1 5 4(5) &#x3D;&gt; 1 9(14) &#x3D;&gt; 10(24)</span><br><span class="line">1 2 3 4 &#x3D;&gt; 1 2 7(7) &#x3D;&gt; 3 7(10) &#x3D;&gt; 10(20)</span><br></pre></td></tr></table></figure>

<p>括号里面为总代价可以看出，第一种方法的代价最低，现在给出n堆石子的数量，计算最小合并代价。</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第1行：N（2 &lt;= N &lt;= 1000)</p>
<p>第2 - N + 1：N堆石子的数量（1 &lt;= A[i] &lt;= 10000)</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出最小合并代价</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">19</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>1021是摆成线，这题是摆成环，需要扩展数组为<code>2*n-1</code>：<code>a[0],a[1],...a[n-1],a[n-2],...a[1],a[0]</code></p>
<p>n=1000，o(n^3)过不了，然后要用四边形不等式优化</p>
<blockquote>
<p>四边形不等式</p>
<p>如果对于任意的a1≤a2&lt;b1≤b2，有m[a1,b1]+m[a2,b2]≤m[a1,b2]+m[a2,b1]，那么m[i,j]满足四边形不等式。</p>
</blockquote>
<p>网上的一篇论文（带数学归纳法证明） -&gt; <a href="https://wenku.baidu.com/view/c44cd84733687e21af45a906.html" target="_blank" rel="noopener">动态规划加速原理之四边形不等式</a></p>
<p>下面直接放解题结论：（因为证明。。看不进去。。mark一下溜了溜了）</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knryv6qej20cd02uglr.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knryyufnj20h105bdgg.jpg" alt=""></p>
<p>原先的状态转移方程是：<code>dp[i,j]=min(dp[i,j],dp[i,k]+dp[k+1,j]+w[i,j])</code>，如果<code>w[i][j]</code>满足四边形不等式，那么<code>dp[i][j]</code>也满足四边形不等式</p>
<p>定义<code>s[i][j]</code>为使<code>dp[i][j]</code>取最小时对应的k值，如果<code>dp[i][j]</code>满足四边形不等式，那么<code>s[i][j]</code>单调，即<code>s[i][j]≤s[i+1][j]≤s[i+1][j+1]</code>，<br>枚举k的时候范围是<code>s[i,j-1]≤k≤s[i+1,j]</code>，只要每次dp完顺便更新一下s数组即可，这样o(n^3)就变成o(n^2)了</p>
<p>进阶版 -&gt; <a href="https://leflacon.github.io/7a2374a/" target="_blank" rel="noopener">51nod 1023 石子归并 V3（GarsiaWachs算法）</a></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;2005;</span><br><span class="line">const int INF&#x3D;0x3f3f3f3f;</span><br><span class="line">int w[N][N],s[N][N],dp[N][N],ans;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;2*n;i++)&#123;</span><br><span class="line">        for(int j&#x3D;0;j&lt;2*n;j++)&#123;</span><br><span class="line">            dp[i][j]&#x3D;INF;</span><br><span class="line">            w[i][j]&#x3D;0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;w[i][i]);</span><br><span class="line">        w[n+i][n+i]&#x3D;w[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;0;i&lt;2*n-1;i++)&#123;</span><br><span class="line">        s[i][i]&#x3D;i;</span><br><span class="line">        dp[i][i]&#x3D;0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;0;i&lt;2*n-2;i++)</span><br><span class="line">        for(int j&#x3D;i+1;j&lt;2*n-1;j++)</span><br><span class="line">            w[i][j]&#x3D;w[i][j-1]+w[j][j];</span><br><span class="line">    for(int len&#x3D;1;len&lt;n;len++)&#123;</span><br><span class="line">        for(int i&#x3D;0;i+len&lt;2*n-1;i++)&#123;</span><br><span class="line">            int j&#x3D;len+i;</span><br><span class="line">            for(int k&#x3D;s[i][j-1];k&lt;&#x3D;s[i+1][j];k++)&#123;</span><br><span class="line">                if(dp[i][j]&gt;w[i][j]+dp[i][k]+dp[k+1][j])&#123;</span><br><span class="line">                    dp[i][j]&#x3D;w[i][j]+dp[i][k]+dp[k+1][j];</span><br><span class="line">                    s[i][j]&#x3D;k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans&#x3D;dp[0][n-1];</span><br><span class="line">    for(int i&#x3D;1;i&lt;n;i++)</span><br><span class="line">        ans&#x3D;min(ans,dp[i][i+n-1]);</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1021 石子归并（区间dp）</title>
    <url>/b46e11b9/</url>
    <content><![CDATA[<p>1 秒  131,072 KB 3 级题</p>
<p>N堆石子摆成一条线。现要将石子有次序地合并成一堆。规定每次只能选相邻的2堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的代价。计算将N堆石子合并成一堆的最小代价。</p>
<a id="more"></a>

<p>例如： 1 2 3 4，有不少合并方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 3 4 &#x3D;&gt; 3 3 4(3) &#x3D;&gt; 6 4(9) &#x3D;&gt; 10(19)</span><br><span class="line">1 2 3 4 &#x3D;&gt; 1 5 4(5) &#x3D;&gt; 1 9(14) &#x3D;&gt; 10(24)</span><br><span class="line">1 2 3 4 &#x3D;&gt; 1 2 7(7) &#x3D;&gt; 3 7(10) &#x3D;&gt; 10(20)</span><br></pre></td></tr></table></figure>

<p>括号里面为总代价可以看出，第一种方法的代价最低，现在给出n堆石子的数量，计算最小合并代价。</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第1行：N（2 &lt;= N &lt;= 100)</p>
<p>第2 - N + 1：N堆石子的数量（1 &lt;= A[i] &lt;= 10000)</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出最小合并代价</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">19</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>基础区间dp，用最水的o(n^3)做</p>
<p><code>dp[i][j]</code>表示i到j需要的最小代价，状态转移方程是：<code>dp[i,j]=min(dp[i,j],dp[i,k]+dp[k+1,j]+w[i,j])</code>，w[i][j]可以用前缀和优化下</p>
<p>进阶版 -&gt; <a href="https://leflacon.github.io/7f353e7f/" target="_blank" rel="noopener">51nod 1022 石子归并 V2（划分dp，四边形不等式优化）</a></p>
<p>进进阶版 -&gt; <a href="https://leflacon.github.io/7a2374a/" target="_blank" rel="noopener">51nod 1023 石子归并 V3（GarsiaWachs算法）</a></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;105;</span><br><span class="line">const int INF&#x3D;0x3f3f3f3f;</span><br><span class="line">int a[N],sum[N],dp[N][N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    sum[0]&#x3D;0;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">        sum[i]&#x3D;sum[i-1]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int len&#x3D;2;len&lt;&#x3D;n;len++)&#123;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">            int j&#x3D;len+i-1;</span><br><span class="line">            if(j&gt;n)break;</span><br><span class="line">            dp[i][j]&#x3D;INF;</span><br><span class="line">            for(int k&#x3D;i;k&lt;&#x3D;j;k++)&#123;</span><br><span class="line">                dp[i][j]&#x3D;min(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,dp[1][n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>《奇遇人生》 第5期：重获新生！朴树动情弹唱《平凡之路》字字戳心，阿雅眼眶泛红</title>
    <url>/2d540f/</url>
    <content><![CDATA[<center><font size="8" color=#8888fd>No Fear In My Heart</font></center>

<a id="more"></a>

<ul>
<li><p style="background-color:rgba(239,221,236,0.7)">蛇蜕皮时，要在一个光线都没有的地方</p>
</li>
<li><p style="background-color:rgba(239,221,236,0.7)">阿雅：一个人很期待，一个人是没有期待跟后悔，看看最后会变怎样</p>
</li>
<li><p style="background-color:rgba(239,221,236,0.7)">先把自己放在那，不要期待看到结果，先把自己放这，等等看</p>
</li>
<li><p style="background-color:rgba(239,221,236,0.7)">朴树：我已经发现我很多行为，背后是要取悦于人，希望从别人那得到我的肯定，这可能是我的童年，我的成长缺失的东西。我觉得，我有点讨厌那样的自己</p>
</li>
<li><p style="background-color:rgba(239,221,236,0.7)">朴树：其实如果机器小一点，不这么招摇就好了（指节目摄像团队）</p>
</li>
<li><p style="background-color:rgba(239,221,236,0.7)">朴树：如果我心里真有一个混蛋的话，我想让那个混蛋，出来，让别人和我自己都看见</p>

</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knnd7f19j203q055jr9.jpg" width = "50
" height = "70" ><br>（混蛋出来之后：）</p>
<ul>
<li><p style="background-color:rgba(239,221,236,0.7)">朴树说：你们真是找错人了，我真不爱录这节目，我真不会录这节目，然后就是你说想让我舒服，其实我不舒服，我是因为，我觉得我答应来录这节目，而且我觉得阿雅非常好，她非常替我考虑，所以我觉得，我会认真的录完这个节目，但是我真的不爱，你真找错人了，比如说你说让我自在，我没法自在，这都不是我爱干的事……我这人真的没有什么故事性，我没有任何可表达的……你让我有故事性，我没有故事性……但是即使这样，我会认真的完成这个节目……</p>

</li>
</ul>
<blockquote>
<p>其实我很羡慕朴树敢这么说，他的混蛋敢说话，但是我的混蛋不敢说，我没有那种勇气，很多事情其实不是真的想做，或者不是真的想那么做，混蛋想逃避，混蛋还是混蛋，无论是即将发生的事还是以前的事，又有什么办法呢。。我不会放任那个混蛋但是我也不介意她的存在</p>
<p>所幸生活不全是那样，丧只是很小一部分，有趣的事情也有很多想做的事情也有很多快乐的人也很多，脑子去云游的时候目光所至皆为美好</p>
<p>可能这就是18年末的我的生活</p>
</blockquote>
<ul>
<li><p style="background-color:rgba(239,221,236,0.7)">朴树：当我把那个负能量散出去之后，我觉得我轻松了一些，然后我轻松的时候，他们也轻松了</p>

</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knnkc2dzj212v0l0aep.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knnkdlhnj212p0kc7a5.jpg" alt=""></p>
<ul>
<li><p style="background-color:rgba(239,221,236,0.7)">朴树：慢慢开始我不想再勉强了，像我这样，我心里有很多复杂的感情，然后有很多悲伤，压抑，然后也有快乐，我去表达那些东西，也是好的，只要是发自内心的，不去迎合别人，就是我去看到自己，就在压抑和放纵之间，我在找那个平衡</p>

</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knnkci28j20jz0b4gn9.jpg" alt=""></p>
<ul>
<li><p style="background-color:rgba(239,221,236,0.7)">朴树：反正从外在看来就是，大病了一场，但我自己内在觉得我是，变成另一个人，我觉得我现在也，我也没有变成最终的我自己，就是还有很长的路要走，long way to go</p>
</li>
<li><p style="background-color:rgba(239,221,236,0.7)">朴树：就是我觉得时间会，会把我变成更好的一个</p>
</li>
<li><p style="background-color:rgba(239,221,236,0.7)">朴树：我觉得都是冥冥中的吧，付出了足够多的代价，就会明白一些道理</p>
</li>
<li><p style="background-color:rgba(200,200,233,0.7)">阿雅：人生就是来这一辈子，如果不用一个自己觉得最好的方式去一试的话，那你也不知道会变成什么样子</p>

</li>
</ul>
<hr>
<center><font size="12" color=#5959ff>J</font><font size="12" color=#a5b2ff>’</font><font size="8" color=#8888fd>a</font><font size="8" color=#7762fd>i</font><font size="8" color=#f1a8ce>m</font><font size="8" color=#a97afd>e </font><font size="8" color=#a7a7f5>m</font><font size="8" color=#628dfd>a </font><font size="8" color=#6363ff>v</font><font size="8" color=#8e64ff>i</font><font size="8" color=#ffafc7>e</font></center>

<hr>
]]></content>
      <categories>
        <category>love&amp;peace</category>
      </categories>
  </entry>
  <entry>
    <title>B.Origami -- 字节跳动冬令营网络赛（区间不交叉）</title>
    <url>/67e1b175/</url>
    <content><![CDATA[<p>什么时候英语才能变好啊。。像我这样想睡一觉做个梦英语就变好的想法实在是。。太恶劣了TAT</p>
<a id="more"></a>

<hr>
<p><a href="https://ac.nowcoder.com/acm/contest/296/B" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/296/B</a></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knqchv14j212w0e9juu.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knqcehckj213i083gnr.jpg" alt=""></p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br><span class="line">2 1 4 3</span><br><span class="line">7</span><br><span class="line">2 5 4 3 6 1 7</span><br><span class="line">4</span><br><span class="line">1 3 2 4</span><br></pre></td></tr></table></figure>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>纸带上一个序列1-n，可以向左折也可以向右折，最后要使折出来的宽度为1，从上到下记录每一个数字可以得到一个排列，问某个排列有没有可能出现</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>画一下样例，把顺序的连起来，然后就可以发现，咋都能折，但是出现这种交叉的就不能折</p>
<img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knqcdzouj20g10b0aac.jpg" width = "400" height = "250" >

<p>所以分成左右两边，把区间取出来，区间不交叉即可</p>
<p>看了别人代码这题还有一个很妙的做法，不交叉的区间其实就是一个括号序列模型，<code>(())()((()))</code>，所以还可以用栈来做</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;1e6+5;</span><br><span class="line">int pos[N],vis[N];</span><br><span class="line">vector&lt;pair&lt;int,int&gt;&gt; v1,v2;</span><br><span class="line">bool ok(vector&lt;pair&lt;int,int&gt;&gt; v)&#123;</span><br><span class="line">    sort(v.begin(),v.end());</span><br><span class="line">    vector&lt;int&gt; tmp;</span><br><span class="line">    for(auto i:v)&#123;</span><br><span class="line">        if(vis[i.second])&#123;</span><br><span class="line">            if(tmp.back()!&#x3D;i.second)</span><br><span class="line">                return false;</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            vis[i.second]&#x3D;1;</span><br><span class="line">            tmp.push_back(i.second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,n,c;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        v1.clear();</span><br><span class="line">        v2.clear();</span><br><span class="line">        fill(vis+1,vis+n+1,0);</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;c);</span><br><span class="line">            pos[c]&#x3D;i;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">            if(i&amp;1)&#123;</span><br><span class="line">                v1.push_back(make_pair(pos[i],i));</span><br><span class="line">                v1.push_back(make_pair(pos[i+1],i));</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                v2.push_back(make_pair(pos[i],i));</span><br><span class="line">                v2.push_back(make_pair(pos[i+1],i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ok(v1)&amp;&amp;ok(v2))puts(&quot;Yes&quot;);</span><br><span class="line">        else puts(&quot;No&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>bzoj2208 [Jsoi2010]连通数（Floyd传递闭包+bitset）</title>
    <url>/d25e576d/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knkrj9zdj20is06t0um.jpg" alt=""></p>
<a id="more"></a>

<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入数据第一行是图顶点的数量，一个正整数N。 接下来N行，每行N个字符。第i行第j列的1表示顶点i到j有边，0则表示无边。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一行一个整数，表示该图的连通数。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">010</span><br><span class="line">001</span><br><span class="line">100</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>
<h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>对于100%的数据，N不超过2000。</p>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p><a href="https://leflacon.github.io/532d9a6f/" target="_blank" rel="noopener">bitset用法</a></p>
<p>如果直接用Floyd的话，<code>o(n^3)</code>是过不了的，但是这个题只要求传递闭包没有权值啥的，所以可以用bitset优化一下，就可以变成快乐的<code>o(n^2)</code></p>
<p>只要把之前合并的那句改成<code>if(a[i][k])a[i]|=a[k];</code>，意思就是如果i可以到k，那么如果k可以到j则i可以到j，合并就不用再来一层循环枚举啦</p>
<p>最后连通数就是每个二进制数1的个数</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;bitset&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;2005;</span><br><span class="line">bitset&lt;N&gt; a[N];</span><br><span class="line">int n;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    string s;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        for(int j&#x3D;0;j&lt;n;j++)</span><br><span class="line">            a[i][j]&#x3D;(int)(s[j]-&#39;0&#39;);</span><br><span class="line">        a[i][i]&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int k&#x3D;0;k&lt;n;k++)&#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            if(a[i][k])a[i]|&#x3D;a[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)ans+&#x3D;a[i].count();</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构第十次作业（dfs，bfs，传递闭包）</title>
    <url>/e38b0c9f/</url>
    <content><![CDATA[<p>懒得用class写。。怎么会有写图还用class这种*&amp;@##@操作。。就没有用class写了</p>
<a id="more"></a>

<hr>
<h1 id="作业一："><a href="#作业一：" class="headerlink" title="作业一："></a>作业一：</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>45.使用BFS而不是DFS，编写16-8（在图中寻找一条路径的前序方法）的另一个版本。证明这个版本所得到的从theSource到theDestination的路径是最短的。</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>先证明是最短的吧。。dfs是找到一条路就好了，所以不一定最短，而bfs是从一个点出发拓展完一层在拓展下一层，所以一旦达到了终点，那肯定是最短的。。即证</p>
<p>此外，因为书中的繁琐的代码风格我不是很喜欢。。就照那个意思重写了一下</p>
<p>bfs就是普通bfs，搞个队列就行，然后要记录路径再递归输出路径</p>
<h2 id="运行效果："><a href="#运行效果：" class="headerlink" title="运行效果："></a>运行效果：</h2><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knlgl9fuj205p05pq2u.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knlgn8dlj204402st8n.jpg" alt=""></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;2333;</span><br><span class="line">int n,m,startt,endd;</span><br><span class="line">vector&lt;int&gt; g[N];</span><br><span class="line">int path[N],vis[N],len,pre[N];</span><br><span class="line">bool dfs(int x)&#123;</span><br><span class="line">    vis[x]&#x3D;1;</span><br><span class="line">    for(int i&#x3D;0;i&lt;g[x].size();i++)&#123;</span><br><span class="line">        int y&#x3D;g[x][i];</span><br><span class="line">        if(vis[y]&#x3D;&#x3D;0)&#123;</span><br><span class="line">            path[++len]&#x3D;y;</span><br><span class="line">            if(y&#x3D;&#x3D;endd||dfs(y))return true;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">bool findpath_dfs(int startt_,int endd_)&#123;</span><br><span class="line">    path[1]&#x3D;startt_;</span><br><span class="line">    len&#x3D;1;</span><br><span class="line">    endd&#x3D;endd_;</span><br><span class="line">    fill(vis,vis+n+1,0);</span><br><span class="line">    if(startt_&#x3D;&#x3D;endd_||dfs(startt_))&#123;</span><br><span class="line">        path[0]&#x3D;len-1;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">bool bfs()&#123;</span><br><span class="line">    len&#x3D;1;</span><br><span class="line">    queue&lt;int&gt;q;</span><br><span class="line">    vis[startt]&#x3D;1;</span><br><span class="line">    q.push(startt);</span><br><span class="line">    int tmp;</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        tmp&#x3D;q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(tmp&#x3D;&#x3D;endd)break;</span><br><span class="line">        int u;</span><br><span class="line">        for(int i&#x3D;0;i&lt;g[tmp].size();i++)&#123;</span><br><span class="line">            u&#x3D;g[tmp][i];</span><br><span class="line">            if(!vis[u])&#123;</span><br><span class="line">                len++;</span><br><span class="line">                path[u]&#x3D;tmp;</span><br><span class="line">                vis[u]&#x3D;1;</span><br><span class="line">                q.push(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(len&#x3D;&#x3D;1)return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">bool findpath_bfs(int startt_,int endd_)&#123;</span><br><span class="line">    path[1]&#x3D;startt_;</span><br><span class="line">    len&#x3D;1;</span><br><span class="line">    endd&#x3D;endd_;</span><br><span class="line">    fill(vis,vis+n,0);</span><br><span class="line">    if(startt_&#x3D;&#x3D;endd_||bfs())&#123;</span><br><span class="line">        path[0]&#x3D;0;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">void show_bfs(int x)&#123;</span><br><span class="line">    if(x&#x3D;&#x3D;startt)&#123;</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;&quot; &quot;;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    show_bfs(path[x]);</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;&quot; &quot;;</span><br><span class="line">    path[0]++;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    int u,v;</span><br><span class="line">    for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        g[u].push_back(v);</span><br><span class="line">        g[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;startt&gt;&gt;endd;</span><br><span class="line">    if(findpath_dfs(startt,endd))&#123;</span><br><span class="line">        cout&lt;&lt;&quot;dfs路径:&quot;;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;len;i++)</span><br><span class="line">            cout&lt;&lt;path[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;&quot;dfs路径长度:&quot;&lt;&lt;path[0]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    if(findpath_bfs(startt,endd))&#123;</span><br><span class="line">        cout&lt;&lt;&quot;bfs路径:&quot;;</span><br><span class="line">        show_bfs(endd);</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;&quot;bfs路径长度:&quot;&lt;&lt;path[0]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="作业二："><a href="#作业二：" class="headerlink" title="作业二："></a>作业二：</h1><h2 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h2><p>52.设G是一个无向图。它的传递闭包是一个0/1数组tc，当且仅当G存在一条边数大于1的从i到j的路径时，tc[i][j]=1。编写一个方法graph::undirectedTC()，计算且返回G的传递闭包。方法的复杂度应为o(n^2)，其中n是G的顶点数。（提示：采用构件标记策略。）</p>
<h2 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h2><p>把题目翻译一下就是。。给一个图，求传递闭包。。但是传递闭包是相连就有1。。这个题“边数大于1的从i到j的路径”。。不知道想干嘛。。反正我按传递闭包写了</p>
<p>一般求传递闭包可以用Floyd，跑三层循环，代码贼短贼好写，但是那个是<code>o(n^3)</code>的，而且这个题目只要求判断可达，没有路径长度的要求，所以就用从题目说的那个什么构件标记来想</p>
<p>那个构件标记，其实就是类似并查集的东西，把每个连通块都标个号，比如下图这样：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knm3oe2jj20cj0afwer.jpg" alt=""></p>
<p>对每个点来说，dfs一次就可以打完能连通到的所有点的标记，代码中标记存在flag数组里了</p>
<p>那么有了标记之后判断起来就很简单了，只要某两个点属于一个构件（也就是有相同的构件标记），那么这两个点ij就有<code>tc[i][j]=1</code>，二重循环一个i一个j跑一下即可</p>
<h2 id="运行效果：-1"><a href="#运行效果：-1" class="headerlink" title="运行效果："></a>运行效果：</h2><p>随便画个样例如下图：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knm3osnoj20an05r74a.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knm3pykyj209w06hjrr.jpg" alt=""></p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;2333;</span><br><span class="line">int n,m,label;</span><br><span class="line">int vis[N],flag[N];</span><br><span class="line">vector&lt;int&gt; g[N];</span><br><span class="line">void dfs(int x,int v[],int label)&#123;</span><br><span class="line">    v[x]&#x3D;1;</span><br><span class="line">    flag[x]&#x3D;label;</span><br><span class="line">    for(int i&#x3D;0;i&lt;g[x].size();i++)&#123;</span><br><span class="line">        int y&#x3D;g[x][i];</span><br><span class="line">        if(v[y]&#x3D;&#x3D;0)&#123;</span><br><span class="line">            dfs(y,v,label);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int lablecomponents(int v[])&#123;</span><br><span class="line">    fill(v,v+n+1,0);</span><br><span class="line">    label&#x3D;0;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        if(v[i]&#x3D;&#x3D;0)&#123;</span><br><span class="line">            dfs(i,v,label);</span><br><span class="line">            label++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return label;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    int u,v;</span><br><span class="line">    for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        g[u].push_back(v);</span><br><span class="line">        g[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    lablecomponents(vis);</span><br><span class="line">    &#x2F;&#x2F; for(int i&#x3D;1;i&lt;&#x3D;n;i++)cout&lt;&lt;flag[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;</span><br><span class="line">            if(flag[i]&#x3D;&#x3D;flag[j]&amp;&amp;i!&#x3D;j)cout&lt;&lt;&quot;1 &quot;;</span><br><span class="line">            else cout&lt;&lt;&quot;0 &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>一些作业</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1013 3的幂的和（快速幂）</title>
    <url>/1a1d659/</url>
    <content><![CDATA[<p>51nod以前土里土气的界面改版了好不习惯啊。。变得和codevs的风格一样。。</p>
<hr>
<p><a href="https://www.51nod.com/Challenge/Problem.html#!#problemId=1013" target="_blank" rel="noopener">https://www.51nod.com/Challenge/Problem.html#!#problemId=1013</a></p>
<p>1 秒  131,072 KB 20 分 3 级题</p>
<p>求：3^0 + 3^1 +…+ 3^(N) mod 1000000007</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>输入一个数N(0 &lt;= N &lt;= 10^9)</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出：计算结果</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>水题</p>
<p>等比数列求和，然后快速幂，2的逆元</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long </span><br><span class="line">const LL p&#x3D;1e9+7;</span><br><span class="line">LL qpow(LL a,LL b)&#123;</span><br><span class="line">    LL ans&#x3D;1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            ans&#x3D;(ans*a)%p;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        b&gt;&gt;&#x3D;1;</span><br><span class="line">        a&#x3D;a*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">    LL ans&#x3D;(((qpow(3,n+1)-1+p)%p)*(500000004))%p;</span><br><span class="line">    printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>Java第八次作业（模拟银行，多线程程序）</title>
    <url>/84d611fa/</url>
    <content><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p>编写一个“模拟银行”的多线程程序，实现如下要求：</p>
<p>银行于某时刻开始营业，运行若干时间后自动关门。营业期间有多名顾客随机的来银行存钱取钱，但是只有一名工作人员提供服务。每次存取钱，银行就报告一次该顾客到当时为止存入和取出的总数及余额，银行关门时在报告一次。不允许透支。</p>
<p>银行和顾客分别用不同的线程实现</p>
<h1 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h1><blockquote>
<p>线程</p>
<p>有时被称为轻量进程(Lightweight Process，LWP），是程序执行流的最小单元</p>
<p>线程的操作：</p>
<p>派生：线程在进程内派生出来，它即可由进程派生，也可由线程派生。</p>
<p>阻塞（Block）：如果一个线程在执行过程中需要等待某个事件发生，则被阻塞。</p>
<p>激活（unblock）：如果阻塞线程的事件发生，则该线程被激活并进入就绪队列。</p>
<p>调度（schedule）：选择一个就绪线程进入执行状态。</p>
<p>结束（Finish）：如果一个线程执行结束，它的寄存器上下文以及堆栈内容等将被释放。</p>
<hr>
<p>ArrayBlockingQueue 阻塞队列</p>
<p>extends AbstractQueueimplements BlockingQueue, java.io.Serializable一个由数组支持的有界阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。队列的头部 是在队列中存在时间最长的元素。队列的尾部 是在队列中存在时间最短的元素。新元素插入到队列的尾部，队列检索操作则是从队列头部开始获得元素。</p>
<p>【以上内容均摘自百度】</p>
</blockquote>
<p>银行和顾客分别用不同的线程实现，所以银行线程就是银行职员给客户办理存取操作，客户线程就是随机生成顾客的线程，生成的客户存入一个阻塞队列中</p>
<h2 id="顾客类customer"><a href="#顾客类customer" class="headerlink" title="顾客类customer"></a>顾客类customer</h2><p>先写一个顾客类customer，顾客的变量如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final int time;&#x2F;&#x2F;一个顾客办理业务需要的时间</span><br><span class="line">private int money;&#x2F;&#x2F;顾客的余额</span><br><span class="line">private int op;&#x2F;&#x2F;op&#x3D;1存款，op&#x3D;0取款</span><br><span class="line">private int op_money;&#x2F;&#x2F;顾客需要操作的金额</span><br></pre></td></tr></table></figure>

<p>然后写一些基本的获取private类型变量的函数，再写存取函数<code>public boolean operation(int ope)</code>，修改用户的余额并输出，因为题目说不允许透支，所以取钱操作要比较一下操作金额和余额</p>
<h2 id="阻塞队列customers"><a href="#阻塞队列customers" class="headerlink" title="阻塞队列customers"></a>阻塞队列customers</h2><p>用<code>ArrayBlockingQueue</code>模拟排队的顾客</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class customers extends ArrayBlockingQueue&lt;customer&gt;&#123;</span><br><span class="line">    public customers(int num)&#123;</span><br><span class="line">        super(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="随机生成顾客线程customer-random"><a href="#随机生成顾客线程customer-random" class="headerlink" title="随机生成顾客线程customer_random"></a>随机生成顾客线程customer_random</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class customer_random extends Thread</span><br><span class="line"></span><br><span class="line">private boolean flag&#x3D;true;&#x2F;&#x2F;表示银行是否开门</span><br></pre></td></tr></table></figure>

<p>写一个函数使<code>flag=false</code>，这样银行关门不再生成新顾客</p>
<p>重写<code>run()</code></p>
<p><code>TimeUnit.MILLISECONDS.sleep(tmp.nextInt(1000));</code>随机生成一个1000范围内int类型的数，代表tmp毫秒，也就是停x毫秒下一个顾客再到来</p>
<p>随机生成一个顾客，然后put(顾客)到队列里<code>cuss.put(new customer(tmp.nextInt(1000),tmp.nextInt(1000),tmp.nextInt(2),tmp.nextInt(1000)));</code></p>
<h2 id="职员线程staff"><a href="#职员线程staff" class="headerlink" title="职员线程staff"></a>职员线程staff</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean flag&#x3D;true;&#x2F;&#x2F;用于表示是否营业中</span><br><span class="line">private int customer_num&#x3D;0;&#x2F;&#x2F;处理的顾客数</span><br><span class="line">private customers cuss;&#x2F;&#x2F;待处理的顾客队列</span><br><span class="line">public int money&#x3D;23333333;&#x2F;&#x2F;银行余额</span><br><span class="line">public int save_money&#x3D;0;&#x2F;&#x2F;当前处理的总存入金额</span><br><span class="line">public int withdraw_money&#x3D;0;&#x2F;&#x2F;当前处理的总取出金额</span><br></pre></td></tr></table></figure>

<p>写一个函数使<code>flag=false</code>，这样银行关门不再处理顾客的业务</p>
<p>一个<code>show()</code>函数用于在每次操作完和银行关门后输出银行信息</p>
<p>重写<code>run()</code></p>
<p>如果当前队列没有顾客就continue，如果有顾客，就从队列中取出队首顾客<code>customer cus_cur=cuss.take();</code>然后停顾客需要的操作时间<code>TimeUnit.MILLISECONDS.sleep(cus_cur.get_time());</code>最后根据顾客操作修改银行信息</p>
<h1 id="运行效果："><a href="#运行效果：" class="headerlink" title="运行效果："></a>运行效果：</h1><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knjyibm7j20f009yzm9.jpg" alt=""></p>
<h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String args[]) throws Exception&#123;</span><br><span class="line">        customers cuss&#x3D;new customers(23);</span><br><span class="line">        customer_random cus_ran&#x3D;new customer_random(cuss);</span><br><span class="line">        staff sta&#x3D;new staff(cuss);</span><br><span class="line">        System.out.println(&quot;----------开始----------\n&quot;);</span><br><span class="line">        sta.start();</span><br><span class="line">        cus_ran.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        sta.end();</span><br><span class="line">        cus_ran.end();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class customer&#123;</span><br><span class="line">    private final int time;</span><br><span class="line">    private int money;</span><br><span class="line">    private int op;&#x2F;&#x2F;op&#x3D;1存款，op&#x3D;0取款</span><br><span class="line">    private int op_money;</span><br><span class="line">    public customer(int t,int m,int o,int o_m)&#123;</span><br><span class="line">        time&#x3D;t;</span><br><span class="line">        money&#x3D;m;</span><br><span class="line">        op&#x3D;o;</span><br><span class="line">        op_money&#x3D;o_m;</span><br><span class="line">    &#125;</span><br><span class="line">    public int get_time()&#123;</span><br><span class="line">        return time;</span><br><span class="line">    &#125;</span><br><span class="line">    public int get_op()&#123;</span><br><span class="line">        return op;</span><br><span class="line">    &#125;</span><br><span class="line">    public int get_op_money()&#123;</span><br><span class="line">        return op_money;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean operation(int ope)&#123;</span><br><span class="line">        if(ope&#x3D;&#x3D;0)&#123;</span><br><span class="line">            if(money&gt;&#x3D;op_money)&#123;</span><br><span class="line">                money-&#x3D;op_money;</span><br><span class="line">                System.out.println(&quot;成功取款&quot;+op_money+&quot;元，当前顾客余额为&quot;+money+&quot;元&quot;);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                System.out.println(&quot;账户余额不足，取款失败，当前顾客余额为&quot;+money+&quot;元&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(ope&#x3D;&#x3D;1)&#123;</span><br><span class="line">            money+&#x3D;op_money;</span><br><span class="line">            System.out.println(&quot;成功存款&quot;+op_money+&quot;元，当前顾客余额为&quot;+money+&quot;元&quot;);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class customers extends ArrayBlockingQueue&lt;customer&gt;&#123;</span><br><span class="line">    public customers(int num)&#123;</span><br><span class="line">        super(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class customer_random extends Thread&#123;</span><br><span class="line">    private boolean flag&#x3D;true;</span><br><span class="line">    private customers cuss;</span><br><span class="line">    public customer_random(customers ss)&#123;</span><br><span class="line">        cuss&#x3D;ss;</span><br><span class="line">    &#125;</span><br><span class="line">    public void end()&#123;</span><br><span class="line">        flag&#x3D;false;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            Random tmp&#x3D;new Random();</span><br><span class="line">            while(flag)&#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(tmp.nextInt(1000));</span><br><span class="line">                cuss.put(new customer(tmp.nextInt(1000),tmp.nextInt(1000),</span><br><span class="line">                        tmp.nextInt(2),tmp.nextInt(1000)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (InterruptedException e)&#123;</span><br><span class="line">            System.out.println(&quot;随机生成顾客线程 Interrupted&quot;);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class staff extends Thread&#123;</span><br><span class="line">    private boolean flag&#x3D;true;</span><br><span class="line">    private int customer_num&#x3D;0;</span><br><span class="line">    private customers cuss;</span><br><span class="line">    public int money&#x3D;23333333;</span><br><span class="line">    public int save_money&#x3D;0;</span><br><span class="line">    public int withdraw_money&#x3D;0;</span><br><span class="line">    public staff(customers ss)&#123;</span><br><span class="line">        cuss&#x3D;ss;</span><br><span class="line">    &#125;</span><br><span class="line">    public void show()&#123;</span><br><span class="line">        System.out.println(&quot;已服务顾客数：&quot;+customer_num+&quot;  排队顾客数：&quot;+cuss.size()+</span><br><span class="line">                &quot;  银行资金：&quot;+money+&quot;  存入资金：&quot;+save_money+&quot;  取出资金：&quot;+withdraw_money);</span><br><span class="line">    &#125;</span><br><span class="line">    public void end()&#123;</span><br><span class="line">        flag&#x3D;false;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            while(flag)&#123;</span><br><span class="line">                if(cuss.size()&#x3D;&#x3D;0)continue;</span><br><span class="line">                customer cus_cur&#x3D;cuss.take();</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(cus_cur.get_time());</span><br><span class="line">                if(cus_cur.get_op()&#x3D;&#x3D;1)&#123;</span><br><span class="line">                    cus_cur.operation(cus_cur.get_op());</span><br><span class="line">                    money+&#x3D;cus_cur.get_op_money();</span><br><span class="line">                    save_money+&#x3D;cus_cur.get_op_money();</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    cus_cur.operation(cus_cur.get_op());</span><br><span class="line">                    money-&#x3D;cus_cur.get_op_money();</span><br><span class="line">                    withdraw_money+&#x3D;cus_cur.get_op_money();</span><br><span class="line">                &#125;</span><br><span class="line">                synchronized (this)&#123;</span><br><span class="line">                    customer_num++;</span><br><span class="line">                    this.show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (InterruptedException e)&#123;</span><br><span class="line">            System.out.println(&quot;职员线程 Interrupted&quot;);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;\n----------银行关门啦，职员下班啦----------\n&quot;);</span><br><span class="line">        this.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>一些作业</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构第九次作业（c++红黑树插入删除，抽象类，可重复值和不可重复值）</title>
    <url>/f1048293/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>36.设计一个C++类redBlackTree，它派生于抽象类bSTree。函数find，insert和delete的时间复杂度必须是o(logn)，函数ascend的时间复杂度应该是o(n)</p>
<p>37.设计一个c++类dredBlackTree（有重复值的二叉搜索树），它派生于抽象类bSTree。函数find，insert和delete的时间复杂度必须是o(logn)，函数ascend的时间复杂度应该是o(n)</p>
<h1 id="作业一"><a href="#作业一" class="headerlink" title="作业一"></a>作业一</h1><p>红黑树详解见下面这篇 ⬇️ </p>
<p><a href="https://leflacon.github.io/6bd2e86e/" target="_blank" rel="noopener">R-B Tree红黑树c++实现插入删除，旋转调整图解</a></p>
<p>第一题照要求加个抽象类派生。。随便写了。。然后既然派生了写了虚函数，所以main函数里也象征性的用了一下指针来操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">class BSTree&#123;</span><br><span class="line">    public:</span><br><span class="line">        Node&lt;T&gt; *root;</span><br><span class="line">        BSTree()&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        ~BSTree()&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        virtual void qianxu()&#x3D;0;</span><br><span class="line">        virtual void ascend()&#x3D;0;</span><br><span class="line">        virtual void houxu()&#x3D;0;</span><br><span class="line">        virtual Node&lt;T&gt;* find(T e)&#x3D;0;</span><br><span class="line">        virtual void erase(T e)&#x3D;0;</span><br><span class="line">        virtual void insert(T e)&#x3D;0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此外，要求的ascend函数，（从小到大升序输出），其实就是中序输出，改个名字换汤不换药。。</p>
<p>没有重复值就是在找到要插入的位置的时候判断一下插入位置的值是不是等于要插入的值，如果有重复就直接return掉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(x!&#x3D;NULL)&#123;</span><br><span class="line">    y&#x3D;x;</span><br><span class="line">    if(e&lt;x-&gt;data)</span><br><span class="line">        x&#x3D;x-&gt;lchild;</span><br><span class="line">    else if(e&gt;x-&gt;data)x&#x3D;x-&gt;rchild;</span><br><span class="line">    else if(e&#x3D;&#x3D;x-&gt;data)&#123;</span><br><span class="line">    	&#x2F;&#x2F;cout&lt;&lt;&quot;重复！&quot;&lt;&lt;endl;</span><br><span class="line">		return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除find只返回一个指针，删掉那个指针指向的结点即可</p>
<h1 id="作业二"><a href="#作业二" class="headerlink" title="作业二"></a>作业二</h1><p>这个和上面那个的不同是允许有重复值，所以insert的时候不用判断重复，直接insert</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(x!&#x3D;NULL)&#123;</span><br><span class="line">    pa&#x3D;x;</span><br><span class="line">    if(e&lt;x-&gt;data)</span><br><span class="line">        x&#x3D;x-&gt;lchild;</span><br><span class="line">    else x&#x3D;x-&gt;rchild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后删除函数，要把所有相同值都删除掉，只需要加个while循环即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">void dredBlackTree&lt;T&gt;::erase(T e)&#123;</span><br><span class="line">    Node&lt;T&gt; *p&#x3D;find(e);</span><br><span class="line">    while(p!&#x3D;NULL)&#123;</span><br><span class="line">    	erase(p); </span><br><span class="line">    	p&#x3D;find(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="运行效果："><a href="#运行效果：" class="headerlink" title="运行效果："></a>运行效果：</h1><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knmpvw4mj20bn0bdgms.jpg" alt=""></p>
<h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><p>为了体现一下派生的作用。。把两个树写一起了，770+行看着还。。蛮酷</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const int RED&#x3D;1;</span><br><span class="line">const int BLACK&#x3D;-1;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">struct Node&#123;</span><br><span class="line">    T data;</span><br><span class="line">    Node *lchild;</span><br><span class="line">    Node *rchild;</span><br><span class="line">    Node *parent;</span><br><span class="line">    int color;</span><br><span class="line">    Node(T e,int col,Node *p,Node *l,Node *r):</span><br><span class="line">        data(e),color(BLACK),parent(NULL),lchild(NULL),rchild(NULL)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class BSTree&#123;</span><br><span class="line">    public:</span><br><span class="line">        Node&lt;T&gt; *root;</span><br><span class="line">        BSTree()&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        ~BSTree()&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        virtual void qianxu()&#x3D;0;</span><br><span class="line">        virtual void ascend()&#x3D;0;</span><br><span class="line">        virtual void houxu()&#x3D;0;</span><br><span class="line">        virtual Node&lt;T&gt;* find(T e)&#x3D;0;</span><br><span class="line">        virtual void erase(T e)&#x3D;0;</span><br><span class="line">        virtual void insert(T e)&#x3D;0;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class redBlackTree:public BSTree&lt;T&gt;&#123;</span><br><span class="line">    private:</span><br><span class="line">        Node&lt;T&gt; *root;</span><br><span class="line">        Node&lt;T&gt;* successor(Node&lt;T&gt; *x);</span><br><span class="line">        bool is_empty();</span><br><span class="line">        void qianxu(Node&lt;T&gt; *t);</span><br><span class="line">        void ascend(Node&lt;T&gt; *t);</span><br><span class="line">        void houxu(Node&lt;T&gt; *t);</span><br><span class="line">        void insert_fix_up(Node&lt;T&gt; *x);</span><br><span class="line">        void erase_fix_up(Node&lt;T&gt; *x);</span><br><span class="line">        void erase(Node&lt;T&gt; *x);</span><br><span class="line">        int get_color(Node&lt;T&gt; *p)&#123;</span><br><span class="line">	    	return p&#x3D;&#x3D;NULL?BLACK:p-&gt;color;</span><br><span class="line">	    &#125;</span><br><span class="line">    public:</span><br><span class="line">        redBlackTree()&#123;</span><br><span class="line">            root&#x3D;NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        ~redBlackTree()&#123;</span><br><span class="line">            set_empty(root);</span><br><span class="line">        &#125;</span><br><span class="line">        void qianxu();</span><br><span class="line">        void ascend();</span><br><span class="line">        void houxu();</span><br><span class="line">        void rotate_left(Node&lt;T&gt; *x);</span><br><span class="line">        void rotate_right(Node&lt;T&gt; *y);</span><br><span class="line">        Node&lt;T&gt;* find(T e);</span><br><span class="line">        T get_min();</span><br><span class="line">        T get_max();</span><br><span class="line">        void erase(T e);</span><br><span class="line">        void insert(T e);</span><br><span class="line">        void set_empty(Node&lt;T&gt; *&amp;t);</span><br><span class="line">        void show();  </span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">bool redBlackTree&lt;T&gt;::is_empty()&#123;</span><br><span class="line">    return root&#x3D;&#x3D;NULL;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::set_empty(Node&lt;T&gt; *&amp;t)&#123;</span><br><span class="line">    if(t&#x3D;&#x3D;NULL)return;</span><br><span class="line">    if(t-&gt;lchild!&#x3D;NULL)</span><br><span class="line">        set_empty(t-&gt;lchild);</span><br><span class="line">    if(t-&gt;rchild!&#x3D;NULL)</span><br><span class="line">        set_empty(t-&gt;rchild);</span><br><span class="line">    delete t;</span><br><span class="line">    t&#x3D;NULL;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::qianxu(Node&lt;T&gt; *t)&#123;</span><br><span class="line">    if(t!&#x3D;NULL)&#123;</span><br><span class="line">        cout&lt;&lt;t-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">        qianxu(t-&gt;lchild);</span><br><span class="line">        qianxu(t-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::qianxu()&#123;</span><br><span class="line">    qianxu(root);</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::ascend(Node&lt;T&gt; *t)&#123;</span><br><span class="line">    if(t!&#x3D;NULL)&#123;</span><br><span class="line">        ascend(t-&gt;lchild);</span><br><span class="line">        cout&lt;&lt;t-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">        ascend(t-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::ascend()&#123;</span><br><span class="line">    ascend(root);</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::houxu(Node&lt;T&gt; *t)&#123;</span><br><span class="line">    if(t!&#x3D;NULL)&#123;</span><br><span class="line">        houxu(t-&gt;lchild);</span><br><span class="line">        houxu(t-&gt;rchild);</span><br><span class="line">        cout&lt;&lt;t-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::houxu()&#123;</span><br><span class="line">    houxu(root);</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T redBlackTree&lt;T&gt;::get_min()&#123;</span><br><span class="line">    if(is_empty())return 0;</span><br><span class="line">    Node&lt;T&gt; *p&#x3D;root;</span><br><span class="line">    while(p-&gt;lchild!&#x3D;NULL)</span><br><span class="line">        p&#x3D;p-&gt;lchild;</span><br><span class="line">    cout&lt;&lt;&quot;min:&quot;&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">    return p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T redBlackTree&lt;T&gt;::get_max()&#123;</span><br><span class="line">    if(is_empty())return 0;</span><br><span class="line">    Node&lt;T&gt; *p&#x3D;root;</span><br><span class="line">    while(p-&gt;rchild!&#x3D;NULL)</span><br><span class="line">        p&#x3D;p-&gt;rchild;</span><br><span class="line">    cout&lt;&lt;&quot;max:&quot;&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">    return p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::rotate_left(Node&lt;T&gt; *x)&#123;</span><br><span class="line">	if(x&#x3D;&#x3D;NULL)return;</span><br><span class="line">    Node&lt;T&gt; *y&#x3D;x-&gt;rchild;</span><br><span class="line">    x-&gt;rchild&#x3D;y-&gt;lchild;</span><br><span class="line">    if(y-&gt;lchild!&#x3D;NULL)</span><br><span class="line">        y-&gt;lchild-&gt;parent&#x3D;x;</span><br><span class="line">    y-&gt;parent&#x3D;x-&gt;parent;</span><br><span class="line">    if(x-&gt;parent&#x3D;&#x3D;NULL)</span><br><span class="line">        root&#x3D;y;</span><br><span class="line">    else&#123;</span><br><span class="line">        if(x-&gt;parent-&gt;lchild&#x3D;&#x3D;x)</span><br><span class="line">            x-&gt;parent-&gt;lchild&#x3D;y;</span><br><span class="line">        else</span><br><span class="line">            x-&gt;parent-&gt;rchild&#x3D;y;</span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;lchild&#x3D;x;</span><br><span class="line">    x-&gt;parent&#x3D;y;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::rotate_right(Node&lt;T&gt; *y)&#123;</span><br><span class="line">	if(y&#x3D;&#x3D;NULL)return;</span><br><span class="line">    Node&lt;T&gt; *x&#x3D;y-&gt;lchild;</span><br><span class="line">    y-&gt;lchild&#x3D;x-&gt;rchild;</span><br><span class="line">    if(x-&gt;rchild!&#x3D;NULL)</span><br><span class="line">        x-&gt;rchild-&gt;parent&#x3D;y;</span><br><span class="line">    x-&gt;parent&#x3D;y-&gt;parent;</span><br><span class="line">    if(y-&gt;parent&#x3D;&#x3D;NULL)</span><br><span class="line">        root&#x3D;x;</span><br><span class="line">    else&#123;</span><br><span class="line">        if(y-&gt;parent-&gt;rchild&#x3D;&#x3D;y)</span><br><span class="line">            y-&gt;parent-&gt;rchild&#x3D;x;</span><br><span class="line">        else</span><br><span class="line">            y-&gt;parent-&gt;lchild&#x3D;x;</span><br><span class="line">    &#125;</span><br><span class="line">    x-&gt;rchild&#x3D;y;</span><br><span class="line">    y-&gt;parent&#x3D;x;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::insert(T e)&#123;</span><br><span class="line">	if(root&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">		root&#x3D;new Node&lt;T&gt;(e,BLACK,NULL,NULL,NULL);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">    Node&lt;T&gt; *pa&#x3D;NULL;</span><br><span class="line">    Node&lt;T&gt; *x&#x3D;root;</span><br><span class="line">    while(x!&#x3D;NULL)&#123;</span><br><span class="line">        pa&#x3D;x;</span><br><span class="line">        if(e&lt;x-&gt;data)</span><br><span class="line">            x&#x3D;x-&gt;lchild;</span><br><span class="line">        else if(e&gt;x-&gt;data)x&#x3D;x-&gt;rchild;</span><br><span class="line">        else if(e&#x3D;&#x3D;x-&gt;data)&#123;</span><br><span class="line">        	&#x2F;&#x2F;cout&lt;&lt;&quot;重复！&quot;&lt;&lt;endl;</span><br><span class="line">    		return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;T&gt; *z&#x3D;new Node&lt;T&gt;(e,BLACK,NULL,NULL,NULL);</span><br><span class="line">    z-&gt;parent&#x3D;pa;</span><br><span class="line">    if(e&lt;pa-&gt;data)</span><br><span class="line">        pa-&gt;lchild&#x3D;z;</span><br><span class="line">    else </span><br><span class="line">        pa-&gt;rchild&#x3D;z;</span><br><span class="line">    insert_fix_up(z);</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::insert_fix_up(Node&lt;T&gt; *x)&#123;</span><br><span class="line">	x-&gt;color&#x3D;RED;</span><br><span class="line">	while(x!&#x3D;NULL&amp;&amp;x!&#x3D;root&amp;&amp;get_color(x-&gt;parent)&#x3D;&#x3D;RED)&#123;</span><br><span class="line">		if(x-&gt;parent&#x3D;&#x3D;x-&gt;parent-&gt;parent-&gt;lchild)&#123;</span><br><span class="line">			&#x2F;&#x2F;父亲是祖父的右儿子，叔叔是左儿子</span><br><span class="line">			Node&lt;T&gt; *uncle&#x3D;x-&gt;parent-&gt;parent-&gt;rchild;</span><br><span class="line">			if(get_color(uncle)&#x3D;&#x3D;RED)&#123;</span><br><span class="line">				&#x2F;&#x2F;1）叔叔是红色</span><br><span class="line">				x-&gt;parent-&gt;color&#x3D;BLACK;</span><br><span class="line">				uncle-&gt;color&#x3D;BLACK;</span><br><span class="line">				x-&gt;parent-&gt;parent-&gt;color&#x3D;RED;</span><br><span class="line">				x&#x3D;x-&gt;parent-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;</span><br><span class="line">				&#x2F;&#x2F;2）叔叔是黑色，x是父亲右儿子</span><br><span class="line">				if(x&#x3D;&#x3D;x-&gt;parent-&gt;rchild)&#123;</span><br><span class="line">					x&#x3D;x-&gt;parent;</span><br><span class="line">					rotate_left(x);</span><br><span class="line">				&#125;</span><br><span class="line">				&#x2F;&#x2F;3）叔叔是黑色，x是父亲左儿子</span><br><span class="line">				x-&gt;parent-&gt;color&#x3D;BLACK;</span><br><span class="line">				x-&gt;parent-&gt;parent-&gt;color&#x3D;RED;</span><br><span class="line">				rotate_right(x-&gt;parent-&gt;parent);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			&#x2F;&#x2F;父亲是祖父的右儿子，叔叔是左儿子</span><br><span class="line">			Node&lt;T&gt; *uncle&#x3D;x-&gt;parent-&gt;parent-&gt;lchild;</span><br><span class="line">			if(get_color(uncle)&#x3D;&#x3D;RED)&#123;</span><br><span class="line">				&#x2F;&#x2F;4）叔叔是红色</span><br><span class="line">				x-&gt;parent-&gt;color&#x3D;BLACK;</span><br><span class="line">				uncle-&gt;color&#x3D;BLACK;</span><br><span class="line">				x-&gt;parent-&gt;parent-&gt;color&#x3D;RED;</span><br><span class="line">				x&#x3D;x-&gt;parent-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;</span><br><span class="line">				&#x2F;&#x2F;5）叔叔是黑色，父亲是祖父左儿子</span><br><span class="line">				if(x&#x3D;&#x3D;x-&gt;parent-&gt;lchild)&#123;</span><br><span class="line">					x&#x3D;x-&gt;parent;</span><br><span class="line">					rotate_right(x);</span><br><span class="line">				&#125;</span><br><span class="line">				&#x2F;&#x2F;6）叔叔是黑色，父亲是祖父右儿子</span><br><span class="line">				x-&gt;parent-&gt;color&#x3D;BLACK;</span><br><span class="line">				x-&gt;parent-&gt;parent-&gt;color&#x3D;RED;</span><br><span class="line">				rotate_left(x-&gt;parent-&gt;parent);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	root-&gt;color&#x3D;BLACK;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Node&lt;T&gt;* redBlackTree&lt;T&gt;::successor(Node&lt;T&gt; *x)&#123;</span><br><span class="line">	if(x&#x3D;&#x3D;NULL)return NULL;</span><br><span class="line">	if(x-&gt;rchild!&#x3D;NULL)&#123;</span><br><span class="line">		Node&lt;T&gt; *p&#x3D;x-&gt;rchild;</span><br><span class="line">		while(p-&gt;lchild!&#x3D;NULL)</span><br><span class="line">			p&#x3D;p-&gt;lchild;</span><br><span class="line">		return p;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		Node&lt;T&gt; *pa&#x3D;x-&gt;parent;</span><br><span class="line">		Node&lt;T&gt; *ch&#x3D;x;</span><br><span class="line">		while(pa!&#x3D;NULL&amp;&amp;ch&#x3D;&#x3D;pa-&gt;rchild)&#123;</span><br><span class="line">			ch&#x3D;pa;</span><br><span class="line">			pa&#x3D;pa-&gt;parent;</span><br><span class="line">		&#125;</span><br><span class="line">		return pa;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Node&lt;T&gt;* redBlackTree&lt;T&gt;::find(T e)&#123;</span><br><span class="line">	Node&lt;T&gt; *p&#x3D;root;</span><br><span class="line">	while(p!&#x3D;NULL)&#123;</span><br><span class="line">		if(e&lt;p-&gt;data)</span><br><span class="line">			p&#x3D;p-&gt;lchild;</span><br><span class="line">		else if(e&gt;p-&gt;data)</span><br><span class="line">			p&#x3D;p-&gt;rchild;</span><br><span class="line">		else&#123;</span><br><span class="line">			&#x2F;&#x2F; cout&lt;&lt;&quot;find it!&quot;&lt;&lt;endl;</span><br><span class="line">			return p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; cout&lt;&lt;&quot;can&#39;t find it.&quot;&lt;&lt;endl;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::erase(T e)&#123;</span><br><span class="line">    Node&lt;T&gt; *p&#x3D;find(e);</span><br><span class="line">    if(p!&#x3D;NULL)erase(p); </span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::erase(Node&lt;T&gt; *x)&#123;</span><br><span class="line">	if(x-&gt;lchild!&#x3D;NULL&amp;&amp;x-&gt;rchild!&#x3D;NULL)&#123;</span><br><span class="line">		Node&lt;T&gt; *s&#x3D;successor(x);</span><br><span class="line">		x-&gt;data&#x3D;s-&gt;data;</span><br><span class="line">		x&#x3D;s;</span><br><span class="line">	&#125;</span><br><span class="line">	Node&lt;T&gt; *tmp&#x3D;(x-&gt;lchild!&#x3D;NULL?x-&gt;lchild:x-&gt;rchild);</span><br><span class="line">	if(tmp!&#x3D;NULL)&#123;</span><br><span class="line">		tmp-&gt;parent&#x3D;x-&gt;parent;</span><br><span class="line">		if(x-&gt;parent&#x3D;&#x3D;NULL)</span><br><span class="line">			root&#x3D;tmp;</span><br><span class="line">		else if(x&#x3D;&#x3D;x-&gt;parent-&gt;lchild)</span><br><span class="line">			x-&gt;parent-&gt;lchild&#x3D;tmp;</span><br><span class="line">		else</span><br><span class="line">			x-&gt;parent-&gt;rchild&#x3D;tmp;</span><br><span class="line">		x-&gt;lchild&#x3D;x-&gt;rchild&#x3D;x-&gt;parent&#x3D;NULL;</span><br><span class="line">		if(get_color(x)&#x3D;&#x3D;BLACK)erase_fix_up(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	else if(x-&gt;parent&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">		root&#x3D;NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		if(get_color(x)&#x3D;&#x3D;BLACK)erase_fix_up(x);</span><br><span class="line">		if(x-&gt;parent!&#x3D;NULL)&#123;</span><br><span class="line">			if(x&#x3D;&#x3D;x-&gt;parent-&gt;lchild)</span><br><span class="line">				x-&gt;parent-&gt;lchild&#x3D;NULL;</span><br><span class="line">			else if(x&#x3D;&#x3D;x-&gt;parent-&gt;rchild)</span><br><span class="line">				x-&gt;parent-&gt;rchild&#x3D;NULL;</span><br><span class="line">			x-&gt;parent&#x3D;NULL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::erase_fix_up(Node&lt;T&gt; *x)&#123;</span><br><span class="line">    while(x!&#x3D;root&amp;&amp;get_color(x)&#x3D;&#x3D;BLACK)&#123;</span><br><span class="line">    	if(x&#x3D;&#x3D;x-&gt;parent-&gt;lchild)&#123;</span><br><span class="line">    		Node&lt;T&gt; *bro&#x3D;x-&gt;parent-&gt;rchild;</span><br><span class="line">    		if(get_color(bro)&#x3D;&#x3D;RED)&#123;</span><br><span class="line">    			bro-&gt;color&#x3D;BLACK;</span><br><span class="line">    			x-&gt;parent-&gt;color&#x3D;RED;</span><br><span class="line">    			rotate_left(x-&gt;parent);</span><br><span class="line">    			bro&#x3D;x-&gt;parent-&gt;rchild;</span><br><span class="line">    		&#125;</span><br><span class="line">    		if(get_color(bro-&gt;lchild)&#x3D;&#x3D;BLACK&amp;&amp;get_color(bro-&gt;rchild)&#x3D;&#x3D;BLACK)&#123;</span><br><span class="line">    			bro-&gt;color&#x3D;RED;</span><br><span class="line">    			x&#x3D;x-&gt;parent;</span><br><span class="line">    		&#125;</span><br><span class="line">    		else&#123;</span><br><span class="line">    			if(get_color(bro-&gt;rchild)&#x3D;&#x3D;BLACK)&#123;</span><br><span class="line">    				bro-&gt;lchild-&gt;color&#x3D;BLACK;</span><br><span class="line">    				bro-&gt;color&#x3D;RED;</span><br><span class="line">    				rotate_right(bro);</span><br><span class="line">    				bro&#x3D;x-&gt;parent-&gt;rchild;</span><br><span class="line">    			&#125;</span><br><span class="line">    			bro-&gt;color&#x3D;get_color(x-&gt;parent);</span><br><span class="line">    			x-&gt;parent-&gt;color&#x3D;BLACK;</span><br><span class="line">    			bro-&gt;rchild-&gt;color&#x3D;BLACK;</span><br><span class="line">    			rotate_left(x-&gt;parent);</span><br><span class="line">    			x&#x3D;root;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	else&#123;</span><br><span class="line">    		Node&lt;T&gt; *bro&#x3D;x-&gt;parent-&gt;lchild;</span><br><span class="line">    		if(get_color(bro)&#x3D;&#x3D;RED)&#123;</span><br><span class="line">    			bro-&gt;color&#x3D;BLACK;</span><br><span class="line">    			x-&gt;parent-&gt;color&#x3D;RED;</span><br><span class="line">    			rotate_right(x-&gt;parent);</span><br><span class="line">    			bro&#x3D;x-&gt;parent-&gt;lchild;</span><br><span class="line">    		&#125;</span><br><span class="line">    		if(get_color(bro-&gt;rchild)&#x3D;&#x3D;BLACK&amp;&amp;get_color(bro-&gt;lchild)&#x3D;&#x3D;BLACK)&#123;</span><br><span class="line">    			bro-&gt;color&#x3D;RED;</span><br><span class="line">    			x&#x3D;x-&gt;parent;</span><br><span class="line">    		&#125;</span><br><span class="line">    		else&#123;</span><br><span class="line">    			if(get_color(bro-&gt;lchild)&#x3D;&#x3D;BLACK)&#123;</span><br><span class="line">    				bro-&gt;rchild-&gt;color&#x3D;BLACK;</span><br><span class="line">    				bro-&gt;color&#x3D;RED;</span><br><span class="line">    				rotate_left(bro);</span><br><span class="line">    				bro&#x3D;x-&gt;parent-&gt;lchild;</span><br><span class="line">    			&#125;</span><br><span class="line">    			bro-&gt;color&#x3D;get_color(x-&gt;parent);</span><br><span class="line">    			x-&gt;parent-&gt;color&#x3D;BLACK;</span><br><span class="line">    			bro-&gt;lchild-&gt;color&#x3D;BLACK;</span><br><span class="line">    			rotate_right(x-&gt;parent);</span><br><span class="line">    			x&#x3D;root;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	x-&gt;color&#x3D;BLACK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class dredBlackTree:public BSTree&lt;T&gt;&#123;</span><br><span class="line">    private:</span><br><span class="line">        Node&lt;T&gt; *root;</span><br><span class="line">        Node&lt;T&gt;* successor(Node&lt;T&gt; *x);</span><br><span class="line">        bool is_empty();</span><br><span class="line">        void qianxu(Node&lt;T&gt; *t);</span><br><span class="line">        void ascend(Node&lt;T&gt; *t);</span><br><span class="line">        void houxu(Node&lt;T&gt; *t);</span><br><span class="line">        void insert_fix_up(Node&lt;T&gt; *x);</span><br><span class="line">        void erase_fix_up(Node&lt;T&gt; *x);</span><br><span class="line">        void erase(Node&lt;T&gt; *x);</span><br><span class="line">        int get_color(Node&lt;T&gt; *p)&#123;</span><br><span class="line">	    	return p&#x3D;&#x3D;NULL?BLACK:p-&gt;color;</span><br><span class="line">	    &#125;</span><br><span class="line">    public:</span><br><span class="line">        dredBlackTree()&#123;</span><br><span class="line">            root&#x3D;NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        ~dredBlackTree()&#123;</span><br><span class="line">            set_empty(root);</span><br><span class="line">        &#125;</span><br><span class="line">        void qianxu();</span><br><span class="line">        void ascend();</span><br><span class="line">        void houxu();</span><br><span class="line">        void rotate_left(Node&lt;T&gt; *x);</span><br><span class="line">        void rotate_right(Node&lt;T&gt; *y);</span><br><span class="line">        Node&lt;T&gt;* find(T e);</span><br><span class="line">        T get_min();</span><br><span class="line">        T get_max();</span><br><span class="line">        void erase(T e);</span><br><span class="line">        void insert(T e);</span><br><span class="line">        void set_empty(Node&lt;T&gt; *&amp;t);</span><br><span class="line">        void show();  </span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">bool dredBlackTree&lt;T&gt;::is_empty()&#123;</span><br><span class="line">    return root&#x3D;&#x3D;NULL;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void dredBlackTree&lt;T&gt;::set_empty(Node&lt;T&gt; *&amp;t)&#123;</span><br><span class="line">    if(t&#x3D;&#x3D;NULL)return;</span><br><span class="line">    if(t-&gt;lchild!&#x3D;NULL)</span><br><span class="line">        set_empty(t-&gt;lchild);</span><br><span class="line">    if(t-&gt;rchild!&#x3D;NULL)</span><br><span class="line">        set_empty(t-&gt;rchild);</span><br><span class="line">    delete t;</span><br><span class="line">    t&#x3D;NULL;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void dredBlackTree&lt;T&gt;::qianxu(Node&lt;T&gt; *t)&#123;</span><br><span class="line">    if(t!&#x3D;NULL)&#123;</span><br><span class="line">        cout&lt;&lt;t-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">        qianxu(t-&gt;lchild);</span><br><span class="line">        qianxu(t-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void dredBlackTree&lt;T&gt;::qianxu()&#123;</span><br><span class="line">    qianxu(root);</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void dredBlackTree&lt;T&gt;::ascend(Node&lt;T&gt; *t)&#123;</span><br><span class="line">    if(t!&#x3D;NULL)&#123;</span><br><span class="line">        ascend(t-&gt;lchild);</span><br><span class="line">        cout&lt;&lt;t-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">        ascend(t-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void dredBlackTree&lt;T&gt;::ascend()&#123;</span><br><span class="line">    ascend(root);</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void dredBlackTree&lt;T&gt;::houxu(Node&lt;T&gt; *t)&#123;</span><br><span class="line">    if(t!&#x3D;NULL)&#123;</span><br><span class="line">        houxu(t-&gt;lchild);</span><br><span class="line">        houxu(t-&gt;rchild);</span><br><span class="line">        cout&lt;&lt;t-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void dredBlackTree&lt;T&gt;::houxu()&#123;</span><br><span class="line">    houxu(root);</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T dredBlackTree&lt;T&gt;::get_min()&#123;</span><br><span class="line">    if(is_empty())return 0;</span><br><span class="line">    Node&lt;T&gt; *p&#x3D;root;</span><br><span class="line">    while(p-&gt;lchild!&#x3D;NULL)</span><br><span class="line">        p&#x3D;p-&gt;lchild;</span><br><span class="line">    cout&lt;&lt;&quot;min:&quot;&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">    return p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T dredBlackTree&lt;T&gt;::get_max()&#123;</span><br><span class="line">    if(is_empty())return 0;</span><br><span class="line">    Node&lt;T&gt; *p&#x3D;root;</span><br><span class="line">    while(p-&gt;rchild!&#x3D;NULL)</span><br><span class="line">        p&#x3D;p-&gt;rchild;</span><br><span class="line">    cout&lt;&lt;&quot;max:&quot;&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">    return p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void dredBlackTree&lt;T&gt;::rotate_left(Node&lt;T&gt; *x)&#123;</span><br><span class="line">	if(x&#x3D;&#x3D;NULL)return;</span><br><span class="line">    Node&lt;T&gt; *y&#x3D;x-&gt;rchild;</span><br><span class="line">    x-&gt;rchild&#x3D;y-&gt;lchild;</span><br><span class="line">    if(y-&gt;lchild!&#x3D;NULL)</span><br><span class="line">        y-&gt;lchild-&gt;parent&#x3D;x;</span><br><span class="line">    y-&gt;parent&#x3D;x-&gt;parent;</span><br><span class="line">    if(x-&gt;parent&#x3D;&#x3D;NULL)</span><br><span class="line">        root&#x3D;y;</span><br><span class="line">    else&#123;</span><br><span class="line">        if(x-&gt;parent-&gt;lchild&#x3D;&#x3D;x)</span><br><span class="line">            x-&gt;parent-&gt;lchild&#x3D;y;</span><br><span class="line">        else</span><br><span class="line">            x-&gt;parent-&gt;rchild&#x3D;y;</span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;lchild&#x3D;x;</span><br><span class="line">    x-&gt;parent&#x3D;y;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void dredBlackTree&lt;T&gt;::rotate_right(Node&lt;T&gt; *y)&#123;</span><br><span class="line">	if(y&#x3D;&#x3D;NULL)return;</span><br><span class="line">    Node&lt;T&gt; *x&#x3D;y-&gt;lchild;</span><br><span class="line">    y-&gt;lchild&#x3D;x-&gt;rchild;</span><br><span class="line">    if(x-&gt;rchild!&#x3D;NULL)</span><br><span class="line">        x-&gt;rchild-&gt;parent&#x3D;y;</span><br><span class="line">    x-&gt;parent&#x3D;y-&gt;parent;</span><br><span class="line">    if(y-&gt;parent&#x3D;&#x3D;NULL)</span><br><span class="line">        root&#x3D;x;</span><br><span class="line">    else&#123;</span><br><span class="line">        if(y-&gt;parent-&gt;rchild&#x3D;&#x3D;y)</span><br><span class="line">            y-&gt;parent-&gt;rchild&#x3D;x;</span><br><span class="line">        else</span><br><span class="line">            y-&gt;parent-&gt;lchild&#x3D;x;</span><br><span class="line">    &#125;</span><br><span class="line">    x-&gt;rchild&#x3D;y;</span><br><span class="line">    y-&gt;parent&#x3D;x;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void dredBlackTree&lt;T&gt;::insert(T e)&#123;</span><br><span class="line">	if(root&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">		root&#x3D;new Node&lt;T&gt;(e,BLACK,NULL,NULL,NULL);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">    Node&lt;T&gt; *pa&#x3D;NULL;</span><br><span class="line">    Node&lt;T&gt; *x&#x3D;root;</span><br><span class="line">    while(x!&#x3D;NULL)&#123;</span><br><span class="line">        pa&#x3D;x;</span><br><span class="line">        if(e&lt;x-&gt;data)</span><br><span class="line">            x&#x3D;x-&gt;lchild;</span><br><span class="line">        else x&#x3D;x-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;T&gt; *z&#x3D;new Node&lt;T&gt;(e,BLACK,NULL,NULL,NULL);</span><br><span class="line">    z-&gt;parent&#x3D;pa;</span><br><span class="line">    if(e&lt;pa-&gt;data)</span><br><span class="line">        pa-&gt;lchild&#x3D;z;</span><br><span class="line">    else </span><br><span class="line">        pa-&gt;rchild&#x3D;z;</span><br><span class="line">    insert_fix_up(z);</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void dredBlackTree&lt;T&gt;::insert_fix_up(Node&lt;T&gt; *x)&#123;</span><br><span class="line">	x-&gt;color&#x3D;RED;</span><br><span class="line">	while(x!&#x3D;NULL&amp;&amp;x!&#x3D;root&amp;&amp;get_color(x-&gt;parent)&#x3D;&#x3D;RED)&#123;</span><br><span class="line">		if(x-&gt;parent&#x3D;&#x3D;x-&gt;parent-&gt;parent-&gt;lchild)&#123;</span><br><span class="line">			&#x2F;&#x2F;父亲是祖父的右儿子，叔叔是左儿子</span><br><span class="line">			Node&lt;T&gt; *uncle&#x3D;x-&gt;parent-&gt;parent-&gt;rchild;</span><br><span class="line">			if(get_color(uncle)&#x3D;&#x3D;RED)&#123;</span><br><span class="line">				&#x2F;&#x2F;1）叔叔是红色</span><br><span class="line">				x-&gt;parent-&gt;color&#x3D;BLACK;</span><br><span class="line">				uncle-&gt;color&#x3D;BLACK;</span><br><span class="line">				x-&gt;parent-&gt;parent-&gt;color&#x3D;RED;</span><br><span class="line">				x&#x3D;x-&gt;parent-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;</span><br><span class="line">				&#x2F;&#x2F;2）叔叔是黑色，x是父亲右儿子</span><br><span class="line">				if(x&#x3D;&#x3D;x-&gt;parent-&gt;rchild)&#123;</span><br><span class="line">					x&#x3D;x-&gt;parent;</span><br><span class="line">					rotate_left(x);</span><br><span class="line">				&#125;</span><br><span class="line">				&#x2F;&#x2F;3）叔叔是黑色，x是父亲左儿子</span><br><span class="line">				x-&gt;parent-&gt;color&#x3D;BLACK;</span><br><span class="line">				x-&gt;parent-&gt;parent-&gt;color&#x3D;RED;</span><br><span class="line">				rotate_right(x-&gt;parent-&gt;parent);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			&#x2F;&#x2F;父亲是祖父的右儿子，叔叔是左儿子</span><br><span class="line">			Node&lt;T&gt; *uncle&#x3D;x-&gt;parent-&gt;parent-&gt;lchild;</span><br><span class="line">			if(get_color(uncle)&#x3D;&#x3D;RED)&#123;</span><br><span class="line">				&#x2F;&#x2F;4）叔叔是红色</span><br><span class="line">				x-&gt;parent-&gt;color&#x3D;BLACK;</span><br><span class="line">				uncle-&gt;color&#x3D;BLACK;</span><br><span class="line">				x-&gt;parent-&gt;parent-&gt;color&#x3D;RED;</span><br><span class="line">				x&#x3D;x-&gt;parent-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;</span><br><span class="line">				&#x2F;&#x2F;5）叔叔是黑色，父亲是祖父左儿子</span><br><span class="line">				if(x&#x3D;&#x3D;x-&gt;parent-&gt;lchild)&#123;</span><br><span class="line">					x&#x3D;x-&gt;parent;</span><br><span class="line">					rotate_right(x);</span><br><span class="line">				&#125;</span><br><span class="line">				&#x2F;&#x2F;6）叔叔是黑色，父亲是祖父右儿子</span><br><span class="line">				x-&gt;parent-&gt;color&#x3D;BLACK;</span><br><span class="line">				x-&gt;parent-&gt;parent-&gt;color&#x3D;RED;</span><br><span class="line">				rotate_left(x-&gt;parent-&gt;parent);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	root-&gt;color&#x3D;BLACK;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Node&lt;T&gt;* dredBlackTree&lt;T&gt;::successor(Node&lt;T&gt; *x)&#123;</span><br><span class="line">	if(x&#x3D;&#x3D;NULL)return NULL;</span><br><span class="line">	if(x-&gt;rchild!&#x3D;NULL)&#123;</span><br><span class="line">		Node&lt;T&gt; *p&#x3D;x-&gt;rchild;</span><br><span class="line">		while(p-&gt;lchild!&#x3D;NULL)</span><br><span class="line">			p&#x3D;p-&gt;lchild;</span><br><span class="line">		return p;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		Node&lt;T&gt; *pa&#x3D;x-&gt;parent;</span><br><span class="line">		Node&lt;T&gt; *ch&#x3D;x;</span><br><span class="line">		while(pa!&#x3D;NULL&amp;&amp;ch&#x3D;&#x3D;pa-&gt;rchild)&#123;</span><br><span class="line">			ch&#x3D;pa;</span><br><span class="line">			pa&#x3D;pa-&gt;parent;</span><br><span class="line">		&#125;</span><br><span class="line">		return pa;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Node&lt;T&gt;* dredBlackTree&lt;T&gt;::find(T e)&#123;</span><br><span class="line">	Node&lt;T&gt; *p&#x3D;root;</span><br><span class="line">	while(p!&#x3D;NULL)&#123;</span><br><span class="line">		if(e&lt;p-&gt;data)</span><br><span class="line">			p&#x3D;p-&gt;lchild;</span><br><span class="line">		else if(e&gt;p-&gt;data)</span><br><span class="line">			p&#x3D;p-&gt;rchild;</span><br><span class="line">		else&#123;</span><br><span class="line">			&#x2F;&#x2F; cout&lt;&lt;&quot;find it!&quot;&lt;&lt;endl;</span><br><span class="line">			return p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; cout&lt;&lt;&quot;can&#39;t find it.&quot;&lt;&lt;endl;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void dredBlackTree&lt;T&gt;::erase(T e)&#123;</span><br><span class="line">    Node&lt;T&gt; *p&#x3D;find(e);</span><br><span class="line">    while(p!&#x3D;NULL)&#123;</span><br><span class="line">    	erase(p); </span><br><span class="line">    	p&#x3D;find(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void dredBlackTree&lt;T&gt;::erase(Node&lt;T&gt; *x)&#123;</span><br><span class="line">	if(x-&gt;lchild!&#x3D;NULL&amp;&amp;x-&gt;rchild!&#x3D;NULL)&#123;</span><br><span class="line">		Node&lt;T&gt; *s&#x3D;successor(x);</span><br><span class="line">		x-&gt;data&#x3D;s-&gt;data;</span><br><span class="line">		x&#x3D;s;</span><br><span class="line">	&#125;</span><br><span class="line">	Node&lt;T&gt; *tmp&#x3D;(x-&gt;lchild!&#x3D;NULL?x-&gt;lchild:x-&gt;rchild);</span><br><span class="line">	if(tmp!&#x3D;NULL)&#123;</span><br><span class="line">		tmp-&gt;parent&#x3D;x-&gt;parent;</span><br><span class="line">		if(x-&gt;parent&#x3D;&#x3D;NULL)</span><br><span class="line">			root&#x3D;tmp;</span><br><span class="line">		else if(x&#x3D;&#x3D;x-&gt;parent-&gt;lchild)</span><br><span class="line">			x-&gt;parent-&gt;lchild&#x3D;tmp;</span><br><span class="line">		else</span><br><span class="line">			x-&gt;parent-&gt;rchild&#x3D;tmp;</span><br><span class="line">		x-&gt;lchild&#x3D;x-&gt;rchild&#x3D;x-&gt;parent&#x3D;NULL;</span><br><span class="line">		if(get_color(x)&#x3D;&#x3D;BLACK)erase_fix_up(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	else if(x-&gt;parent&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">		root&#x3D;NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		if(get_color(x)&#x3D;&#x3D;BLACK)erase_fix_up(x);</span><br><span class="line">		if(x-&gt;parent!&#x3D;NULL)&#123;</span><br><span class="line">			if(x&#x3D;&#x3D;x-&gt;parent-&gt;lchild)</span><br><span class="line">				x-&gt;parent-&gt;lchild&#x3D;NULL;</span><br><span class="line">			else if(x&#x3D;&#x3D;x-&gt;parent-&gt;rchild)</span><br><span class="line">				x-&gt;parent-&gt;rchild&#x3D;NULL;</span><br><span class="line">			x-&gt;parent&#x3D;NULL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void dredBlackTree&lt;T&gt;::erase_fix_up(Node&lt;T&gt; *x)&#123;</span><br><span class="line">    while(x!&#x3D;root&amp;&amp;get_color(x)&#x3D;&#x3D;BLACK)&#123;</span><br><span class="line">    	if(x&#x3D;&#x3D;x-&gt;parent-&gt;lchild)&#123;</span><br><span class="line">    		Node&lt;T&gt; *bro&#x3D;x-&gt;parent-&gt;rchild;</span><br><span class="line">    		if(get_color(bro)&#x3D;&#x3D;RED)&#123;</span><br><span class="line">    			bro-&gt;color&#x3D;BLACK;</span><br><span class="line">    			x-&gt;parent-&gt;color&#x3D;RED;</span><br><span class="line">    			rotate_left(x-&gt;parent);</span><br><span class="line">    			bro&#x3D;x-&gt;parent-&gt;rchild;</span><br><span class="line">    		&#125;</span><br><span class="line">    		if(get_color(bro-&gt;lchild)&#x3D;&#x3D;BLACK&amp;&amp;get_color(bro-&gt;rchild)&#x3D;&#x3D;BLACK)&#123;</span><br><span class="line">    			bro-&gt;color&#x3D;RED;</span><br><span class="line">    			x&#x3D;x-&gt;parent;</span><br><span class="line">    		&#125;</span><br><span class="line">    		else&#123;</span><br><span class="line">    			if(get_color(bro-&gt;rchild)&#x3D;&#x3D;BLACK)&#123;</span><br><span class="line">    				bro-&gt;lchild-&gt;color&#x3D;BLACK;</span><br><span class="line">    				bro-&gt;color&#x3D;RED;</span><br><span class="line">    				rotate_right(bro);</span><br><span class="line">    				bro&#x3D;x-&gt;parent-&gt;rchild;</span><br><span class="line">    			&#125;</span><br><span class="line">    			bro-&gt;color&#x3D;get_color(x-&gt;parent);</span><br><span class="line">    			x-&gt;parent-&gt;color&#x3D;BLACK;</span><br><span class="line">    			bro-&gt;rchild-&gt;color&#x3D;BLACK;</span><br><span class="line">    			rotate_left(x-&gt;parent);</span><br><span class="line">    			x&#x3D;root;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	else&#123;</span><br><span class="line">    		Node&lt;T&gt; *bro&#x3D;x-&gt;parent-&gt;lchild;</span><br><span class="line">    		if(get_color(bro)&#x3D;&#x3D;RED)&#123;</span><br><span class="line">    			bro-&gt;color&#x3D;BLACK;</span><br><span class="line">    			x-&gt;parent-&gt;color&#x3D;RED;</span><br><span class="line">    			rotate_right(x-&gt;parent);</span><br><span class="line">    			bro&#x3D;x-&gt;parent-&gt;lchild;</span><br><span class="line">    		&#125;</span><br><span class="line">    		if(get_color(bro-&gt;rchild)&#x3D;&#x3D;BLACK&amp;&amp;get_color(bro-&gt;lchild)&#x3D;&#x3D;BLACK)&#123;</span><br><span class="line">    			bro-&gt;color&#x3D;RED;</span><br><span class="line">    			x&#x3D;x-&gt;parent;</span><br><span class="line">    		&#125;</span><br><span class="line">    		else&#123;</span><br><span class="line">    			if(get_color(bro-&gt;lchild)&#x3D;&#x3D;BLACK)&#123;</span><br><span class="line">    				bro-&gt;rchild-&gt;color&#x3D;BLACK;</span><br><span class="line">    				bro-&gt;color&#x3D;RED;</span><br><span class="line">    				rotate_left(bro);</span><br><span class="line">    				bro&#x3D;x-&gt;parent-&gt;lchild;</span><br><span class="line">    			&#125;</span><br><span class="line">    			bro-&gt;color&#x3D;get_color(x-&gt;parent);</span><br><span class="line">    			x-&gt;parent-&gt;color&#x3D;BLACK;</span><br><span class="line">    			bro-&gt;lchild-&gt;color&#x3D;BLACK;</span><br><span class="line">    			rotate_right(x-&gt;parent);</span><br><span class="line">    			x&#x3D;root;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	x-&gt;color&#x3D;BLACK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	BSTree&lt;int&gt; *p;</span><br><span class="line">	redBlackTree&lt;int&gt; A;</span><br><span class="line">	dredBlackTree&lt;int&gt; B;</span><br><span class="line">	p&#x3D;&amp;A;</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    int tmp;</span><br><span class="line">    cout&lt;&lt;&quot;-----插入数据-----&quot;&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    for(int i&#x3D;0;i&lt;10;i++)&#123;</span><br><span class="line">        tmp&#x3D;i+1;</span><br><span class="line">        cout&lt;&lt;tmp&lt;&lt;&quot; &quot;;</span><br><span class="line">        A.insert(tmp);</span><br><span class="line">        B.insert(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;0;i&lt;15;i++)&#123;</span><br><span class="line">    	tmp&#x3D;rand()%10;</span><br><span class="line">    	cout&lt;&lt;tmp&lt;&lt;&quot; &quot;;</span><br><span class="line">    	A.insert(tmp);</span><br><span class="line">        B.insert(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;&quot;-----中序（升序）输出-----&quot;&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;redBlackTree:&quot;&lt;&lt;endl;A.ascend();cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;dredBlackTree:&quot;&lt;&lt;endl;B.ascend();cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;&quot;-----删除3-----&quot;&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    A.erase(3);</span><br><span class="line">	B.erase(3);</span><br><span class="line">    cout&lt;&lt;&quot;redBlackTree:&quot;&lt;&lt;endl;A.ascend();cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;dredBlackTree:&quot;&lt;&lt;endl;B.ascend();cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;&quot;-----删除5-----&quot;&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    A.erase(5);</span><br><span class="line">	B.erase(5);</span><br><span class="line">    cout&lt;&lt;&quot;redBlackTree:&quot;&lt;&lt;endl;A.ascend();cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;dredBlackTree:&quot;&lt;&lt;endl;B.ascend();cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>一些作业</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构第?次作业（R-B Tree红黑树c++实现插入删除，旋转调整图解）</title>
    <url>/6bd2e86e/</url>
    <content><![CDATA[<p>之前写的调整函数有点问题。。因为当时写完如释重负然后粗心大意的只测试了删除一个的情况，所以当时没有发现问题。。如果删除多个的话，可能会出现段错误，还是红黑赋颜色和判断出了问题</p>
<p>现在已经修改了</p>
<p>此外，推荐一下wiki的红黑树讲解<a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Red%E2%80%93black_tree</a>，讲的很详细。。不过我太菜了有英文障碍(＜_＜)</p>
<a id="more"></a>

<hr>
<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p>据说是要实现红黑树插删和前序输出</p>
<h1 id="红黑树："><a href="#红黑树：" class="headerlink" title="红黑树："></a>红黑树：</h1><h2 id="1-红黑树的性质："><a href="#1-红黑树的性质：" class="headerlink" title="1.红黑树的性质："></a>1.红黑树的性质：</h2><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knewl778j20pg09o3zv.jpg" alt=""></p>
<p>[ 这张图是盗的 ]</p>
<ol>
<li>节点是红色或黑色</li>
<li>根节点是黑色</li>
<li>每个叶节点（NIL节点，空节点!!!）是黑色的</li>
<li>每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点</li>
<li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点</li>
</ol>
<p>有红必有黑，反之则不一定</p>
<p>所以红黑树本质是一棵二叉查找树，最基础的二叉查找树如果退化成单链的话搜索性能是o(n)，但是增加了红黑着色使二叉树相对平衡，这样搜索性能就优化为o(logn)</p>
<p>平衡二叉树AVL的搜索性能也是o(logn)，它是高度平衡的二叉树，任意左子树和右子树高度差都小于等于1，但是这样在插入删除的时候就需要旋转多次来维护平衡，耗费时间，而红黑树的旋转操作简单一些，但是它并没有avl那么稳定</p>
<p>AVL树见这篇 -&gt; <a href="http://leflacon.github.io/a534447f/" target="_blank" rel="noopener">c++实现AVL树平衡二叉树，插入删除旋转图解</a></p>
<h2 id="2-红黑树的遍历："><a href="#2-红黑树的遍历：" class="headerlink" title="2.红黑树的遍历："></a>2.红黑树的遍历：</h2><p>前序中序后序遍历，因为本质是棵二叉树，所以就是二叉树的遍历</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">void RBTree&lt;T&gt;::qianxu(Node&lt;T&gt; *t)&#123;</span><br><span class="line">    if(t!&#x3D;NULL)&#123;</span><br><span class="line">        cout&lt;&lt;t-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">        qianxu(t-&gt;lchild);</span><br><span class="line">        qianxu(t-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void RBTree&lt;T&gt;::qianxu()&#123;</span><br><span class="line">    qianxu(root);</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void RBTree&lt;T&gt;::zhongxu(Node&lt;T&gt; *t)&#123;</span><br><span class="line">    if(t!&#x3D;NULL)&#123;</span><br><span class="line">        zhongxu(t-&gt;lchild);</span><br><span class="line">        cout&lt;&lt;t-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">        zhongxu(t-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void RBTree&lt;T&gt;::zhongxu()&#123;</span><br><span class="line">    zhongxu(root);</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void RBTree&lt;T&gt;::houxu(Node&lt;T&gt; *t)&#123;</span><br><span class="line">    if(t!&#x3D;NULL)&#123;</span><br><span class="line">        houxu(t-&gt;lchild);</span><br><span class="line">        houxu(t-&gt;rchild);</span><br><span class="line">        cout&lt;&lt;t-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void RBTree&lt;T&gt;::houxu()&#123;</span><br><span class="line">    houxu(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-红黑树的旋转："><a href="#3-红黑树的旋转：" class="headerlink" title="3.红黑树的旋转："></a>3.红黑树的旋转：</h2><h3 id="1）左旋"><a href="#1）左旋" class="headerlink" title="1）左旋"></a>1）左旋</h3><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knewlcozj20en05sweo.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::rotate_left(Node&lt;T&gt; *x)&#123;</span><br><span class="line">	if(x&#x3D;&#x3D;NULL)return;</span><br><span class="line">    Node&lt;T&gt; *y&#x3D;x-&gt;rchild;</span><br><span class="line">    x-&gt;rchild&#x3D;y-&gt;lchild;</span><br><span class="line">    if(y-&gt;lchild!&#x3D;NULL)</span><br><span class="line">        y-&gt;lchild-&gt;parent&#x3D;x;</span><br><span class="line">    y-&gt;parent&#x3D;x-&gt;parent;</span><br><span class="line">    if(x-&gt;parent&#x3D;&#x3D;NULL)</span><br><span class="line">        root&#x3D;y;</span><br><span class="line">    else&#123;</span><br><span class="line">        if(x-&gt;parent-&gt;lchild&#x3D;&#x3D;x)</span><br><span class="line">            x-&gt;parent-&gt;lchild&#x3D;y;</span><br><span class="line">        else</span><br><span class="line">            x-&gt;parent-&gt;rchild&#x3D;y;</span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;lchild&#x3D;x;</span><br><span class="line">    x-&gt;parent&#x3D;y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2）右旋"><a href="#2）右旋" class="headerlink" title="2）右旋"></a>2）右旋</h3><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knewkkitj20dt05laa9.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::rotate_right(Node&lt;T&gt; *y)&#123;</span><br><span class="line">	if(y&#x3D;&#x3D;NULL)return;</span><br><span class="line">    Node&lt;T&gt; *x&#x3D;y-&gt;lchild;</span><br><span class="line">    y-&gt;lchild&#x3D;x-&gt;rchild;</span><br><span class="line">    if(x-&gt;rchild!&#x3D;NULL)</span><br><span class="line">        x-&gt;rchild-&gt;parent&#x3D;y;</span><br><span class="line">    x-&gt;parent&#x3D;y-&gt;parent;</span><br><span class="line">    if(y-&gt;parent&#x3D;&#x3D;NULL)</span><br><span class="line">        root&#x3D;x;</span><br><span class="line">    else&#123;</span><br><span class="line">        if(y-&gt;parent-&gt;rchild&#x3D;&#x3D;y)</span><br><span class="line">            y-&gt;parent-&gt;rchild&#x3D;x;</span><br><span class="line">        else</span><br><span class="line">            y-&gt;parent-&gt;lchild&#x3D;x;</span><br><span class="line">    &#125;</span><br><span class="line">    x-&gt;rchild&#x3D;y;</span><br><span class="line">    y-&gt;parent&#x3D;x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-红黑树的插入："><a href="#4-红黑树的插入：" class="headerlink" title="4.红黑树的插入："></a>4.红黑树的插入：</h2><p>1）首先按照二叉搜索树的方法插入，就是一个节点的左子树都比它小，右子树都比它大</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::insert(T e)&#123;</span><br><span class="line">	if(root&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">		root&#x3D;new Node&lt;T&gt;(e,BLACK,NULL,NULL,NULL);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">    Node&lt;T&gt; *pa&#x3D;NULL;</span><br><span class="line">    Node&lt;T&gt; *x&#x3D;root;</span><br><span class="line">    while(x!&#x3D;NULL)&#123;</span><br><span class="line">        pa&#x3D;x;</span><br><span class="line">        if(e&lt;x-&gt;data)</span><br><span class="line">            x&#x3D;x-&gt;lchild;</span><br><span class="line">        else if(e&gt;x-&gt;data)x&#x3D;x-&gt;rchild;</span><br><span class="line">        else if(e&#x3D;&#x3D;x-&gt;data)&#123;</span><br><span class="line">        	&#x2F;&#x2F;cout&lt;&lt;&quot;重复！&quot;&lt;&lt;endl;</span><br><span class="line">    		return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;T&gt; *z&#x3D;new Node&lt;T&gt;(e,BLACK,NULL,NULL,NULL);</span><br><span class="line">    z-&gt;parent&#x3D;pa;</span><br><span class="line">    if(e&lt;pa-&gt;data)</span><br><span class="line">        pa-&gt;lchild&#x3D;z;</span><br><span class="line">    else </span><br><span class="line">        pa-&gt;rchild&#x3D;z;</span><br><span class="line">    &#x2F;&#x2F;然后调整</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）插入的节点染色为红色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x-&gt;color&#x3D;RED;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>染成红色而不是黑色是因为：上文红黑树性质5说“从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点”</p>
<p>染成红色就可以满足这条，然后只需要做其他调整即可</p>
</blockquote>
<p>3）重新调整为红黑树</p>
<h2 id="5-红黑树插入后的调整："><a href="#5-红黑树插入后的调整：" class="headerlink" title="5.红黑树插入后的调整："></a>5.红黑树插入后的调整：</h2><p>下面的图可画的可累死我了_(´ཀ`」 ∠) 但是这样直观好多（如果有哪里画错了。。那就是真的画错了。。以文字意思为准）</p>
<p>需要调整的条件：父亲存在并且父亲为红色（因为插入的当前儿子为红色，出现了红-红）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while((pa&#x3D;x-&gt;parent)!&#x3D;NULL&amp;&amp;pa-&gt;color&#x3D;&#x3D;RED)&#123;</span><br><span class="line">	&#x2F;&#x2F;调整</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1）父亲是祖父左儿子，叔叔是红色"><a href="#1）父亲是祖父左儿子，叔叔是红色" class="headerlink" title="1）父亲是祖父左儿子，叔叔是红色"></a>1）父亲是祖父左儿子，叔叔是红色</h3><p>如图，目前违背了红节点的儿子都是黑色，所以叔叔父亲都变黑，祖父变红，然后continue往上判断祖父是否要调整</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knfkqq40j20d605raac.jpg" alt=""></p>
<h3 id="2）父亲是祖父左儿子，叔叔是黑色，x是父亲右儿子"><a href="#2）父亲是祖父左儿子，叔叔是黑色，x是父亲右儿子" class="headerlink" title="2）父亲是祖父左儿子，叔叔是黑色，x是父亲右儿子"></a>2）父亲是祖父左儿子，叔叔是黑色，x是父亲右儿子</h3><p>左旋父亲，然后交换父亲和x</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kng21xthj20ey06vaaf.jpg" alt=""></p>
<p>可以发现经过这样的调整之后还是有红-红，这时候父亲是祖父左儿子，叔叔是黑色，x是父亲左儿子，需要再做调整，也就是下面的情况3）</p>
<h3 id="3）父亲是祖父左儿子，叔叔是黑色，x是父亲左儿子"><a href="#3）父亲是祖父左儿子，叔叔是黑色，x是父亲左儿子" class="headerlink" title="3）父亲是祖父左儿子，叔叔是黑色，x是父亲左儿子"></a>3）父亲是祖父左儿子，叔叔是黑色，x是父亲左儿子</h3><p>父亲变黑，祖父变红，右旋祖父</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kng6uky7j20ee064mxh.jpg" alt=""></p>
<h3 id="4）父亲是祖父右儿子，叔叔是红色"><a href="#4）父亲是祖父右儿子，叔叔是红色" class="headerlink" title="4）父亲是祖父右儿子，叔叔是红色"></a>4）父亲是祖父右儿子，叔叔是红色</h3><p>叔叔父亲都变黑，祖父变红，然后continue往上判断祖父是否要调整</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kngnsu43j209e03zjrf.jpg" alt=""></p>
<h3 id="5）父亲是祖父右儿子，叔叔是黑色，x是父亲左儿子"><a href="#5）父亲是祖父右儿子，叔叔是黑色，x是父亲左儿子" class="headerlink" title="5）父亲是祖父右儿子，叔叔是黑色，x是父亲左儿子"></a>5）父亲是祖父右儿子，叔叔是黑色，x是父亲左儿子</h3><p>右旋父亲，然后交换父亲和x</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kngnsp8ij20ec059wes.jpg" alt=""></p>
<p>还是有红-红，这时候父亲是祖父右儿子，叔叔是黑色，x是父亲右儿子，需要再做调整，也就是下面的情况6）</p>
<h3 id="6）父亲是祖父右儿子，叔叔是黑色，x是父亲右儿子"><a href="#6）父亲是祖父右儿子，叔叔是黑色，x是父亲右儿子" class="headerlink" title="6）父亲是祖父右儿子，叔叔是黑色，x是父亲右儿子"></a>6）父亲是祖父右儿子，叔叔是黑色，x是父亲右儿子</h3><p>父亲变黑，祖父变红，左旋祖父</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kngnsjyhj20di05lq38.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::insert_fix_up(Node&lt;T&gt; *x)&#123;</span><br><span class="line">	x-&gt;color&#x3D;RED;</span><br><span class="line">	while(x!&#x3D;NULL&amp;&amp;x!&#x3D;root&amp;&amp;get_color(x-&gt;parent)&#x3D;&#x3D;RED)&#123;</span><br><span class="line">		if(x-&gt;parent&#x3D;&#x3D;x-&gt;parent-&gt;parent-&gt;lchild)&#123;</span><br><span class="line">			&#x2F;&#x2F;父亲是祖父的右儿子，叔叔是左儿子</span><br><span class="line">			Node&lt;T&gt; *uncle&#x3D;x-&gt;parent-&gt;parent-&gt;rchild;</span><br><span class="line">			if(get_color(uncle)&#x3D;&#x3D;RED)&#123;</span><br><span class="line">				&#x2F;&#x2F;1）叔叔是红色</span><br><span class="line">				x-&gt;parent-&gt;color&#x3D;BLACK;</span><br><span class="line">				uncle-&gt;color&#x3D;BLACK;</span><br><span class="line">				x-&gt;parent-&gt;parent-&gt;color&#x3D;RED;</span><br><span class="line">				x&#x3D;x-&gt;parent-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;</span><br><span class="line">				&#x2F;&#x2F;2）叔叔是黑色，x是父亲右儿子</span><br><span class="line">				if(x&#x3D;&#x3D;x-&gt;parent-&gt;rchild)&#123;</span><br><span class="line">					x&#x3D;x-&gt;parent;</span><br><span class="line">					rotate_left(x);</span><br><span class="line">				&#125;</span><br><span class="line">				&#x2F;&#x2F;3）叔叔是黑色，x是父亲左儿子</span><br><span class="line">				x-&gt;parent-&gt;color&#x3D;BLACK;</span><br><span class="line">				x-&gt;parent-&gt;parent-&gt;color&#x3D;RED;</span><br><span class="line">				rotate_right(x-&gt;parent-&gt;parent);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			&#x2F;&#x2F;父亲是祖父的右儿子，叔叔是左儿子</span><br><span class="line">			Node&lt;T&gt; *uncle&#x3D;x-&gt;parent-&gt;parent-&gt;lchild;</span><br><span class="line">			if(get_color(uncle)&#x3D;&#x3D;RED)&#123;</span><br><span class="line">				&#x2F;&#x2F;4）叔叔是红色</span><br><span class="line">				x-&gt;parent-&gt;color&#x3D;BLACK;</span><br><span class="line">				uncle-&gt;color&#x3D;BLACK;</span><br><span class="line">				x-&gt;parent-&gt;parent-&gt;color&#x3D;RED;</span><br><span class="line">				x&#x3D;x-&gt;parent-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;</span><br><span class="line">				&#x2F;&#x2F;5）叔叔是黑色，父亲是祖父左儿子</span><br><span class="line">				if(x&#x3D;&#x3D;x-&gt;parent-&gt;lchild)&#123;</span><br><span class="line">					x&#x3D;x-&gt;parent;</span><br><span class="line">					rotate_right(x);</span><br><span class="line">				&#125;</span><br><span class="line">				&#x2F;&#x2F;6）叔叔是黑色，父亲是祖父右儿子</span><br><span class="line">				x-&gt;parent-&gt;color&#x3D;BLACK;</span><br><span class="line">				x-&gt;parent-&gt;parent-&gt;color&#x3D;RED;</span><br><span class="line">				rotate_left(x-&gt;parent-&gt;parent);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	root-&gt;color&#x3D;BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-红黑树的查找："><a href="#6-红黑树的查找：" class="headerlink" title="6.红黑树的查找："></a>6.红黑树的查找：</h2><p>根据二叉查找树的性质，小的在左子树大的在右子树，很容易写出如下查找函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">Node&lt;T&gt;* redBlackTree&lt;T&gt;::find(T e)&#123;</span><br><span class="line">	Node&lt;T&gt; *p&#x3D;root;</span><br><span class="line">	while(p!&#x3D;NULL)&#123;</span><br><span class="line">		if(e&lt;p-&gt;data)</span><br><span class="line">			p&#x3D;p-&gt;lchild;</span><br><span class="line">		else if(e&gt;p-&gt;data)</span><br><span class="line">			p&#x3D;p-&gt;rchild;</span><br><span class="line">		else&#123;</span><br><span class="line">			&#x2F;&#x2F; cout&lt;&lt;&quot;find it!&quot;&lt;&lt;endl;</span><br><span class="line">			return p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; cout&lt;&lt;&quot;can&#39;t find it.&quot;&lt;&lt;endl;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-红黑树的删除"><a href="#7-红黑树的删除" class="headerlink" title="7.红黑树的删除"></a>7.红黑树的删除</h2><h3 id="1）首先查找到要删除的元素，然后删除该结点"><a href="#1）首先查找到要删除的元素，然后删除该结点" class="headerlink" title="1）首先查找到要删除的元素，然后删除该结点"></a>1）首先查找到要删除的元素，然后删除该结点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node&lt;T&gt; *p&#x3D;find(e);</span><br><span class="line">if(p!&#x3D;NULL)erase(p);</span><br></pre></td></tr></table></figure>

<h3 id="2）重新调整为红黑树"><a href="#2）重新调整为红黑树" class="headerlink" title="2）重新调整为红黑树"></a>2）重新调整为红黑树</h3><h2 id="8-红黑树删除后的调整"><a href="#8-红黑树删除后的调整" class="headerlink" title="8.红黑树删除后的调整"></a>8.红黑树删除后的调整</h2><p>调整条件为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(x!&#x3D;root&amp;&amp;get_color(x)&#x3D;&#x3D;BLACK)&#123;</span><br><span class="line">	&#x2F;&#x2F;调整</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说如果当前x是黑色或者x是根，就满足红黑树了无需再调整</p>
<p>删除后可能出现的情况可以分为以下6种：【以下英文说明和图片均来自wiki】</p>
<h4 id="Case-1"><a href="#Case-1" class="headerlink" title="Case 1:"></a>Case 1:</h4><p>N is the new root. In this case, we are done. We removed one black node from every path, and the new root is black, so the properties are preserved.</p>
<p>如果要删除的是根的话，那么我们将获得一个新根，由于删除的那个根将使每条路都少一个黑色结点，而新的根是黑色的，所以每条路径上的黑色结点个数是一样的，仍保持红黑树</p>
<h4 id="Case-2"><a href="#Case-2" class="headerlink" title="Case 2:"></a>Case 2:</h4><p>S is red. In this case we reverse the colors of P and S, and then rotate left at P, turning S into N’s grandparent. Note that P has to be black as it had a red child. The resulting subtree has a path short one black node so we are not done. Now N has a black sibling and a red parent, so we can proceed to step 4, 5, or 6. (Its new sibling is black because it was once the child of the red S.) In later cases, we will relabel N’s new sibling as S.</p>
<p>如图，S是红色，先交换P和S位置，根据定义需要调整为P红S黑，然后对P实行左旋</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knhku5jhj209u046t8x.jpg" alt=""></p>
<h4 id="Case-3"><a href="#Case-3" class="headerlink" title="Case 3:"></a>Case 3:</h4><p>P, S, and S’s children are black. In this case, we simply repaint S red. The result is that all paths passing through S, which are precisely those paths not passing through N, have one less black node. Because deleting N’s original parent made all paths passing through N have one less black node, this evens things up. However, all paths through P now have one fewer black node than paths that do not pass through P, so property 5 (all paths from any given node to its leaf nodes contain the same number of black nodes) is still violated. To correct this, we perform the rebalancing procedure on P, starting at case 1.</p>
<p>如图，只需要把S变红即可满足要求</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knhkvgfmj209o045mxc.jpg" alt=""></p>
<h4 id="Case-4"><a href="#Case-4" class="headerlink" title="Case 4:"></a>Case 4:</h4><p>S and S’s children are black, but P is red. In this case, we simply exchange the colors of S and P. This does not affect the number of black nodes on paths going through S, but it does add one to the number of black nodes on paths going through N, making up for the deleted black node on those paths.</p>
<p>路径黑色结点个数不同，把P变黑S变红，则路径上的黑色结点个数相等</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knhkuv1uj209r0400sw.jpg" alt=""></p>
<h4 id="Case-5"><a href="#Case-5" class="headerlink" title="Case 5:"></a>Case 5:</h4><p>S is black, S’s left child is red, S’s right child is black, and N is the left child of its parent. In this case we rotate right at S, so that S’s left child becomes S’s parent and N’s new sibling. We then exchange the colors of S and its new parent. All paths still have the same number of black nodes, but now N has a black sibling whose right child is red, so we fall into case 6. Neither N nor its parent are affected by this transformation. (Again, for case 6, we relabel N’s new sibling as S.)</p>
<p>如图，进行一次右旋，然后中间的S变红</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knifadn2j207604cq2z.jpg" alt=""></p>
<h4 id="Case-6"><a href="#Case-6" class="headerlink" title="Case 6:"></a>Case 6:</h4><p>S is black, S’s right child is red, and N is the left child of its parent P. In this case we rotate left at P, so that S becomes the parent of P and S’s right child. We then exchange the colors of P and S, and make S’s right child black. The subtree still has the same color at its root, so Properties 4 (Both children of every red node are black) and 5 (All paths from any given node to its leaf nodes contain the same number of black nodes) are not violated. However, N now has one additional black ancestor: either P has become black, or it was black and S was added as a black grandparent. Thus, the paths passing through N pass through one additional black node.</p>
<p>对S左旋，然后SR变黑</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knifal1ej209k04174e.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::erase_fix_up(Node&lt;T&gt; *x)&#123;</span><br><span class="line">    while(x!&#x3D;root&amp;&amp;get_color(x)&#x3D;&#x3D;BLACK)&#123;</span><br><span class="line">    	if(x&#x3D;&#x3D;x-&gt;parent-&gt;lchild)&#123;</span><br><span class="line">    		Node&lt;T&gt; *bro&#x3D;x-&gt;parent-&gt;rchild;</span><br><span class="line">    		if(get_color(bro)&#x3D;&#x3D;RED)&#123;</span><br><span class="line">    			bro-&gt;color&#x3D;BLACK;</span><br><span class="line">    			x-&gt;parent-&gt;color&#x3D;RED;</span><br><span class="line">    			rotate_left(x-&gt;parent);</span><br><span class="line">    			bro&#x3D;x-&gt;parent-&gt;rchild;</span><br><span class="line">    		&#125;</span><br><span class="line">    		if(get_color(bro-&gt;lchild)&#x3D;&#x3D;BLACK&amp;&amp;get_color(bro-&gt;rchild)&#x3D;&#x3D;BLACK)&#123;</span><br><span class="line">    			bro-&gt;color&#x3D;RED;</span><br><span class="line">    			x&#x3D;x-&gt;parent;</span><br><span class="line">    		&#125;</span><br><span class="line">    		else&#123;</span><br><span class="line">    			if(get_color(bro-&gt;rchild)&#x3D;&#x3D;BLACK)&#123;</span><br><span class="line">    				bro-&gt;lchild-&gt;color&#x3D;BLACK;</span><br><span class="line">    				bro-&gt;color&#x3D;RED;</span><br><span class="line">    				rotate_right(bro);</span><br><span class="line">    				bro&#x3D;x-&gt;parent-&gt;rchild;</span><br><span class="line">    			&#125;</span><br><span class="line">    			bro-&gt;color&#x3D;get_color(x-&gt;parent);</span><br><span class="line">    			x-&gt;parent-&gt;color&#x3D;BLACK;</span><br><span class="line">    			bro-&gt;rchild-&gt;color&#x3D;BLACK;</span><br><span class="line">    			rotate_left(x-&gt;parent);</span><br><span class="line">    			x&#x3D;root;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	else&#123;</span><br><span class="line">    		Node&lt;T&gt; *bro&#x3D;x-&gt;parent-&gt;lchild;</span><br><span class="line">    		if(get_color(bro)&#x3D;&#x3D;RED)&#123;</span><br><span class="line">    			bro-&gt;color&#x3D;BLACK;</span><br><span class="line">    			x-&gt;parent-&gt;color&#x3D;RED;</span><br><span class="line">    			rotate_right(x-&gt;parent);</span><br><span class="line">    			bro&#x3D;x-&gt;parent-&gt;lchild;</span><br><span class="line">    		&#125;</span><br><span class="line">    		if(get_color(bro-&gt;rchild)&#x3D;&#x3D;BLACK&amp;&amp;get_color(bro-&gt;lchild)&#x3D;&#x3D;BLACK)&#123;</span><br><span class="line">    			bro-&gt;color&#x3D;RED;</span><br><span class="line">    			x&#x3D;x-&gt;parent;</span><br><span class="line">    		&#125;</span><br><span class="line">    		else&#123;</span><br><span class="line">    			if(get_color(bro-&gt;lchild)&#x3D;&#x3D;BLACK)&#123;</span><br><span class="line">    				bro-&gt;rchild-&gt;color&#x3D;BLACK;</span><br><span class="line">    				bro-&gt;color&#x3D;RED;</span><br><span class="line">    				rotate_left(bro);</span><br><span class="line">    				bro&#x3D;x-&gt;parent-&gt;lchild;</span><br><span class="line">    			&#125;</span><br><span class="line">    			bro-&gt;color&#x3D;get_color(x-&gt;parent);</span><br><span class="line">    			x-&gt;parent-&gt;color&#x3D;BLACK;</span><br><span class="line">    			bro-&gt;lchild-&gt;color&#x3D;BLACK;</span><br><span class="line">    			rotate_right(x-&gt;parent);</span><br><span class="line">    			x&#x3D;root;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	x-&gt;color&#x3D;BLACK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-红黑树的析构"><a href="#9-红黑树的析构" class="headerlink" title="9.红黑树的析构"></a>9.红黑树的析构</h2><p>从根节点一直往下delete即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">void RBTree&lt;T&gt;::set_empty(Node&lt;T&gt; *&amp;t)&#123;</span><br><span class="line">    if(t&#x3D;&#x3D;NULL)return;</span><br><span class="line">    if(t-&gt;lchild!&#x3D;NULL)</span><br><span class="line">        set_empty(t-&gt;lchild);</span><br><span class="line">    if(t-&gt;rchild!&#x3D;NULL)</span><br><span class="line">        set_empty(t-&gt;rchild);</span><br><span class="line">    delete t;</span><br><span class="line">    t&#x3D;NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="运行效果："><a href="#运行效果：" class="headerlink" title="运行效果："></a>运行效果：</h1><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knifa8ldj204p056dfw.jpg" alt=""></p>
<h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const int RED&#x3D;1;</span><br><span class="line">const int BLACK&#x3D;-1;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">struct Node&#123;</span><br><span class="line">    T data;</span><br><span class="line">    Node *lchild;</span><br><span class="line">    Node *rchild;</span><br><span class="line">    Node *parent;</span><br><span class="line">    int color;</span><br><span class="line">    Node(T e,int col,Node *p,Node *l,Node *r):</span><br><span class="line">        data(e),color(BLACK),parent(NULL),lchild(NULL),rchild(NULL)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class redBlackTree&#123;</span><br><span class="line">    private:</span><br><span class="line">        Node&lt;T&gt; *root;</span><br><span class="line">        Node&lt;T&gt;* successor(Node&lt;T&gt; *x);</span><br><span class="line">        bool is_empty();</span><br><span class="line">        void qianxu(Node&lt;T&gt; *t);</span><br><span class="line">        void ascend(Node&lt;T&gt; *t);</span><br><span class="line">        void houxu(Node&lt;T&gt; *t);</span><br><span class="line">        void insert_fix_up(Node&lt;T&gt; *x);</span><br><span class="line">        void erase_fix_up(Node&lt;T&gt; *x);</span><br><span class="line">        void erase(Node&lt;T&gt; *x);</span><br><span class="line">        int get_color(Node&lt;T&gt; *p)&#123;</span><br><span class="line">	    	return p&#x3D;&#x3D;NULL?BLACK:p-&gt;color;</span><br><span class="line">	    &#125;</span><br><span class="line">    public:</span><br><span class="line">        redBlackTree()&#123;</span><br><span class="line">            root&#x3D;NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        ~redBlackTree()&#123;</span><br><span class="line">            set_empty(root);</span><br><span class="line">        &#125;</span><br><span class="line">        void qianxu();</span><br><span class="line">        void ascend();</span><br><span class="line">        void houxu();</span><br><span class="line">        void rotate_left(Node&lt;T&gt; *x);</span><br><span class="line">        void rotate_right(Node&lt;T&gt; *y);</span><br><span class="line">        Node&lt;T&gt;* find(T e);</span><br><span class="line">        T get_min();</span><br><span class="line">        T get_max();</span><br><span class="line">        void erase(T e);</span><br><span class="line">        void insert(T e);</span><br><span class="line">        void set_empty(Node&lt;T&gt; *&amp;t);</span><br><span class="line">        void show();  </span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">bool redBlackTree&lt;T&gt;::is_empty()&#123;</span><br><span class="line">    return root&#x3D;&#x3D;NULL;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::set_empty(Node&lt;T&gt; *&amp;t)&#123;</span><br><span class="line">    if(t&#x3D;&#x3D;NULL)return;</span><br><span class="line">    if(t-&gt;lchild!&#x3D;NULL)</span><br><span class="line">        set_empty(t-&gt;lchild);</span><br><span class="line">    if(t-&gt;rchild!&#x3D;NULL)</span><br><span class="line">        set_empty(t-&gt;rchild);</span><br><span class="line">    delete t;</span><br><span class="line">    t&#x3D;NULL;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::qianxu(Node&lt;T&gt; *t)&#123;</span><br><span class="line">    if(t!&#x3D;NULL)&#123;</span><br><span class="line">        cout&lt;&lt;t-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">        qianxu(t-&gt;lchild);</span><br><span class="line">        qianxu(t-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::qianxu()&#123;</span><br><span class="line">    qianxu(root);</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::ascend(Node&lt;T&gt; *t)&#123;</span><br><span class="line">    if(t!&#x3D;NULL)&#123;</span><br><span class="line">        ascend(t-&gt;lchild);</span><br><span class="line">        cout&lt;&lt;t-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">        ascend(t-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::ascend()&#123;</span><br><span class="line">    ascend(root);</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::houxu(Node&lt;T&gt; *t)&#123;</span><br><span class="line">    if(t!&#x3D;NULL)&#123;</span><br><span class="line">        houxu(t-&gt;lchild);</span><br><span class="line">        houxu(t-&gt;rchild);</span><br><span class="line">        cout&lt;&lt;t-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::houxu()&#123;</span><br><span class="line">    houxu(root);</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T redBlackTree&lt;T&gt;::get_min()&#123;</span><br><span class="line">    if(is_empty())return 0;</span><br><span class="line">    Node&lt;T&gt; *p&#x3D;root;</span><br><span class="line">    while(p-&gt;lchild!&#x3D;NULL)</span><br><span class="line">        p&#x3D;p-&gt;lchild;</span><br><span class="line">    cout&lt;&lt;&quot;min:&quot;&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">    return p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T redBlackTree&lt;T&gt;::get_max()&#123;</span><br><span class="line">    if(is_empty())return 0;</span><br><span class="line">    Node&lt;T&gt; *p&#x3D;root;</span><br><span class="line">    while(p-&gt;rchild!&#x3D;NULL)</span><br><span class="line">        p&#x3D;p-&gt;rchild;</span><br><span class="line">    cout&lt;&lt;&quot;max:&quot;&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">    return p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::rotate_left(Node&lt;T&gt; *x)&#123;</span><br><span class="line">	if(x&#x3D;&#x3D;NULL)return;</span><br><span class="line">    Node&lt;T&gt; *y&#x3D;x-&gt;rchild;</span><br><span class="line">    x-&gt;rchild&#x3D;y-&gt;lchild;</span><br><span class="line">    if(y-&gt;lchild!&#x3D;NULL)</span><br><span class="line">        y-&gt;lchild-&gt;parent&#x3D;x;</span><br><span class="line">    y-&gt;parent&#x3D;x-&gt;parent;</span><br><span class="line">    if(x-&gt;parent&#x3D;&#x3D;NULL)</span><br><span class="line">        root&#x3D;y;</span><br><span class="line">    else&#123;</span><br><span class="line">        if(x-&gt;parent-&gt;lchild&#x3D;&#x3D;x)</span><br><span class="line">            x-&gt;parent-&gt;lchild&#x3D;y;</span><br><span class="line">        else</span><br><span class="line">            x-&gt;parent-&gt;rchild&#x3D;y;</span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;lchild&#x3D;x;</span><br><span class="line">    x-&gt;parent&#x3D;y;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::rotate_right(Node&lt;T&gt; *y)&#123;</span><br><span class="line">	if(y&#x3D;&#x3D;NULL)return;</span><br><span class="line">    Node&lt;T&gt; *x&#x3D;y-&gt;lchild;</span><br><span class="line">    y-&gt;lchild&#x3D;x-&gt;rchild;</span><br><span class="line">    if(x-&gt;rchild!&#x3D;NULL)</span><br><span class="line">        x-&gt;rchild-&gt;parent&#x3D;y;</span><br><span class="line">    x-&gt;parent&#x3D;y-&gt;parent;</span><br><span class="line">    if(y-&gt;parent&#x3D;&#x3D;NULL)</span><br><span class="line">        root&#x3D;x;</span><br><span class="line">    else&#123;</span><br><span class="line">        if(y-&gt;parent-&gt;rchild&#x3D;&#x3D;y)</span><br><span class="line">            y-&gt;parent-&gt;rchild&#x3D;x;</span><br><span class="line">        else</span><br><span class="line">            y-&gt;parent-&gt;lchild&#x3D;x;</span><br><span class="line">    &#125;</span><br><span class="line">    x-&gt;rchild&#x3D;y;</span><br><span class="line">    y-&gt;parent&#x3D;x;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::insert(T e)&#123;</span><br><span class="line">	if(root&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">		root&#x3D;new Node&lt;T&gt;(e,BLACK,NULL,NULL,NULL);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">    Node&lt;T&gt; *pa&#x3D;NULL;</span><br><span class="line">    Node&lt;T&gt; *x&#x3D;root;</span><br><span class="line">    while(x!&#x3D;NULL)&#123;</span><br><span class="line">        pa&#x3D;x;</span><br><span class="line">        if(e&lt;x-&gt;data)</span><br><span class="line">            x&#x3D;x-&gt;lchild;</span><br><span class="line">        else if(e&gt;x-&gt;data)x&#x3D;x-&gt;rchild;</span><br><span class="line">        else if(e&#x3D;&#x3D;x-&gt;data)&#123;</span><br><span class="line">        	&#x2F;&#x2F;cout&lt;&lt;&quot;重复！&quot;&lt;&lt;endl;</span><br><span class="line">    		return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;T&gt; *z&#x3D;new Node&lt;T&gt;(e,BLACK,NULL,NULL,NULL);</span><br><span class="line">    z-&gt;parent&#x3D;pa;</span><br><span class="line">    if(e&lt;pa-&gt;data)</span><br><span class="line">        pa-&gt;lchild&#x3D;z;</span><br><span class="line">    else </span><br><span class="line">        pa-&gt;rchild&#x3D;z;</span><br><span class="line">    insert_fix_up(z);</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::insert_fix_up(Node&lt;T&gt; *x)&#123;</span><br><span class="line">	x-&gt;color&#x3D;RED;</span><br><span class="line">	while(x!&#x3D;NULL&amp;&amp;x!&#x3D;root&amp;&amp;get_color(x-&gt;parent)&#x3D;&#x3D;RED)&#123;</span><br><span class="line">		if(x-&gt;parent&#x3D;&#x3D;x-&gt;parent-&gt;parent-&gt;lchild)&#123;</span><br><span class="line">			&#x2F;&#x2F;父亲是祖父的右儿子，叔叔是左儿子</span><br><span class="line">			Node&lt;T&gt; *uncle&#x3D;x-&gt;parent-&gt;parent-&gt;rchild;</span><br><span class="line">			if(get_color(uncle)&#x3D;&#x3D;RED)&#123;</span><br><span class="line">				&#x2F;&#x2F;1）叔叔是红色</span><br><span class="line">				x-&gt;parent-&gt;color&#x3D;BLACK;</span><br><span class="line">				uncle-&gt;color&#x3D;BLACK;</span><br><span class="line">				x-&gt;parent-&gt;parent-&gt;color&#x3D;RED;</span><br><span class="line">				x&#x3D;x-&gt;parent-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;</span><br><span class="line">				&#x2F;&#x2F;2）叔叔是黑色，x是父亲右儿子</span><br><span class="line">				if(x&#x3D;&#x3D;x-&gt;parent-&gt;rchild)&#123;</span><br><span class="line">					x&#x3D;x-&gt;parent;</span><br><span class="line">					rotate_left(x);</span><br><span class="line">				&#125;</span><br><span class="line">				&#x2F;&#x2F;3）叔叔是黑色，x是父亲左儿子</span><br><span class="line">				x-&gt;parent-&gt;color&#x3D;BLACK;</span><br><span class="line">				x-&gt;parent-&gt;parent-&gt;color&#x3D;RED;</span><br><span class="line">				rotate_right(x-&gt;parent-&gt;parent);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			&#x2F;&#x2F;父亲是祖父的右儿子，叔叔是左儿子</span><br><span class="line">			Node&lt;T&gt; *uncle&#x3D;x-&gt;parent-&gt;parent-&gt;lchild;</span><br><span class="line">			if(get_color(uncle)&#x3D;&#x3D;RED)&#123;</span><br><span class="line">				&#x2F;&#x2F;4）叔叔是红色</span><br><span class="line">				x-&gt;parent-&gt;color&#x3D;BLACK;</span><br><span class="line">				uncle-&gt;color&#x3D;BLACK;</span><br><span class="line">				x-&gt;parent-&gt;parent-&gt;color&#x3D;RED;</span><br><span class="line">				x&#x3D;x-&gt;parent-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;</span><br><span class="line">				&#x2F;&#x2F;5）叔叔是黑色，父亲是祖父左儿子</span><br><span class="line">				if(x&#x3D;&#x3D;x-&gt;parent-&gt;lchild)&#123;</span><br><span class="line">					x&#x3D;x-&gt;parent;</span><br><span class="line">					rotate_right(x);</span><br><span class="line">				&#125;</span><br><span class="line">				&#x2F;&#x2F;6）叔叔是黑色，父亲是祖父右儿子</span><br><span class="line">				x-&gt;parent-&gt;color&#x3D;BLACK;</span><br><span class="line">				x-&gt;parent-&gt;parent-&gt;color&#x3D;RED;</span><br><span class="line">				rotate_left(x-&gt;parent-&gt;parent);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	root-&gt;color&#x3D;BLACK;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Node&lt;T&gt;* redBlackTree&lt;T&gt;::successor(Node&lt;T&gt; *x)&#123;</span><br><span class="line">	if(x&#x3D;&#x3D;NULL)return NULL;</span><br><span class="line">	if(x-&gt;rchild!&#x3D;NULL)&#123;</span><br><span class="line">		Node&lt;T&gt; *p&#x3D;x-&gt;rchild;</span><br><span class="line">		while(p-&gt;lchild!&#x3D;NULL)</span><br><span class="line">			p&#x3D;p-&gt;lchild;</span><br><span class="line">		return p;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		Node&lt;T&gt; *pa&#x3D;x-&gt;parent;</span><br><span class="line">		Node&lt;T&gt; *ch&#x3D;x;</span><br><span class="line">		while(pa!&#x3D;NULL&amp;&amp;ch&#x3D;&#x3D;pa-&gt;rchild)&#123;</span><br><span class="line">			ch&#x3D;pa;</span><br><span class="line">			pa&#x3D;pa-&gt;parent;</span><br><span class="line">		&#125;</span><br><span class="line">		return pa;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Node&lt;T&gt;* redBlackTree&lt;T&gt;::find(T e)&#123;</span><br><span class="line">	Node&lt;T&gt; *p&#x3D;root;</span><br><span class="line">	while(p!&#x3D;NULL)&#123;</span><br><span class="line">		if(e&lt;p-&gt;data)</span><br><span class="line">			p&#x3D;p-&gt;lchild;</span><br><span class="line">		else if(e&gt;p-&gt;data)</span><br><span class="line">			p&#x3D;p-&gt;rchild;</span><br><span class="line">		else&#123;</span><br><span class="line">			&#x2F;&#x2F; cout&lt;&lt;&quot;find it!&quot;&lt;&lt;endl;</span><br><span class="line">			return p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; cout&lt;&lt;&quot;can&#39;t find it.&quot;&lt;&lt;endl;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::erase(T e)&#123;</span><br><span class="line">    Node&lt;T&gt; *p&#x3D;find(e);</span><br><span class="line">    if(p!&#x3D;NULL)erase(p); </span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::erase(Node&lt;T&gt; *x)&#123;</span><br><span class="line">	if(x-&gt;lchild!&#x3D;NULL&amp;&amp;x-&gt;rchild!&#x3D;NULL)&#123;</span><br><span class="line">		Node&lt;T&gt; *s&#x3D;successor(x);</span><br><span class="line">		x-&gt;data&#x3D;s-&gt;data;</span><br><span class="line">		x&#x3D;s;</span><br><span class="line">	&#125;</span><br><span class="line">	Node&lt;T&gt; *tmp&#x3D;(x-&gt;lchild!&#x3D;NULL?x-&gt;lchild:x-&gt;rchild);</span><br><span class="line">	if(tmp!&#x3D;NULL)&#123;</span><br><span class="line">		tmp-&gt;parent&#x3D;x-&gt;parent;</span><br><span class="line">		if(x-&gt;parent&#x3D;&#x3D;NULL)</span><br><span class="line">			root&#x3D;tmp;</span><br><span class="line">		else if(x&#x3D;&#x3D;x-&gt;parent-&gt;lchild)</span><br><span class="line">			x-&gt;parent-&gt;lchild&#x3D;tmp;</span><br><span class="line">		else</span><br><span class="line">			x-&gt;parent-&gt;rchild&#x3D;tmp;</span><br><span class="line">		x-&gt;lchild&#x3D;x-&gt;rchild&#x3D;x-&gt;parent&#x3D;NULL;</span><br><span class="line">		if(get_color(x)&#x3D;&#x3D;BLACK)erase_fix_up(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	else if(x-&gt;parent&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">		root&#x3D;NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		if(get_color(x)&#x3D;&#x3D;BLACK)erase_fix_up(x);</span><br><span class="line">		if(x-&gt;parent!&#x3D;NULL)&#123;</span><br><span class="line">			if(x&#x3D;&#x3D;x-&gt;parent-&gt;lchild)</span><br><span class="line">				x-&gt;parent-&gt;lchild&#x3D;NULL;</span><br><span class="line">			else if(x&#x3D;&#x3D;x-&gt;parent-&gt;rchild)</span><br><span class="line">				x-&gt;parent-&gt;rchild&#x3D;NULL;</span><br><span class="line">			x-&gt;parent&#x3D;NULL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void redBlackTree&lt;T&gt;::erase_fix_up(Node&lt;T&gt; *x)&#123;</span><br><span class="line">    while(x!&#x3D;root&amp;&amp;get_color(x)&#x3D;&#x3D;BLACK)&#123;</span><br><span class="line">    	if(x&#x3D;&#x3D;x-&gt;parent-&gt;lchild)&#123;</span><br><span class="line">    		Node&lt;T&gt; *bro&#x3D;x-&gt;parent-&gt;rchild;</span><br><span class="line">    		if(get_color(bro)&#x3D;&#x3D;RED)&#123;</span><br><span class="line">    			bro-&gt;color&#x3D;BLACK;</span><br><span class="line">    			x-&gt;parent-&gt;color&#x3D;RED;</span><br><span class="line">    			rotate_left(x-&gt;parent);</span><br><span class="line">    			bro&#x3D;x-&gt;parent-&gt;rchild;</span><br><span class="line">    		&#125;</span><br><span class="line">    		if(get_color(bro-&gt;lchild)&#x3D;&#x3D;BLACK&amp;&amp;get_color(bro-&gt;rchild)&#x3D;&#x3D;BLACK)&#123;</span><br><span class="line">    			bro-&gt;color&#x3D;RED;</span><br><span class="line">    			x&#x3D;x-&gt;parent;</span><br><span class="line">    		&#125;</span><br><span class="line">    		else&#123;</span><br><span class="line">    			if(get_color(bro-&gt;rchild)&#x3D;&#x3D;BLACK)&#123;</span><br><span class="line">    				bro-&gt;lchild-&gt;color&#x3D;BLACK;</span><br><span class="line">    				bro-&gt;color&#x3D;RED;</span><br><span class="line">    				rotate_right(bro);</span><br><span class="line">    				bro&#x3D;x-&gt;parent-&gt;rchild;</span><br><span class="line">    			&#125;</span><br><span class="line">    			bro-&gt;color&#x3D;get_color(x-&gt;parent);</span><br><span class="line">    			x-&gt;parent-&gt;color&#x3D;BLACK;</span><br><span class="line">    			bro-&gt;rchild-&gt;color&#x3D;BLACK;</span><br><span class="line">    			rotate_left(x-&gt;parent);</span><br><span class="line">    			x&#x3D;root;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	else&#123;</span><br><span class="line">    		Node&lt;T&gt; *bro&#x3D;x-&gt;parent-&gt;lchild;</span><br><span class="line">    		if(get_color(bro)&#x3D;&#x3D;RED)&#123;</span><br><span class="line">    			bro-&gt;color&#x3D;BLACK;</span><br><span class="line">    			x-&gt;parent-&gt;color&#x3D;RED;</span><br><span class="line">    			rotate_right(x-&gt;parent);</span><br><span class="line">    			bro&#x3D;x-&gt;parent-&gt;lchild;</span><br><span class="line">    		&#125;</span><br><span class="line">    		if(get_color(bro-&gt;rchild)&#x3D;&#x3D;BLACK&amp;&amp;get_color(bro-&gt;lchild)&#x3D;&#x3D;BLACK)&#123;</span><br><span class="line">    			bro-&gt;color&#x3D;RED;</span><br><span class="line">    			x&#x3D;x-&gt;parent;</span><br><span class="line">    		&#125;</span><br><span class="line">    		else&#123;</span><br><span class="line">    			if(get_color(bro-&gt;lchild)&#x3D;&#x3D;BLACK)&#123;</span><br><span class="line">    				bro-&gt;rchild-&gt;color&#x3D;BLACK;</span><br><span class="line">    				bro-&gt;color&#x3D;RED;</span><br><span class="line">    				rotate_left(bro);</span><br><span class="line">    				bro&#x3D;x-&gt;parent-&gt;lchild;</span><br><span class="line">    			&#125;</span><br><span class="line">    			bro-&gt;color&#x3D;get_color(x-&gt;parent);</span><br><span class="line">    			x-&gt;parent-&gt;color&#x3D;BLACK;</span><br><span class="line">    			bro-&gt;lchild-&gt;color&#x3D;BLACK;</span><br><span class="line">    			rotate_right(x-&gt;parent);</span><br><span class="line">    			x&#x3D;root;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	x-&gt;color&#x3D;BLACK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	redBlackTree&lt;int&gt; *p&#x3D;new redBlackTree&lt;int&gt;;</span><br><span class="line"></span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    int tmp;</span><br><span class="line">    cout&lt;&lt;&quot;-----插入数据-----&quot;&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    for(int i&#x3D;0;i&lt;10;i++)&#123;</span><br><span class="line">        tmp&#x3D;i+1;</span><br><span class="line">        cout&lt;&lt;tmp&lt;&lt;&quot; &quot;;</span><br><span class="line">        p-&gt;insert(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;&quot;-----前序输出-----&quot;&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    p-&gt;qianxu();</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;&quot;-----删除123-----&quot;&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    p-&gt;erase(3);p-&gt;qianxu();cout&lt;&lt;endl;</span><br><span class="line">    p-&gt;erase(1);p-&gt;qianxu();cout&lt;&lt;endl;</span><br><span class="line">    p-&gt;erase(2);p-&gt;qianxu();cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>一些作业</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 518 (Div. 2) [Thanks, Mail.Ru!]（A-F）</title>
    <url>/408c21d7/</url>
    <content><![CDATA[<h1 id="A-Birthday"><a href="#A-Birthday" class="headerlink" title="A. Birthday"></a>A. Birthday</h1><p><a href="http://codeforces.com/contest/1068/problem/A" target="_blank" rel="noopener">http://codeforces.com/contest/1068/problem/A</a></p>
<blockquote>
<p>题意：有n种不同硬币，寿星已经有k种硬币，他有m个朋友，每个朋友会给他送硬币，对于每个朋友来说有三个要求：1.所有朋友送的硬币数相同 2.所有要送的硬币种类不同 3.最终寿星要获得至少l种新硬币，求每个朋友需要送的最小硬币数</p>
</blockquote>
<p>就是求满足下式的最小ans，没有的话就是-1</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmobepf5j207x02wa9z.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">int main()&#123;</span><br><span class="line">    long double n,m,k,l;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;l;</span><br><span class="line">    LL ans&#x3D;ceil((k+l)&#x2F;m);</span><br><span class="line">    printf(&quot;%lld\n&quot;,ans*m&lt;&#x3D;n?ans:-1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-LCM（gcd）"><a href="#B-LCM（gcd）" class="headerlink" title="B. LCM（gcd）"></a>B. LCM（gcd）</h1><p><a href="http://codeforces.com/contest/1068/problem/B" target="_blank" rel="noopener">http://codeforces.com/contest/1068/problem/B</a></p>
<blockquote>
<p>题意：给定b，对所有a[1,1e18]，求<code>lcm(a,b)/a</code>可能的取值个数</p>
</blockquote>
<p>如下化简，因为a可以取所有值，所以最后求的就是b的因子个数</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmobbsv5j209l02mt8o.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">int main()&#123;</span><br><span class="line">    LL b;</span><br><span class="line">    cin&gt;&gt;b;</span><br><span class="line">    int ans&#x3D;0;</span><br><span class="line">    LL i;</span><br><span class="line">    for(i&#x3D;1;i*i&lt;b;i++)</span><br><span class="line">        if(b%i&#x3D;&#x3D;0)</span><br><span class="line">            ans+&#x3D;2;</span><br><span class="line">    if(i*i&#x3D;&#x3D;b)ans++;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-Colored-Rooks（构造）"><a href="#C-Colored-Rooks（构造）" class="headerlink" title="C. Colored Rooks（构造）"></a>C. Colored Rooks（构造）</h1><p><a href="http://codeforces.com/contest/1068/problem/C" target="_blank" rel="noopener">http://codeforces.com/contest/1068/problem/C</a></p>
<blockquote>
<p>题意：</p>
<p>n个颜色，m种颜色关系，在<code>1e9*1e9</code>的图中摆放这些颜色</p>
<p>如果两个颜色有关系就要放在同一行同一列，否则就不行，相连就是指在同一行同一列</p>
<p>要求满足：1）每种颜色必须用一次，2）同色必须相连，3）有关系的才能相连，没关系的不能相连</p>
</blockquote>
<p>构造思路：</p>
<p>每个颜色放一行，如果有颜色和它有关系，就依次加在那一列上，反正是1e9的棋盘，肯定能放下</p>
<p>比如1和24有关，2和34有关，3和4有关：</p>
<p>| | | | | | | |<br>—|—|—|—|—|—|—|—<br>| | 4| |4 |4 | | |<br>| | |3 | |3 | | |<br>|2 | |2 |2 | | | |<br>|1 |1 | | | | | |</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;105;</span><br><span class="line">int g[N][N],n,m;</span><br><span class="line">vector&lt;int&gt;v[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    memset(g,0,sizeof(g));</span><br><span class="line">    for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">        int u,v;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">        g[u][v]&#x3D;g[v][u]&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    int ji&#x3D;1;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        v[i].push_back(ji);&#x2F;&#x2F;i行ji列填i</span><br><span class="line">        ji++;</span><br><span class="line">        for(int j&#x3D;i+1;j&lt;&#x3D;n;j++)&#123;</span><br><span class="line">            if(g[i][j])&#123;</span><br><span class="line">                v[i].push_back(ji);&#x2F;&#x2F;i行ji列填i</span><br><span class="line">                v[j].push_back(ji);&#x2F;&#x2F;j行ji列填j</span><br><span class="line">                ji++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;v[i].size()&lt;&lt;endl;</span><br><span class="line">        for(int j&#x3D;0;j&lt;v[i].size();j++)</span><br><span class="line">            printf(&quot;%d %d\n&quot;,i,v[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-Array-Without-Local-Maximums（dp）"><a href="#D-Array-Without-Local-Maximums（dp）" class="headerlink" title="D. Array Without Local Maximums（dp）"></a>D. Array Without Local Maximums（dp）</h1><p><a href="http://codeforces.com/contest/1068/problem/D" target="_blank" rel="noopener">http://codeforces.com/contest/1068/problem/D</a></p>
<blockquote>
<p>题意：有一个由[1,200]间的数组成的n个数的序列，这个序列满足下图条件，即对于第2个到第n-1个元素要求相邻元素至少有一个大于等于它，现在这个序列有一部分不记得了，不记得的位置标记为-1，求恢复的方法数</p>
</blockquote>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmobbkxdj208j02iq2v.jpg" alt=""></p>
<p>dp[i][j][k]表示第i个数字为j，且第i个数和第i-1个数的关系为k时的方案数，k取值为0，1，2分别代表小于等于大于</p>
<p>状态转移的时候对于某个不确定的位的方法数，可以用一个前缀和tmp累加，求小于时j从小到大，求大于时j从大到小</p>
<p>最后答案就是<code>∑(dp[n][i][1]+dp[n][i][2])</code>，枚举最后一位i[1,200]相加即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;1e5+5;</span><br><span class="line">const int p&#x3D;998244353;</span><br><span class="line">LL dp[N][205][3],a[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">        scanf(&quot;%lld&quot;,&amp;a[i]);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;200;i++)&#123;</span><br><span class="line">        if(a[1]&#x3D;&#x3D;-1||a[1]&#x3D;&#x3D;i)</span><br><span class="line">            dp[1][i][0]&#x3D;1;</span><br><span class="line">        else</span><br><span class="line">            dp[1][i][0]&#x3D;0;</span><br><span class="line">    &#125;</span><br><span class="line">    int tmp;</span><br><span class="line">    for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        for(int j&#x3D;1;j&lt;&#x3D;200;j++)&#123;</span><br><span class="line">            if(a[i]&#x3D;&#x3D;-1||a[i]&#x3D;&#x3D;j)</span><br><span class="line">                dp[i][j][1]&#x3D;(dp[i-1][j][0]+dp[i-1][j][1]+dp[i-1][j][2])%p;</span><br><span class="line">            else dp[i][j][1]&#x3D;0;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp&#x3D;0;</span><br><span class="line">        for(int j&#x3D;1;j&lt;&#x3D;200;j++)&#123;</span><br><span class="line">            if(a[i]&#x3D;&#x3D;-1||a[i]&#x3D;&#x3D;j)dp[i][j][0]&#x3D;tmp;</span><br><span class="line">            else dp[i][j][0]&#x3D;0;</span><br><span class="line">            tmp&#x3D;(tmp+dp[i-1][j][0]+dp[i-1][j][1]+dp[i-1][j][2])%p;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp&#x3D;0;</span><br><span class="line">        for(int j&#x3D;200;j&gt;&#x3D;1;j--)&#123;</span><br><span class="line">            if(a[i]&#x3D;&#x3D;-1||a[i]&#x3D;&#x3D;j)dp[i][j][2]&#x3D;tmp;</span><br><span class="line">            else dp[i][j][2]&#x3D;0;</span><br><span class="line">            tmp&#x3D;(tmp+dp[i-1][j][1]+dp[i-1][j][2])%p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans&#x3D;0;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;200;i++)ans&#x3D;(ans+dp[n][i][1]+dp[n][i][2])%p;</span><br><span class="line">    printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E-Multihedgehog（dfs，找多叉树的根）"><a href="#E-Multihedgehog（dfs，找多叉树的根）" class="headerlink" title="E. Multihedgehog（dfs，找多叉树的根）"></a>E. Multihedgehog（dfs，找多叉树的根）</h1><p><a href="http://codeforces.com/contest/1068/problem/E" target="_blank" rel="noopener">http://codeforces.com/contest/1068/problem/E</a></p>
<blockquote>
<p>题意：</p>
<p>「k-刺猬」定义如下</p>
<p>1-刺猬：有一个度数至少为3的点和一些度数为1的点</p>
<p>k-刺猬（k&gt;=2）：如果把所有(k-1)-刺猬看成一个度数为1的点，那么有一个度数至少为3的点和一些度数为1的点</p>
<p>给一棵树，问这棵树是不是k-刺猬</p>
</blockquote>
<p>一种思路是模拟：找度数为1的点，然后同父亲且三个以上的合并，父亲在下一轮作为一个新的度数为1的结点，一直模拟下去判断是否符合定义即可</p>
<p>所以还有一种思路是dfs:先找到树根，然后从树根开始往下dfs判断是否是合法的k-刺猬，判断就是如果当前深度为1就判断度数是否为1，如果当前深度不为1就dfs儿子，如果儿子都合法判断儿子个数是否大于等于3</p>
<p>个人感觉。。第二种优美一些，就写的第二种</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;1e5+5;</span><br><span class="line">vector&lt;int&gt;g[N];</span><br><span class="line">int rt,n,k;</span><br><span class="line">int find_root(int x,int pre)&#123;</span><br><span class="line">    int d&#x3D;-1;</span><br><span class="line">    for(int i&#x3D;0;i&lt;g[x].size();i++)&#123;</span><br><span class="line">        int y&#x3D;g[x][i];</span><br><span class="line">        if(y!&#x3D;pre)&#123;</span><br><span class="line">            int dd&#x3D;find_root(y,x);</span><br><span class="line">            if(dd&#x3D;&#x3D;-1)return -1;</span><br><span class="line">            d&#x3D;max(d,dd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(++d&#x3D;&#x3D;k)&#123;</span><br><span class="line">        rt&#x3D;x;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line">bool dfs(int x,int pre,int d)&#123;</span><br><span class="line">    if(d&#x3D;&#x3D;0)return g[x].size()&#x3D;&#x3D;1;</span><br><span class="line">    d--;</span><br><span class="line">    int num&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;g[x].size();i++)&#123;</span><br><span class="line">        int y&#x3D;g[x][i];</span><br><span class="line">        if(y!&#x3D;pre)&#123;</span><br><span class="line">            num++;</span><br><span class="line">            if(!dfs(y,x,d))return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return num&gt;&#x3D;3;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);</span><br><span class="line">    int u,v;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n-1;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">        g[u].push_back(v);</span><br><span class="line">        g[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    find_root(1,1);</span><br><span class="line">    if(dfs(rt,rt,k))puts(&quot;Yes&quot;);</span><br><span class="line">    else puts(&quot;No&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="F-Knights（思维，神仙构造）"><a href="#F-Knights（思维，神仙构造）" class="headerlink" title="F. Knights（思维，神仙构造）"></a>F. Knights（思维，神仙构造）</h1><p><a href="http://codeforces.com/contest/1068/problem/F" target="_blank" rel="noopener">http://codeforces.com/contest/1068/problem/F</a></p>
<p>题意：有一个无限大的棋盘，一开始有n个骑士（骑士走“日”字），如果一个点可以被四个骑士一步走到，就在这个点的位置放一个新骑士，这个步骤是有限的，重复这样的步骤到不能增加为止，要求给出初始的n个位置使最终骑士数至少为<code>[n^2/10]</code>，n范围[1,1000]</p>
<p>蛮酷的构造题0.0官方题解如下：（为什么这么构造呢0.0我也不知道。。那个<code>[n^2/10]</code>就很迷很神仙的样子。。可能就是见多了就会构造了吧。。mark一下）</p>
<p>如图，所有初始棋子都摆在固定两行（中间间隔两行即可），然后一层<code>[1,2n/3]</code>，另一层间隔的摆剩下的<code>n-2n/3</code>个</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmow696bj20ad05gmxn.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;2*n&#x2F;3;i++)</span><br><span class="line">        printf(&quot;%d %d\n&quot;,i,1);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n-2*n&#x2F;3;i++)</span><br><span class="line">        printf(&quot;%d %d\n&quot;,i*2,4);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>dp</tag>
        <tag>搜索</tag>
        <tag>cf</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>《奇遇人生》 第4期：毛不易探访老人院，为他们再唱《消愁》引合唱</title>
    <url>/bb091769/</url>
    <content><![CDATA[<ul>
<li><p style="background-color:rgba(239,221,236,0.7)">以音乐温暖生命</p>
</li>
<li><p style="background-color:rgba(239,221,236,0.7)">因为你们觉得很孤独，在做一样事情的人很少</p>

</li>
</ul>
<blockquote>
<p>有些事情，选择去做的时候，也默许选择了孤独</p>
</blockquote>
<ul>
<li><p style="background-color:rgba(239,221,236,0.7)">毛毛：我当然很关心，我希望她幸福，她是集真善美与一身的一个人（阿雅：所以小s是你的偶像？），我希望成为她</p>
</li>
<li><p style="background-color:rgba(239,221,236,0.7)">毛毛：她觉得她的儿子都是一个不成功的人，就是，就是那个时候我学习又不好，又容易挂科，然后又可能拿不到毕业证，就很多很多事，然后让她很焦虑，然后又不会做饭，又不会照顾自己，在她临走的那一刻都，她的儿子都是一个不成功的人</p>
</li>
<li><p style="background-color:rgba(239,221,236,0.7)">毛毛：感觉很，无能为力，就是，洪水猛兽，时间流逝，你能做的就那么多，帮不到所有人。珮珮：我们是帮不到所有人，但是，不做就永远没有人。</p>

</li>
</ul>
<center>

<p>日出又日落<br>深处再深处<br>一张小方桌<br>有一荤一素<br>一个身影从容的忙忙碌碌<br>一双手让这时光有了温度<br>太年轻的人，他总是不满足<br>固执地不愿停下<br>远行的脚步<br>望着高高的天<br>走了长长的路<br>忘了回头看<br>她有没有哭</p>
<p>月儿明<br>风儿轻<br>可是你在敲打我的窗棂<br>听到这你就别担心<br>其实我过得还可以<br>月儿明<br>风儿轻<br>你又可曾来过我的梦里<br>一定是你来时太小心<br>知道我睡的轻</p>
</center>

<blockquote>
<p>但我还是固执的不愿停下远行的脚步</p>
</blockquote>
<ul>
<li><p style="background-color:rgba(239,221,236,0.7)">一想到你呀，人间似天堂</p>

</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knj53bgjj20xx0he43f.jpg" alt=""></p>
<ul>
<li><p style="background-color:rgba(200,200,233,0.7)">毛不易：这次从台湾回来之后，确实给我很大触动，确实音乐，像音乐治疗师他们，可以通过音乐来帮助到很多人，但是在内地，这一块还是相对不那么普遍，我也希望通过咱们这个纪录片，能够让大家意识到，音乐对于健康和对于人文关怀上的一些帮助。用音乐的方式去感动别人也感动自己。</p>

</li>
</ul>
<hr>
<center><font size="12" color=#5959ff>J</font><font size="12" color=#a5b2ff>’</font><font size="8" color=#8888fd>a</font><font size="8" color=#7762fd>i</font><font size="8" color=#f1a8ce>m</font><font size="8" color=#a97afd>e </font><font size="8" color=#a7a7f5>m</font><font size="8" color=#628dfd>a </font><font size="8" color=#6363ff>v</font><font size="8" color=#8e64ff>i</font><font size="8" color=#ffafc7>e</font></center>

<hr>
]]></content>
      <categories>
        <category>love&amp;peace</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构第八次作业（c++实现AVL树平衡二叉树，插入删除旋转图解）</title>
    <url>/a534447f/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ol>
<li><p>编写函数，计算AVL树的高度，要求说明该函数是所有算法中最优的</p>
</li>
<li><p>编写函数，返回AVL树中距离根节点最近的叶节点的值</p>
</li>
</ol>
<a id="more"></a>

<h1 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>空二叉树是AVL树</p>
<p>如果T是一棵非空的二叉树，TL和TR分别是其左子树和右子树，那么满足以下条件，T是一棵AVL树：</p>
<p>1.TL和TR是AVL树</p>
<p>2.|hL-hR|≤1，hL和hR分别是左子树和右子树的高度</p>
<h2 id="AVL树的特性："><a href="#AVL树的特性：" class="headerlink" title="AVL树的特性："></a>AVL树的特性：</h2><p>n个元素（节点）的AVL树的高度是O(logn)</p>
<p>对于每一个n（n≥0）值，都存在一棵AVL树（保证任何时刻，插入操作都是可完成的）</p>
<p>一棵n元素的AVL搜索树能在O(高度)=O(logn)的时间内完成搜索</p>
<p>将一个新元素插入到一棵n元素的AVL搜索树中，可得到一棵n+1元素的AVL树，这种插入过程可以在O(logn)时间内完成</p>
<p>从一棵n元素的AVL搜索树中删除一个元素，可得到一棵n-1元素的AVL树，这种删除过程可以在O(logn)时间内完成</p>
<h2 id="AVL树搜索："><a href="#AVL树搜索：" class="headerlink" title="AVL树搜索："></a>AVL树搜索：</h2><p>与一般的二叉搜索树BST一致</p>
<p>从根节点开始将key与节点值比较，如果key小于节点值，进入左子树；如果key大于节点值，进入右子树；直到找到或子树为空停止</p>
<h2 id="AVL树插入："><a href="#AVL树插入：" class="headerlink" title="AVL树插入："></a>AVL树插入：</h2><p>与二叉搜索树的插入一样，然后进行旋转调整</p>
<h2 id="AVL树旋转："><a href="#AVL树旋转：" class="headerlink" title="AVL树旋转："></a>AVL树旋转：</h2><p>下面是特地配色了的旋转图解(｡ì _ í｡)</p>
<h3 id="1）LL型-右单旋"><a href="#1）LL型-右单旋" class="headerlink" title="1）LL型 右单旋"></a>1）LL型 右单旋</h3><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knbp7jgvj20kx0biaax.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">void AVLTree&lt;T&gt;::rotate_right(Node&lt;T&gt; *&amp;t)&#123;</span><br><span class="line">    Node&lt;T&gt; *p&#x3D;t-&gt;lchild;</span><br><span class="line">    t-&gt;lchild&#x3D;p-&gt;rchild;</span><br><span class="line">    p-&gt;rchild&#x3D;t;</span><br><span class="line">    t-&gt;height&#x3D;max(get_height(t-&gt;lchild),get_height(t-&gt;rchild))+1;</span><br><span class="line">    p-&gt;height&#x3D;max(get_height(p-&gt;lchild),t-&gt;height)+1;</span><br><span class="line">    t&#x3D;p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2）RR型-左单旋"><a href="#2）RR型-左单旋" class="headerlink" title="2）RR型 左单旋"></a>2）RR型 左单旋</h3><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knbpf1r2j20js0bl3yx.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">void AVLTree&lt;T&gt;::rotate_left(Node&lt;T&gt; *&amp;t)&#123;</span><br><span class="line">    Node&lt;T&gt; *p&#x3D;t-&gt;rchild;</span><br><span class="line">    t-&gt;rchild&#x3D;p-&gt;lchild;</span><br><span class="line">    p-&gt;lchild&#x3D;t;</span><br><span class="line">    t-&gt;height&#x3D;max(get_height(t-&gt;lchild),get_height(t-&gt;rchild))+1;</span><br><span class="line">    p-&gt;height&#x3D;max(get_height(p-&gt;rchild),t-&gt;height)+1;</span><br><span class="line">    t&#x3D;p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3）RL型-先右后左旋"><a href="#3）RL型-先右后左旋" class="headerlink" title="3）RL型 先右后左旋"></a>3）RL型 先右后左旋</h3><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knbp8c07j20oa0bgmy9.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">void AVLTree&lt;T&gt;::right_left(Node&lt;T&gt; *&amp;t)&#123;</span><br><span class="line">    rotate_right(t-&gt;rchild);</span><br><span class="line">    rotate_left(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4）LR型-先左后右旋"><a href="#4）LR型-先左后右旋" class="headerlink" title="4）LR型 先左后右旋"></a>4）LR型 先左后右旋</h3><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kndgkbxkj20oa0ah754.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">void AVLTree&lt;T&gt;::left_right(Node&lt;T&gt; *&amp;t)&#123;</span><br><span class="line">    rotate_left(t-&gt;lchild);</span><br><span class="line">    rotate_right(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AVL树删除"><a href="#AVL树删除" class="headerlink" title="AVL树删除"></a>AVL树删除</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(e&lt;t-&gt;data)remove(e,t-&gt;lchild);</span><br><span class="line">else if(e&gt;t-&gt;data)remove(e,t-&gt;rchild);</span><br><span class="line">else&#123;</span><br><span class="line">	&#x2F;&#x2F;删除</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如果要删除的节点不为叶子节点"><a href="#如果要删除的节点不为叶子节点" class="headerlink" title="如果要删除的节点不为叶子节点"></a>如果要删除的节点不为叶子节点</h3><p>那么把该节点右子树里最小的左儿子（也就是左儿子的左儿子的左儿子……）移到该节点，然后删除那个最小的节点，如下图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(t-&gt;lchild!&#x3D;NULL&amp;&amp;t-&gt;rchild!&#x3D;NULL)&#123;</span><br><span class="line">    Node *p&#x3D;t-&gt;rchild;</span><br><span class="line">    while(p-&gt;lchild!&#x3D;NULL)p&#x3D;p-&gt;lchild;</span><br><span class="line">    t-&gt;data&#x3D;p-&gt;data;</span><br><span class="line">    remove(t-&gt;rchild,p-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kne09vufj20bb072glu.jpg" alt=""></p>
<h3 id="如果要删除的节点为叶子节点"><a href="#如果要删除的节点为叶子节点" class="headerlink" title="如果要删除的节点为叶子节点"></a>如果要删除的节点为叶子节点</h3><p>直接delete即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node&lt;T&gt; *p&#x3D;t-&gt;lchild&#x3D;&#x3D;NULL?t-&gt;rchild:t-&gt;lchild;</span><br><span class="line">delete t;</span><br><span class="line">t&#x3D;p;</span><br><span class="line">return;</span><br></pre></td></tr></table></figure>

<h3 id="删除后如果失去平衡要重新调整"><a href="#删除后如果失去平衡要重新调整" class="headerlink" title="删除后如果失去平衡要重新调整"></a>删除后如果失去平衡要重新调整</h3><p>调整原理和判断条件都和插入一样，最后更新一下高度即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(get_height(t-&gt;lchild)-get_height(t-&gt;rchild)&#x3D;&#x3D;2)&#123;</span><br><span class="line">    if(get_height(t-&gt;lchild-&gt;lchild)&gt;get_height(t-&gt;lchild-&gt;rchild))</span><br><span class="line">            rotate_right(t);</span><br><span class="line">        else left_right(t);</span><br><span class="line">&#125;</span><br><span class="line">else if(get_height(t-&gt;rchild)-get_height(t-&gt;lchild)&#x3D;&#x3D;2)&#123;</span><br><span class="line">    if(get_height(t-&gt;rchild-&gt;lchild)&gt;get_height(t-&gt;rchild-&gt;rchild))</span><br><span class="line">        right_left(t);</span><br><span class="line">    else rotate_left(t);</span><br><span class="line">&#125;</span><br><span class="line">t-&gt;height&#x3D;max(get_height(t-&gt;lchild),get_height(t-&gt;rchild))+1;</span><br></pre></td></tr></table></figure>

<h2 id="AVL树的高度"><a href="#AVL树的高度" class="headerlink" title="AVL树的高度"></a>AVL树的高度</h2><p>树的高度就是 左右子树取高的那个高度再加一</p>
<p>一直递归即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">int AVLTree&lt;T&gt;::tree_height(Node&lt;T&gt; *t)&#123;</span><br><span class="line">    if(t&#x3D;&#x3D;NULL)return 0;</span><br><span class="line">    int lh&#x3D;0,rh&#x3D;0;</span><br><span class="line">    lh&#x3D;tree_height(t-&gt;lchild)+1;</span><br><span class="line">    rh&#x3D;tree_height(t-&gt;rchild)+1;</span><br><span class="line">    return max(lh,rh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AVL树中距离根节点最近的叶节点的值"><a href="#AVL树中距离根节点最近的叶节点的值" class="headerlink" title="AVL树中距离根节点最近的叶节点的值"></a>AVL树中距离根节点最近的叶节点的值</h2><p>第二个题说返回AVL树中距离根节点最近的叶节点的值，但是距离相同的最近的可以有很多，所以把距离最小的全部输出</p>
<p>思路就是一个dfs遍历下去，因为高度差最大也就1，所以最后只需在高度差为1和为2的时候判断是否只向单边拓展即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">void AVLTree&lt;T&gt;::get_near2(Node&lt;T&gt; *t)&#123;</span><br><span class="line">    if(t&#x3D;&#x3D;NULL)return;</span><br><span class="line">    if(t-&gt;lchild&#x3D;&#x3D;NULL&amp;&amp;t-&gt;rchild&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">        cout&lt;&lt;t-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int lh&#x3D;0,rh&#x3D;0;</span><br><span class="line">    lh&#x3D;tree_height(t-&gt;lchild);</span><br><span class="line">    rh&#x3D;tree_height(t-&gt;rchild);</span><br><span class="line">    if(lh&lt;rh&amp;&amp;lh!&#x3D;0)get_near2(t-&gt;lchild);</span><br><span class="line">    else if(lh&gt;rh&amp;&amp;rh!&#x3D;0)get_near2(t-&gt;rchild);</span><br><span class="line">    else&#123;</span><br><span class="line">        get_near2(t-&gt;lchild);</span><br><span class="line">        get_near2(t-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h1><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kneajoggj20fr0i4n2f.jpg" alt=""></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">struct Node&#123;</span><br><span class="line">    T data;</span><br><span class="line">    Node *lchild;</span><br><span class="line">    Node *rchild;</span><br><span class="line">    int height;</span><br><span class="line">    Node(const T &amp;e,Node *lc,Node *rc,int h&#x3D;0)</span><br><span class="line">        :data(e),lchild(lc),rchild(rc),height(h)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class AVLTree&#123;</span><br><span class="line">    private:</span><br><span class="line">        Node&lt;T&gt; *root;</span><br><span class="line">        void insert(const T &amp;x,Node&lt;T&gt; *&amp;t);</span><br><span class="line">        void remove(T e,Node&lt;T&gt; *&amp;t);</span><br><span class="line">        void set_empty();</span><br><span class="line">    public:</span><br><span class="line">        AVLTree()&#123;</span><br><span class="line">            root&#x3D;NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        ~AVLTree()&#123;</span><br><span class="line">            set_empty(root);</span><br><span class="line">        &#125;</span><br><span class="line">        bool is_empty();</span><br><span class="line">        void set_empty(Node&lt;T&gt; *t);</span><br><span class="line">        T find_min(Node&lt;T&gt; *t);</span><br><span class="line">        T find_max(Node&lt;T&gt; *t);</span><br><span class="line">        int get_height(Node&lt;T&gt; *t);</span><br><span class="line">        Node&lt;T&gt;* get_root();</span><br><span class="line">        void insert(const T &amp;x);</span><br><span class="line">        void rotate_right(Node&lt;T&gt; *&amp;t);</span><br><span class="line">        void rotate_left(Node&lt;T&gt; *&amp;t);</span><br><span class="line">        void right_left(Node&lt;T&gt; *&amp;t);</span><br><span class="line">        void left_right(Node&lt;T&gt; *&amp;t);</span><br><span class="line">        void show_smaller(Node&lt;T&gt; *t);</span><br><span class="line">        void show_bigger(Node&lt;T&gt; *t);</span><br><span class="line">        void remove(T e);</span><br><span class="line">        int tree_height(Node&lt;T&gt; *t);</span><br><span class="line">        void get_near(Node&lt;T&gt; *t);</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">bool AVLTree&lt;T&gt;::is_empty()&#123;</span><br><span class="line">    return root&#x3D;&#x3D;NULL;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void AVLTree&lt;T&gt;::set_empty(Node&lt;T&gt; *t)&#123;</span><br><span class="line">    if(t!&#x3D;NULL)&#123;</span><br><span class="line">        set_empty(t-&gt;lchild);</span><br><span class="line">        set_empty(t-&gt;rchild);</span><br><span class="line">        delete t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void AVLTree&lt;T&gt;::set_empty()&#123;</span><br><span class="line">    this-&gt;set_empty(root);</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">int AVLTree&lt;T&gt;::get_height(Node&lt;T&gt; *t)&#123;</span><br><span class="line">    return t&#x3D;&#x3D;NULL?-1:t-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Node&lt;T&gt;* AVLTree&lt;T&gt;::get_root()&#123;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T AVLTree&lt;T&gt;::find_max(Node&lt;T&gt; *t)&#123;</span><br><span class="line">    if(t-&gt;rchild&#x3D;&#x3D;NULL)return t-&gt;data;</span><br><span class="line">    else return find_max(t-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T AVLTree&lt;T&gt;::find_min(Node&lt;T&gt; *t)&#123;</span><br><span class="line">    if(t-&gt;lchild&#x3D;&#x3D;NULL)return t-&gt;data;</span><br><span class="line">    else return find_min(t-&gt;lchild);</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void AVLTree&lt;T&gt;::insert(const T &amp;x,Node&lt;T&gt; *&amp;t)&#123;</span><br><span class="line">    if(t&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">        t&#x3D;new Node&lt;T&gt;(x,NULL,NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(x&lt;t-&gt;data)&#123;</span><br><span class="line">        insert(x,t-&gt;lchild);</span><br><span class="line">        if(get_height(t-&gt;lchild)-get_height(t-&gt;rchild)&#x3D;&#x3D;2)&#123;</span><br><span class="line">            if(get_height(t-&gt;lchild-&gt;lchild)&gt;get_height(t-&gt;lchild-&gt;rchild))</span><br><span class="line">                rotate_right(t);</span><br><span class="line">            else left_right(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(x&gt;t-&gt;data)&#123;</span><br><span class="line">        insert(x,t-&gt;rchild);</span><br><span class="line">        if(get_height(t-&gt;rchild)-get_height(t-&gt;lchild)&#x3D;&#x3D;2)&#123;</span><br><span class="line">            if(get_height(t-&gt;rchild-&gt;lchild)&gt;get_height(t-&gt;rchild-&gt;rchild))</span><br><span class="line">                right_left(t);</span><br><span class="line">            else rotate_left(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;cout&lt;&lt;get_height(t-&gt;lchild)&lt;&lt;&quot; &quot;&lt;&lt;get_height(t-&gt;rchild)&lt;&lt;endl;</span><br><span class="line">    t-&gt;height&#x3D;max(get_height(t-&gt;lchild),get_height(t-&gt;rchild))+1;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void AVLTree&lt;T&gt;::insert(const T &amp;x)&#123;</span><br><span class="line">    insert(x,root);</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void AVLTree&lt;T&gt;::rotate_right(Node&lt;T&gt; *&amp;t)&#123;</span><br><span class="line">    Node&lt;T&gt; *p&#x3D;t-&gt;lchild;</span><br><span class="line">    t-&gt;lchild&#x3D;p-&gt;rchild;</span><br><span class="line">    p-&gt;rchild&#x3D;t;</span><br><span class="line">    t-&gt;height&#x3D;max(get_height(t-&gt;lchild),get_height(t-&gt;rchild))+1;</span><br><span class="line">    p-&gt;height&#x3D;max(get_height(p-&gt;lchild),t-&gt;height)+1;</span><br><span class="line">    t&#x3D;p;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void AVLTree&lt;T&gt;::rotate_left(Node&lt;T&gt; *&amp;t)&#123;</span><br><span class="line">    Node&lt;T&gt; *p&#x3D;t-&gt;rchild;</span><br><span class="line">    t-&gt;rchild&#x3D;p-&gt;lchild;</span><br><span class="line">    p-&gt;lchild&#x3D;t;</span><br><span class="line">    t-&gt;height&#x3D;max(get_height(t-&gt;lchild),get_height(t-&gt;rchild))+1;</span><br><span class="line">    p-&gt;height&#x3D;max(get_height(p-&gt;rchild),t-&gt;height)+1;</span><br><span class="line">    t&#x3D;p;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void AVLTree&lt;T&gt;::left_right(Node&lt;T&gt; *&amp;t)&#123;</span><br><span class="line">    rotate_left(t-&gt;lchild);</span><br><span class="line">    rotate_right(t);</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void AVLTree&lt;T&gt;::right_left(Node&lt;T&gt; *&amp;t)&#123;</span><br><span class="line">    rotate_right(t-&gt;rchild);</span><br><span class="line">    rotate_left(t);</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void AVLTree&lt;T&gt;::remove(T e,Node&lt;T&gt; *&amp;t)&#123;</span><br><span class="line">    if(t&#x3D;&#x3D;NULL)return;</span><br><span class="line">    if(e&lt;t-&gt;data)remove(e,t-&gt;lchild);</span><br><span class="line">    else if(e&gt;t-&gt;data)remove(e,t-&gt;rchild);</span><br><span class="line">    else&#123;</span><br><span class="line">        if(t-&gt;lchild!&#x3D;NULL&amp;&amp;t-&gt;rchild!&#x3D;NULL)&#123;</span><br><span class="line">            Node&lt;T&gt; *p&#x3D;t-&gt;rchild;</span><br><span class="line">            while(p-&gt;lchild!&#x3D;NULL)p&#x3D;p-&gt;lchild;</span><br><span class="line">            t-&gt;data&#x3D;p-&gt;data;</span><br><span class="line">            remove(p-&gt;data,t-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            Node&lt;T&gt; *p&#x3D;t-&gt;lchild&#x3D;&#x3D;NULL?t-&gt;rchild:t-&gt;lchild;</span><br><span class="line">            &#x2F;&#x2F; cout&lt;&lt;t-&gt;data&lt;&lt;endl;</span><br><span class="line">            delete t;</span><br><span class="line">            t&#x3D;p;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(get_height(t-&gt;lchild)-get_height(t-&gt;rchild)&#x3D;&#x3D;2)&#123;</span><br><span class="line">        if(get_height(t-&gt;lchild-&gt;lchild)&gt;get_height(t-&gt;lchild-&gt;rchild))</span><br><span class="line">                rotate_right(t);</span><br><span class="line">            else left_right(t);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(get_height(t-&gt;rchild)-get_height(t-&gt;lchild)&#x3D;&#x3D;2)&#123;</span><br><span class="line">        if(get_height(t-&gt;rchild-&gt;lchild)&gt;get_height(t-&gt;rchild-&gt;rchild))</span><br><span class="line">            right_left(t);</span><br><span class="line">        else rotate_left(t);</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;height&#x3D;max(get_height(t-&gt;lchild),get_height(t-&gt;rchild))+1;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void AVLTree&lt;T&gt;::remove(T e)&#123;</span><br><span class="line">    remove(e,root);</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">int AVLTree&lt;T&gt;::tree_height(Node&lt;T&gt; *t)&#123;</span><br><span class="line">    if(t&#x3D;&#x3D;NULL)return 0;</span><br><span class="line">    int lh&#x3D;0,rh&#x3D;0;</span><br><span class="line">    lh&#x3D;tree_height(t-&gt;lchild)+1;</span><br><span class="line">    rh&#x3D;tree_height(t-&gt;rchild)+1;</span><br><span class="line">    return max(lh,rh);</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void AVLTree&lt;T&gt;::get_near(Node&lt;T&gt; *t)&#123;</span><br><span class="line">    if(t&#x3D;&#x3D;NULL)return;</span><br><span class="line">    if(t-&gt;lchild&#x3D;&#x3D;NULL&amp;&amp;t-&gt;rchild&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">        cout&lt;&lt;t-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int lh&#x3D;0,rh&#x3D;0;</span><br><span class="line">    lh&#x3D;tree_height(t-&gt;lchild);</span><br><span class="line">    rh&#x3D;tree_height(t-&gt;rchild);</span><br><span class="line">    if(lh&#x3D;&#x3D;1&amp;&amp;rh&#x3D;&#x3D;2)&#123;</span><br><span class="line">        get_near(t-&gt;lchild);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(lh&#x3D;&#x3D;2&amp;&amp;rh&#x3D;&#x3D;1)&#123;</span><br><span class="line">        get_near(t-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        get_near(t-&gt;lchild);</span><br><span class="line">        get_near(t-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void AVLTree&lt;T&gt;::show_smaller(Node&lt;T&gt; *t)&#123;</span><br><span class="line">    if(t!&#x3D;NULL)&#123;</span><br><span class="line">        show_smaller(t-&gt;rchild);</span><br><span class="line">        cout&lt;&lt;t-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">        show_smaller(t-&gt;lchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void AVLTree&lt;T&gt;::show_bigger(Node&lt;T&gt; *t)&#123;</span><br><span class="line">    if(t!&#x3D;NULL)&#123;</span><br><span class="line">        show_bigger(t-&gt;lchild);</span><br><span class="line">        cout&lt;&lt;t-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">        show_bigger(t-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    AVLTree&lt;int&gt; avl;</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    int tmp;</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;&quot;-----插入随机数-----&quot;&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    for(int i&#x3D;0;i&lt;100;i++)&#123;</span><br><span class="line">        tmp&#x3D;rand()%2333;</span><br><span class="line">        cout&lt;&lt;tmp&lt;&lt;&quot; &quot;;</span><br><span class="line">        avl.insert(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">    int a[]&#x3D;&#123;1,2,3,4,5,6,7,9,10&#125;;</span><br><span class="line">    for(int i&#x3D;0;i&lt;9;i++)&#123;</span><br><span class="line">        avl.insert(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    *&#x2F;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;&quot;-----从小到大输出-----&quot;&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    avl.show_bigger(avl.get_root());</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;&quot;-----从大到小输出-----&quot;&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    avl.show_smaller(avl.get_root());</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;&quot;-----树的高度-----&quot;&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;avl.tree_height(avl.get_root())&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;&quot;-----删除最后一个插入的随机数-----&quot;&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    avl.remove(tmp);</span><br><span class="line">    avl.show_bigger(avl.get_root());</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;&quot;-----距离根最近的叶节点的值-----&quot;&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    avl.get_near(avl.get_root());</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>一些作业</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Java第六次作业（JFrame 计算器）</title>
    <url>/16b7bd4f/</url>
    <content><![CDATA[<p>写bug和补作业的一天又一天</p>
<p>本来写的差不多了的。。但是我作死的觉得一个有灵魂的计算器。。一定要会叫“归零”“归零”“归零”“归零”“归零”“归零”。。所以研究了一下怎么播放声音注入灵魂。。然后。。各种方法都失败了，说啥AudioClip废弃了。。算了懒得搞了。。失去灵魂</p>
<img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmwdhgbdj20jg0j8dh6.jpg" width = "250" height = "250" >

<a id="more"></a>

<hr>
<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p>创建一个Frame，完成一个计算器的功能</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmwditqoj20li097myc.jpg" alt=""></p>
<h1 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h1><h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h2><p>Main继承自JFrame</p>
<h3 id="1）布局"><a href="#1）布局" class="headerlink" title="1）布局"></a>1）布局</h3><p>首先确定布局，如下图</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmwdj0pgj20fa05saaq.jpg" alt=""></p>
<h3 id="2）变量"><a href="#2）变量" class="headerlink" title="2）变量"></a>2）变量</h3><p>根据上面需要的东西，就可以写出一堆变量</p>
<p>按键我分了三个部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final String[] main_option&#x3D;&#123;&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;&#x2F;&quot;,&quot;sqrt&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,</span><br><span class="line">        &quot;*&quot;,&quot;%&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;-&quot;,&quot;1&#x2F;x&quot;,&quot;+&#x2F;-&quot;,&quot;0&quot;,&quot;.&quot;,&quot;+&quot;,&quot;&#x3D;&quot;&#125;;</span><br><span class="line">private final String[] command_option&#x3D;&#123;&quot;Back&quot;,&quot;CE&quot;,&quot;C&quot;&#125;;</span><br><span class="line">private final String[] other_option&#x3D;&#123;&quot; &quot;,&quot;sin&quot;,&quot;MC&quot;,&quot;cos&quot;,&quot;MR&quot;,&quot;tan&quot;,&quot;MS&quot;,&quot;ln&quot;,&quot;M+&quot;,&quot;log10&quot;&#125;;</span><br></pre></td></tr></table></figure>

<p>按钮，显示输入和结果的文本框</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private JButton main_button[]&#x3D;new JButton[main_option.length];</span><br><span class="line">private JButton command_button[]&#x3D;new JButton[command_option.length];</span><br><span class="line">private JButton other_button[]&#x3D;new JButton[other_option.length];</span><br><span class="line">private JTextField tf&#x3D;new JTextField(&quot;0&quot;);</span><br></pre></td></tr></table></figure>


<p>此外，还有下面几个变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean is_first_num&#x3D;true;&#x2F;&#x2F;记录是否开始输入数字</span><br><span class="line">private double ans_number&#x3D;0.0;&#x2F;&#x2F;保存运算结果</span><br><span class="line">private String operator&#x3D;&quot;&#x3D;&quot;;&#x2F;&#x2F;保存操作符</span><br><span class="line">private boolean legal&#x3D;true;&#x2F;&#x2F;是否合法</span><br><span class="line">private double store_number&#x3D;0.0;&#x2F;&#x2F;保存M系列功能键存储的数</span><br></pre></td></tr></table></figure>

<h3 id="3）布局实现"><a href="#3）布局实现" class="headerlink" title="3）布局实现"></a>3）布局实现</h3><p>用一些panel实现布局，具体见init()函数</p>
<p><code>main_button</code>和<code>command_button</code>对应的<code>main_panel</code>和<code>command_panel</code>放一个panel1里，这样这两个就可以变成一块，再放到最大的panel中间<code>getContentPane().add(panel1,BorderLayout.CENTER);</code>，同理，文本框对应的panel放north，其他other放west</p>
<h4 id="网格布局"><a href="#网格布局" class="headerlink" title="@网格布局"></a>@网格布局</h4><blockquote>
<p>GridLayout()：</p>
<p>创建具有默认值的网格布局，即每个组件占据一行一列。</p>
<p>GridLayout(int rows, int cols)：</p>
<p>创建具有指定行数和列数的网格布局。Rows为行数，cols为列数。</p>
<p>GridLayout(int rows, int cols, int hgap, int vgap)：</p>
<p>创建具有指定行数、列数以及组件水平、纵向一定间距的网格布局。</p>
</blockquote>
<h3 id="4）事件监听器"><a href="#4）事件监听器" class="headerlink" title="4）事件监听器"></a>4）事件监听器</h3><p>初始化的时候为按钮添加事件监听器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i&#x3D;0;i&lt;main_option.length;i++)&#123;</span><br><span class="line">    main_button[i].addActionListener(this);</span><br><span class="line">&#125;</span><br><span class="line">for(int i&#x3D;0;i&lt;command_option.length;i++)&#123;</span><br><span class="line">    command_button[i].addActionListener(this);</span><br><span class="line">&#125;</span><br><span class="line">for(int i&#x3D;0;i&lt;other_option.length;i++) &#123;</span><br><span class="line">    other_button[i].addActionListener(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-actionPerformed"><a href="#2-actionPerformed" class="headerlink" title="2.actionPerformed"></a>2.actionPerformed</h2><p>事件监听器函数，处理单击不同按钮时触发的事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void actionPerformed(ActionEvent e)&#123;</span><br><span class="line">    String cur_button&#x3D;e.getActionCommand();</span><br><span class="line">    if(cur_button.equals(command_option[0]))&#123;</span><br><span class="line">        set_back();</span><br><span class="line">    &#125;</span><br><span class="line">    else if(cur_button.equals(command_option[1]))&#123;</span><br><span class="line">        tf.setText(&quot;0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(cur_button.equals(command_option[2]))&#123;</span><br><span class="line">        set_c();</span><br><span class="line">    &#125;</span><br><span class="line">    else if(&quot;0123456789.&quot;.indexOf(cur_button)&gt;&#x3D;0)&#123;</span><br><span class="line">        set_number(cur_button);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(cur_button.indexOf(&quot;M&quot;)!&#x3D;-1)&#123;</span><br><span class="line">        set_m(cur_button);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        set_cal(cur_button);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有五个set_xxx的函数，分别对应不同的功能</p>
<h2 id="3-功能函数"><a href="#3-功能函数" class="headerlink" title="3.功能函数"></a>3.功能函数</h2><p>五个<code>set_xxx</code>的函数和一个附加的获取数字的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void set_back();&#x2F;&#x2F;回退</span><br><span class="line">private void set_number(String text);&#x2F;&#x2F;设置数字</span><br><span class="line">private void set_m(String cur_button);&#x2F;&#x2F;存储功能键</span><br><span class="line">private void set_c();&#x2F;&#x2F;全部清零</span><br><span class="line">private void set_cal(String cur_button);&#x2F;&#x2F;其他求值运算符</span><br><span class="line">private double get_text_number();&#x2F;&#x2F;获取输入数字</span><br></pre></td></tr></table></figure>

<p>设置数字<code>set_number</code>这个函数中要注意对小数点的处理，如果有小数点了就不能再加了，这样从文本框中读取数据时才不会出错</p>
<p>运算逻辑就是如果输入数字就输入数字，初始化操作符为“=”，如果按了某操作符，那么先执行初始化的等于，再将该按下的操作符保存，输入另一个数，在按下下一个操作符时，这时候调用的操作符就是上一次按的那个，就可以完成对前两个数字的运算，并将结果更新到文本框中</p>
<p>输出结果的时候还要控制一下小数形式还是整数形式，实现如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long t1;</span><br><span class="line">double t2;</span><br><span class="line">t1&#x3D;(long)ans_number;</span><br><span class="line">t2&#x3D;ans_number-t1;</span><br><span class="line">if(t2&#x3D;&#x3D;0)&#123;</span><br><span class="line">    tf.setText(String.valueOf(t1));</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    tf.setText(String.valueOf(ans_number));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-main函数"><a href="#4-main函数" class="headerlink" title="4.main函数"></a>4.main函数</h2><p>调用这个计算器的类，可视，然后设置用户单击窗口的关闭按钮时程序执行的操作是退出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Main main_cal&#x3D;new Main();</span><br><span class="line">main_cal.setVisible(true);</span><br><span class="line">main_cal.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br></pre></td></tr></table></figure>

<h1 id="运行效果："><a href="#运行效果：" class="headerlink" title="运行效果："></a>运行效果：</h1><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmx0odycj20fb05sdgk.jpg" alt=""></p>
<h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.awt.*;</span><br><span class="line">import java.awt.Color;</span><br><span class="line">import java.awt.GridLayout;</span><br><span class="line">import java.awt.event.ActionEvent;</span><br><span class="line">import java.awt.event.ActionListener;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import javax.swing.JButton;</span><br><span class="line">import javax.swing.JFrame;</span><br><span class="line">import javax.swing.JPanel;</span><br><span class="line">import javax.swing.JTextField;</span><br><span class="line"></span><br><span class="line">public class Main extends JFrame implements ActionListener &#123;</span><br><span class="line">    private final String[] main_option&#x3D;&#123;&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;&#x2F;&quot;,&quot;sqrt&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,</span><br><span class="line">            &quot;*&quot;,&quot;%&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;-&quot;,&quot;1&#x2F;x&quot;,&quot;+&#x2F;-&quot;,&quot;0&quot;,&quot;.&quot;,&quot;+&quot;,&quot;&#x3D;&quot;&#125;;</span><br><span class="line">    private final String[] command_option&#x3D;&#123;&quot;Back&quot;,&quot;CE&quot;,&quot;C&quot;&#125;;</span><br><span class="line">    private final String[] other_option&#x3D;&#123;&quot; &quot;,&quot;sin&quot;,&quot;MC&quot;,&quot;cos&quot;,&quot;MR&quot;,&quot;tan&quot;,&quot;MS&quot;,&quot;ln&quot;,&quot;M+&quot;,&quot;log10&quot;&#125;;</span><br><span class="line">    private JButton main_button[]&#x3D;new JButton[main_option.length];</span><br><span class="line">    private JButton command_button[]&#x3D;new JButton[command_option.length];</span><br><span class="line">    private JButton other_button[]&#x3D;new JButton[other_option.length];</span><br><span class="line">    private JTextField tf&#x3D;new JTextField(&quot;0&quot;);</span><br><span class="line">    private boolean is_first_num&#x3D;true;</span><br><span class="line">    private double ans_number&#x3D;0.0;</span><br><span class="line">    private String operator&#x3D;&quot;&#x3D;&quot;;</span><br><span class="line">    private boolean legal&#x3D;true;&#x2F;&#x2F;合法</span><br><span class="line">    private double store_number&#x3D;0.0;</span><br><span class="line"></span><br><span class="line">    public Main() &#123;</span><br><span class="line">        super();</span><br><span class="line">        init();</span><br><span class="line">        this.setBackground(Color.LIGHT_GRAY);</span><br><span class="line">        this.setTitle(&quot;1711447 计算器&quot;);</span><br><span class="line">        this.setLocation(500,300);</span><br><span class="line">        this.setResizable(false);</span><br><span class="line">        this.pack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Main main_cal&#x3D;new Main();</span><br><span class="line">        main_cal.setVisible(true);</span><br><span class="line">        main_cal.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void init() &#123;</span><br><span class="line">        tf.setHorizontalAlignment(JTextField.RIGHT);</span><br><span class="line">        tf.setEditable(false);</span><br><span class="line">        tf.setBackground(Color.WHITE);</span><br><span class="line">        JPanel main_panel&#x3D;new JPanel();</span><br><span class="line">        main_panel.setLayout(new GridLayout(4,5,3,3));</span><br><span class="line">        String[] red_button&#x3D;&#123;&quot;&#x2F;&quot;,&quot;*&quot;,&quot;+&quot;,&quot;-&quot;,&quot;&#x3D;&quot;&#125;;</span><br><span class="line">        for(int i&#x3D;0;i&lt;main_option.length;i++) &#123;</span><br><span class="line">            main_button[i]&#x3D;new JButton(main_option[i]);</span><br><span class="line">            main_panel.add(main_button[i]);</span><br><span class="line">            Arrays.sort(red_button);</span><br><span class="line">            if(Arrays.binarySearch(red_button,main_option[i])&gt;&#x3D;0) &#123;</span><br><span class="line">                main_button[i].setForeground(Color.red);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(&quot;0123456789&quot;.indexOf(main_option[i])&gt;&#x3D;0) &#123;</span><br><span class="line">                main_button[i].setForeground(Color.black);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                main_button[i].setForeground(Color.blue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        JPanel command_panel&#x3D;new JPanel();</span><br><span class="line">        command_panel.setLayout(new GridLayout(1,3,3,3));</span><br><span class="line">        for(int i&#x3D;0;i&lt;command_option.length;i++) &#123;</span><br><span class="line">            command_button[i]&#x3D;new JButton(command_option[i]);</span><br><span class="line">            command_panel.add(command_button[i]);</span><br><span class="line">            command_button[i].setForeground(Color.red);</span><br><span class="line">        &#125;</span><br><span class="line">        JPanel other_panel&#x3D;new JPanel();</span><br><span class="line">        other_panel.setLayout(new GridLayout(5,1,3,3));</span><br><span class="line">        for(int i&#x3D;0;i&lt;other_option.length;i++) &#123;</span><br><span class="line">            other_button[i]&#x3D;new JButton(other_option[i]);</span><br><span class="line">            other_panel.add(other_button[i]);</span><br><span class="line">            if(other_option[i].indexOf(&quot;M&quot;)!&#x3D;-1) &#123;</span><br><span class="line">                other_button[i].setForeground(Color.red);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                other_button[i].setForeground(Color.blue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        JPanel panel1&#x3D;new JPanel();</span><br><span class="line">        panel1.setLayout(new BorderLayout(3,3));</span><br><span class="line">        panel1.add(command_panel,BorderLayout.NORTH);</span><br><span class="line">        panel1.add(main_panel,BorderLayout.CENTER);</span><br><span class="line">        JPanel text_panel&#x3D;new JPanel();</span><br><span class="line">        text_panel.setLayout(new BorderLayout());</span><br><span class="line">        text_panel.add(tf,BorderLayout.CENTER);</span><br><span class="line">        getContentPane().setLayout(new BorderLayout(3,5));</span><br><span class="line">        getContentPane().add(text_panel,BorderLayout.NORTH);</span><br><span class="line">        getContentPane().add(panel1,BorderLayout.CENTER);</span><br><span class="line">        getContentPane().add(other_panel,BorderLayout.WEST);</span><br><span class="line">        for(int i&#x3D;0;i&lt;main_option.length;i++) &#123;</span><br><span class="line">            main_button[i].addActionListener(this);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;0;i&lt;command_option.length;i++) &#123;</span><br><span class="line">            command_button[i].addActionListener(this);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;0;i&lt;other_option.length;i++) &#123;</span><br><span class="line">            other_button[i].addActionListener(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void actionPerformed(ActionEvent e) &#123;</span><br><span class="line">        String cur_button&#x3D;e.getActionCommand();</span><br><span class="line">        if(cur_button.equals(command_option[0])) &#123;</span><br><span class="line">            set_back();</span><br><span class="line">        &#125;</span><br><span class="line">        else if(cur_button.equals(command_option[1])) &#123;</span><br><span class="line">            tf.setText(&quot;0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(cur_button.equals(command_option[2])) &#123;</span><br><span class="line">            set_c();</span><br><span class="line">        &#125;</span><br><span class="line">        else if(&quot;0123456789.&quot;.indexOf(cur_button)&gt;&#x3D;0) &#123;</span><br><span class="line">            set_number(cur_button);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(cur_button.indexOf(&quot;M&quot;)!&#x3D;-1) &#123;</span><br><span class="line">            set_m(cur_button);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            set_cal(cur_button);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void set_back() &#123;</span><br><span class="line">        String text&#x3D;tf.getText();</span><br><span class="line">        int len&#x3D;text.length();</span><br><span class="line">        if(len&gt;0) &#123;</span><br><span class="line">            text&#x3D;text.substring(0,len-1);</span><br><span class="line">            if(text.length()&#x3D;&#x3D;0) &#123;</span><br><span class="line">                tf.setText(&quot;0&quot;);</span><br><span class="line">                is_first_num&#x3D;true;</span><br><span class="line">                operator&#x3D;&quot;&#x3D;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                tf.setText(text);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void set_number(String text) &#123;</span><br><span class="line">        if(is_first_num)&#123;</span><br><span class="line">            tf.setText(text);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(text.equals(&quot;.&quot;)&amp;&amp;tf.getText().indexOf(&quot;.&quot;)&lt;0) &#123;</span><br><span class="line">            tf.setText(tf.getText()+&quot;.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(!text.equals(&quot;.&quot;)) &#123;</span><br><span class="line">            tf.setText(tf.getText()+text);</span><br><span class="line">        &#125;</span><br><span class="line">        is_first_num&#x3D;false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void set_m(String cur_button) &#123;</span><br><span class="line">        if(cur_button.equals(&quot;MS&quot;)) &#123;&#x2F;&#x2F;存入</span><br><span class="line">            store_number&#x3D;get_text_number();</span><br><span class="line">            other_button[0].setText(&quot;M&quot;);</span><br><span class="line">            is_first_num&#x3D;true;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(cur_button.equals(&quot;MC&quot;)) &#123;&#x2F;&#x2F;清楚储存</span><br><span class="line">            store_number&#x3D;0.0;</span><br><span class="line">            other_button[0].setText(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(cur_button.equals(&quot;M+&quot;)) &#123;&#x2F;&#x2F;累加</span><br><span class="line">            store_number+&#x3D;get_text_number();</span><br><span class="line">            other_button[0].setText(&quot;M+&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(cur_button.equals(&quot;MR&quot;)) &#123;&#x2F;&#x2F;显示存储</span><br><span class="line">            tf.setText(String.valueOf(store_number));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void set_c() &#123;</span><br><span class="line">        tf.setText(&quot;0&quot;);</span><br><span class="line">        is_first_num&#x3D;true;</span><br><span class="line">        operator&#x3D;&quot;&#x3D;&quot;;</span><br><span class="line">        store_number&#x3D;0.0;</span><br><span class="line">        other_button[0].setText(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void set_cal(String cur_button) &#123;</span><br><span class="line">        if(operator.equals(&quot;&#x2F;&quot;)) &#123;</span><br><span class="line">            if(get_text_number()&#x3D;&#x3D;0.0) &#123;</span><br><span class="line">                legal&#x3D;false;</span><br><span class="line">                tf.setText(&quot;除数不能为零&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                ans_number&#x2F;&#x3D;get_text_number();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(operator.equals(&quot;1&#x2F;x&quot;)) &#123;</span><br><span class="line">            if(ans_number&#x3D;&#x3D;0.0) &#123;</span><br><span class="line">                legal&#x3D;false;</span><br><span class="line">                tf.setText(&quot;不能对0取倒数&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                ans_number&#x3D;1&#x2F;ans_number;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(operator.equals(&quot;+&quot;)) &#123;</span><br><span class="line">            ans_number+&#x3D;get_text_number();</span><br><span class="line">        &#125;</span><br><span class="line">        else if(operator.equals(&quot;-&quot;)) &#123;</span><br><span class="line">            ans_number-&#x3D;get_text_number();</span><br><span class="line">        &#125;</span><br><span class="line">        else if(operator.equals(&quot;*&quot;)) &#123;</span><br><span class="line">            ans_number*&#x3D;get_text_number();</span><br><span class="line">        &#125;</span><br><span class="line">        else if(operator.equals(&quot;sqrt&quot;)) &#123;</span><br><span class="line">            ans_number&#x3D;Math.sqrt(ans_number);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(operator.equals(&quot;%&quot;)) &#123;</span><br><span class="line">            ans_number&#x2F;&#x3D;100;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(operator.equals(&quot;+&#x2F;-&quot;)) &#123;</span><br><span class="line">            ans_number*&#x3D;(-1.0);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(operator.equals(&quot;&#x3D;&quot;)) &#123;</span><br><span class="line">            ans_number&#x3D;get_text_number();</span><br><span class="line">        &#125;</span><br><span class="line">        else if(operator.equals(&quot;sin&quot;)) &#123;</span><br><span class="line">            ans_number&#x3D;Math.sin(ans_number);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(operator.equals(&quot;cos&quot;)) &#123;</span><br><span class="line">            ans_number&#x3D;Math.cos(ans_number);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(operator.equals(&quot;tan&quot;)) &#123;</span><br><span class="line">            ans_number&#x3D;Math.tan(ans_number);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(operator.equals(&quot;ln&quot;)) &#123;</span><br><span class="line">            ans_number&#x3D;Math.log(ans_number);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(operator.equals(&quot;log10&quot;)) &#123;</span><br><span class="line">            ans_number&#x3D;Math.log10(ans_number);</span><br><span class="line">        &#125;</span><br><span class="line">        if(legal)&#123;</span><br><span class="line">            long t1;</span><br><span class="line">            double t2;</span><br><span class="line">            t1&#x3D;(long) ans_number;</span><br><span class="line">            t2&#x3D;ans_number-t1;</span><br><span class="line">            if(t2&#x3D;&#x3D;0) &#123;</span><br><span class="line">                tf.setText(String.valueOf(t1));</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                tf.setText(String.valueOf(ans_number));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        operator&#x3D;cur_button;</span><br><span class="line">        is_first_num&#x3D;true;</span><br><span class="line">        legal&#x3D;true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private double get_text_number() &#123;</span><br><span class="line">        double num&#x3D;0;</span><br><span class="line">        try &#123;</span><br><span class="line">            num&#x3D;Double.valueOf(tf.getText()).doubleValue();</span><br><span class="line">            &#x2F;&#x2F;System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (NumberFormatException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>一些作业</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>QT 简易浏览器+截图</title>
    <url>/fb59c576/</url>
    <content><![CDATA[<p>之前小学期的代码。。大作业做的这个<s>实话实说没啥功能并不好用</s>的浏览器。。这个当时没写实现说明来着。。那就没有说明啦</p>
<p>代码在最后嗷ᶘ ᵒᴥᵒᶅ</p>
<a id="more"></a>

<hr>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kn9sq7ohj206u08ggly.jpg" alt=""></p>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>isafari，当时随手<s>用心</s>取的名字。。</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kn9t6alxj204a04ct8m.jpg" alt=""></p>
<p>这是一个基于<code>Qt WebEngine Widgets</code>的浏览器；</p>
<p>目前具有多窗口网页浏览/网页缩放/工具栏显示隐藏/工具栏风格设置/fusion风格/macintosh风格/windows风格/网页内容查找/历史记录/全网页截图/截图到剪切板/截图到文件/的功能 ；</p>
<p>截图功能是利用QPixmap里的函数实现的；<br>别的网页相关的功能是利用QWebView里的函数实现的；</p>
<p>下面两张图一个是webview自带的右键菜单，第二个是在工具栏中选择后可以实现截图到剪切板和截图保存到文件的右键菜单</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kn9srrclj20l70cmgm9.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kna75dtdj20kp0c674s.jpg" alt=""></p>
<p>查找功能 网页中对应的字会变底色</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kna75vrcj20vk0mmq5f.jpg" alt=""></p>
<p>历史记录 按下文字后可以跳转到对应的链接；</p>
<p>尚待开发的功能：<br>新建空白页/历史记录的继承/支持下载功能/网页区域截图等；</p>
<h1 id="遇到的问题和解决"><a href="#遇到的问题和解决" class="headerlink" title="遇到的问题和解决"></a>遇到的问题和解决</h1><h2 id="1-mac系统下icon的设置"><a href="#1-mac系统下icon的设置" class="headerlink" title="1.mac系统下icon的设置"></a>1.mac系统下icon的设置</h2><p>1.用app icon gear生成png文件；</p>
<p>2.文件名必须按照icon_32x32.png格式；</p>
<p>3.将文件放到任意文件夹中，命名为xx.iconset；</p>
<p>4.在终端输入iconutil -c icns “/Users/bibi/Desktop/xx.iconset”生成icns图标；</p>
<h2 id="2-打开新窗口后地址栏地址不变"><a href="#2-打开新窗口后地址栏地址不变" class="headerlink" title="2.打开新窗口后地址栏地址不变"></a>2.打开新窗口后地址栏地址不变</h2><p>添加函数内第一行那句话即可；</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knao2lnlj20h50643z5.jpg" alt=""></p>
<h2 id="3-无法播放视频"><a href="#3-无法播放视频" class="headerlink" title="3.无法播放视频"></a>3.无法播放视频</h2><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knao2nsaj20eb0c9758.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knao2k1xj20id02adgf.jpg" alt=""></p>
<h2 id="4-无法下载！！！"><a href="#4-无法下载！！！" class="headerlink" title="4.无法下载！！！"></a>4.无法下载！！！</h2><p>没解决。。太麻烦了</p>
<h2 id="5-更换网页图标的功能并没有显示出具体效果"><a href="#5-更换网页图标的功能并没有显示出具体效果" class="headerlink" title="5.更换网页图标的功能并没有显示出具体效果"></a>5.更换网页图标的功能并没有显示出具体效果</h2><p>原因不明，或许不是代码的锅吧。。</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knb4frpij20ii0attam.jpg" alt=""></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>用这个浏览器浏览自己网站的时候发现。。被记录的信息是这样的</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4knb4er3nj2073035wef.jpg" alt=""></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://github.com/LeFlacon/QT-simple-practice/tree/master/liulanqi" target="_blank" rel="noopener">https://github.com/LeFlacon/QT-simple-practice/tree/master/liulanqi</a></p>
]]></content>
      <categories>
        <category>一些作业</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>QT 涂鸦程序，放大</title>
    <url>/afb3d1ef/</url>
    <content><![CDATA[<p>之前小学期的代码。。这个说明我竟然连个rtfd都没留。。只有一个pdf版的。。而且每句话结尾都是分号。。什么毛病-_-#</p>
<hr>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>基于Qt鼠标事件和2D绘图，实现一个涂鸦程序，可在“画布”上绘出鼠标左键按下后拖动的轨迹</p>
<p>选做：添加“放大”按钮，可实现放大功能，并能在放大后的画布上继续作图</p>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kn7jj1xaj20gu0dn74i.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kn7jjf9zj20ig0eygm4.jpg" alt=""></p>
<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><p>新建了一个<code>myLine</code>结构，这个结构包括<code>QPoint startp</code>和<code>QPoint endp</code>，用一个<code>vector</code>来存这些点; 两个全局变量量，<code>bool isPressed</code>来记录⿏标是否按下，<code>int scale</code>来记录当前是否放⼤;</p>
<h2 id="2-实现绘图功能的基本函数"><a href="#2-实现绘图功能的基本函数" class="headerlink" title="2.实现绘图功能的基本函数"></a>2.实现绘图功能的基本函数</h2><p>先在构造函数中把鼠标的拖动设置好<code>this- &gt;setMouseTracking(true)</code>;</p>
<p><code>isPressed</code>初始设置成<code>false</code>，⿏鼠标没有按下;</p>
<p><code>void paintEvent(QPaintEvent *p)</code>; 设置好<code>QPainter和Qpen</code>，循环<code>lines</code>中的每一个点，⽤<code>drawLine()</code>函数画出来;</p>
<p><code>void mousePressEvent(QMouseEvent *e)</code>; 鼠标按下，把⿏标的坐标给<code>startp</code>和<code>endp</code>，<code>ispressed</code>标记为<code>true</code>;<br><code>void mouseMoveEvent(QMouseEvent *e)</code>; 若<code>ispressed</code>标记为<code>true</code>，就要记录⿏标拖动的路<br>径，获取坐标存⼊<code>endp</code>中，把新的myline存⼊ <code>vector</code>中，然后<code>update()</code>更新界面把画的显示出来，<code>startp=endp</code>，这样这⼀次的尾坐标就是下一次的头坐标，使点变成连续的线;<br><code>void mouseReleaseEvent(QMouseEvent *e);</code>鼠标释放，<code>ispressed</code>改为<code>false</code>;</p>
<h2 id="3-实现放⼤大功能"><a href="#3-实现放⼤大功能" class="headerlink" title="3.实现放⼤大功能"></a>3.实现放⼤大功能</h2><p>一个槽函数<code>fangda()</code>，在<code>widget.cpp</code>构造函数中生成按钮时，把按钮的<code>clicked()</code>信号和这个槽函数联系; 因为要放大之前画的所有东⻄西，所以循环<code>vector</code>中的每个点，把他们的<code>startp</code>和<code>endp</code>的坐标都乘2，这样就可以实现整体的放大，然后调⽤<code>repaint()</code>立即显示放⼤后的图;</p>
<p>然后回到<code>paintevent</code>函数中，加上⼀句如果<code>scale</code>不等于1，就把scale置1，以便下次放⼤时⽤;</p>
<h2 id="4-问题记录"><a href="#4-问题记录" class="headerlink" title="4.问题记录"></a>4.问题记录</h2><p>按下放⼤按钮后，改变了之前的坐标，但<code>update()</code>无法实现⻢上更新画布的操作，要等到下一次画才能显示出放大效果，这里用<code>repaint()</code>即可实现按下按钮就放大;</p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kn7jio3dj206x05jmx8.jpg" alt=""></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://github.com/LeFlacon/QT-simple-practice/tree/master/draw" target="_blank" rel="noopener">https://github.com/LeFlacon/QT-simple-practice/tree/master/draw</a></p>
]]></content>
      <categories>
        <category>一些作业</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>QT 文本编辑器</title>
    <url>/cf72cda3/</url>
    <content><![CDATA[<p>之前小学期的代码。。当时写的说明文件还没用md格式，写的也乱七八糟的。。唉真麻烦</p>
<hr>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>基于QMainWindow类和QTextEdit类实现一个文本编辑器，要求至少包含以下功能：<br>新建、打开、关闭、保存、另存为、查找<br>菜单栏和工具栏都要有相应图标</p>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmth9jtwj20m60emq40.jpg" alt=""></p>
<h2 id="【菜单栏】："><a href="#【菜单栏】：" class="headerlink" title="【菜单栏】："></a>【菜单栏】：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[文件]—新建&#x2F;打开&#x2F;保存&#x2F;另存为</span><br><span class="line">[编辑]—撤销&#x2F;重做—剪切&#x2F;复制&#x2F;粘贴&#x2F;删除—全选&#x2F;全部删除—查找</span><br><span class="line">[格式]—字体&#x2F;颜色</span><br><span class="line">[帮助]—关于</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmth9b5tj205j035wei.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmth8chrj206401xa9z.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmu4clbsj208602aweg.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmu4d9rhj206g087q39.jpg" alt=""></p>
<h2 id="【状态栏】："><a href="#【状态栏】：" class="headerlink" title="【状态栏】："></a>【状态栏】：</h2><p>左下角“欢迎使用建议文本编辑器”在打开文本编辑器时出现五秒，然后消失；<br>右下角“…”一直存在；</p>
<h2 id="【工具栏】："><a href="#【工具栏】：" class="headerlink" title="【工具栏】："></a>【工具栏】：</h2><p>分别为菜单栏中对应的新建/打开/保存/另存为/字体/撤销/重做/查找/关于；<br>因为有些功能没有找到适合的图标所以没有加入到工具栏中；</p>
<h2 id="【其他按钮功能】："><a href="#【其他按钮功能】：" class="headerlink" title="【其他按钮功能】："></a>【其他按钮功能】：</h2><p>统计行数和字数按钮（其中中英文都按一个字符来算）；</p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmu4cp3oj206u06kjrm.jpg" alt=""></p>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><p>先设置菜单栏并添加各个动作，关于菜单栏的动作无法使用中文输入的问题，我的解决方法是：直接输入英文，比如输入<code>xinjian</code>，然后会生成<code>actionxinjian</code>，然后在右下角更改动作的<code>text</code>属性输入“新建”即可；</p>
<h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><p>在ui界面添加<code>textEdit</code>，并设置窗体垂直布局管理，这样<code>textedit</code>大小可随窗体一起改变；</p>
<h2 id="3-图标"><a href="#3-图标" class="headerlink" title="3.图标"></a>3.图标</h2><p>添加图标资源文件，在动作编辑器中为动作添加图标和快捷键；</p>
<h2 id="4-状态栏"><a href="#4-状态栏" class="headerlink" title="4.状态栏"></a>4.状态栏</h2><p>设置状态栏<code>ui-&gt;statusBar；</code></p>
<p>其中一直显示的通过<code>addPermanentWidget</code>实现；</p>
<p>显示五秒的通过设置<code>showMessage</code>的参数<code>5000ms</code>实现；</p>
<h2 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h2><p><code>textEdit</code>中自带复制/粘贴/撤销/重做/剪切/全选槽函数，可以直接与对应动作关联，因此这些函数在此不详细展开；<br>￼<br><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmutcujpj20hi03twfy.jpg" alt=""></p>
<p>其中全删函数通过全选加删除选取两个函数组合来实现；<br>但是此处有一个问题，qt并没有提供<code>delete（）</code>相关的槽函数，笔者能力有限，所以此处暂且用<code>cut（）</code>来代替实现删除选区的功能；</p>
<h2 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h2><p>在<code>mainwindow.h</code>声明一些文件菜单下的功能函数，然后在<code>mainwindow.cpp</code>中完成对这些功能函数的定义 ；<br>载入文件/打开文件/保存函数；</p>
<p>关于查找功能的实现：先初始化查找的对话框<code>findDialog</code>，并添加一个输入查找字符的<code>lineEdit</code>和“查找下一个”的按钮，然后通过<code>textEdit</code>提供的<code>find（）</code>函数来实现查找，这里设置的方向是<code>backward</code>，从后往前找，如果没有找到就跳出没有找到的<code>messagebox</code></p>
<p>关于保存的逻辑问题，思路如下：</p>
<p>首先设置<code>bool</code>型变量<code>isSaved</code>来记录文件是否保存过，<code>int</code>型变量<code>num</code>代表<code>textEdit</code>中的字数；</p>
<p><code>saveFile();</code>保存文件窗口</p>
<p><code>file_Save();</code>如果文件没有保存过就执行<code>file_SaveAs()</code>另存为，如果保存过就直接<code>saveFile()</code>跳出保存文件窗口</p>
<p><code>file_SaveOrNot();</code>跳出<code>messagebox</code>文件未保存，是否保存，如果是则调用<code>file_Save()</code></p>
<p><code>file_SaveAs();</code>另存为</p>
<p>然后重写<code>colseEvent</code>（关闭文本编辑器时的事件处理函数），先更新当前字数<code>num</code>，如果<code>isModified（）</code>且字数<code>num</code>不等于0说明写入了内容，就调用<code>file_SaveOrNot()</code>问是否保存，如果按Yes则调用<code>file_Save()</code>，如果按No就不保存当前的直接退出，如果按取消就不接受事件，会回到原来的文本编辑器窗口；</p>
<h2 id="7-设置txt文本拖入事件；"><a href="#7-设置txt文本拖入事件；" class="headerlink" title="7.设置txt文本拖入事件；"></a>7.设置txt文本拖入事件；</h2><p>这里有一个要注意的地方是：</p>
<p>如果把txt直接拖入textEdit中会显示文件的路径，达不到显示txt文件里内容的效果，所以在构造函数中先设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ui-&gt;textEdit-&gt;setAcceptDrops(false);</span><br><span class="line">setAcceptDrops(true);</span><br></pre></td></tr></table></figure>
<p>即<code>textEdit</code>不接受<code>drop</code>事件，而窗体可以接受；</p>
<h2 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h2><p>把各个动作转到槽，<code>actionxxx_triggered()；</code></p>
<p>在槽函数中调用相应的功能函数即可；</p>
<p>其中设置字体和颜色这两个功能没有写功能函数，是直接写在对应槽函数中实现的；</p>
<p>但是其中设置字体的部分无法到达预期效果，经过各种调试和实验发现，如果在构造函数中将字体初始设置为（黑体，16号）<code>ui-&gt;textEdit-&gt;setCurrentFont(QFont(tr(“黑体”),16));</code>选中文字，然后打开<code>fontdialog</code>设置好自己选择的字体后，<code>textedit</code>中的字体会从（黑体，16）变成默认的字体和默认的13号，并没有根据选中的设置来，而咨询了同学同样的代码在她的qt中则可以实现更换字体的功能，尚不清楚问题所在；</p>
<p>我的代码如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmuzrr2lj20bs03nq36.jpg" alt=""></p>
<h1 id="9-帮助-关于"><a href="#9-帮助-关于" class="headerlink" title="9.帮助-关于"></a>9.帮助-关于</h1><p>写一个<code>massagebox</code>输出一些基本信息即可</p>
<h1 id="10-统计字数和行数的按钮"><a href="#10-统计字数和行数的按钮" class="headerlink" title="10.统计字数和行数的按钮"></a>10.统计字数和行数的按钮</h1><p>在.h文件里设置两个int型变量<code>num</code>和<code>linenum</code>，先获取<code>textEdit</code>的内容到<code>document</code>变量中，然后用<code>lineCount（）</code>函数得到行数，再获取内容到<code>string</code>中，用<code>length（）</code>获取字数，其中记录字数的编码格式为<code>（UTF-8）</code>，英文和中文都按一个字符来算，用一个<code>messagebox</code>输出结果即可；</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://github.com/LeFlacon/QT-simple-practice/tree/master/txt" target="_blank" rel="noopener">https://github.com/LeFlacon/QT-simple-practice/tree/master/txt</a></p>
]]></content>
      <categories>
        <category>一些作业</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>QT 登陆对话框输入用户名密码</title>
    <url>/53180a5f/</url>
    <content><![CDATA[<p>之前小学期的代码。。懒得写注释了。。丢上来先</p>
<hr>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>程序运行开始出现一个对话框，在弹出对话框中填写用户名和密码，按下登录按钮，如果用户名和密码均正确则进入主窗口，如果有错则弹出警告对话框。如果直接关闭这个对话框，便不能进入主窗口，整个程序也将退出。进入主窗口后，按下显示对话框按钮，会弹出一个对话框（和之前登陆对话框不同），关闭这个对话框，会回到主窗口。</p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmvkt4ldj207j06swep.jpg" alt=""></p>
<h1 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h1><p>如果输入密码正确就可以直接登录进入主窗口</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmvktekoj20az08qglq.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmvtbmwcj20m80dydfz.jpg" alt=""></p>
<p>如果输入错误就会提示错误</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmvtccaoj20b3090weu.jpg" alt=""></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://github.com/LeFlacon/QT-simple-practice/tree/master/denglu" target="_blank" rel="noopener">https://github.com/LeFlacon/QT-simple-practice/tree/master/denglu</a></p>
]]></content>
      <categories>
        <category>一些作业</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构第七次作业（最大堆，Python和c++实现霍夫曼编码）</title>
    <url>/6e0586a2/</url>
    <content><![CDATA[<p>没法读文件也没法写文件的sublime。。更不要说处理二进制文件了。。唉那么霍夫曼编码就用Python写一发吧，写了一半的c++版本也丢上来了φ(･_･</p>
<img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmxzn3rtj20jg0j8dh6.jpg" width = "250" height = "250" >

<a id="more"></a>

<hr>
<h1 id="作业一："><a href="#作业一：" class="headerlink" title="作业一："></a>作业一：</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>根据下面的假设，重新编写maxHeap的方法</p>
<p>1）在创建堆时，创建者应该提供两个元素maxElement和minElement，堆中没有元素比maxElement大，也没有元素比minElement小</p>
<p>2）一个n元素的堆需要一个数组heap[0:2n+1]</p>
<p>3）n个元素按本节所描述的方法存储在heap[1:n]中</p>
<p>4）maxElement存储在heap[0]中</p>
<p>5）minElement存储在heap[n+1:2n+1]中</p>
<p>这些假设应该使push和pop的代码简化。通过实验将本练习的实现与本节的实现做比较。</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>极大值极小值，还是“哨兵”的那个原理</p>
<p>设置<code>heap[0]=maxElem</code>和<code>heap[n+1:2n+1]=minElem</code></p>
<h3 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h3><p>push中while的比较本来要比较两次，现在有了这个heap[0]，只需一个x&gt;heap[i/2]即可，因为无论如何x最后都小于heap[1/2]=heap[0]，然后跳出while，push到根节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">MaxHeap_&lt;T&gt;&amp; MaxHeap_&lt;T&gt;::Push(const T&amp; x)&#123;</span><br><span class="line">	if(CurrentSize&#x3D;&#x3D;MaxSize)cout&lt;&lt;&quot;满&quot;&lt;&lt;endl;</span><br><span class="line">	int i&#x3D;++CurrentSize;</span><br><span class="line">	&#x2F;&#x2F;while(i!&#x3D;1&amp;&amp;x&gt;heap[i&#x2F;2])&#123;修改这句判断条件</span><br><span class="line">	while(x&gt;heap[i&#x2F;2])&#123;</span><br><span class="line">		heap[i]&#x3D;heap[i&#x2F;2];</span><br><span class="line">		i&#x2F;&#x3D;2;</span><br><span class="line">	&#125;</span><br><span class="line">	heap[i]&#x3D;x;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><p>同理，加了一堆最小值，就可以在比较的时候设置下限</p>
<p>本来既要比较ci和CurrentSize又要比较y和heap[ci]，有了极小值之后，只要比较y和heap[ci]这两个就可以了，因为如果儿子到了无穷小就说明父节点以及不能向下了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">MaxHeap&lt;T&gt;&amp; MaxHeap&lt;T&gt;::Pop(T&amp; x)&#123;</span><br><span class="line">	if(CurrentSize&#x3D;&#x3D;0)&#123;</span><br><span class="line">		cout&lt;&lt;&quot;空&quot;&lt;&lt;endl;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	x&#x3D;heap[1];</span><br><span class="line">	T y&#x3D;heap[CurrentSize--];</span><br><span class="line">	heap[CurrentSize--]&#x3D;-INF;&#x2F;&#x2F;增加这句，把最后一个点移到开头后最后一个点位置及时置为极小值</span><br><span class="line">	int i&#x3D;1,ci&#x3D;2;</span><br><span class="line">	&#x2F;*原先是靠CurrentSize来控制下限</span><br><span class="line">	while(ci&lt;&#x3D;CurrentSize)&#123;</span><br><span class="line">		if(ci&lt;CurrentSize&amp;&amp;heap[ci]&lt;heap[ci+1])ci++;</span><br><span class="line">		if(y&gt;&#x3D;heap[ci])break;</span><br><span class="line">		heap[i]&#x3D;heap[ci];</span><br><span class="line">		i&#x3D;ci;</span><br><span class="line">		ci*&#x3D;2;</span><br><span class="line">	&#125;</span><br><span class="line">	*&#x2F;</span><br><span class="line">	&#x2F;&#x2F;修改为如下直接靠heap[i]的值来控制条件，比较次数减半</span><br><span class="line">	while(heap[ci]&gt;y)&#123;</span><br><span class="line">		if(heap[ci]&lt;heap[ci+1])ci++;</span><br><span class="line">		heap[i]&#x3D;heap[ci];</span><br><span class="line">		i&#x3D;ci;</span><br><span class="line">		ci*&#x3D;2;</span><br><span class="line">	&#125;</span><br><span class="line">	heap[i]&#x3D;y;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行效果："><a href="#运行效果：" class="headerlink" title="运行效果："></a>运行效果：</h2><p>数据采用随机生成的方式，多次测试都是方法二比方法一快</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmyevebrj20a9084wf4.jpg" alt=""></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int MAXN&#x3D;1e9;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class MaxHeap&#123;</span><br><span class="line">	public:</span><br><span class="line">		MaxHeap(int MaxHeapSize&#x3D;MAXN);</span><br><span class="line">		&#x2F;&#x2F;~MaxHeap()&#123;delete [] heap;heap&#x3D;NULL;&#125;</span><br><span class="line">		int Size()const &#123;return CurrentSize;&#125;</span><br><span class="line">		T Max()&#123;</span><br><span class="line">			if(CurrentSize&#x3D;&#x3D;0)cout&lt;&lt;&quot;空&quot;&lt;&lt;endl;</span><br><span class="line">			return heap[1];</span><br><span class="line">		&#125;</span><br><span class="line">		MaxHeap&lt;T&gt;&amp; Push(const T&amp; x);</span><br><span class="line">		MaxHeap&lt;T&gt;&amp; Pop(T&amp; x);</span><br><span class="line">		void Initialize(T a[],int size,int ArraySize);</span><br><span class="line">		void show();</span><br><span class="line">	private:</span><br><span class="line">		int CurrentSize,MaxSize;</span><br><span class="line">		T *heap;</span><br><span class="line">&#125;; </span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">MaxHeap&lt;T&gt;::MaxHeap(int MaxHeapSize)&#123;</span><br><span class="line">	MaxSize&#x3D;MaxHeapSize;</span><br><span class="line">	heap&#x3D;new T[MaxSize+1];</span><br><span class="line">	CurrentSize&#x3D;0;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">MaxHeap&lt;T&gt;&amp; MaxHeap&lt;T&gt;::Push(const T&amp; x)&#123;</span><br><span class="line">	if(CurrentSize&#x3D;&#x3D;MaxSize)cout&lt;&lt;&quot;满&quot;&lt;&lt;endl;</span><br><span class="line">	int i&#x3D;++CurrentSize;</span><br><span class="line">	while(i!&#x3D;1&amp;&amp;x&gt;heap[i&#x2F;2])&#123;</span><br><span class="line">		heap[i]&#x3D;heap[i&#x2F;2];</span><br><span class="line">		i&#x2F;&#x3D;2;</span><br><span class="line">	&#125;</span><br><span class="line">	heap[i]&#x3D;x;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">MaxHeap&lt;T&gt;&amp; MaxHeap&lt;T&gt;::Pop(T&amp; x)&#123;</span><br><span class="line">	if(CurrentSize&#x3D;&#x3D;0)&#123;</span><br><span class="line">		cout&lt;&lt;&quot;空&quot;&lt;&lt;endl;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	x&#x3D;heap[1];</span><br><span class="line">	T y&#x3D;heap[CurrentSize--];</span><br><span class="line">	int i&#x3D;1,ci&#x3D;2;</span><br><span class="line">	while(ci&lt;&#x3D;CurrentSize)&#123;</span><br><span class="line">		if(ci&lt;CurrentSize&amp;&amp;heap[ci]&lt;heap[ci+1])ci++;</span><br><span class="line">		if(y&gt;&#x3D;heap[ci])break;</span><br><span class="line">		heap[i]&#x3D;heap[ci];</span><br><span class="line">		i&#x3D;ci;</span><br><span class="line">		ci*&#x3D;2;</span><br><span class="line">	&#125;</span><br><span class="line">	heap[i]&#x3D;y;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void MaxHeap&lt;T&gt;::Initialize(T a[],int size,int ArraySize)&#123;</span><br><span class="line">	delete [] heap;</span><br><span class="line">	heap&#x3D;a;</span><br><span class="line">	CurrentSize&#x3D;size;</span><br><span class="line">	MaxSize&#x3D;ArraySize;</span><br><span class="line">	for(int i&#x3D;CurrentSize&#x2F;2;i&gt;&#x3D;1;i--)&#123;</span><br><span class="line">		T y&#x3D;heap[i];</span><br><span class="line">		int c&#x3D;2*i;</span><br><span class="line">		while(c&lt;&#x3D;CurrentSize)&#123;</span><br><span class="line">			if(c&lt;CurrentSize&amp;&amp;heap[c]&lt;heap[c+1])c++;</span><br><span class="line">			if(y&gt;&#x3D;heap[c])break;</span><br><span class="line">			heap[c&#x2F;2]&#x3D;heap[c];</span><br><span class="line">			c*&#x3D;2;</span><br><span class="line">		&#125;</span><br><span class="line">		heap[c&#x2F;2]&#x3D;y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void MaxHeap&lt;T&gt;::show()&#123;</span><br><span class="line">	if(CurrentSize&#x3D;&#x3D;0)&#123;</span><br><span class="line">		cout&lt;&lt;&quot;空&quot;&lt;&lt;endl;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;1;i&lt;CurrentSize;i++)cout&lt;&lt;heap[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">	cout&lt;&lt;heap[CurrentSize]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void HeapSort(T a[],int n)&#123;</span><br><span class="line">	MaxHeap&lt;T&gt; H(1);</span><br><span class="line">	H.Initialize(a,n,n);</span><br><span class="line">	T x;</span><br><span class="line">	for(int i&#x3D;n-1;i&gt;&#x3D;1;i--)&#123;</span><br><span class="line">		H.Pop(x);</span><br><span class="line">		a[i+1]&#x3D;x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const int INF&#x3D;0x3f3f3f3f;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class MaxHeap_&#123;</span><br><span class="line">	public:</span><br><span class="line">		MaxHeap_(int n&#x3D;MAXN,int maxx&#x3D;0,int minn&#x3D;0);</span><br><span class="line">		&#x2F;&#x2F;~MaxHeap()&#123;delete [] heap;heap&#x3D;NULL;&#125;</span><br><span class="line">		int Size()const &#123;return CurrentSize;&#125;</span><br><span class="line">		T Max()&#123;</span><br><span class="line">			if(CurrentSize&#x3D;&#x3D;0)cout&lt;&lt;&quot;空&quot;&lt;&lt;endl;</span><br><span class="line">			return heap[1];</span><br><span class="line">		&#125;</span><br><span class="line">		MaxHeap_&lt;T&gt;&amp; Push(const T&amp; x);</span><br><span class="line">		MaxHeap_&lt;T&gt;&amp; Pop(T&amp; x);</span><br><span class="line">		void show();</span><br><span class="line">	private:</span><br><span class="line">		int CurrentSize,MaxSize;</span><br><span class="line">		T maxElem,minElem;</span><br><span class="line">		T *heap;</span><br><span class="line">&#125;; </span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">MaxHeap_&lt;T&gt;::MaxHeap_(int n,int maxx,int minn)&#123;</span><br><span class="line">	MaxSize&#x3D;2*n+1;</span><br><span class="line">	heap&#x3D;new T[MaxSize+1];</span><br><span class="line">	CurrentSize&#x3D;0;</span><br><span class="line">	maxElem&#x3D;maxx;</span><br><span class="line">	minElem&#x3D;minn;</span><br><span class="line">	heap[0]&#x3D;maxElem;</span><br><span class="line">	for(int i&#x3D;n+1;i&lt;&#x3D;2*n+1;i++)heap[i]&#x3D;minElem;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">MaxHeap_&lt;T&gt;&amp; MaxHeap_&lt;T&gt;::Push(const T&amp; x)&#123;</span><br><span class="line">	if(CurrentSize&#x3D;&#x3D;MaxSize)cout&lt;&lt;&quot;满&quot;&lt;&lt;endl;</span><br><span class="line">	int i&#x3D;++CurrentSize;</span><br><span class="line">	while(x&gt;heap[i&#x2F;2])&#123;</span><br><span class="line">		heap[i]&#x3D;heap[i&#x2F;2];</span><br><span class="line">		i&#x2F;&#x3D;2;</span><br><span class="line">	&#125;</span><br><span class="line">	heap[i]&#x3D;x;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">MaxHeap_&lt;T&gt;&amp; MaxHeap_&lt;T&gt;::Pop(T&amp; x)&#123;</span><br><span class="line">	if(CurrentSize&#x3D;&#x3D;0)&#123;</span><br><span class="line">		cout&lt;&lt;&quot;空&quot;&lt;&lt;endl;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	x&#x3D;heap[1];</span><br><span class="line">	T y&#x3D;heap[CurrentSize];</span><br><span class="line">	heap[CurrentSize--]&#x3D;-INF;</span><br><span class="line">	int i&#x3D;1,ci&#x3D;2;	</span><br><span class="line">	while(heap[ci]&gt;y)&#123;</span><br><span class="line">		if(heap[ci]&lt;heap[ci+1])ci++;</span><br><span class="line">		heap[i]&#x3D;heap[ci];</span><br><span class="line">		i&#x3D;ci;</span><br><span class="line">		ci*&#x3D;2;</span><br><span class="line">	&#125;</span><br><span class="line">	heap[i]&#x3D;y;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void MaxHeap_&lt;T&gt;::show()&#123;</span><br><span class="line">	if(CurrentSize&#x3D;&#x3D;0)&#123;</span><br><span class="line">		cout&lt;&lt;&quot;空&quot;&lt;&lt;endl;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;1;i&lt;CurrentSize;i++)cout&lt;&lt;heap[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">	cout&lt;&lt;heap[CurrentSize]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void show(T a[],int n)&#123;</span><br><span class="line">	for(int i&#x3D;1;i&lt;n;i++)cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">	cout&lt;&lt;a[n]&lt;&lt;endl;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	clock_t t1,t2;</span><br><span class="line">	int n;</span><br><span class="line">	cout&lt;&lt;&quot;请输入数字个数n：&quot;;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	int a[n],b[n];</span><br><span class="line">	srand(time(NULL));</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		a[i]&#x3D;rand()%INF;</span><br><span class="line">		b[i]&#x3D;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	MaxHeap&lt;int&gt; A(n);</span><br><span class="line">	MaxHeap_&lt;int&gt; B(n,INF,-INF);</span><br><span class="line">	&#x2F;&#x2F;show(a,n);</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;endl&lt;&lt;&quot;-----测试Push方法-----&quot;&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">	t1&#x3D;clock();</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)A.Push(a[i]);</span><br><span class="line">	&#x2F;&#x2F;A.show();</span><br><span class="line">	t2&#x3D;clock();</span><br><span class="line">	cout&lt;&lt;&quot;方法一用时： &quot;&lt;&lt;(t2-t1)&lt;&lt;&quot; CLOCKS_PER_SEC&quot;&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	t1&#x3D;clock();</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)B.Push(a[i]);</span><br><span class="line">	&#x2F;&#x2F;B.show();</span><br><span class="line">	t2&#x3D;clock();</span><br><span class="line">	cout&lt;&lt;&quot;方法二用时： &quot;&lt;&lt;(t2-t1)&lt;&lt;&quot; CLOCKS_PER_SEC&quot;&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;endl&lt;&lt;&quot;-----测试Pop方法-----&quot;&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">	t1&#x3D;clock();</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)A.Pop(a[i]);</span><br><span class="line">	&#x2F;&#x2F;A.show();</span><br><span class="line">	t2&#x3D;clock();</span><br><span class="line">	cout&lt;&lt;&quot;方法一用时： &quot;&lt;&lt;(t2-t1)&lt;&lt;&quot; CLOCKS_PER_SEC&quot;&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	t1&#x3D;clock();</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		B.Pop(a[i]);</span><br><span class="line">		&#x2F;&#x2F;B.show();</span><br><span class="line">	&#125;</span><br><span class="line">	t2&#x3D;clock();</span><br><span class="line">	cout&lt;&lt;&quot;方法二用时： &quot;&lt;&lt;(t2-t1)&lt;&lt;&quot; CLOCKS_PER_SEC&quot;&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="作业二："><a href="#作业二：" class="headerlink" title="作业二："></a>作业二：</h1><h2 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h2><p>设计一个完整的基于霍夫曼编码的压缩-解压缩软件包，测试你的代码</p>
<h2 id="霍夫曼编码"><a href="#霍夫曼编码" class="headerlink" title="霍夫曼编码"></a>霍夫曼编码</h2><p>考虑字符的出现频率进行编码</p>
<h3 id="1）获取不同字符的频率"><a href="#1）获取不同字符的频率" class="headerlink" title="1）获取不同字符的频率"></a>1）获取不同字符的频率</h3><h3 id="2）构造霍夫曼树"><a href="#2）构造霍夫曼树" class="headerlink" title="2）构造霍夫曼树"></a>2）构造霍夫曼树</h3><p>选择两个w值最小的树合并，权重相加作为新的权重，重复，直至只剩一棵树</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmysletej20j004gjrx.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmysm4nxj20jl0760tj.jpg" alt=""></p>
<p>霍夫曼树</p>
<ul>
<li>是一棵二叉树</li>
<li>叶节点是具有不同权值的元素</li>
<li>其他节点仅用于计算，没有实际意义</li>
<li>从根到叶的路径（左0右1）即是该叶的编码</li>
</ul>
<h3 id="3）遍历根到外部节点路径➔每个字符编码"><a href="#3）遍历根到外部节点路径➔每个字符编码" class="headerlink" title="3）遍历根到外部节点路径➔每个字符编码"></a>3）遍历根到外部节点路径➔每个字符编码</h3><h3 id="4）用编码替换文本中的字"><a href="#4）用编码替换文本中的字" class="headerlink" title="4）用编码替换文本中的字"></a>4）用编码替换文本中的字</h3><p>霍夫曼编码的基本思想：让权值高的叶节点尽量靠近根，这样它的路径就能尽量短</p>
<h1 id="1-Python"><a href="#1-Python" class="headerlink" title="1.Python"></a>1.Python</h1><h2 id="Python实现思路："><a href="#Python实现思路：" class="headerlink" title="Python实现思路："></a>Python实现思路：</h2><p>一个虚基类HuffNode</p>
<p>继承自HuffNode的类LeafNode，代表叶节点，叶节点没有儿子，isleaf()结果为True，继承自HuffNode的类OtherNode，代表其他节点，其他节点有儿子，isleaf()结果为False</p>
<p>一个霍夫曼树的类，有个encode成员函数实现编码，编码的结果存入字典<code>char_times={}</code>中</p>
<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>先求的所有字符出现的次数</p>
<p>建树就是每次取两个权值最小的节点，先按权值排个序即可<code>list_HuffTree.sort(key=lambda x: x.get_times())</code></p>
<p>压缩的结果写入文件的步骤为：</p>
<p>1）写入叶子结点个数，即字符种数<br>2）写入字典中存储的字符和对应的霍夫曼编码<br>3）对原文件中的每一个字符输出其编码</p>
<h3 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h3><p>先按上面的顺序读入1）2），然后就可以开始建树了，建好树之后解码输出，具体见代码</p>
<h2 id="运行效果：-1"><a href="#运行效果：-1" class="headerlink" title="运行效果："></a>运行效果：</h2><h3 id="1）压缩随便打的几个乱七八糟的字符"><a href="#1）压缩随便打的几个乱七八糟的字符" class="headerlink" title="1）压缩随便打的几个乱七八糟的字符"></a>1）压缩随便打的几个乱七八糟的字符</h3><p><code>qwertyuiopasdfghjkldwheduiewhuiudgghjczbcnjbxHvhbkasdhkjssajdakhkHKDWNCYUIYN@EIUq3847c89374n8q4q78&amp;N^*$(@*NCOINSLKMJDHNSJHNKSdahhhhhhhhhhhhhhhhhhh</code></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmzc2ytjj20ex01jmxd.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmzc4accj20aq0ckjup.jpg" alt=""></p>
<h3 id="2）压缩本篇博文"><a href="#2）压缩本篇博文" class="headerlink" title="2）压缩本篇博文"></a>2）压缩本篇博文</h3><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmzc2z3pj206b03n74b.jpg" alt=""></p>
<p>字节数确实变少了</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kn0fyn96j20dt04wq3g.jpg" alt=""></p>
<p>out.txt中的内容如下：（700+行）</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kn0nd5bkj20bv03wgmf.jpg" alt=""></p>
<p>然后对压缩后的结果out.txt进行解压缩</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kn0nd9r4j207d03ngln.jpg" alt=""></p>
<p>还原的一丝不苟，撒花(=ﾟωﾟ)ﾉ🌹</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kn16ejnsj20i40bt769.jpg" alt=""></p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><p>顺便也丢到github上了。。</p>
<p><a href="https://github.com/LeFlacon/Simple-Python-Practice/blob/master/hfm.py" target="_blank" rel="noopener">https://github.com/LeFlacon/Simple-Python-Practice/blob/master/hfm.py</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import six</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">class HuffNode(object):</span><br><span class="line">    def get_times(self):</span><br><span class="line">        raise NotImplementedError(</span><br><span class="line">            &quot;抽象类没有定义获取次数的函数&quot;)</span><br><span class="line">    def isleaf(self):</span><br><span class="line">        raise NotImplementedError(</span><br><span class="line">            &quot;抽象类没有定义判断是否为叶节点的函数&quot;)</span><br><span class="line"></span><br><span class="line">class LeafNode(HuffNode):</span><br><span class="line">    def __init__(self,c&#x3D;0,times&#x3D;0,):</span><br><span class="line">        super(LeafNode, self).__init__()</span><br><span class="line">        self.c&#x3D;c</span><br><span class="line">        self.times&#x3D;times</span><br><span class="line">    def isleaf(self):</span><br><span class="line">        return True</span><br><span class="line">    def get_times(self):</span><br><span class="line">        return self.times</span><br><span class="line">    def get_c(self):</span><br><span class="line">        return self.c</span><br><span class="line"></span><br><span class="line">class OtherNode(HuffNode):</span><br><span class="line">    def __init__(self,lchild&#x3D;None,rchild&#x3D;None):</span><br><span class="line">        super(OtherNode,self).__init__()</span><br><span class="line">        self.times&#x3D;lchild.get_times()+rchild.get_times()</span><br><span class="line">        self.lchild&#x3D;lchild</span><br><span class="line">        self.rchild&#x3D;rchild</span><br><span class="line">    def isleaf(self):</span><br><span class="line">        return False</span><br><span class="line">    def get_times(self):</span><br><span class="line">        return self.times</span><br><span class="line">    def get_lchild(self):</span><br><span class="line">        return self.lchild</span><br><span class="line">    def get_rchild(self):</span><br><span class="line">        return self.rchild</span><br><span class="line"></span><br><span class="line">class HuffTree(object):</span><br><span class="line">    def __init__(self,flag,c&#x3D;0,times&#x3D;0,left_tree&#x3D;None,right_tree&#x3D;None):</span><br><span class="line">        super(HuffTree, self).__init__()</span><br><span class="line">        if flag&#x3D;&#x3D;0:</span><br><span class="line">            self.root&#x3D;LeafNode(c,times)</span><br><span class="line">        else:</span><br><span class="line">            self.root&#x3D;OtherNode(left_tree.get_root(), right_tree.get_root())</span><br><span class="line">    def get_root(self):</span><br><span class="line">        return self.root</span><br><span class="line">    def get_times(self):</span><br><span class="line">        return self.root.get_times()</span><br><span class="line">    def encode(self,root,code,char_times):</span><br><span class="line">        if root.isleaf():</span><br><span class="line">            char_times[root.get_c()]&#x3D;code</span><br><span class="line">            # print((&quot;it &#x3D; %c  and  times &#x3D; %d  code &#x3D; %s&quot;)%(chr(root.get_c()),root.get_times(),code))</span><br><span class="line">            return None</span><br><span class="line">        else:</span><br><span class="line">            self.encode(root.get_lchild(),code+&#39;0&#39;,char_times)</span><br><span class="line">            self.encode(root.get_rchild(),code+&#39;1&#39;,char_times)</span><br><span class="line"></span><br><span class="line">def build(list_HuffTree):</span><br><span class="line">    while len(list_HuffTree)&gt;1:</span><br><span class="line">        list_HuffTree.sort(key&#x3D;lambda x: x.get_times()) </span><br><span class="line">        n1&#x3D;list_HuffTree[0]</span><br><span class="line">        n2&#x3D;list_HuffTree[1]</span><br><span class="line">        list_HuffTree&#x3D;list_HuffTree[2:]</span><br><span class="line">        new_HuffTree&#x3D;HuffTree(1,0,0,n1,n2)</span><br><span class="line">        list_HuffTree.append(new_HuffTree)</span><br><span class="line">    return list_HuffTree[0]</span><br><span class="line"></span><br><span class="line">def yasuo(in_file_name,out_file_name):</span><br><span class="line">    f&#x3D;open(in_file_name,&#39;rb&#39;)</span><br><span class="line">    data&#x3D;f.read()</span><br><span class="line">    size&#x3D;f.tell()</span><br><span class="line">    char_times&#x3D;&#123;&#125;</span><br><span class="line">    for x in range(size):</span><br><span class="line">        tmp&#x3D;data[x]</span><br><span class="line">        if tmp in char_times.keys():</span><br><span class="line">            char_times[tmp]&#x3D;char_times[tmp]+1</span><br><span class="line">        else:</span><br><span class="line">            char_times[tmp]&#x3D;1</span><br><span class="line">    # for tmp in char_times.keys():</span><br><span class="line">        # print(tmp,&#39; : &#39;,char_times[tmp])</span><br><span class="line">    list_HuffTree &#x3D; []</span><br><span class="line">    for x in char_times.keys():</span><br><span class="line">        leaf_&#x3D;HuffTree(0,x,char_times[x],None,None)</span><br><span class="line">        list_HuffTree.append(leaf_)</span><br><span class="line">    leaf_num&#x3D;len(char_times.keys())</span><br><span class="line">    a4&#x3D;leaf_num&amp;255</span><br><span class="line">    leaf_num&#x3D;leaf_num&gt;&gt;8</span><br><span class="line">    a3&#x3D;leaf_num&amp;255</span><br><span class="line">    leaf_num&#x3D;leaf_num&gt;&gt;8</span><br><span class="line">    a2&#x3D;leaf_num&amp;255</span><br><span class="line">    leaf_num&#x3D;leaf_num&gt;&gt;8</span><br><span class="line">    a1&#x3D;leaf_num&amp;255</span><br><span class="line">    output&#x3D;open(out_file_name,&#39;wb&#39;)</span><br><span class="line">    output.write(six.int2byte(a1))</span><br><span class="line">    output.write(six.int2byte(a2))</span><br><span class="line">    output.write(six.int2byte(a3))</span><br><span class="line">    output.write(six.int2byte(a4))</span><br><span class="line">    for x in char_times.keys():</span><br><span class="line">        output.write(six.int2byte(x))</span><br><span class="line">        tmpp&#x3D;char_times[x]</span><br><span class="line">        a4&#x3D;tmpp&amp;255</span><br><span class="line">        tmpp&#x3D;tmpp&gt;&gt;8</span><br><span class="line">        a3&#x3D;tmpp&amp;255</span><br><span class="line">        tmpp&#x3D;tmpp&gt;&gt;8</span><br><span class="line">        a2&#x3D;tmpp&amp;255</span><br><span class="line">        tmpp&#x3D;tmpp&gt;&gt;8</span><br><span class="line">        a1&#x3D;tmpp&amp;255</span><br><span class="line">        output.write(six.int2byte(a1))</span><br><span class="line">        output.write(six.int2byte(a2))</span><br><span class="line">        output.write(six.int2byte(a3))</span><br><span class="line">        output.write(six.int2byte(a4))</span><br><span class="line"></span><br><span class="line">    HTree&#x3D;build(list_HuffTree)</span><br><span class="line">    HTree.encode(HTree.get_root(),&#39;&#39;,char_times)</span><br><span class="line">    </span><br><span class="line">    code&#x3D;&#39;&#39;</span><br><span class="line">    for i in range(size):</span><br><span class="line">        key&#x3D;data[i]</span><br><span class="line">        code&#x3D;code+char_times[key]</span><br><span class="line">        ans&#x3D;0</span><br><span class="line">        while len(code)&gt;8:</span><br><span class="line">            for x in range(8):</span><br><span class="line">                ans&#x3D;ans&lt;&lt;1</span><br><span class="line">                if code[x]&#x3D;&#x3D;&#39;1&#39;:</span><br><span class="line">                    ans&#x3D;ans|1</span><br><span class="line">            code&#x3D;code[8:]</span><br><span class="line">            output.write(six.int2byte(ans))</span><br><span class="line">            ans&#x3D;0</span><br><span class="line"></span><br><span class="line">    output.write(six.int2byte(len(code)))</span><br><span class="line">    ans&#x3D;0</span><br><span class="line">    for i in range(len(code)):</span><br><span class="line">        ans&#x3D;ans&lt;&lt;1</span><br><span class="line">        if code[i]&#x3D;&#x3D;&#39;1&#39;:</span><br><span class="line">            ans&#x3D;ans|1</span><br><span class="line">    for i in range(8-len(code)):</span><br><span class="line">        ans&#x3D;ans&lt;&lt;1</span><br><span class="line">    output.write(six.int2byte(ans))</span><br><span class="line">    output.close()</span><br><span class="line"></span><br><span class="line">def jieyasuo(in_file_name, out_file_name):</span><br><span class="line">    f&#x3D;open(in_file_name,&#39;rb&#39;)</span><br><span class="line">    data&#x3D;f.read()</span><br><span class="line">    size&#x3D;f.tell()</span><br><span class="line">    a1&#x3D;data[0]</span><br><span class="line">    a2&#x3D;data[1]</span><br><span class="line">    a3&#x3D;data[2]</span><br><span class="line">    a4&#x3D;data[3]    </span><br><span class="line">    j&#x3D;0</span><br><span class="line">    j&#x3D;j|a1</span><br><span class="line">    j&#x3D;j&lt;&lt;8</span><br><span class="line">    j&#x3D;j|a2</span><br><span class="line">    j&#x3D;j&lt;&lt;8</span><br><span class="line">    j&#x3D;j|a3</span><br><span class="line">    j&#x3D;j&lt;&lt;8</span><br><span class="line">    j&#x3D;j|a4</span><br><span class="line"></span><br><span class="line">    leaf_num&#x3D;j</span><br><span class="line">    char_times&#x3D;&#123;&#125;</span><br><span class="line">    for i in range(leaf_num):</span><br><span class="line">        c&#x3D;data[4+i*5+0]</span><br><span class="line">        a1&#x3D;data[4+i*5+1]</span><br><span class="line">        a2&#x3D;data[4+i*5+2]</span><br><span class="line">        a3&#x3D;data[4+i*5+3]</span><br><span class="line">        a4&#x3D;data[4+i*5+4]</span><br><span class="line">        j&#x3D;0</span><br><span class="line">        j&#x3D;j|a1</span><br><span class="line">        j&#x3D;j&lt;&lt;8</span><br><span class="line">        j&#x3D;j|a2</span><br><span class="line">        j&#x3D;j&lt;&lt;8</span><br><span class="line">        j&#x3D;j|a3</span><br><span class="line">        j&#x3D;j&lt;&lt;8</span><br><span class="line">        j&#x3D;j|a4</span><br><span class="line">        # print(c,j)</span><br><span class="line">        char_times[c]&#x3D;j</span><br><span class="line">    list_HuffTree&#x3D;[]</span><br><span class="line">    for x in char_times.keys():</span><br><span class="line">        tmp&#x3D;HuffTree(0,x,char_times[x],None,None)</span><br><span class="line">        list_HuffTree.append(tmp)</span><br><span class="line">    HTree&#x3D;build(list_HuffTree)</span><br><span class="line">    HTree.encode(HTree.get_root(),&#39;&#39;,char_times)</span><br><span class="line"></span><br><span class="line">    output&#x3D;open(out_file_name,&#39;wb&#39;)</span><br><span class="line">    code&#x3D;&#39;&#39;</span><br><span class="line">    currnode&#x3D;HTree.get_root()</span><br><span class="line">    for x in range(leaf_num*5+4,size):</span><br><span class="line">        c&#x3D;data[x]</span><br><span class="line">        for i in range(8):</span><br><span class="line">            if c&amp;128:</span><br><span class="line">                code&#x3D;code+&#39;1&#39;</span><br><span class="line">            else:</span><br><span class="line">                code&#x3D;code+&#39;0&#39;</span><br><span class="line">            c&#x3D;c&lt;&lt;1</span><br><span class="line">        while len(code)&gt;24:</span><br><span class="line">            if currnode.isleaf():</span><br><span class="line">                tmp_byte&#x3D;six.int2byte(currnode.get_c())</span><br><span class="line">                output.write(tmp_byte)</span><br><span class="line">                currnode&#x3D;HTree.get_root()</span><br><span class="line">            if code[0]&#x3D;&#x3D;&#39;1&#39;:</span><br><span class="line">                currnode&#x3D;currnode.get_rchild()</span><br><span class="line">            else:</span><br><span class="line">                currnode&#x3D;currnode.get_lchild()</span><br><span class="line">            code&#x3D;code[1:]</span><br><span class="line">    sub_code&#x3D;code[-16:-8]</span><br><span class="line">    last_leaf_num&#x3D;0</span><br><span class="line">    for i in range(8):</span><br><span class="line">        last_leaf_num&#x3D;last_leaf_num&lt;&lt;1</span><br><span class="line">        if sub_code[i]&#x3D;&#x3D;&#39;1&#39;:</span><br><span class="line">            last_leaf_num&#x3D;last_leaf_num|1</span><br><span class="line">    code&#x3D;code[:-16]+code[-8:-8+last_leaf_num]</span><br><span class="line">    while len(code)&gt;0:</span><br><span class="line">        if currnode.isleaf():</span><br><span class="line">            tmp_byte&#x3D;six.int2byte(currnode.get_c())</span><br><span class="line">            output.write(tmp_byte)</span><br><span class="line">            currnode&#x3D;HTree.get_root()</span><br><span class="line">        if code[0]&#x3D;&#x3D;&#39;1&#39;:</span><br><span class="line">            currnode&#x3D;currnode.get_rchild()</span><br><span class="line">        else:</span><br><span class="line">            currnode&#x3D;currnode.get_lchild()</span><br><span class="line">        code&#x3D;code[1:]</span><br><span class="line">    if currnode.isleaf():</span><br><span class="line">        tmp_byte&#x3D;six.int2byte(currnode.get_c())</span><br><span class="line">        output.write(tmp_byte)</span><br><span class="line">        currnode&#x3D;HTree.get_root()</span><br><span class="line">    output.close()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    print(&quot;0.压缩 1.解压缩\n&quot;)</span><br><span class="line">    FLAG&#x3D;input(&quot;请输入操作：&quot;)</span><br><span class="line">    INPUTFILE&#x3D;input(&quot;请输入需要操作的文件名：&quot;)</span><br><span class="line">    OUTPUTFILE&#x3D;input(&quot;请输入保存结果的文件名：&quot;)</span><br><span class="line">    if FLAG&#x3D;&#x3D;&#39;0&#39;:</span><br><span class="line">        print(&quot;压缩文件&quot;)</span><br><span class="line">        yasuo(INPUTFILE,OUTPUTFILE)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;解压缩文件&quot;)</span><br><span class="line">        jieyasuo(INPUTFILE,OUTPUTFILE)</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="2-c"><a href="#2-c" class="headerlink" title="2.c++"></a>2.c++</h1><h2 id="c-实现思路："><a href="#c-实现思路：" class="headerlink" title="c++实现思路："></a>c++实现思路：</h2><p>首先要记录每个字符出现的次数，用了一个<code>map&lt;char,int&gt;char_times_map;</code>，用map直接映射可以省好多事</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kn1tjtc6j205203m0sn.jpg" alt=""></p>
<p>然后先对叶节点和其他节点初始化，再建树，建树就是选择两个权值最小的节点作为左右儿子，跑个循环即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i&#x3D;leaf_num;i&lt;node_num;i++)&#123;</span><br><span class="line">    int x1,x2;</span><br><span class="line">    find_min_node(HuffTree,i,x1,x2);</span><br><span class="line">    &#x2F;&#x2F; cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;x1&lt;&lt;&quot; &quot;&lt;&lt;x2&lt;&lt;endl;</span><br><span class="line">    HuffTree[i].times&#x3D;HuffTree[x1].times+HuffTree[x2].times;</span><br><span class="line">    HuffTree[i].lchild&#x3D;x1;</span><br><span class="line">    HuffTree[i].rchild&#x3D;x2;</span><br><span class="line">    HuffTree[x1].parent&#x3D;HuffTree[x2].parent&#x3D;i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建树后就可以获取某个字符对应的编码了</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kn1th4s1j202g035a9y.jpg" alt=""></p>
<h2 id="只实现了压缩的c-代码："><a href="#只实现了压缩的c-代码：" class="headerlink" title="只实现了压缩的c++代码："></a>只实现了压缩的c++代码：</h2><p>因为开始写解压的时候发现？？sublime没法读文件的我根本不知道怎么读二进制文件。。只好投靠Python了，压缩部分或许压缩成功了吧。。不管了就这样吧</p>
<p>下面是段废弃的代码，能实现霍夫曼的建树编码压缩操作，仅供参考</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line"></span><br><span class="line">map&lt;char,int&gt;char_times_map;</span><br><span class="line">map&lt;char,string&gt;char_code_map;</span><br><span class="line"></span><br><span class="line">class HuffNode&#123;</span><br><span class="line">    public:</span><br><span class="line">        char c;</span><br><span class="line">        int times;</span><br><span class="line">        int parent;</span><br><span class="line">        int lchild;</span><br><span class="line">        int rchild;</span><br><span class="line">        bool isleaf()&#123;</span><br><span class="line">            if(lchild&#x3D;&#x3D;-1&amp;&amp;rchild&#x3D;&#x3D;-1)return true;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        bool have_parent()&#123;</span><br><span class="line">            return parent!&#x3D;-1;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void encode(HuffNode* HuffTree,int i,string s)&#123;</span><br><span class="line">    if(HuffTree[i].isleaf())&#123;</span><br><span class="line">        char_code_map[HuffTree[i].c]&#x3D;s;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(HuffTree[i].lchild!&#x3D;-1)&#123;</span><br><span class="line">        s+&#x3D;&#39;0&#39;;</span><br><span class="line">        encode(HuffTree,HuffTree[i].lchild,s);</span><br><span class="line">    &#125;</span><br><span class="line">    s.erase(s.end()-1);&#x2F;&#x2F;end()返回最后一个位置的后一个位置</span><br><span class="line">    if(HuffTree[i].rchild!&#x3D;-1)&#123;</span><br><span class="line">        s+&#x3D;&#39;1&#39;;</span><br><span class="line">        encode(HuffTree,HuffTree[i].rchild,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void find_min_node(HuffNode *HuffTree,int pos,int &amp;x1,int &amp;x2)&#123;</span><br><span class="line">    int min1&#x3D;INF,min2&#x3D;INF;</span><br><span class="line">    for(int i&#x3D;0;i&lt;pos;i++)&#123;</span><br><span class="line">        if(HuffTree[i].have_parent())continue;</span><br><span class="line">        else&#123;</span><br><span class="line">            if(HuffTree[i].times&lt;min2)&#123;</span><br><span class="line">                if(HuffTree[i].times&lt;min1)&#123;</span><br><span class="line">                    min2&#x3D;min1;</span><br><span class="line">                    x2&#x3D;x1;</span><br><span class="line">                    min1&#x3D;HuffTree[i].times;</span><br><span class="line">                    x1&#x3D;i;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    min2&#x3D;HuffTree[i].times;</span><br><span class="line">                    x2&#x3D;i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void yasuo()&#123;</span><br><span class="line">    char c;</span><br><span class="line">    vector&lt;char&gt;in_v;</span><br><span class="line">    while(cin&gt;&gt;c&amp;&amp;c!&#x3D;&#39;#&#39;)&#123;</span><br><span class="line">        in_v.push_back(c);</span><br><span class="line">        char_times_map[c]++;</span><br><span class="line">    &#125;</span><br><span class="line">    int leaf_num&#x3D;char_times_map.size();</span><br><span class="line">    int node_num&#x3D;leaf_num*2-1;</span><br><span class="line">    HuffNode* HuffTree&#x3D;new HuffNode[node_num];</span><br><span class="line">    map&lt;char,int&gt;::iterator it;</span><br><span class="line">    &#x2F;*</span><br><span class="line">    for(it&#x3D;char_times_map.begin();it!&#x3D;char_times_map.end();it++)</span><br><span class="line">        cout&lt;&lt;it-&gt;first&lt;&lt;&quot; : &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;</span><br><span class="line">    *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;初始化叶节点</span><br><span class="line">    it&#x3D;char_times_map.begin();</span><br><span class="line">    for(int i&#x3D;0;i&lt;leaf_num;i++,it++)&#123;</span><br><span class="line">        HuffTree[i].c&#x3D;it-&gt;first;</span><br><span class="line">        HuffTree[i].times&#x3D;it-&gt;second;</span><br><span class="line">        HuffTree[i].parent&#x3D;HuffTree[i].lchild&#x3D;HuffTree[i].rchild&#x3D;-1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;初始化其他节点</span><br><span class="line">    for(int i&#x3D;leaf_num;i&lt;node_num;i++)&#123;</span><br><span class="line">        HuffTree[i].times&#x3D;0;</span><br><span class="line">        HuffTree[i].parent&#x3D;HuffTree[i].lchild&#x3D;HuffTree[i].rchild&#x3D;-1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;建树</span><br><span class="line">    for(int i&#x3D;leaf_num;i&lt;node_num;i++)&#123;</span><br><span class="line">        int x1,x2;</span><br><span class="line">        find_min_node(HuffTree,i,x1,x2);</span><br><span class="line">        &#x2F;&#x2F; cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;x1&lt;&lt;&quot; &quot;&lt;&lt;x2&lt;&lt;endl;</span><br><span class="line">        HuffTree[i].times&#x3D;HuffTree[x1].times+HuffTree[x2].times;</span><br><span class="line">        HuffTree[i].lchild&#x3D;x1;</span><br><span class="line">        HuffTree[i].rchild&#x3D;x2;</span><br><span class="line">        HuffTree[x1].parent&#x3D;HuffTree[x2].parent&#x3D;i;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;编码</span><br><span class="line">    string str;</span><br><span class="line">    encode(HuffTree,node_num-1,str);</span><br><span class="line"></span><br><span class="line">    map&lt;char,string&gt;::iterator it2;</span><br><span class="line">    for(it2&#x3D;char_code_map.begin();it2!&#x3D;char_code_map.end();it2++)</span><br><span class="line">        cout&lt;&lt;it2-&gt;first&lt;&lt;&quot; : &quot;&lt;&lt;it2-&gt;second&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    for(int i&#x3D;0;i&lt;in_v.size();i++)&#123;</span><br><span class="line">        cout&lt;&lt;char_code_map[in_v[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;cout&lt;&lt;endl&lt;&lt;&quot;压缩完成&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    yasuo();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h2><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kn1ticljj20fq07gt9p.jpg" alt=""></p>
]]></content>
      <categories>
        <category>一些作业</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 5492 Find a path（dp，方差）</title>
    <url>/1869630f/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmxi8vnnj20s10b5n1e.jpg" alt=""></p>
<a id="more"></a>

<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2 2</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case #1: 14</span><br></pre></td></tr></table></figure>

<h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>2015 ACM/ICPC Asia Regional Hefei Online</p>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给一个<code>n*m</code>矩阵，每个位置有一个权值，从(1,1)到(n,m)，只能向右或者向下，到一个位置获得那个位置的分数，求<img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmxi8czbj206300o3yc.jpg" alt="">的最小值，Aavg为经过所有点的平均值</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>先化简一下要求的式子</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmxi8tmfj20gk03h74s.jpg" alt=""></p>
<p>dp[i][j][k]表示走到(i,j)时Ai和为k得到的Ai^2的和</p>
<p>k最大即<code>(30+30-1)*30&lt;1800</code></p>
<p>状态转移方程为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i+1][j][k+v[i+1][j]]&#x3D;min(dp[i][j][k]+v[i+1][j]*v[i+1][j],dp[i+1][j][k+v[i+1][j]]);</span><br><span class="line"></span><br><span class="line">dp[i][j+1][k+v[i][j+1]]&#x3D;min(dp[i][j][k]+v[i][j+1]*v[i][j+1],dp[i][j+1][k+v[i][j+1]]);</span><br></pre></td></tr></table></figure>

<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line">const int N&#x3D;32;</span><br><span class="line">int n,m,v[N][N],dp[N][N][1832];</span><br><span class="line">int main()&#123;</span><br><span class="line">	int t;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">	for(int cas&#x3D;1;cas&lt;&#x3D;t;cas++)&#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">			for(int j&#x3D;1;j&lt;&#x3D;m;j++)</span><br><span class="line">				scanf(&quot;%d&quot;,&amp;v[i][j]);</span><br><span class="line">		memset(dp,INF,sizeof(dp));</span><br><span class="line">		dp[1][1][v[1][1]]&#x3D;v[1][1]*v[1][1];</span><br><span class="line">		int q;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">			for(int j&#x3D;1;j&lt;&#x3D;m;j++)&#123;</span><br><span class="line">				if(i+1&lt;&#x3D;n)&#123;</span><br><span class="line">					q&#x3D;v[i+1][j];</span><br><span class="line">					for(int k&#x3D;0;k&lt;1800;k++)</span><br><span class="line">						if(dp[i][j][k]!&#x3D;INF)</span><br><span class="line">							dp[i+1][j][k+q]&#x3D;min(dp[i][j][k]+q*q,dp[i+1][j][k+q]);</span><br><span class="line">				&#125;</span><br><span class="line">				if(j+1&lt;&#x3D;m)&#123;</span><br><span class="line">					q&#x3D;v[i][j+1];</span><br><span class="line">					for(int k&#x3D;0;k&lt;1800;k++)</span><br><span class="line">						if(dp[i][j][k]!&#x3D;INF)</span><br><span class="line">							dp[i][j+1][k+q]&#x3D;min(dp[i][j][k]+q*q,dp[i][j+1][k+q]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		int ans&#x3D;INF;</span><br><span class="line">		for(int i&#x3D;0;i&lt;1800;i++)</span><br><span class="line">			if(dp[n][m][i]!&#x3D;INF)</span><br><span class="line">				ans&#x3D;min(ans,(n+m-1)*dp[n][m][i]-i*i);</span><br><span class="line">		printf(&quot;Case #%d: %d\n&quot;,cas,ans);</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>codevs 1004 四子连棋（迭代加深搜索）</title>
    <url>/f5526d01/</url>
    <content><![CDATA[<h3 id="题目描述-Description"><a href="#题目描述-Description" class="headerlink" title="题目描述 Description"></a>题目描述 Description</h3><p>在一个<code>4*4</code>的棋盘上摆放了14颗棋子，其中有7颗白色棋子，7颗黑色棋子，有两个空白地带，任何一颗黑白棋子都可以向上下左右四个方向移动到相邻的空格，这叫行棋一步，黑白双方交替走棋，任意一方可以先走，如果某个时刻使得任意一种颜色的棋子形成四个一线（包括斜线），这样的状态为目标棋局。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">●	○	●	 </span><br><span class="line">○	●	○	●</span><br><span class="line">●	○	●	○</span><br><span class="line">○	●	○</span><br></pre></td></tr></table></figure>


<h3 id="输入描述-Input-Description"><a href="#输入描述-Input-Description" class="headerlink" title="输入描述 Input Description"></a>输入描述 Input Description</h3><p>从文件中读入一个<code>4*4</code>的初始棋局，黑棋子用B表示，白棋子用W表示，空格地带用O表示。</p>
<h3 id="输出描述-Output-Description"><a href="#输出描述-Output-Description" class="headerlink" title="输出描述 Output Description"></a>输出描述 Output Description</h3><p>用最少的步数移动到目标棋局的步数。</p>
<h3 id="样例输入-Sample-Input"><a href="#样例输入-Sample-Input" class="headerlink" title="样例输入 Sample Input"></a>样例输入 Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BWBO</span><br><span class="line">WBWB</span><br><span class="line">BWBW</span><br><span class="line">WBWO</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-Sample-Output"><a href="#样例输出-Sample-Output" class="headerlink" title="样例输出 Sample Output"></a>样例输出 Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>有两个空格 而且双方都可以先手</p>
<p>移动棋子实际上就是移动空格</p>
<p>如果直接深搜深度是无穷无尽的。。所以迭代加深搜索，设置一个maxd最大深度</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define INF 2333</span><br><span class="line">char a[5][5];</span><br><span class="line">int dir[4][2]&#x3D;&#123;-1,0,1,0,0,-1,0,1&#125;,maxd;</span><br><span class="line">bool ok()&#123;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;4;i++)&#123;</span><br><span class="line">		if(a[i][1]&#x3D;&#x3D;a[i][2]&amp;&amp;a[i][1]&#x3D;&#x3D;a[i][3]</span><br><span class="line">			&amp;&amp;a[i][1]&#x3D;&#x3D;a[i][4])return true;</span><br><span class="line">		if(a[1][i]&#x3D;&#x3D;a[2][i]&amp;&amp;a[1][i]&#x3D;&#x3D;a[3][i]</span><br><span class="line">			&amp;&amp;a[1][i]&#x3D;&#x3D;a[4][i])return true;</span><br><span class="line">	&#125;</span><br><span class="line">	if(a[1][1]&#x3D;&#x3D;a[2][2]&amp;&amp;a[1][1]&#x3D;&#x3D;a[3][3]</span><br><span class="line">		&amp;&amp;a[1][1]&#x3D;&#x3D;a[4][4])return true;</span><br><span class="line">	if(a[1][4]&#x3D;&#x3D;a[2][3]&amp;&amp;a[1][4]&#x3D;&#x3D;a[3][2]</span><br><span class="line">		&amp;&amp;a[1][4]&#x3D;&#x3D;a[4][1])return true;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">bool dfs(int x1,int y1,int x2,int y2,int d,char col)&#123;</span><br><span class="line">	char tmp&#x3D;col&#x3D;&#x3D;&#39;B&#39;?&#39;W&#39;:&#39;B&#39;;</span><br><span class="line">	if(d&#x3D;&#x3D;maxd)&#123;</span><br><span class="line">		if(ok())return true;</span><br><span class="line">		else return false;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;0;i&lt;4;i++)&#123;</span><br><span class="line">		int nx1,ny1,nx2,ny2;</span><br><span class="line">		nx1&#x3D;x1+dir[i][0];</span><br><span class="line">		ny1&#x3D;y1+dir[i][1];</span><br><span class="line">		nx2&#x3D;x2+dir[i][0];</span><br><span class="line">		ny2&#x3D;y2+dir[i][1];</span><br><span class="line">		if(nx1&gt;&#x3D;1&amp;&amp;nx1&lt;&#x3D;4&amp;&amp;ny1&gt;&#x3D;1&amp;&amp;ny1&lt;&#x3D;4&amp;&amp;a[nx1][ny1]!&#x3D;col)&#123;</span><br><span class="line">			swap(a[x1][y1],a[nx1][ny1]);</span><br><span class="line">			if(dfs(nx1,ny1,x2,y2,d+1,tmp))return true;</span><br><span class="line">			swap(a[x1][y1],a[nx1][ny1]);</span><br><span class="line">		&#125;</span><br><span class="line">		if(nx2&gt;&#x3D;1&amp;&amp;nx2&lt;&#x3D;4&amp;&amp;ny2&gt;&#x3D;1&amp;&amp;ny2&lt;&#x3D;4&amp;&amp;a[nx2][ny2]!&#x3D;col)&#123;</span><br><span class="line">			swap(a[x2][y2],a[nx2][ny2]);</span><br><span class="line">			if(dfs(x1,y1,nx2,ny2,d+1,tmp))return true;</span><br><span class="line">			swap(a[x2][y2],a[nx2][ny2]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	char s[5];</span><br><span class="line">	vector&lt;int&gt;v;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;4;i++)&#123;</span><br><span class="line">    	scanf(&quot;%s&quot;,s);</span><br><span class="line">    	for(int j&#x3D;1;j&lt;&#x3D;4;j++)&#123;</span><br><span class="line">    		a[i][j]&#x3D;s[j-1];</span><br><span class="line">    		if(a[i][j]&#x3D;&#x3D;&#39;O&#39;)&#123;</span><br><span class="line">    			v.push_back(i);</span><br><span class="line">    			v.push_back(j);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;INF;i++)&#123;</span><br><span class="line">    	maxd&#x3D;i;</span><br><span class="line">    	if(dfs(v[0],v[1],v[2],v[3],0,&#39;W&#39;))break;</span><br><span class="line">    	if(dfs(v[0],v[1],v[2],v[3],0,&#39;B&#39;))break;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,maxd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 520 (Div. 2) （A-D）</title>
    <url>/bb5eaeba/</url>
    <content><![CDATA[<p>EF待补。。mark</p>
<a id="more"></a>

<hr>
<h1 id="A-A-Prank（贪心）"><a href="#A-A-Prank（贪心）" class="headerlink" title="A. A Prank（贪心）"></a>A. A Prank（贪心）</h1><p><a href="http://codeforces.com/contest/1062/problem/A" target="_blank" rel="noopener">http://codeforces.com/contest/1062/problem/A</a></p>
<p>题意：给n个数的递增序列<code>(1≤𝑎1&lt;𝑎2&lt;⋯&lt;𝑎𝑛≤10^3)</code>，这些数的范围是[1,1000]，最小差值为1，问最多拿掉几个数后这个序列还能被复原，比如样例1 3 4 5 6 9，拿掉4 5，3 6之间缺4 5是可以确定的，所以答案为2，比如样例998 999 1000，因为最大也就1000，所以拿掉999 1000，比如样例1 2 3 4 5，最小也就1，拿掉1 2 3 4</p>
<p>贪心取最长的连续的（相差为1），开头和结尾特殊处理一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int a[1005];</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">	int ans&#x3D;0,num&#x3D;0;</span><br><span class="line">	for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">		if(a[i]-a[i-1]&#x3D;&#x3D;1)num++;</span><br><span class="line">		else&#123;</span><br><span class="line">			ans&#x3D;max(ans,num-1);</span><br><span class="line">			num&#x3D;0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans&#x3D;max(ans,num-1);</span><br><span class="line">	if(a[0]&#x3D;&#x3D;1)&#123;</span><br><span class="line">		num&#x3D;0;</span><br><span class="line">		for(int i&#x3D;1;i&lt;n;i++)</span><br><span class="line">			if(a[i]-a[i-1]&#x3D;&#x3D;1)num++;</span><br><span class="line">			else break;</span><br><span class="line">		ans&#x3D;max(ans,num);</span><br><span class="line">	&#125;</span><br><span class="line">	if(a[n-1]&#x3D;&#x3D;1000)&#123;</span><br><span class="line">		num&#x3D;0;</span><br><span class="line">		for(int i&#x3D;n-2;i&gt;&#x3D;0;i--)</span><br><span class="line">			if(a[i+1]-a[i]&#x3D;&#x3D;1)num++;</span><br><span class="line">			else break;</span><br><span class="line">		ans&#x3D;max(ans,num);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-Math"><a href="#B-Math" class="headerlink" title="B. Math"></a>B. Math</h1><p><a href="http://codeforces.com/contest/1062/problem/B" target="_blank" rel="noopener">http://codeforces.com/contest/1062/problem/B</a></p>
<p>题意：给一个数n，可以对这个数进行两种操作：1.乘以任意一个正整数x，2.开根号，求一番操作后能得到的最小的数以及它的操作次数</p>
<p>先分解质因子，记录一下每个质因子的个数，其中最大的那个个数记为maxx，能得到的最小的数就是每个质因子相乘，操作次数就是maxx对应的2的幂次，如果maxx不够或者其他数不够，操作次数+1（也就是需要乘一个数把这些质因子的个数都变成那个2的幂次）</p>
<p>比如5184可以分为<code>2^6*3^4</code>，能得到的最小数就是<code>2*3=6</code>，次数就是<code>ceil(log(6))=3</code>，因为<code>4&lt;8,6&lt;8</code>，所以次数加一，为4</p>
<p>打的时候竟然没想到log。。不知道我在写啥。。代码写麻烦了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int p[50];</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	p[0]&#x3D;1;</span><br><span class="line">	for(int i&#x3D;1;i&lt;25;i++)p[i]&#x3D;p[i-1]*2;</span><br><span class="line">	int tmp&#x3D;n,ans&#x3D;1,res&#x3D;0,num&#x3D;0,maxx&#x3D;0;</span><br><span class="line">	for(int i&#x3D;2;i&lt;&#x3D;n&amp;&amp;tmp!&#x3D;1;i++)&#123;</span><br><span class="line">		if(tmp%i&#x3D;&#x3D;0)ans*&#x3D;i;</span><br><span class="line">		while(tmp%i&#x3D;&#x3D;0)&#123;</span><br><span class="line">			tmp&#x2F;&#x3D;i;</span><br><span class="line">			num++;</span><br><span class="line">			&#x2F;&#x2F;2cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		if(num!&#x3D;0)&#123;</span><br><span class="line">			v.push_back(num);</span><br><span class="line">			maxx&#x3D;max(num,maxx);</span><br><span class="line">		&#125;</span><br><span class="line">		num&#x3D;0;</span><br><span class="line">	&#125;</span><br><span class="line">	if(ans&#x3D;&#x3D;n)&#123;</span><br><span class="line">		res&#x3D;0;</span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;&quot; &quot;&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	int flag&#x3D;0;</span><br><span class="line">	int j;</span><br><span class="line">	for(j&#x3D;0;maxx&gt;p[j];j++);</span><br><span class="line">	res&#x3D;j;</span><br><span class="line">	if(maxx!&#x3D;p[j])flag&#x3D;1;</span><br><span class="line">	&#x2F;&#x2F;cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">	for(int i&#x3D;0;i&lt;v.size();i++)</span><br><span class="line">		if(v[i]&lt;maxx)flag&#x3D;1;</span><br><span class="line">	if(flag)res++;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;&quot; &quot;&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-Banh-mi（前缀和）"><a href="#C-Banh-mi（前缀和）" class="headerlink" title="C. Banh-mi（前缀和）"></a>C. Banh-mi（前缀和）</h1><p><a href="http://codeforces.com/contest/1062/problem/C" target="_blank" rel="noopener">http://codeforces.com/contest/1062/problem/C</a></p>
<p>题意：给一个长为n的串，ai=0或1，q次询问，每次取一个[l,r]内 的数，取ai后获得ai分且剩下的所有数各自加上i，求能获得的最大分数</p>
<p>肯定是贪心的先取完1后取0，所以模拟一下最后就是求l,r区间内0和1的个数，答案是<code>2^(0的个数+1的个数)-2^(0的个数)</code>，要模1e9+7，之前没模wa的我怪懵逼的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;1e5+5;</span><br><span class="line">const int p&#x3D;1e9+7;</span><br><span class="line">string s;</span><br><span class="line">int num0[N],num1[N];</span><br><span class="line">LL qpow(LL a,LL b)&#123;</span><br><span class="line">    LL ans&#x3D;1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            ans&#x3D;(ans*a)%p;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        b&#x2F;&#x3D;2;</span><br><span class="line">        a&#x3D;a*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,q;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">	cin&gt;&gt;s;</span><br><span class="line">	num0[0]&#x3D;0;num1[0]&#x3D;0;</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">		if(s[i]&#x3D;&#x3D;&#39;0&#39;)&#123;</span><br><span class="line">			num0[i+1]&#x3D;num0[i]+1;</span><br><span class="line">			num1[i+1]&#x3D;num1[i];</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			num0[i+1]&#x3D;num0[i];</span><br><span class="line">			num1[i+1]&#x3D;num1[i]+1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int l,r,x,y;</span><br><span class="line">	for(int i&#x3D;0;i&lt;q;i++)&#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;,&amp;l,&amp;r);</span><br><span class="line">		x&#x3D;num0[r]-num0[l-1];</span><br><span class="line">		y&#x3D;num1[r]-num1[l-1];</span><br><span class="line">		&#x2F;&#x2F;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">		LL ans&#x3D;(qpow(2,x+y)-qpow(2,x)+p)%p;</span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-Fun-with-Integers（欧拉回路）"><a href="#D-Fun-with-Integers（欧拉回路）" class="headerlink" title="D. Fun with Integers（欧拉回路）"></a>D. Fun with Integers（欧拉回路）</h1><p><a href="http://codeforces.com/contest/1062/problem/D" target="_blank" rel="noopener">http://codeforces.com/contest/1062/problem/D</a></p>
<p>题意：给一个大于等于2的数n，如果<code>(a*x=b||b*x=a)&amp;&amp;abs(x)&gt;1</code>，那么a，b连边，边权为|x|，求从n开始走不重复能获得的最大权值</p>
<p>用欧拉回路证明：如果a有b和他连，那么一定有-b也和他连，所以每个点度数都是偶数，一定存在一条欧拉回路，所以一定能走完，直接求所有边权和乘4即可，四是因为有四条边<code>a_b,a_-b,-a_b,-a_-b</code></p>
<p>可惜当时没想到。。唉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">int main()&#123;</span><br><span class="line">	LL ans&#x3D;0;</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	for(int i&#x3D;2;i&lt;&#x3D;n;i++)</span><br><span class="line">		for(int j&#x3D;i+i;j&lt;&#x3D;n;j+&#x3D;i)</span><br><span class="line">			ans+&#x3D;j&#x2F;i;</span><br><span class="line">	cout&lt;&lt;(ans&lt;&lt;2)&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E-Company（lca）"><a href="#E-Company（lca）" class="headerlink" title="E. Company（lca）"></a>E. Company（lca）</h1><p><a href="http://codeforces.com/contest/1062/problem/E" target="_blank" rel="noopener">http://codeforces.com/contest/1062/problem/E</a></p>
<p>题意：给一颗树，q次询问，删除区间[l,r]中哪一点使lca深度最大，求删除的点和lca深度</p>
<p>rmq+dfs序+st表，区间的lca也是区间内dfs序最小和最大两点的lca，所以删这两个点其中一个，所以先求dfs序然后st表维护区间最值</p>
<p>emmmmm还不会写，只知道个思路</p>
<h1 id="F-Upgrading-Cities"><a href="#F-Upgrading-Cities" class="headerlink" title="F. Upgrading Cities"></a>F. Upgrading Cities</h1><p><a href="http://codeforces.com/contest/1062/problem/F" target="_blank" rel="noopener">http://codeforces.com/contest/1062/problem/F</a></p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>图论</tag>
        <tag>cf</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构第六次作业（双端队列，二叉树表达式树）</title>
    <url>/7728dd26/</url>
    <content><![CDATA[<p>现在。。博客索引量最高的。。已经变成java作业和数据结构作业相关的了。。而且上次java第五个作业写错了。。没注意要参数直接scanner了。。那篇阅读数还蛮多ahhhhh真是对不住了我不背锅</p>
<a id="more"></a>

<hr>
<h1 id="作业一："><a href="#作业一：" class="headerlink" title="作业一："></a>作业一：</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>所谓双端队列（double-ended queue，deque），就是在列表的两端都可以插入和删除数据。因此它允许的操作有Create、IsEmpty、IsFull、Left、Right、AddLeft、AddRight、DeleteLeft、DeleteRight。使用循环数组方式实现双端队列，要求实现上述操作，并实现一个Print输出操作，能将队列由左至右的次序输出于一行，元素间用空格间隔。队列元素类型设为整型。</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>我还是用类来写，总共有五个private属性变量，一个int型指针用于生成数组，cursize表示当前队列大小，maxsize表示最大队列大小，两个索引，front指向最左端，tail指向最右端</p>
<p>判断当前数组内某个位置是否有元素，我是直接设置了一个极大值INF，当然也可以再加一个private成员：一个bool型数组vis来实现</p>
<p>循环数组的实现很简单，就是利用front和next这两个索引，左移就是<code>x=(x-1+maxsize)%maxsize;</code>，右移就是<code>x=(x+1)%maxsize;</code></p>
<p>因为初始化front=tail=0，所以往队列中添加元素的第一步一定要先判断当前front或tail指向的数组位置是否有数据，同理，最后删除的时候也有一个要注意的地方，如果tail=front的话，删除之后就不必再更新这两个的位置了（否则就可能出现deleteleft之后front还往前移超过tail）</p>
<p>写完先简单测试一下功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dequeue_ d(20);</span><br><span class="line">for(int i&#x3D;10;i&lt;20;i++)</span><br><span class="line">	d.add_right(i);</span><br><span class="line">for(int i&#x3D;20;i&lt;31;i++)</span><br><span class="line">	d.add_left(i);</span><br><span class="line">d.print();</span><br><span class="line">cout&lt;&lt;&quot;删除左边两个右边一个：&quot;&lt;&lt;endl;</span><br><span class="line">d.delete_left();</span><br><span class="line">d.delete_left();</span><br><span class="line">d.delete_right();</span><br><span class="line">d.print();</span><br><span class="line">cout&lt;&lt;&quot;添加右边两个左边一个：&quot;&lt;&lt;endl;</span><br><span class="line">d.add_right((int)233);</span><br><span class="line">d.add_right((int)456);</span><br><span class="line">d.add_left((int)678);</span><br><span class="line">d.print();</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmpu44faj20cr04z74p.jpg" alt=""></p>
<h2 id="运行效果："><a href="#运行效果：" class="headerlink" title="运行效果："></a>运行效果：</h2><p>样例输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AddLeft	1</span><br><span class="line">AddLeft	2</span><br><span class="line">DeleteRight</span><br><span class="line">IsFull</span><br><span class="line">DeleteLeft</span><br><span class="line">IsEmpty</span><br><span class="line">AddRight 3</span><br><span class="line">AddLeft 2</span><br><span class="line">AddRight 1</span><br><span class="line">End</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmpu4qzgj20bm092gm1.jpg" alt=""></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;2333;</span><br><span class="line">const int INF&#x3D;0x3f3f3f3f;</span><br><span class="line">class Dequeue_&#123;</span><br><span class="line">	private:</span><br><span class="line">		int front;</span><br><span class="line">		int tail;</span><br><span class="line">		int cursize;</span><br><span class="line">		int maxsize;</span><br><span class="line">		int *t;</span><br><span class="line">	public:</span><br><span class="line">		Dequeue_(int a)&#123;</span><br><span class="line">			front&#x3D;tail&#x3D;maxsize&#x3D;cursize&#x3D;0;</span><br><span class="line">			create(a);</span><br><span class="line">		&#125;</span><br><span class="line">		bool create(int a);</span><br><span class="line">		bool is_empty();</span><br><span class="line">		bool is_full();</span><br><span class="line">		int left();</span><br><span class="line">		int right();</span><br><span class="line">		bool add_left(int a);</span><br><span class="line">		bool add_right(int a);</span><br><span class="line">		int delete_left();</span><br><span class="line">		int delete_right();</span><br><span class="line">		void print();</span><br><span class="line">&#125;;</span><br><span class="line">bool Dequeue_::create(int a)&#123;</span><br><span class="line">	if(maxsize!&#x3D;0)&#123;</span><br><span class="line">		cout&lt;&lt;&quot;已经创造过，无法再次创造&quot;&lt;&lt;endl;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	if(a&gt;N)&#123;</span><br><span class="line">		cout&lt;&lt;&quot;太大啦，创造失败&quot;&lt;&lt;endl;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	maxsize&#x3D;a;</span><br><span class="line">	t&#x3D;new int[maxsize];</span><br><span class="line">	for(int i&#x3D;0;i&lt;maxsize;i++)t[i]&#x3D;INF;</span><br><span class="line">	front&#x3D;tail&#x3D;cursize&#x3D;0;</span><br><span class="line">	cout&lt;&lt;&quot;队列创造初始化成功&quot;&lt;&lt;endl;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line">bool Dequeue_::is_empty()&#123;</span><br><span class="line">	return cursize&#x3D;&#x3D;0;</span><br><span class="line">&#125;</span><br><span class="line">bool Dequeue_::is_full()&#123;</span><br><span class="line">	return cursize&#x3D;&#x3D;maxsize;</span><br><span class="line">&#125;</span><br><span class="line">int Dequeue_::left()&#123;</span><br><span class="line">	if(t[front]!&#x3D;INF)&#123;</span><br><span class="line">		cout&lt;&lt;t[front]&lt;&lt;endl;</span><br><span class="line">		return t[front];</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		cout&lt;&lt;&quot;空&quot;&lt;&lt;endl;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int Dequeue_::right()&#123;</span><br><span class="line">	if(t[tail]!&#x3D;INF)&#123;</span><br><span class="line">		cout&lt;&lt;t[tail]&lt;&lt;endl;</span><br><span class="line">		return t[tail];</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		cout&lt;&lt;&quot;空&quot;&lt;&lt;endl;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">bool Dequeue_::add_left(int a)&#123;</span><br><span class="line">	if(this-&gt;is_full())&#123;</span><br><span class="line">		cout&lt;&lt;&quot;FULL&quot;&lt;&lt;endl;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	if(t[front]&#x3D;&#x3D;INF)&#123;</span><br><span class="line">		t[front]&#x3D;a;</span><br><span class="line">		cursize++;</span><br><span class="line">		this-&gt;print();</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	front&#x3D;(front-1+maxsize)%maxsize;</span><br><span class="line">	t[front]&#x3D;a;</span><br><span class="line">	cursize++;</span><br><span class="line">	this-&gt;print();</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line">bool Dequeue_::add_right(int a)&#123;</span><br><span class="line">	if(this-&gt;is_full())&#123;</span><br><span class="line">		cout&lt;&lt;&quot;已经满了，添加失败&quot;&lt;&lt;endl;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	if(t[tail]&#x3D;&#x3D;INF)&#123;</span><br><span class="line">		t[tail]&#x3D;a;</span><br><span class="line">		cursize++;</span><br><span class="line">		this-&gt;print();</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	tail&#x3D;(tail+1)%maxsize;</span><br><span class="line">	t[tail]&#x3D;a;</span><br><span class="line">	cursize++;</span><br><span class="line">	this-&gt;print();</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line">int Dequeue_::delete_left()&#123;</span><br><span class="line">	if(this-&gt;is_empty())&#123;</span><br><span class="line">		cout&lt;&lt;&quot;EMPTY&quot;&lt;&lt;endl;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	int tmp&#x3D;t[front];</span><br><span class="line">	t[front]&#x3D;INF;</span><br><span class="line">	if(front!&#x3D;tail)front&#x3D;(front+1)%maxsize;</span><br><span class="line">	cursize--;</span><br><span class="line">	this-&gt;print();</span><br><span class="line">	return tmp;</span><br><span class="line">&#125;</span><br><span class="line">int Dequeue_::delete_right()&#123;</span><br><span class="line">	if(this-&gt;is_empty())&#123;</span><br><span class="line">		cout&lt;&lt;&quot;EMPTY&quot;&lt;&lt;endl;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	int tmp&#x3D;t[tail];</span><br><span class="line">	t[tail]&#x3D;INF;</span><br><span class="line">	if(front!&#x3D;tail)tail&#x3D;(tail-1+maxsize)%maxsize;</span><br><span class="line">	cursize--;</span><br><span class="line">	this-&gt;print();</span><br><span class="line">	return tmp;</span><br><span class="line">&#125;</span><br><span class="line">void Dequeue_::print()&#123;</span><br><span class="line">	&#x2F;&#x2F;cout&lt;&lt;&quot;?????&quot;&lt;&lt;front&lt;&lt;&quot; &quot;&lt;&lt;tail&lt;&lt;endl;</span><br><span class="line">	if(this-&gt;is_empty())&#123;</span><br><span class="line">		&#x2F;&#x2F;cout&lt;&lt;&quot;队列为空&quot;&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;cout&lt;&lt;&quot;----------输出队列----------&quot;&lt;&lt;endl;</span><br><span class="line">	for(int i&#x3D;front;i!&#x3D;tail;i&#x3D;(i+1)%maxsize)</span><br><span class="line">		cout&lt;&lt;t[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">	cout&lt;&lt;t[tail]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	&#x2F;&#x2F;freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	Dequeue_ d(2333);</span><br><span class="line">	string s;</span><br><span class="line">	int a;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		cin&gt;&gt;s;</span><br><span class="line">		if(s&#x3D;&#x3D;&quot;End&quot;)break;</span><br><span class="line">		else if(s&#x3D;&#x3D;&quot;AddLeft&quot;)&#123;</span><br><span class="line">			cin&gt;&gt;a;</span><br><span class="line">			d.add_left(a);</span><br><span class="line">		&#125;</span><br><span class="line">		else if(s&#x3D;&#x3D;&quot;AddRight&quot;)&#123;</span><br><span class="line">			cin&gt;&gt;a;</span><br><span class="line">			d.add_right(a);</span><br><span class="line">		&#125;</span><br><span class="line">		else if(s&#x3D;&#x3D;&quot;IsFull&quot;)&#123;</span><br><span class="line">			if(d.is_full())cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">			else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(s&#x3D;&#x3D;&quot;IsEmpty&quot;)&#123;</span><br><span class="line">			if(d.is_empty())cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">			else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(s&#x3D;&#x3D;&quot;Left&quot;)&#123;</span><br><span class="line">			d.left();</span><br><span class="line">		&#125;</span><br><span class="line">		else if(s&#x3D;&#x3D;&quot;Right&quot;)&#123;</span><br><span class="line">			d.right();</span><br><span class="line">		&#125;</span><br><span class="line">		else if(s&#x3D;&#x3D;&quot;DeleteLeft&quot;)&#123;</span><br><span class="line">			d.delete_left();</span><br><span class="line">		&#125;</span><br><span class="line">		else if(s&#x3D;&#x3D;&quot;DeleteRight&quot;)&#123;</span><br><span class="line">			d.delete_right();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="作业二："><a href="#作业二：" class="headerlink" title="作业二："></a>作业二：</h1><h2 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h2><p>输入一个中缀表达式，构造表达式树，以文本方式输出树结构</p>
<p>输入：例如，输入<code>a+b+c*(d+e)</code></p>
<p>输出：以缩进表示二叉树的层次，左——根、右——叶、上——右子树、下——左子树（向左扭一下脖子。。就能看出来是棵树了）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">			e</span><br><span class="line">		+</span><br><span class="line">			d</span><br><span class="line">	*</span><br><span class="line">		c</span><br><span class="line">+</span><br><span class="line">		b</span><br><span class="line">	+</span><br><span class="line">		a</span><br></pre></td></tr></table></figure>

<h2 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h2><p>表达式树就是下图这样</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmqza3rxj20aa08aglq.jpg" alt=""></p>
<p>虽然中缀表达式人看着很易懂，但是如果要建树的话，还是后缀表达式方便</p>
<h3 id="1-后缀表达式及后缀表达式的建树过程："><a href="#1-后缀表达式及后缀表达式的建树过程：" class="headerlink" title="1.后缀表达式及后缀表达式的建树过程："></a>1.后缀表达式及后缀表达式的建树过程：</h3><p><code>a b + c d e + * +</code></p>
<p>后缀表达式建树过程如下：</p>
<p>读入a，读入b，读入+</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmqz9xmqj203r03rt8j.jpg" alt=""></p>
<p>读入c，读入d，读入e</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmqz9tqpj20a203dt8m.jpg" alt=""></p>
<p>读入+</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmrh6ys6j20a2043glk.jpg" alt=""></p>
<p>读入*</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmrh7c4lj20a806hmx5.jpg" alt=""></p>
<p>读入+</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmqza3rxj20aa08aglq.jpg" alt=""></p>
<p>建完了</p>
<h3 id="2-中缀表达式转化为后缀表达式（逆波兰表达式）"><a href="#2-中缀表达式转化为后缀表达式（逆波兰表达式）" class="headerlink" title="2.中缀表达式转化为后缀表达式（逆波兰表达式）"></a>2.中缀表达式转化为后缀表达式（逆波兰表达式）</h3><p>因为题目给出的是中缀表达式，所以先把它转变成后缀表达式</p>
<p>要借助栈来操作一番</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）遇到左括号，入栈</span><br><span class="line">2）遇到右括号，弹出栈中元素，直到弹出的是左括号为止</span><br><span class="line">3）遇到运算符，如果栈为空，运算符直接入栈；否则栈中优先级大于等于改运算符的出栈，该运算符入栈</span><br><span class="line">4）遇到数字，直接输出</span><br><span class="line"></span><br><span class="line">0）最后把栈中剩余元素依次弹出</span><br></pre></td></tr></table></figure>

<p>这里涉及到判断当前字符是否是<code>+-*/</code>以及优先级的问题，为了代码的简洁and优美，我用了一个数组yx[128]，给这四个符号对应的char的数字赋值如下<code>yx[&#39;+&#39;]=yx[&#39;-&#39;]=1;yx[&#39;*&#39;]=yx[&#39;/&#39;]=2;</code>，数组中其余元素赋值为0</p>
<p>效果如图：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmrh70qgj202h00wwea.jpg" alt=""></p>
<h3 id="3-后缀表达式建树"><a href="#3-后缀表达式建树" class="headerlink" title="3.后缀表达式建树"></a>3.后缀表达式建树</h3><p>上文第一点已经给出了利用后缀表达式建树步骤的图解，代码实现很容易，只需要对后缀表达式的每一位处理，如果是运算符的话就出栈两个元素，一个当右儿子一个当左儿子，如果是数字的话就入栈，等待着当运算符的儿子</p>
<p>这里要注意的一点是，最后指针指向的最后一个生成的节点，肯定是根节点，所以函数返回值就是这个根节点，这样后续才能遍历这棵树</p>
<h3 id="4-输出歪一下头才能看的表达式树"><a href="#4-输出歪一下头才能看的表达式树" class="headerlink" title="4.输出歪一下头才能看的表达式树"></a>4.输出歪一下头才能看的表达式树</h3><p>setw控制格式，保证每层有同样的宽度，从root开始，先输出右子树再输出左子树，一直递推下去即可，直到某一点的左右儿子为NULL，说明已经到叶子下面了，无需继续</p>
<h2 id="运行效果：-1"><a href="#运行效果：-1" class="headerlink" title="运行效果："></a>运行效果：</h2><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmsj9m9aj209i06r74j.jpg" alt=""></p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int yx[128];</span><br><span class="line">string transform(string zhongzhui)&#123;</span><br><span class="line">	char c;</span><br><span class="line">	string tmp,houzhui;</span><br><span class="line">	stack&lt;char&gt;st;</span><br><span class="line">	int len&#x3D;zhongzhui.length();</span><br><span class="line">	for(int i&#x3D;0;i&lt;len;i++)&#123;</span><br><span class="line">		c&#x3D;zhongzhui[i];</span><br><span class="line">		if(c&#x3D;&#x3D;&#39;(&#39;)</span><br><span class="line">			st.push(c);</span><br><span class="line">		else if(c&#x3D;&#x3D;&#39;)&#39;)&#123;</span><br><span class="line">			while(st.top()!&#x3D;&#39;(&#39;)&#123;</span><br><span class="line">				tmp&#x3D;st.top();</span><br><span class="line">				houzhui.append(tmp);</span><br><span class="line">				st.pop();</span><br><span class="line">			&#125;</span><br><span class="line">			st.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		else if(st.empty()&amp;&amp;yx[c]&gt;&#x3D;1)</span><br><span class="line">			st.push(c);</span><br><span class="line">		else if(yx[c]&gt;&#x3D;1)&#123;</span><br><span class="line">			while(!st.empty()&amp;&amp;yx[st.top()]&gt;&#x3D;yx[c])&#123;</span><br><span class="line">				tmp&#x3D;st.top();</span><br><span class="line">				houzhui.append(tmp);</span><br><span class="line">				st.pop();</span><br><span class="line">			&#125;</span><br><span class="line">			st.push(c);</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			tmp&#x3D;c;</span><br><span class="line">			houzhui.append(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	while(!st.empty())&#123;</span><br><span class="line">		tmp&#x3D;st.top();</span><br><span class="line">		houzhui.append(tmp);</span><br><span class="line">		st.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	return houzhui;</span><br><span class="line">&#125;</span><br><span class="line">struct Node&#123;</span><br><span class="line">	char data;</span><br><span class="line">	Node *lchild,*rchild;</span><br><span class="line">	Node()&#123;</span><br><span class="line">		data&#x3D;0;</span><br><span class="line">		lchild&#x3D;NULL;</span><br><span class="line">		rchild&#x3D;NULL;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Node* build_Tree(string s)&#123;</span><br><span class="line">	char c;</span><br><span class="line">	int len&#x3D;s.length();</span><br><span class="line">	Node *p;</span><br><span class="line">	if(len&#x3D;&#x3D;0)&#123;</span><br><span class="line">		cout&lt;&lt;&quot;空&quot;&lt;&lt;endl;</span><br><span class="line">		return p;</span><br><span class="line">	&#125;</span><br><span class="line">	stack&lt;Node*&gt;st;</span><br><span class="line">	for(int i&#x3D;0;i&lt;len;i++)&#123;</span><br><span class="line">		c&#x3D;s[i];</span><br><span class="line">		if(yx[c]&gt;&#x3D;1)&#123;</span><br><span class="line">			p&#x3D;new Node;</span><br><span class="line">			Node *tmp&#x3D;st.top();</span><br><span class="line">			p-&gt;rchild&#x3D;tmp;</span><br><span class="line">			st.pop();</span><br><span class="line">			tmp&#x3D;st.top();</span><br><span class="line">			p-&gt;lchild&#x3D;tmp;</span><br><span class="line">			st.pop();</span><br><span class="line">			p-&gt;data&#x3D;c;</span><br><span class="line">			st.push(p);</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			p&#x3D;new Node;</span><br><span class="line">			p-&gt;data&#x3D;c;</span><br><span class="line">			st.push(p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return p;</span><br><span class="line">&#125;</span><br><span class="line">void show(Node *x,int d)&#123;</span><br><span class="line">	if(x!&#x3D;NULL)&#123;</span><br><span class="line">		show(x-&gt;rchild,d+1);</span><br><span class="line">		cout.setf(ios::right);</span><br><span class="line">		cout&lt;&lt;setw(3*d)&lt;&lt;&quot; &quot;;</span><br><span class="line">		cout&lt;&lt;x-&gt;data&lt;&lt;endl;</span><br><span class="line">		show(x-&gt;lchild,d+1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);</span><br><span class="line">	memset(yx,0,sizeof(yx));</span><br><span class="line">	yx[&#39;+&#39;]&#x3D;yx[&#39;-&#39;]&#x3D;1;</span><br><span class="line">	yx[&#39;*&#39;]&#x3D;yx[&#39;&#x2F;&#39;]&#x3D;2;</span><br><span class="line">	string s1,s2;</span><br><span class="line">	cin&gt;&gt;s1;</span><br><span class="line">	s2&#x3D;transform(s1);</span><br><span class="line">	cout&lt;&lt;s2&lt;&lt;endl;</span><br><span class="line">	Node* root&#x3D;build_Tree(s2);</span><br><span class="line">	show(root,0);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>一些作业</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS下安装Pyspider和安装完成后command not found的解决办法（python环境变量配置）</title>
    <url>/7bbef420/</url>
    <content><![CDATA[<h1 id="1-pip"><a href="#1-pip" class="headerlink" title="1.pip"></a>1.pip</h1><p>首先得有pip，好像没啥好说的</p>
<h1 id="2-phantomjs"><a href="#2-phantomjs" class="headerlink" title="2.phantomjs"></a>2.phantomjs</h1><p>PhantomJS 是一个基于 WebKit 的服务器端 JavaScript API。它全面支持web而不需浏览器支持，其快速、原生支持各种Web标准：DOM 处理、CSS 选择器、JSON、Canvas 和 SVG。 PhantomJS 可以用于页面自动化、网络监测、网页截屏以及无界面测试等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install phantomjs</span><br></pre></td></tr></table></figure>

<p>但是我直接<code>brew install phantomjs</code>失败了</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmlcgmncj20ax02laae.jpg" alt=""></p>
<p>所以根据提示输入如下两句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew tap homebrew&#x2F;cask</span><br><span class="line">brew cask install phantomjs</span><br></pre></td></tr></table></figure>

<p>就可以成功安装了</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmlmuv4qj20fr023jrs.jpg" alt=""></p>
<h1 id="3-pyspider"><a href="#3-pyspider" class="headerlink" title="3.pyspider"></a>3.pyspider</h1><p>项目地址：<a href="https://github.com/binux/pyspider" target="_blank" rel="noopener">https://github.com/binux/pyspider</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install pyspider</span><br></pre></td></tr></table></figure>

<p>如果遇到了<code>Command &quot;python setup.py egg_info&quot; failed with error code 1 in /private/var/folders/pk/08vbgtjs4vz5tzvxl43v6yc80000gn/T/pip-install-uol4vk_m/pycurl/</code>这样的问题，请参考这篇 -&gt; <a href="http://leflacon.github.io/5e90e18e/" target="_blank" rel="noopener">macOS下安装Python第三方库报错“Command “python setup.py egg_info” failed with error code 1”的解决办法（附如何卸载自己安装的python）</a></p>
<h1 id="4-安装完成后command-not-found的解决办法"><a href="#4-安装完成后command-not-found的解决办法" class="headerlink" title="4.安装完成后command not found的解决办法"></a>4.安装完成后command not found的解决办法</h1><h2 id="1）原因"><a href="#1）原因" class="headerlink" title="1）原因"></a>1）原因</h2><p>安装完成后我遇到了另一个问题</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmlmv1tjj207600uglj.jpg" alt=""></p>
<p>但是<code>pip3 list</code>列出所有库的时候里面是可以找到pyspider的</p>
<p>查了一些issue有人说是环境变量没有配置好：比如这个-&gt; <a href="https://github.com/lucky9322/PYLesson/tree/master/src/main/pyspider_lib" target="_blank" rel="noopener">https://github.com/lucky9322/PYLesson/tree/master/src/main/pyspider_lib</a></p>
<p>也有人说可能是pip和python位置不同引起的。。这就麻烦了</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmm6cqzmj206w00xt8l.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmm6dm2bj207c00v746.jpg" alt=""></p>
<p>那么用另一种方式安装pyspider试试呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo python -m pip install pyspider --user</span><br></pre></td></tr></table></figure>

<p>重启终端后有别的输出了，报了下图的错</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmm6dc5xj20fq02tdgb.jpg" alt=""></p>
<p>然后可以发现！？？？2.7！！？？？┬─┬﻿ ノ( ゜-゜ノ) </p>
<p style="background-color:rgba(200,200,230,0.7)">我大概可能搞明白了，想了想推测应该还是python的锅。。也就是说输入pyspider系统自动调用的是python2.7版本下的pyspider，而2.7版本的环境中又缺失了一堆库（可能是被我之前惨烈的删删装装给搞出了问题。。），所以python3.6版本我本身的安装下载和pyspider.py中需要import的库都是没有问题的，在之前2.7中没有安装pyspider的时候，就会输出command not found（因为当时2.7中确实没下）</p>

<p><font size="6" color=#222222>所以现在问题在于：输入pyspider，怎么能让系统机智的去调用python3.6版</font></p>
<h2 id="2）配置python环境变量"><a href="#2）配置python环境变量" class="headerlink" title="2）配置python环境变量"></a>2）配置python环境变量</h2><p>先查找一下python3装在什么地方</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmn3asxfj207t00vglj.jpg" alt=""></p>
<p>然后根据结果修改，一定要根据自己的路径来，放上我加的两句供参考（以前前两句是有效的，有一次重装了python之后变成前两句失效了，加上后三句又可以了）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~&#x2F;.bash_profile</span><br><span class="line"></span><br><span class="line">或者直接</span><br><span class="line">touch ~&#x2F;.bash_profile</span><br><span class="line">open ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PYTHONPATH&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.6&#x2F;site-packages&quot;</span><br><span class="line">export PATH&#x3D;&quot;&#x2F;Users&#x2F;mac&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;bin:$PATH&quot;</span><br><span class="line"></span><br><span class="line">PATH&#x3D;&quot;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;bin:$&#123;PATH&#125;&quot;</span><br><span class="line">export PATH</span><br><span class="line">alias python&#x3D;&quot;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;bin&#x2F;python3.6&quot;</span><br></pre></td></tr></table></figure>

<p>:wq保存退出后在终端输入下面这句即可生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure>

<h2 id="3-设置软链接："><a href="#3-设置软链接：" class="headerlink" title="3.设置软链接："></a>3.设置软链接：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ln -f &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python</span><br></pre></td></tr></table></figure>

<hr>
<p>现在输入pyspider，终于可以正常运行了</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmn3c95xj20fp03x75e.jpg" alt=""></p>
<p>然后在浏览器输入<code>http://localhost:5000/</code>即可访问</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmn3dtksj213z085dha.jpg" alt=""></p>
<hr>
<p>最后不报错的人一分钟能装完然后在端口运行的pyspider。。我整整拖了一个星期。。。。。。。真是快乐啊ヽ(；▽；)ノ</p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
        <tag>python</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS下安装Python第三方库报错 Command python setup.py egg_info failed with error code 1 的解决办法（附如何卸载自己安装的python）</title>
    <url>/5e90e18e/</url>
    <content><![CDATA[<p>前面只是记录向，如果要看我最终如何解决的这个问题，可以直接跳到最后第三点，由于这个错误网上有很多种解决方法，所以这个方法并不一定能解决你的问题 But I was successful with it (=ﾟωﾟ)ﾉ</p>
<p>这个星期试了很多很多很多很多没有works for me的方法，相当绝望。。数电下课前跟旁边小妹妹说我又浪费了三节课然后！！！！！在下课前一分钟啊啊啊啊啊啊啊出现了Successfully…！！！！！！！啊啊啊啊啊太激动了非常快乐特别快乐无敌快乐原地爆炸原地起飞的快乐！</p>
<hr>
<h1 id="1-一堆乱七八糟没啥用的记录"><a href="#1-一堆乱七八糟没啥用的记录" class="headerlink" title="1.一堆乱七八糟没啥用的记录"></a>1.一堆乱七八糟没啥用的记录</h1><p>本来是要装个Python第三方库pyspider<code>pip3 install pyspider</code>，然后遇到了<code>“Command &quot;python setup.py egg_info&quot; failed with error code 1 in /private/var/folders/pk/08vbgtjs4vz5tzvxl43v6yc80000gn/T/pip-install-uol4vk_m/pycurl/”</code>这个问题。。</p>
<p>如下图：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmfjnwnaj20ft06a768.jpg" alt=""></p>
<p>经过一系列大风大浪。。大概推测出了几个问题，安装pyspider好像和pycurl有关，但是我也没法安装pycurl，报了类似的错：<code>Command &quot;python setup.py egg_info&quot; failed with error code 1 in /private/var/folders/pk/08vbgtjs4vz5tzvxl43v6yc80000gn/T/pip-build-Q5mgzB/pycurl/</code></p>
<p>除了百度的方法还把下面几个链接里说的都试了一遍，还是不行</p>
<p><a href="https://github.com/facebook/prophet/issues/418" target="_blank" rel="noopener">https://github.com/facebook/prophet/issues/418</a></p>
<p><a href="https://pypi.org/search/?q=pycurl" target="_blank" rel="noopener">https://pypi.org/search/?q=pycurl</a></p>
<p>但是注意到一个小哥说不建议用Python3.7：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmfjonohj20mk0520te.jpg" alt=""></p>
<p>然后去<a href="https://github.com/binux/pyspider" target="_blank" rel="noopener">Pyspider</a>的项目说明里看了一下，emmmm好像确实不行？？</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmg7co6lj20l1015mx9.jpg" alt=""></p>
<p>然后我就去重装了python3.6😂</p>
<h1 id="2-macOS下如何卸载自己安装的Python"><a href="#2-macOS下如何卸载自己安装的Python" class="headerlink" title="2.macOS下如何卸载自己安装的Python"></a>2.macOS下如何卸载自己安装的Python</h1><h2 id="1）删除框架"><a href="#1）删除框架" class="headerlink" title="1）删除框架"></a>1）删除框架</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm -rf &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.7</span><br></pre></td></tr></table></figure>

<h2 id="2）删除应用"><a href="#2）删除应用" class="headerlink" title="2）删除应用"></a>2）删除应用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm -rf &quot;&#x2F;Applications&#x2F;Python 3.7&quot;</span><br></pre></td></tr></table></figure>

<h2 id="3）删除指向python的链接"><a href="#3）删除指向python的链接" class="headerlink" title="3）删除指向python的链接"></a>3）删除指向python的链接</h2><p>（第二次查看的时候可以发现链接都被删完了）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;bin&#x2F;</span><br><span class="line"></span><br><span class="line">ls -l &#x2F;usr&#x2F;local&#x2F;bin | grep &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.7&#39;</span><br><span class="line"></span><br><span class="line">brew prune</span><br><span class="line"></span><br><span class="line">ls -l &#x2F;usr&#x2F;local&#x2F;bin | grep &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.7&#39;</span><br></pre></td></tr></table></figure>

<p>删完之后就可以去官网<a href="https://www.python.org/" target="_blank" rel="noopener">https://www.python.org/</a>找自己需要的python版本重新下载了</p>
<p>我下的是</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmgjkn90j207d01m0sn.jpg" alt=""></p>
<h1 id="3-“Command-“python-setup-py-egg-info”-failed-with-error-code-1”的解决办法"><a href="#3-“Command-“python-setup-py-egg-info”-failed-with-error-code-1”的解决办法" class="headerlink" title="3.“Command “python setup.py egg_info” failed with error code 1”的解决办法"></a>3.“Command “python setup.py egg_info” failed with error code 1”的解决办法</h1><p>如果你已经获得了一个合适版本的python，那么请继续</p>
<p style="background-color:rgba(200,200,230,0.7)">总之我这个报错是macOS高版本引发的（我的macOS版本是10.13.6），和openssl有关，OS 10.11开始，苹果sdk中不再提供openssl，因为openssl是mac不推荐的加密方式，mac有自己的加密方式，于是安装这些第三方库的时候就可能出现找不到openssl</p>

<p style="background-color:rgba(200,200,230,0.7)">所以解决办法就是在安装前设置一下SSL library</p>

<h2 id="1-升级pip（不更新应该也行）"><a href="#1-升级pip（不更新应该也行）" class="headerlink" title="1).升级pip（不更新应该也行）"></a>1).升级pip（不更新应该也行）</h2><p>因为官网python3.6.2带的pip版本是9.0.1，所以先升级一下pip，<code>pip3 install --upgrade pip</code>，更新后的pip版本是18.1</p>
<h2 id="2-wheel"><a href="#2-wheel" class="headerlink" title="2).wheel"></a>2).wheel</h2><p>然后我中途安装了一个wheel，<code>pip3 install wheel</code></p>
<p>对问题的解决应该没有影响，但它是和egg_info有点关系，就记录一下</p>
<p>wheel是新的Python的disribution，用于替代Python传统的egg文件，目前有超过一半的库文件有对应的wheel文件</p>
<p>也就是说，wheel相当于编译后的东西，可以直接安装。pip默认先下载wheel文件安装，没有的话再源码编译安装</p>
<h2 id="3-openssl"><a href="#3-openssl" class="headerlink" title="3).openssl"></a>3).openssl</h2><p>先安装openssl</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install openssl</span><br></pre></td></tr></table></figure>

<p>然后根据提示输入一些至关重要的话！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PYCURL_SSL_LIBRARY&#x3D;openssl</span><br><span class="line"></span><br><span class="line">export LDFLAGS&#x3D;-L&#x2F;usr&#x2F;local&#x2F;opt&#x2F;openssl&#x2F;lib</span><br><span class="line"></span><br><span class="line">export CPPFLAGS&#x3D;-I&#x2F;usr&#x2F;local&#x2F;opt&#x2F;openssl&#x2F;include</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmgw4so5j20ke08dabc.jpg" alt=""></p>
<p>不是很懂<code>export PYCURL_SSL_LIBRARY=openssl</code>，但是差不多干的事情就是：“匹配pycurl（或其他）期望的SSL库”</p>
<p>具体讨论可以见stackoverflow的这个问题：<a href="https://stackoverflow.com/questions/21096436/ssl-backend-error-when-using-openssl" target="_blank" rel="noopener">SSL backend error when using OpenSSL
</a></p>
<h2 id="4-安装pycurl和pyspider"><a href="#4-安装pycurl和pyspider" class="headerlink" title="4).安装pycurl和pyspider"></a>4).安装pycurl和pyspider</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install pycurl --compile --no-cache-dir</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmh4mn9sj20fr037wf9.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install pyspider</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmh4ngnsj207t00v3yh.jpg" alt=""></p>
<p>successfully!<del>(≧▽≦)/</del></p>
<p>可以用Pyspider愉快的玩耍了～</p>
<hr>
<p>然而！我以为这么就完了的时候！这还没有完！</p>
<p>如果你成功安装后在终端输入<code>pyspider</code>却遇到了<code>command not found</code>的问题，可以继续参考这篇 -&gt; <a href="http://leflacon.github.io/7bbef420/" target="_blank" rel="noopener"><br>macOS下安装Pyspider和安装完成后command not found的解决办法（包括python环境变量配置）</a></p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
        <tag>python</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>递归 —— 三色汉诺塔（分离型）</title>
    <url>/3fcdc8fa/</url>
    <content><![CDATA[<p>双色和单色 -&gt; <a href="http://leflacon.github.io/a8a3dabc/" target="_blank" rel="noopener">递归 —— 汉诺塔&amp;双色汉诺塔（分离型）</a></p>
<h1 id="三色汉诺塔（分离型）"><a href="#三色汉诺塔（分离型）" class="headerlink" title="三色汉诺塔（分离型）"></a>三色汉诺塔（分离型）</h1><p>三色汉诺塔如图：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klw3hwu1j20lh0fudgj.jpg" alt=""></p>
<a id="more"></a>

<h2 id="1）三色汉诺塔基本思路："><a href="#1）三色汉诺塔基本思路：" class="headerlink" title="1）三色汉诺塔基本思路："></a>1）三色汉诺塔基本思路：</h2><p>根据分离型二色思路慢慢来</p>
<p>首先肯定是要写一个像二色和单色那样的基础递归hanoi，n=1时每次移三个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void hanoi(int n,char a,char b,char c)&#123;</span><br><span class="line">	if(n&#x3D;&#x3D;1)&#123;</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		hanoi(n-1,a,c,b);</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">		hanoi(n-1,b,a,c);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="n-3时："><a href="#n-3时：" class="headerlink" title="n=3时："></a>n=3时：</h3><p>然后分析一下n=3的时候的移动策略，共六步，如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klw3ic6xj20lc07cdfx.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klw3hqmij20lc07dmx9.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klwvbej5j20lb07faa5.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klwvbx5vj20l607emx8.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klwvbi39j20l007baa6.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klxm6mlwj20lc07fmx9.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klxm7ej9j20l007baa6.jpg" alt=""></p>
<p>然后考虑递归思路：</p>
<h3 id="错误递归思路："><a href="#错误递归思路：" class="headerlink" title="错误递归思路："></a>错误递归思路：</h3><p>先放上我一开始错误的思路。。这种思路不是最优的</p>
<p><s>1.把A上的n-3个借助B移到C上</s></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kly5gj9vj20l607dwep.jpg" alt=""></p>
<p><s>2.三步把A上的三个大盘移到B上</s></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kly5h9yij20l607h0sy.jpg" alt=""></p>
<p><s>3.把C上的n-3个借助B移到A上</s></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kly5htr9j20l907d74i.jpg" alt=""></p>
<p><s>4.三步把B上的三个大盘移到C上</s></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klyuoom4j20l807i0sz.jpg" alt=""></p>
<p><s>5.把A上的n-3个借助C移到B上</s></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klyur6f0j20ll07nweq.jpg" alt=""></p>
<p><s>6.两步把C上的两个大盘移到A上</s></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klyuoru6j20ln07i0sz.jpg" alt=""></p>
<p><s>7.把B上的n-3个借助C移回A上</s></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klzhcygxj20lk07h3yr.jpg" alt=""></p>
<p><s>8.一步把C上的大盘移到B上</s></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klzhdhwuj20ln07i0sz.jpg" alt=""></p>
<p><s>最后一层可以不用看了，现在已经转化成了一个n-3的子局面，所以只要像双色汉诺塔那样跑个循环即可</s></p>
<p>错误代码就不放了。。反正也被我搞没了。。错误的运行结果是这样的：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klzhfedij204z06omx9.jpg" alt=""></p>
<p>更优的思路如下：</p>
<h3 id="网上的递归思路："><a href="#网上的递归思路：" class="headerlink" title="网上的递归思路："></a>网上的递归思路：</h3><p>如果n=3直接输出六步，否则先进行如下八步操作：</p>
<p>1.把A上的n-3个借助B移到C上</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4km0okyabj20l607dwep.jpg" alt=""></p>
<p>2.把A上的3个大盘移到B上</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4km12x17cj20lf07ejrn.jpg" alt=""></p>
<p>3.C上的n-3个借助B移回A上</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4km12wwgvj20lg07laaa.jpg" alt=""></p>
<p>4.B上的3个大盘移到C上</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4km1ihd5yj20lp07qaac.jpg" alt=""></p>
<p>5.A上的n-3个借助C移到B上</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4km1ihv4lj20l707gt8y.jpg" alt=""></p>
<p>6.C上的两个大盘移到A上</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4km1ihcndj20ld07edg2.jpg" alt=""></p>
<p>7.B上的n-3个借助A移到C上</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4km2b7tqjj20le07fq36.jpg" alt=""></p>
<p>8.A上的一个大盘移到B上</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4km2b8fwcj20l807jdg3.jpg" alt=""></p>
<p>然后跑个循环：</p>
<p>循环中步骤如下：</p>
<p>1.把C上n-6个借助A移到B上</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4km2b7yz6j20lf07emxf.jpg" alt=""></p>
<p>2.把C上两个稍大盘移到A上</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4km330sjnj20lf07hglu.jpg" alt=""></p>
<p>3.把B上n-6个借助A移回C</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4km331j8hj20lr07o3yr.jpg" alt=""></p>
<p>4.A上一个稍大盘移到B上</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4km330uzzj20ld07kq36.jpg" alt=""></p>
<p>完成一遍循环，又回到了下一步要操作的i-3个盘都在C上的子状态，很奇妙</p>
<p>可能有人疑惑那为什么不直接一开始就把A上所有盘移到C上满足那个子状态，然后直接跑循环而不经过一开始的八步，因为那样做相当于是四次hanoi(n-3,a,b,c)，而直接移就是hanoi(n,a,b,c)，这两个差的差不多是2^3也就是八倍左右，所以一开始必须要特殊的移一下，然后才能进入轻松愉快的循环</p>
<p>这个思路的第一步和我之前不是最优的思路一样，都是四次子递归，所以二者数量级是差不多的，但是它快就快在后续的循环里</p>
<h2 id="2）运行结果"><a href="#2）运行结果" class="headerlink" title="2）运行结果"></a>2）运行结果</h2><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4km3oncmhj207j073wep.jpg" alt=""></p>
<p>除了前两项，后面的结果都满足<code>an=f[n]-2*f[n-1]，an为公差为3的等差数列</code>，那就先这样好啦</p>
<h2 id="3）代码："><a href="#3）代码：" class="headerlink" title="3）代码："></a>3）代码：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int num;</span><br><span class="line">void hanoi(int n,char a,char b,char c)&#123;</span><br><span class="line">	if(n&#x3D;&#x3D;1)&#123;</span><br><span class="line">		&#x2F;*</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">		*&#x2F;</span><br><span class="line">		num+&#x3D;3;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		hanoi(n-1,a,c,b);</span><br><span class="line">		&#x2F;*</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">		*&#x2F;</span><br><span class="line">		num+&#x3D;3;</span><br><span class="line">		hanoi(n-1,b,a,c);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void hanoi3(int n,char a,char b,char c)&#123;</span><br><span class="line">	if(n&#x3D;&#x3D;3)&#123;</span><br><span class="line">		&#x2F;*</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;b&lt;&lt;&quot;-&gt;&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;b&lt;&lt;&quot;-&gt;&quot;&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;c&lt;&lt;&quot;-&gt;&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">		*&#x2F;</span><br><span class="line">		num+&#x3D;6;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		hanoi(n&#x2F;3-1,a,b,c);</span><br><span class="line">		&#x2F;*</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">		*&#x2F;</span><br><span class="line">		num+&#x3D;3;</span><br><span class="line">		hanoi(n&#x2F;3-1,c,b,a);</span><br><span class="line">		&#x2F;*</span><br><span class="line">		cout&lt;&lt;b&lt;&lt;&quot;-&gt;&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;b&lt;&lt;&quot;-&gt;&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;b&lt;&lt;&quot;-&gt;&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">		*&#x2F;</span><br><span class="line">		num+&#x3D;3;</span><br><span class="line">		hanoi(n&#x2F;3-1,a,c,b);</span><br><span class="line">		&#x2F;*</span><br><span class="line">		cout&lt;&lt;c&lt;&lt;&quot;-&gt;&quot;&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;c&lt;&lt;&quot;-&gt;&quot;&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">		*&#x2F;</span><br><span class="line">		num+&#x3D;2;</span><br><span class="line">		hanoi(n&#x2F;3-1,b,a,c);</span><br><span class="line">		&#x2F;&#x2F;cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">		num++;</span><br><span class="line">		for(int i&#x3D;n&#x2F;3-1;i&gt;0;i--)&#123;</span><br><span class="line">			if(i&gt;1)hanoi(i-1,c,a,b);</span><br><span class="line">			&#x2F;*</span><br><span class="line">			cout&lt;&lt;c&lt;&lt;&quot;-&gt;&quot;&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">			cout&lt;&lt;c&lt;&lt;&quot;-&gt;&quot;&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">			*&#x2F;</span><br><span class="line">			num+&#x3D;2;</span><br><span class="line">			if(i&gt;1)hanoi(i-1,b,a,c);</span><br><span class="line">			&#x2F;&#x2F;cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">			num++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int nn;</span><br><span class="line">	char a&#x3D;&#39;A&#39;,b&#x3D;&#39;B&#39;,c&#x3D;&#39;C&#39;;</span><br><span class="line">	for(nn&#x3D;3;nn&lt;&#x3D;50;nn+&#x3D;3)&#123;</span><br><span class="line">		num&#x3D;0;</span><br><span class="line">		hanoi3(nn,a,b,c);</span><br><span class="line">		cout&lt;&lt;nn&lt;&lt;&quot;:&quot;&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
  </entry>
  <entry>
    <title>Java第五次作业（系统属性）</title>
    <url>/3c9a08ea/</url>
    <content><![CDATA[<p>没有看见要命令行参数。。之前直接愚蠢的scanner了。。现在更新了</p>
<a id="more"></a>

<hr>
<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p>编写一个程序，如果没有命令行参数，则列出所有系统属性（属性=属性值），如果有命令行参数，则根据命令行参数显示指定的系统属性（属性=属性值）</p>
<h1 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h1><p>用一个list列出所有系统属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Properties pro&#x3D;System.getProperties();</span><br><span class="line">pro.list(System.out);</span><br></pre></td></tr></table></figure>

<p><code>pro.getProperty(s)</code>可以获得名为s的某个指定属性</p>
<h1 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h1><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmhmmq63j20d408wdh4.jpg" alt=""></p>
<h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Properties pro&#x3D;System.getProperties();</span><br><span class="line">        if(args.length&#x3D;&#x3D;0)pro.list(System.out);</span><br><span class="line">        else&#123;</span><br><span class="line">            for(String s:args)System.out.println(s+&quot; &quot;+pro.getProperty(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>一些作业</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构第五次作业（散列表类 hashTable）</title>
    <url>/434dcb65/</url>
    <content><![CDATA[<p>这两个作业写的我。。老感觉没读懂题一样。。要是真的读错题了。。还请各路神仙大侠告诉我一声。。</p>
<hr>
<h1 id="作业一"><a href="#作业一" class="headerlink" title="作业一"></a>作业一</h1><p>开发一个基于线性探查的散列表类，要求用neverUsed思想进行删除操作，为每个方法编写C++代码，其中有一个方法，它在60%的空桶的neverUsed域的值为false时，重新组织散列表，重新组织散列表的过程要在必要时移动记录，重新组织之后，每个空桶的neverUsed域的值为true，测试代码的正确性</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="neverUsed："><a href="#neverUsed：" class="headerlink" title="neverUsed："></a>neverUsed：</h3><p>因为删除一个桶，把empty直接标记为空可能导致在后续的查找中出现问题，比如11，22，33，44，55顺次输入，都要填入ht[0]的位置，但是ht[0]被11占用了，22只能填入ht[1]，33只能填入ht[2]，以此类推，相当冲突，这时如果把11，33删了，把ht[1]，ht[3]的empty标记为true，那么要搜索44就会出现问题，直接返回了第一个空桶的位置，如下图：</p>
<p>（不用neverUsed的不良后果）</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmiutdzjj20fd03wdg5.jpg" alt=""></p>
<p>所以要用neverUsed思想进行操作，表明这个地方有无存在过元素，减去一句加上一句，修改后的运行结果如图：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmiusuozj20cd05h74r.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmjwuospj20fk03v74l.jpg" alt=""></p>
<p>也就是要开三个数组，一个用来记录值，一个记录这个桶是否为空，一个用来记录这个桶是否被用过</p>
<h3 id="重新组织散列表："><a href="#重新组织散列表：" class="headerlink" title="重新组织散列表："></a>重新组织散列表：</h3><p>知道了neverused数组的用途，重新组织就很简单了</p>
<p>当前empty[i]却又!neverused[i]的空间就浪费了，所以扫一遍，对于每个元素找到他最优的位置，如果那个位置是empty就直接放过去，这样后续查找就不会受到删除元素的影响了，然后最后把没用的位置都neverused重新标记回false</p>
<h2 id="运行效果："><a href="#运行效果：" class="headerlink" title="运行效果："></a>运行效果：</h2><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmk5zejqj20fe0a8wft.jpg" alt=""></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class E,class K&gt;</span><br><span class="line">class HashTable&#123;</span><br><span class="line">	private:</span><br><span class="line">		int m;</span><br><span class="line">		E *ht;</span><br><span class="line">		bool *empty;</span><br><span class="line">		bool *neverUsed;</span><br><span class="line">	public:</span><br><span class="line">		HashTable(int divisor&#x3D;11); </span><br><span class="line">		~HashTable() &#123;delete [] ht;  delete [] empty;&#125;</span><br><span class="line">		int get_pos(const K&amp; k)const;</span><br><span class="line">		bool Search(const K&amp; k,E&amp; e)const;</span><br><span class="line">		HashTable&lt;E,K&gt;&amp; Insert(const E&amp; e);</span><br><span class="line">		void show();</span><br><span class="line">		bool move(const K&amp; k);</span><br><span class="line">		bool check();</span><br><span class="line">		void update();</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class E,class K&gt;</span><br><span class="line">HashTable&lt;E,K&gt;::HashTable(int divisor)&#123;</span><br><span class="line">	m&#x3D;divisor;</span><br><span class="line">	ht&#x3D;new E [m];</span><br><span class="line">	empty&#x3D;new bool [m];</span><br><span class="line">	neverUsed&#x3D;new bool [m];</span><br><span class="line">	for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">		empty[i]&#x3D;true;</span><br><span class="line">		neverUsed[i]&#x3D;true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class E,class K&gt;</span><br><span class="line">int HashTable&lt;E,K&gt;::get_pos(const K&amp; k)const&#123;</span><br><span class="line">	int i&#x3D;k%m;</span><br><span class="line">	int j&#x3D;i;</span><br><span class="line">	do&#123;</span><br><span class="line">		&#x2F;&#x2F;if(empty[j]||ht[j]&#x3D;&#x3D;k)return j;</span><br><span class="line">		if(neverUsed[j]||ht[j]&#x3D;&#x3D;k)return j;</span><br><span class="line">		j&#x3D;(j+1)%m;</span><br><span class="line">	&#125;while(j!&#x3D;i);</span><br><span class="line">	return j;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class E,class K&gt;</span><br><span class="line">bool HashTable&lt;E,K&gt;::Search(const K&amp; k,E&amp; e)const&#123;</span><br><span class="line">	int b&#x3D;get_pos(k);</span><br><span class="line">	if(empty[b]||ht[b]!&#x3D;k)&#123;</span><br><span class="line">		cout&lt;&lt;&quot;没有找到&quot;&lt;&lt;k&lt;&lt;&quot;这个元素&quot;&lt;&lt;endl;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	e&#x3D;ht[b];</span><br><span class="line">	cout&lt;&lt;&quot;元素&quot;&lt;&lt;k&lt;&lt;&quot;在第&quot;&lt;&lt;b&lt;&lt;&quot;个桶中&quot;&lt;&lt;endl;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class E,class K&gt;</span><br><span class="line">HashTable&lt;E,K&gt;&amp; HashTable&lt;E,K&gt;::Insert(const E&amp; e)&#123;</span><br><span class="line">	K k &#x3D;e;</span><br><span class="line">	int b&#x3D;get_pos(k);</span><br><span class="line">	if(empty[b]&amp;&amp;neverUsed[b])&#123;</span><br><span class="line">		neverUsed[b]&#x3D;false;</span><br><span class="line">		empty[b]&#x3D;false;</span><br><span class="line">		ht[b]&#x3D;e;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	if(ht[b]&#x3D;&#x3D;k)cout&lt;&lt;&quot;重复的输入&quot;&lt;&lt;endl;</span><br><span class="line">	else cout&lt;&lt;&quot;空间不足！&quot;&lt;&lt;endl;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class E,class K&gt;</span><br><span class="line">bool HashTable&lt;E,K&gt;::move(const K&amp; k)&#123;</span><br><span class="line">	int i&#x3D;k%m;</span><br><span class="line">	int j&#x3D;i;</span><br><span class="line">	do&#123;</span><br><span class="line">		if(ht[j]&#x3D;&#x3D;k)&#123;</span><br><span class="line">			empty[j]&#x3D;true;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		j&#x3D;(j+1)%m;</span><br><span class="line">	&#125;while(j!&#x3D;i);</span><br><span class="line">	cout&lt;&lt;&quot;没有找到要删除的数&quot;&lt;&lt;endl;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class E,class K&gt;</span><br><span class="line">void HashTable&lt;E,K&gt;::show()&#123;</span><br><span class="line">	cout&lt;&lt;&quot;当前桶中的元素为：&quot;;</span><br><span class="line">	for(int i&#x3D;0;i&lt;m;i++)</span><br><span class="line">		if(!empty[i])cout&lt;&lt;&quot;(&quot;&lt;&lt;i&lt;&lt;&quot;)&quot;&lt;&lt;ht[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class E,class K&gt;</span><br><span class="line">bool HashTable&lt;E,K&gt;::check()&#123;</span><br><span class="line">	int num&#x3D;0,sum&#x3D;0;</span><br><span class="line">	for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">		if(empty[i])&#123;</span><br><span class="line">			sum++;</span><br><span class="line">			if(!neverUsed[i])num++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	double tmp&#x3D;(double)num&#x2F;sum;</span><br><span class="line">	if(tmp&gt;0.6)&#123;</span><br><span class="line">		cout&lt;&lt;&quot;有&quot;&lt;&lt;tmp&lt;&lt;&quot;%空桶neverused域的值为false，重新组织散列表&quot;&lt;&lt;endl;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;&quot;空间足够，无需重新组织散列表&quot;&lt;&lt;endl;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class E,class K&gt;</span><br><span class="line">void HashTable&lt;E,K&gt;::update()&#123;</span><br><span class="line">	if(!this-&gt;check())return;</span><br><span class="line">	for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">		if(!empty[i])&#123;</span><br><span class="line">			int tmp&#x3D;ht[i]%m,j&#x3D;tmp;</span><br><span class="line">			while(i!&#x3D;j)&#123;</span><br><span class="line">				if(empty[j])&#123;</span><br><span class="line">					empty[i]&#x3D;true;</span><br><span class="line">					empty[j]&#x3D;false;</span><br><span class="line">					ht[j]&#x3D;ht[i];</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				j&#x3D;(j+1)%m;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;0;i&lt;m;i++)</span><br><span class="line">		if(!neverUsed[i]&amp;&amp;empty[i])neverUsed[i]&#x3D;true;</span><br><span class="line">	int num&#x3D;0,sum&#x3D;0;</span><br><span class="line">	for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">		if(empty[i])&#123;</span><br><span class="line">			sum++;</span><br><span class="line">			if(!neverUsed[i])num++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	double t&#x3D;(double)num&#x2F;sum;</span><br><span class="line">	cout&lt;&lt;t&lt;&lt;&quot; 成功更新散列表&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	HashTable&lt;int,int&gt; my_ht(11);</span><br><span class="line">	int x;</span><br><span class="line">	cout&lt;&lt;&quot;----------新建一个散列表----------&quot;&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">	for(int i&#x3D;0;i&lt;10;i++)my_ht.Insert(11*i);</span><br><span class="line">	my_ht.show();</span><br><span class="line">	my_ht.Search(44,x);</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;----------删除部分元素后----------&quot;&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">	for(int i&#x3D;0;i&lt;11;i++)if(i&amp;1)my_ht.move(11*i);</span><br><span class="line">	my_ht.show();</span><br><span class="line">	my_ht.Search(44,x);</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;----------重新组织散列表后----------&quot;&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">	my_ht.update();</span><br><span class="line">	my_ht.show();</span><br><span class="line">	my_ht.Search(44,x);</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="作业二"><a href="#作业二" class="headerlink" title="作业二"></a>作业二</h1><p>设计一个类hashChainsWithTail，其中每个散列链表都是一个有尾节点的有序链表，而且所有链表在物理上都共享一个尾节点，不使用任何链表类的方法实现插入和删除，和类hashChain比较时间性能</p>
<h2 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h2><p>先用链表的思想实现哈希表，然后盗用一下ppt</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmklpgl8j20jr0cugnf.jpg" alt=""></p>
<p>其实我觉得这个优化。。很勉强，因为这种只限于链表内的元素是顺序存储的时候才可以减少一半的比较次数，而散列表插入应该是乱序的，所以i-&gt;data&lt;k一个条件在乱序时并不起作用，比着比着答案就没了</p>
<p>所以为了体现题目时间性能比较的要求，我写了个链表按从小到大顺序存储的散列表，也就是在插入的时候比较一下大小再插入，然后比较搜索程序的时间性能</p>
<p>此外，如果散列表很散的时候，也就是只要比较一次就能找到，测试发现对其实结果影响不大，只有比较次数多了才能体现出二者差异，所以测试数据size选为17（反正小一点都行），数据采用随机方式生成</p>
<h2 id="运行效果：-1"><a href="#运行效果：-1" class="headerlink" title="运行效果："></a>运行效果：</h2><p>最终就是差不多两倍少一点的关系，因为后者比较次数是前者两倍</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmklr8voj20pq0iznas.jpg" alt=""></p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line">const int size&#x3D;17;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">struct Node&#123;</span><br><span class="line">	T data;</span><br><span class="line">	Node *next;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class hashChainsWithTail&#123;</span><br><span class="line">	public:</span><br><span class="line">		hashChainsWithTail()&#123;</span><br><span class="line">			tail&#x3D;new Node&lt;T&gt;;</span><br><span class="line">			tail-&gt;next&#x3D;NULL;</span><br><span class="line">			tail-&gt;data&#x3D;INF;</span><br><span class="line">			for(int i&#x3D;0;i&lt;size;i++)&#123;</span><br><span class="line">				HT[i]&#x3D;new Node&lt;T&gt;;</span><br><span class="line">				HT[i]-&gt;next&#x3D;tail;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		~hashChainsWithTail()&#123;</span><br><span class="line">			delete tail;</span><br><span class="line">			for(int i&#x3D;0;i&lt;size;i++)delete [] HT[i];</span><br><span class="line">		&#125;</span><br><span class="line">		int hash(T v);</span><br><span class="line">		bool vis(T v);</span><br><span class="line">		void insert(T v);</span><br><span class="line">		void show();</span><br><span class="line">		bool search1(T v);</span><br><span class="line">		bool search2(T v);</span><br><span class="line">	private:</span><br><span class="line">		Node&lt;T&gt; *HT[size];</span><br><span class="line">		Node&lt;T&gt; *tail;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">int hashChainsWithTail&lt;T&gt;::hash(T v)&#123;</span><br><span class="line">	int tmp&#x3D;0;</span><br><span class="line">	tmp&#x3D;v*33%size;</span><br><span class="line">	return tmp;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">bool hashChainsWithTail&lt;T&gt;::vis(T v)&#123;</span><br><span class="line">	Node&lt;T&gt; *p;</span><br><span class="line">	int index&#x3D;hash(v);</span><br><span class="line">	p&#x3D;HT[index];</span><br><span class="line">	for(p&#x3D;p-&gt;next;p-&gt;data&lt;&#x3D;v;p&#x3D;p-&gt;next);</span><br><span class="line">	if(p-&gt;data&#x3D;&#x3D;v)return true;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void hashChainsWithTail&lt;T&gt;::insert(T v)&#123;</span><br><span class="line">	Node&lt;T&gt; *p,*tmp;</span><br><span class="line">	int index&#x3D;hash(v);</span><br><span class="line">	if(vis(v))return;</span><br><span class="line">	p&#x3D;HT[index];</span><br><span class="line">	if(p-&gt;next&#x3D;&#x3D;tail)&#123;</span><br><span class="line">		tmp&#x3D;new Node&lt;T&gt;;</span><br><span class="line">		tmp-&gt;data&#x3D;v;</span><br><span class="line">		tmp-&gt;next&#x3D;tail;</span><br><span class="line">		p-&gt;next&#x3D;tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		for(p&#x3D;HT[index];p-&gt;next-&gt;data&lt;v;p&#x3D;p-&gt;next);</span><br><span class="line">		tmp&#x3D;new Node&lt;T&gt;;</span><br><span class="line">		tmp-&gt;data&#x3D;v;</span><br><span class="line">		tmp-&gt;next&#x3D;p-&gt;next;</span><br><span class="line">		p-&gt;next&#x3D;tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">bool hashChainsWithTail&lt;T&gt;::search1(T v)&#123;</span><br><span class="line">	int index&#x3D;hash(v);</span><br><span class="line">	Node&lt;T&gt; *p;</span><br><span class="line">	p&#x3D;HT[index];</span><br><span class="line">	for(p&#x3D;p-&gt;next;p-&gt;data&lt;v;p&#x3D;p-&gt;next);</span><br><span class="line">	if(p-&gt;data!&#x3D;INF)&#123;</span><br><span class="line">		&#x2F;&#x2F;cout&lt;&lt;v&lt;&lt;&quot;对应的data是：&quot;&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;cout&lt;&lt;&quot;啥玩意儿啊找不着啊QWQ&quot;&lt;&lt;endl;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">bool hashChainsWithTail&lt;T&gt;::search2(T v)&#123;</span><br><span class="line">	int index&#x3D;hash(v);</span><br><span class="line">	Node&lt;T&gt; *p;</span><br><span class="line">	p&#x3D;HT[index];</span><br><span class="line">	for(p&#x3D;p-&gt;next;p-&gt;next!&#x3D;tail;p&#x3D;p-&gt;next)&#123;</span><br><span class="line">		if(p-&gt;data&#x3D;&#x3D;v)&#123;</span><br><span class="line">			&#x2F;&#x2F;cout&lt;&lt;v&lt;&lt;&quot;对应的data是：&quot;&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;cout&lt;&lt;&quot;啥玩意儿啊找不着啊QWQ&quot;&lt;&lt;endl;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void hashChainsWithTail&lt;T&gt;::show()&#123;</span><br><span class="line">	Node&lt;T&gt; *p;</span><br><span class="line">	for(int i&#x3D;0;i&lt;size;i++)&#123;</span><br><span class="line">		if(HT[i]!&#x3D;NULL)&#123;</span><br><span class="line">			p&#x3D;HT[i];</span><br><span class="line">			for(p&#x3D;p-&gt;next;p-&gt;data&lt;INF;p&#x3D;p-&gt;next)</span><br><span class="line">				cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">			cout&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	clock_t t1,t2;</span><br><span class="line">	hashChainsWithTail&lt;int&gt; ht;</span><br><span class="line">	for(int i&#x3D;0;i&lt;888;i++)ht.insert(i+rand()%8888);</span><br><span class="line">	&#x2F;&#x2F;ht.show();</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;endl&lt;&lt;&quot;-----测试结果-----&quot;&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">	t1&#x3D;clock();</span><br><span class="line">	for(int i&#x3D;0;i&lt;8888;i++)ht.search1(i);</span><br><span class="line">	t2&#x3D;clock();</span><br><span class="line">	cout&lt;&lt;&quot;方法一用时： &quot;&lt;&lt;(t2-t1)&lt;&lt;&quot; CLOCKS_PER_SEC&quot;&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	t1&#x3D;clock();</span><br><span class="line">	for(int i&#x3D;0;i&lt;8888;i++)ht.search2(i);</span><br><span class="line">	t2&#x3D;clock();</span><br><span class="line">	cout&lt;&lt;&quot;方法二用时： &quot;&lt;&lt;(t2-t1)&lt;&lt;&quot; CLOCKS_PER_SEC&quot;&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>一些作业</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ bitset 二进制STL</title>
    <url>/532d9a6f/</url>
    <content><![CDATA[<p>记录一下方便日后用到，还蛮方便的</p>
<h1 id="BitSet"><a href="#BitSet" class="headerlink" title="BitSet"></a>BitSet</h1><p>C++语言的一个类库，用来方便地管理一系列的bit位而不用程序员自己来写代码</p>
<p>bitset除了可以访问指定下标的bit位以外，还可以把它们作为一个整数来进行某些统计</p>
<p>声明一个该类型变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bitset&lt;N&gt;varm (M)</span><br><span class="line"></span><br><span class="line">varm为变量名，N表示该类型在内存中占的位数，M表示变量varm的初始值</span><br></pre></td></tr></table></figure>

<h1 id="测试代码："><a href="#测试代码：" class="headerlink" title="测试代码："></a>测试代码：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;bitset&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	bitset&lt;16&gt; x;</span><br><span class="line">	bitset&lt;16&gt; y(0x2333);</span><br><span class="line">	bitset&lt;16&gt; z(&quot;01010101&quot;);</span><br><span class="line">	cout&lt;&lt;&quot;x:&quot;&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;y:&quot;&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;z:&quot;&lt;&lt;z&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	x|&#x3D;y;</span><br><span class="line">	x&amp;&#x3D;y;</span><br><span class="line">	y&#x3D;~y;</span><br><span class="line">	z^&#x3D;x;</span><br><span class="line">	z&gt;&gt;&#x3D;2;</span><br><span class="line">	z&lt;&lt;&#x3D;1;</span><br><span class="line">	cout&lt;&lt;&quot;x:&quot;&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;y:&quot;&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;z:&quot;&lt;&lt;z&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;x的位数：&quot;&lt;&lt;x.size()&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;x中1的个数：&quot;&lt;&lt;x.count()&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;x中是否有1：&quot;&lt;&lt;x.any()&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;x中是否没有1：&quot;&lt;&lt;x.none()&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;x的i+1位置1：&quot;&lt;&lt;x.set(15)&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;x的i+1位置为z：&quot;&lt;&lt;x.set(15,2)&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;x全部取反：&quot;&lt;&lt;x.flip()&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;x的i+1位取反：&quot;&lt;&lt;x.flip(15)&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;x转化为unsigned long的结果：&quot;&lt;&lt;x.to_ulong()&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;x转化为unsigned long long的结果：&quot;&lt;&lt;x.to_ullong()&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;x转化为string的结果：&quot;&lt;&lt;x.to_string()&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;x全部置1：&quot;&lt;&lt;x.set()&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;x全部置0：&quot;&lt;&lt;x.reset()&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="运行效果："><a href="#运行效果：" class="headerlink" title="运行效果："></a>运行效果：</h1><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmiuu2ttj20fx0a6400.jpg" alt=""></p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>Python爬取hexo个人博客所有文章网址（11.11快乐）</title>
    <url>/209ef750/</url>
    <content><![CDATA[<p>已经是两个星期前的事情了啊啊啊哈哈哈。。。我这个拖延症。。。</p>
<p>今天又重新改了点代码再爬一次，爬了两百多个的时候。。一个忘我拔了数据线断了热点(#ﾟДﾟ)。。然后只好重新爬。。记了下时间， 338个链接大概爬了34分钟，应该emmmmm还可以吧0.0</p>
<a id="more"></a>

<hr>
<h1 id="1-运行效果："><a href="#1-运行效果：" class="headerlink" title="1.运行效果："></a>1.运行效果：</h1><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klp3e0qgj20fw0fbgn0.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klp3elktj20g70hbmyu.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klp3ee8mj20i40bq41a.jpg" alt=""></p>
<h1 id="2-动因和可行性分析"><a href="#2-动因和可行性分析" class="headerlink" title="2.动因和可行性分析"></a>2.动因和可行性分析</h1><p>爬自己博客的原因是安了个abbrlink插件，换了所有文章的链接，所以之前的链接都404了，因为百度收录速度太慢，所以打算主动递交链接，两百多个链接一个一个点太傻了，让爬虫自己来吧(OvO)</p>
<p>文章虽然有两百多篇，但是博客的页码只有25页，并且每一页的链接具有统一格式：<code>https://leflacon.github.io/page/2/</code>，那个2的地方即代表页码，所以只要爬这25个页面就能获取所有文章的链接</p>
<h1 id="3-具体思路："><a href="#3-具体思路：" class="headerlink" title="3.具体思路："></a>3.具体思路：</h1><p>一个vis，一个unvis，分别存爬过的和没爬过待爬过的</p>
<h2 id="1）初始化unvis"><a href="#1）初始化unvis" class="headerlink" title="1）初始化unvis"></a>1）初始化unvis</h2><p>因为第一页就是博客首页的链接，而不是page1，所以单独处理，然后循环把所有page的地址加入到待爬的页面中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in range(2,26):</span><br><span class="line">    page_&#x3D;&quot;https:&#x2F;&#x2F;leflacon.github.io&#x2F;page&#x2F;&quot;+str(i)+&quot;&#x2F;&quot;</span><br><span class="line">    self.links_.add_unvis(page_)</span><br></pre></td></tr></table></figure>

<h2 id="2）获取域名"><a href="#2）获取域名" class="headerlink" title="2）获取域名"></a>2）获取域名</h2><p>先给个首页的地址，然后根据这个地址可以获得协议名和域名，如何获得的。。其实我不会。。学的别人的代码</p>
<p>因为爬的是个人博客，所以域名是一定要获取的，因为这样才可以避免爬到外链之后还莫名其妙的爬下去，要保证最后的结果都是本博客里的，所以写一个筛选函数，比较爬到的网址集是否包含域名</p>
<h2 id="3）bfs"><a href="#3）bfs" class="headerlink" title="3）bfs"></a>3）bfs</h2><p>感觉其实就是个bfs</p>
<p>可以拓展的链接存入unvis里，然后每次pop一个链接cur_link来爬，爬某个网页的操作是小函数<code>def small_spider(url):</code>，然后对于某个网页爬到的链接cur_links进行筛选（爬过的不要，和域名不同的不要），这里要先和之前的vis集合比较，然后把vis中没有的添加到unvis里待爬，然后再把爬到的所有链接更新到vis里</p>
<p>最后跳出循环的条件就是unvis为空，没法再拓展了，把vis里的链接写入文件</p>
<h2 id="4）其他"><a href="#4）其他" class="headerlink" title="4）其他"></a>4）其他</h2><p>其实有个问题是，明明主页包含有page的链接，为什么只爬一个主页就不行呢0.0，不知道不知道不会不会不了解不了解，先这样吧。。我也不知道那个爬取的小函数到底能爬到啥</p>
<h1 id="4-代码"><a href="#4-代码" class="headerlink" title="4.代码"></a>4.代码</h1><p>代码◡◡◡◡◡◡ ヽ(`Д´)ﾉ丢～</p>
<p>丢好了(・ω・)ノ <a href="https://github.com/LeFlacon/Simple-Python-Practice/blob/master/spider_blog.py" target="_blank" rel="noopener">https://github.com/LeFlacon/Simple-Python-Practice/blob/master/spider_blog.py</a></p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>CF 516 D. Candies for Children（分类讨论）</title>
    <url>/13028674/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/contest/1063/problem/D" target="_blank" rel="noopener">http://codeforces.com/contest/1063/problem/D</a></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmi3zowuj20ot0cddii.jpg" alt=""></p>
<a id="more"></a>

<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>n人环，k个糖果，从起点l出发到终点r（可以绕圈），爱吃甜食的小朋友每次拿两个糖果，其他小朋友拿一个，但是如果最后一个小朋友是爱吃甜食的然后糖只剩一个了，那这个小朋友只有一个糖</p>
<p>问最多有几个小朋友爱吃甜食</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>分成两部分，一部分是整圈的，一部分是最后小半圈的</p>
<p>然后分两种情况讨论：</p>
<p>第一种是n小的时候，那么圈数多，枚举每圈爱吃糖的人，判断合法性</p>
<p>第二种是n大大时候，圈数少，直接枚举圈数即可</p>
<p>大佬的解方程的思路虽然大概懂了。。但是还是雾雾的 (;-;)。。只好继续想想了，参考了别人提交的代码大概改成了现在这样。。这题要考虑的点真的好多啊，具体见代码注释</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p>跑的飞快0.0</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmi400j9j20il02d3yq.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">int main()&#123;</span><br><span class="line">	LL n,l,r,k,x,ans&#x3D;-1;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;l&gt;&gt;r&gt;&gt;k;</span><br><span class="line">	x&#x3D;(r-l+n)%n+1;&#x2F;&#x2F;小半圈的人数</span><br><span class="line">	if(n&lt;&#x3D;3e6)&#123;&#x2F;&#x2F;n小，圈数多</span><br><span class="line">		for(LL i&#x3D;n;i&gt;&#x3D;0;i--)&#123;</span><br><span class="line">			&#x2F;&#x2F;枚举每圈爱吃糖的人的个数，即每圈需要i+n个糖</span><br><span class="line">			LL z&#x3D;(k-1)%(i+n)-x+1;</span><br><span class="line">			&#x2F;&#x2F;z为发完所有整圈，小半圈先一人一个后剩余的糖数</span><br><span class="line">			&#x2F;&#x2F;这些剩余的糖都是要发给小半圈爱吃糖的人的</span><br><span class="line">			LL p&#x3D;z+1;</span><br><span class="line">			if(z&lt;0||z&gt;i||z&gt;x||x-z&gt;n-i+1)continue;</span><br><span class="line">			&#x2F;&#x2F;非法情况如下：</span><br><span class="line">			&#x2F;&#x2F;小半圈不够发，小半圈每人都再发一个还多</span><br><span class="line">			&#x2F;&#x2F;小半圈要发的大于小半圈人数</span><br><span class="line">			&#x2F;&#x2F;小半圈不爱吃糖的人数大于总不爱吃糖的人数加一</span><br><span class="line">			&#x2F;&#x2F;（这里恰好等于是可行的，因为最后一个人r可以委屈一下吃一颗）</span><br><span class="line">			if((p&lt;&#x3D;i&amp;&amp;p&lt;&#x3D;x)||x-z&lt;&#x3D;n-i)&#123;</span><br><span class="line">				ans&#x3D;i;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;剩余糖数+1小于等于爱吃糖的人数并且小于等于小半圈人数即合法</span><br><span class="line">			&#x2F;&#x2F;小半圈人数减去剩余糖数得小半圈不爱吃糖人数，小于等于总不爱吃糖人数也合法</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;&#x2F;&#x2F;n大，圈数小，枚举圈数i</span><br><span class="line">		LL t&#x3D;k&#x2F;n;&#x2F;&#x2F;圈数范围</span><br><span class="line">		for(LL i&#x3D;0;i&lt;&#x3D;t;i++)&#123;</span><br><span class="line">			LL res&#x3D;(k-2*x-n*(i-1)+1)&#x2F;(i+1);</span><br><span class="line">			&#x2F;&#x2F;化简前的式子应该是这样，res&#x3D;(k-x+(n-x)-n*i+1)&#x2F;(i+1)</span><br><span class="line">			&#x2F;&#x2F;res为每整圈爱吃糖的人数</span><br><span class="line">			LL z&#x3D;k-i*(res+n)-x,a;&#x2F;&#x2F;z为发完所有整圈，小半圈先一人一个后剩余的糖数</span><br><span class="line">			if(z&lt;0)&#123;&#x2F;&#x2F;缺糖了没法给小半圈爱吃糖的人加糖</span><br><span class="line">				a&#x3D;ceil((-z)*1.0&#x2F;i);</span><br><span class="line">				&#x2F;&#x2F;那么每圈需要少发a个糖，即每圈发res-a个</span><br><span class="line">				&#x2F;&#x2F;现在能给小半圈加的糖数是a*i-z</span><br><span class="line">				if(a*i+z&lt;&#x3D;res-a&amp;&amp;a*i+z&lt;&#x3D;x)ans&#x3D;max(ans,res-a);</span><br><span class="line">				&#x2F;&#x2F;小半圈爱吃糖人数小于等于总爱吃糖人数并且小于等于小半圈人数</span><br><span class="line">			&#125;</span><br><span class="line">			else if(res&lt;&#x3D;n)&#123;&#x2F;&#x2F;要排除res&gt;n的非法情况</span><br><span class="line">				if(z&gt;&#x3D;0&amp;&amp;z&lt;&#x3D;x&amp;&amp;z&lt;&#x3D;res)ans&#x3D;max(ans,res);</span><br><span class="line">				&#x2F;&#x2F;小半圈爱吃糖人数大于等于0,小于等于小半圈人数，小于等于每圈爱吃糖人数</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl; </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>Java第四次作业（CD Store）</title>
    <url>/e10dd693/</url>
    <content><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p>假设你在业余时间经营一个会员制的CD出租销售店，需要一个管理程序，可以增加会员，删除会员，出租，销售，进货，统计等，请设计适当的功能，并实现该程序</p>
<hr>
<p>下次写这种乱七八糟的东西的时候0.0我一定先列个提纲。。这次完全是想到啥写啥东补西补啊。。其实还有好多东西可以补，并且有些实现并不是o(1)的最优方法（可以实现但是我懒得写）。。</p>
<p>此外，添加了各种判断，因为要排除各种库存不足，cd名输错，手机号输错等情况，尽管加了不少，但是这个简单的系统仍然一点也不强壮，一点也不╮(￣▽￣””)╭</p>
<h1 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h1><h2 id="1-一个Vip类，保存单个客户的基本信息"><a href="#1-一个Vip类，保存单个客户的基本信息" class="headerlink" title="1.一个Vip类，保存单个客户的基本信息"></a>1.一个Vip类，保存单个客户的基本信息</h2><p>成员变量如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private String name;</span><br><span class="line">private String phone;</span><br><span class="line">private int score;&#x2F;&#x2F;会员积分</span><br><span class="line">private String rent_cd[]&#x3D;new String[5];&#x2F;&#x2F;租借信息</span><br></pre></td></tr></table></figure>

<p>因为要修改vip的信息，所以每个vip一定要有一个属性是与众不同的便于索引，考虑到张三和李四可能同名，所以这里选择了手机号来满足这个唯一性，每个人的手机号都是不一样的</p>
<p>此外，因为对于一个CD系统来说，租借信息必须保存，笔者对于租借信息的处理是用一个String类型的数组来记录租借的CD名</p>
<p>成员函数如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Vip(String name_,String phone_);</span><br><span class="line">public String get_name();&#x2F;&#x2F;获得会员名</span><br><span class="line">public String get_phone();&#x2F;&#x2F;获得会员手机号</span><br><span class="line">public int get_score();&#x2F;&#x2F;获得会员积分</span><br><span class="line">public void set_score(int a);&#x2F;&#x2F;修改会员积分</span><br><span class="line">public void show()&#x2F;&#x2F;显示会员信息</span><br><span class="line">public boolean add_rent(String s);&#x2F;&#x2F;添加租借记录</span><br><span class="line">public boolean delete_rent(String s);&#x2F;&#x2F;删除租借记录</span><br></pre></td></tr></table></figure>

<p>因为刚写过哈希表，所以有一个思路是把姓名字符串hash一下获得一个数组号，存入该会员的信息，这样的优点是o(1)就可以查询某会员，缺点是写着麻烦了许多，因为还要链表处理哈希冲突啥的，所以最后我还是没写hash</p>
<h2 id="2-一个Vip-类，保存一个客户集"><a href="#2-一个Vip-类，保存一个客户集" class="headerlink" title="2.一个Vip_类，保存一个客户集"></a>2.一个Vip_类，保存一个客户集</h2><p>成员变量如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Vip vips[]&#x3D;new Vip[233];</span><br></pre></td></tr></table></figure>

<p>直接用数组了，因为方便啊0.0</p>
<p>成员函数如下：</p>
<p>购买租借归还的道理都差不多，就是利用唯一的手机号码扫一遍索引到相应的用户，如果没找到就报个错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean add_vip(Vip v);&#x2F;&#x2F;添加会员</span><br><span class="line">public boolean delete_vip(String phone_);&#x2F;&#x2F;删除会员</span><br><span class="line">public void show_vip();&#x2F;&#x2F;显示会员信息</span><br><span class="line">public void buy(String s,int money);&#x2F;&#x2F;某会员购买</span><br><span class="line">public void rent(String s,String c);&#x2F;&#x2F;某会员租借</span><br><span class="line">public void back(String s,String c);&#x2F;&#x2F;某会员归还</span><br></pre></td></tr></table></figure>

<h2 id="3-一个cd类，保存单个cd的基本信息"><a href="#3-一个cd类，保存单个cd的基本信息" class="headerlink" title="3.一个cd类，保存单个cd的基本信息"></a>3.一个cd类，保存单个cd的基本信息</h2><p>成员变量如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private String name;&#x2F;&#x2F;cd名</span><br><span class="line">private int num;&#x2F;&#x2F;cd数量</span><br><span class="line">private int price;&#x2F;&#x2F;cd单价</span><br></pre></td></tr></table></figure>

<p>成员函数如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public cd(String name_,int price_,int num_);</span><br><span class="line">public void show();&#x2F;&#x2F;显示cd信息</span><br><span class="line">public int get_num();&#x2F;&#x2F;获取某cd数量</span><br><span class="line">public void set_num(int num_);&#x2F;&#x2F;修改某cd数量</span><br><span class="line">public String get_name();&#x2F;&#x2F;获取cd名</span><br><span class="line">public int get_price();&#x2F;&#x2F;获取cd单价</span><br></pre></td></tr></table></figure>

<h2 id="4-一个cd-类，保存一个cd集"><a href="#4-一个cd-类，保存一个cd集" class="headerlink" title="4.一个cd_类，保存一个cd集"></a>4.一个cd_类，保存一个cd集</h2><p>成员变量如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private cd cds[]&#x3D;new cd[2333];</span><br></pre></td></tr></table></figure>

<p>成员函数如下：</p>
<p>这里的售出租借归还都只是一个预先的操作，返回一个能否执行的boolean类型，不是实际售出租借归还，因为考虑完库存和cd是否存在等问题后，还要考虑某会员是否存在等等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean add_cd(cd c);&#x2F;&#x2F;添加cd</span><br><span class="line">public boolean delete_cd(String name_);&#x2F;&#x2F;删除cd</span><br><span class="line">public void show_cd();&#x2F;&#x2F;显示所有cd信息</span><br><span class="line">public int sold_cd(String s,int a);&#x2F;&#x2F;卖出cd</span><br><span class="line">public boolean rent_cd(String s);&#x2F;&#x2F;租借cd</span><br><span class="line">public boolean back_cd(String s);&#x2F;&#x2F;归还cd</span><br></pre></td></tr></table></figure>

<h2 id="5-一个store类，里面有一个cd集和一个客户集"><a href="#5-一个store类，里面有一个cd集和一个客户集" class="headerlink" title="5.一个store类，里面有一个cd集和一个客户集"></a>5.一个store类，里面有一个cd集和一个客户集</h2><p>成员变量如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Vip_ vv&#x3D;new Vip_();&#x2F;&#x2F;客户集</span><br><span class="line">private cd_ cc&#x3D;new cd_();&#x2F;&#x2F;cd集</span><br><span class="line">private int money;&#x2F;&#x2F;钱</span><br></pre></td></tr></table></figure>

<p>成员函数如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public store(int money_);&#x2F;&#x2F;构造函数初始资金</span><br><span class="line">public void add_vip();</span><br><span class="line">public void add_cd();&#x2F;&#x2F;添加cd</span><br><span class="line">public void sold();&#x2F;&#x2F;出售cd</span><br><span class="line">public void rent();&#x2F;&#x2F;出租cd</span><br><span class="line">public void back();&#x2F;&#x2F;归还cd</span><br><span class="line">public void show_cds();&#x2F;&#x2F;显示cd</span><br><span class="line">public void show_vips();&#x2F;&#x2F;显示会员</span><br><span class="line">public void show_money()&#x2F;&#x2F;显示钱钱</span><br></pre></td></tr></table></figure>

<h1 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h1><p>写的时候遇到一个小问题就是，我在别的类里调用了Scanner，无法cin.close()，因为Scanner指向的是同一个输入流，一个close掉之后别的也不能用了</p>
<h1 id="运行效果："><a href="#运行效果：" class="headerlink" title="运行效果："></a>运行效果：</h1><p>输入商店的初始资金，输入一些会员</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4km4mo1cdj206308edg7.jpg" alt=""></p>
<p>输入一些cd信息</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4km4moti7j205t0a3gm1.jpg" alt=""></p>
<p>输出当前所有的会员信息和cd信息</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4km4mp53gj20680cyt9f.jpg" alt=""></p>
<p>输入一些购买信息</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4km5aa996j20660ayt9b.jpg" alt=""></p>
<p>输入一些租借信息</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4km5aagbrj2078080wez.jpg" alt=""></p>
<p>输出更改后的会员信息和cd信息</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4km5aarbmj206b0dejs6.jpg" alt=""></p>
<p>输入归还信息</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4km5xhm0vj205t02maa1.jpg" alt=""></p>
<p>输出更改后的会员信息和cd信息</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4km7njolnj205z0dlq3q.jpg" alt=""></p>
<h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入商店初始资金：&quot;);</span><br><span class="line">        int a&#x3D;cin.nextInt();</span><br><span class="line">        store mystore&#x3D;new store(a);</span><br><span class="line">        mystore.add_vip();</span><br><span class="line">        mystore.add_vip();</span><br><span class="line">        mystore.add_vip();</span><br><span class="line">        mystore.add_cd();</span><br><span class="line">        mystore.add_cd();</span><br><span class="line">        mystore.add_cd();</span><br><span class="line">        mystore.show_vips();</span><br><span class="line">        mystore.show_cds();</span><br><span class="line">        mystore.sold();</span><br><span class="line">        mystore.sold();</span><br><span class="line">        mystore.sold();</span><br><span class="line">        mystore.rent();</span><br><span class="line">        mystore.rent();</span><br><span class="line">        mystore.rent();</span><br><span class="line">        mystore.show_cds();</span><br><span class="line">        mystore.show_vips();</span><br><span class="line">        mystore.back();</span><br><span class="line">        mystore.show_cds();</span><br><span class="line">        mystore.show_vips();</span><br><span class="line">        mystore.show_money();</span><br><span class="line">        cin.close();</span><br><span class="line">    &#125;</span><br><span class="line">    public static class Vip&#123;</span><br><span class="line">        private String name;&#x2F;&#x2F;姓名</span><br><span class="line">        private String phone;&#x2F;&#x2F;电话号码</span><br><span class="line">        private int score;&#x2F;&#x2F;会员积分</span><br><span class="line">        private String rent_cd[]&#x3D;new String[5];&#x2F;&#x2F;租借信息</span><br><span class="line">        public Vip(String name_,String phone_)&#123;</span><br><span class="line">            name&#x3D;name_;</span><br><span class="line">            phone&#x3D;phone_;</span><br><span class="line">            score&#x3D;0;</span><br><span class="line">        &#125;</span><br><span class="line">        public String get_name()&#123;&#x2F;&#x2F;获得会员名</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">        public String get_phone()&#123;&#x2F;&#x2F;获得会员手机号</span><br><span class="line">            return phone;</span><br><span class="line">        &#125;</span><br><span class="line">        public int get_score()&#123;&#x2F;&#x2F;获得会员积分</span><br><span class="line">            return score;</span><br><span class="line">        &#125;</span><br><span class="line">        public void set_score(int a)&#123;&#x2F;&#x2F;修改会员积分</span><br><span class="line">            score+&#x3D;a*6;</span><br><span class="line">        &#125;</span><br><span class="line">        public void show()&#123;&#x2F;&#x2F;显示会员信息</span><br><span class="line">            System.out.println(&quot;姓名：&quot;+name);</span><br><span class="line">            System.out.println(&quot;手机号码：&quot;+phone);</span><br><span class="line">            System.out.println(&quot;积分：&quot;+score);</span><br><span class="line">            System.out.println(&quot;租借记录：&quot;);</span><br><span class="line">            for(int i&#x3D;0;i&lt;5;i++)&#123;</span><br><span class="line">                if(rent_cd[i]!&#x3D;null)&#123;</span><br><span class="line">                    System.out.println(&quot;《&quot;+rent_cd[i]+&quot;》&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;---------------------------&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean add_rent(String s)&#123;&#x2F;&#x2F;添加租借记录</span><br><span class="line">            for(int i&#x3D;0;i&lt;5;i++)&#123;</span><br><span class="line">                if(rent_cd[i]&#x3D;&#x3D;null)&#123;</span><br><span class="line">                    rent_cd[i]&#x3D;s;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean delete_rent(String s)&#123;&#x2F;&#x2F;删除租借记录</span><br><span class="line">            for(int i&#x3D;0;i&lt;5;i++)&#123;</span><br><span class="line">                if(rent_cd[i].compareTo(s)&#x3D;&#x3D;0)&#123;</span><br><span class="line">                    rent_cd[i]&#x3D;null;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static class Vip_&#123;</span><br><span class="line">        private Vip vips[]&#x3D;new Vip[233];</span><br><span class="line">        public boolean add_vip(Vip v)&#123;&#x2F;&#x2F;添加会员</span><br><span class="line">            for(int i&#x3D;0;i&lt;vips.length;i++)&#123;</span><br><span class="line">                if(vips[i]&#x3D;&#x3D;null)&#123;</span><br><span class="line">                    vips[i]&#x3D;v;</span><br><span class="line">                    System.out.println(&quot;添加新会员成功！&quot;);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;添加新会员失败！&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean delete_vip(String phone_)&#123;&#x2F;&#x2F;删除会员</span><br><span class="line">            for(int i&#x3D;0;i&lt;vips.length;i++)&#123;</span><br><span class="line">                if(vips[i].get_phone().compareTo(phone_)&#x3D;&#x3D;0)&#123;</span><br><span class="line">                    vips[i]&#x3D;null;</span><br><span class="line">                    System.out.println(&quot;删除会员成功！&quot;);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;删除会员失败！&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        public void show_vip()&#123;&#x2F;&#x2F;显示会员信息</span><br><span class="line">            System.out.println(&quot;----------会员信息----------&quot;);</span><br><span class="line">            int j&#x3D;0;</span><br><span class="line">            for(int i&#x3D;0;i&lt; vips.length;i++)&#123;</span><br><span class="line">                if(vips[i]!&#x3D;null)&#123;</span><br><span class="line">                    vips[i].show();</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;共有&quot;+j+&quot;位会员&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        public void buy(String s,int money)&#123;&#x2F;&#x2F;某会员购买</span><br><span class="line">            for(int i&#x3D;0;i&lt;vips.length;i++)&#123;</span><br><span class="line">                if(vips[i]!&#x3D;null&amp;&amp;vips[i].get_phone().compareTo(s)&#x3D;&#x3D;0)&#123;</span><br><span class="line">                    vips[i].set_score(money);</span><br><span class="line">                    System.out.println(&quot;售出成功！&quot;);</span><br><span class="line">                    System.out.println(&quot;尊敬的&quot;+vips[i].get_name()+&quot;，您当前的积分为&quot;+vips[i].get_score());</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;抱歉，没有找到该会员，请检查号码是否正确&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        public void rent(String s,String c)&#123;&#x2F;&#x2F;某会员租借</span><br><span class="line">            for(int i&#x3D;0;i&lt;vips.length;i++)&#123;</span><br><span class="line">                if(vips[i]!&#x3D;null&amp;&amp;vips[i].get_phone().compareTo(s)&#x3D;&#x3D;0)&#123;</span><br><span class="line">                    if(vips[i].add_rent(c)&#x3D;&#x3D;true)&#123;</span><br><span class="line">                        System.out.println(&quot;租借成功！&quot;);</span><br><span class="line">                        System.out.println(&quot;尊敬的&quot;+vips[i].get_name()+&quot;，请记得在一个月内归还哦&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else System.out.println(&quot;抱歉，您当前的租借数已达五张，请尽快归还后再租借&quot;);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;抱歉，没有找到该会员，请检查号码是否正确&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        public void back(String s,String c)&#123;&#x2F;&#x2F;某会员归还</span><br><span class="line">            for(int i&#x3D;0;i&lt;vips.length;i++)&#123;</span><br><span class="line">                if(vips[i]!&#x3D;null&amp;&amp;vips[i].get_phone().compareTo(s)&#x3D;&#x3D;0)&#123;</span><br><span class="line">                    if(vips[i].delete_rent(c)&#x3D;&#x3D;true)</span><br><span class="line">                        System.out.println(&quot;尊敬的&quot;+vips[i].get_name()+&quot;，归还成功&quot;);</span><br><span class="line">                    else System.out.println(&quot;抱歉，没有找到租借信息，请检查CD名是否有误&quot;);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;抱歉，没有找到该会员，请检查号码是否正确&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static class cd&#123;</span><br><span class="line">        private String name;&#x2F;&#x2F;cd名</span><br><span class="line">        private int num;&#x2F;&#x2F;cd数量</span><br><span class="line">        private int price;&#x2F;&#x2F;cd单价</span><br><span class="line">        public cd(String name_,int price_,int num_)&#123;</span><br><span class="line">            name&#x3D;name_;</span><br><span class="line">            price&#x3D;price_;</span><br><span class="line">            num&#x3D;num_;</span><br><span class="line">        &#125;</span><br><span class="line">        public void show()&#123;&#x2F;&#x2F;显示cd信息</span><br><span class="line">            System.out.println(&quot;CD名：《&quot;+name+&quot;》&quot;);</span><br><span class="line">            System.out.println(&quot;价格：&quot;+price);</span><br><span class="line">            System.out.println(&quot;数量：&quot;+num);</span><br><span class="line">            System.out.println(&quot;---------------------------&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        public int get_num()&#123;&#x2F;&#x2F;获取某cd数量</span><br><span class="line">            return num;</span><br><span class="line">        &#125;</span><br><span class="line">        public void set_num(int num_)&#123;&#x2F;&#x2F;修改某cd数量</span><br><span class="line">            num &#x3D; num_;</span><br><span class="line">        &#125;</span><br><span class="line">        public String get_name()&#123;&#x2F;&#x2F;获取cd名</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">        public int get_price()&#123;&#x2F;&#x2F;获取cd单价</span><br><span class="line">            return price;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static class cd_&#123;</span><br><span class="line">        private cd cds[]&#x3D;new cd[2333];</span><br><span class="line">        public boolean add_cd(cd c)&#123;&#x2F;&#x2F;添加cd</span><br><span class="line">            for(int i&#x3D;0;i&lt;cds.length;i++)&#123;</span><br><span class="line">                if(cds[i]&#x3D;&#x3D;null)&#123;</span><br><span class="line">                    cds[i]&#x3D;c;</span><br><span class="line">                    System.out.println(&quot;添加新CD成功！&quot;);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;添加新CD失败！&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean delete_cd(String name_)&#123;&#x2F;&#x2F;删除cd</span><br><span class="line">            for(int i&#x3D;0;i&lt;cds.length;i++)&#123;</span><br><span class="line">                if(cds[i].get_name().compareTo(name_)&#x3D;&#x3D;0)&#123;</span><br><span class="line">                    cds[i]&#x3D;null;</span><br><span class="line">                    System.out.println(&quot;删除CD成功！&quot;);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;删除CD失败！&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        public void show_cd()&#123;&#x2F;&#x2F;显示所有cd信息</span><br><span class="line">            System.out.println(&quot;----------CD信息----------&quot;);</span><br><span class="line">            int j&#x3D;0;</span><br><span class="line">            for(int i&#x3D;0;i&lt;cds.length;i++)&#123;</span><br><span class="line">                if(cds[i]!&#x3D;null)&#123;</span><br><span class="line">                    cds[i].show();</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;共有&quot;+j+&quot;张CD&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        public int sold_cd(String s,int a)&#123;&#x2F;&#x2F;卖出cd</span><br><span class="line">            if(a&#x3D;&#x3D;0)&#123;</span><br><span class="line">                System.out.println(&quot;输入张数为0？？&quot;);</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            int money&#x3D;0;</span><br><span class="line">            for(int i&#x3D;0;i&lt;cds.length;i++)&#123;</span><br><span class="line">                if(cds[i]!&#x3D;null&amp;&amp;cds[i].get_name().compareTo(s)&#x3D;&#x3D;0)&#123;</span><br><span class="line">                    int tmp&#x3D;cds[i].get_num()-a;</span><br><span class="line">                    if(tmp&gt;&#x3D;0)&#123;</span><br><span class="line">                        money&#x3D;cds[i].get_price()*a;</span><br><span class="line">                        cds[i].set_num(tmp);</span><br><span class="line">                        &#x2F;&#x2F;System.out.println(&quot;售出成功！&quot;);</span><br><span class="line">                        return money;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else&#123;</span><br><span class="line">                        System.out.println(&quot;库存不足，售出失败&quot;);</span><br><span class="line">                        return 0;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;库存中没有该CD，售出失败&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean rent_cd(String s)&#123;&#x2F;&#x2F;租借cd</span><br><span class="line">            for(int i&#x3D;0;i&lt;cds.length;i++)&#123;</span><br><span class="line">                if(cds[i]!&#x3D;null&amp;&amp;cds[i].get_name().compareTo(s)&#x3D;&#x3D;0)&#123;</span><br><span class="line">                    int tmp&#x3D;cds[i].get_num();</span><br><span class="line">                    if(tmp&gt;0)&#123;</span><br><span class="line">                        cds[i].set_num(tmp-1);</span><br><span class="line">                        &#x2F;&#x2F;System.out.println(&quot;出租成功！&quot;);</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else&#123;</span><br><span class="line">                        System.out.println(&quot;库存不足，出租失败&quot;);</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;没有找到该CD，请检查CD名是否有误&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean back_cd(String s)&#123;&#x2F;&#x2F;归还cd</span><br><span class="line">            for(int i&#x3D;0;i&lt;cds.length;i++)&#123;</span><br><span class="line">                if(cds[i]!&#x3D;null&amp;&amp;cds[i].get_name().compareTo(s)&#x3D;&#x3D;0)&#123;</span><br><span class="line">                    int tmp&#x3D;cds[i].get_num()+1;</span><br><span class="line">                    cds[i].set_num(tmp);</span><br><span class="line">                    &#x2F;&#x2F;System.out.println(&quot;归还成功！&quot;);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;库中没有记录该CD，请检查CD名是否有误&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static class store&#123;</span><br><span class="line">        Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">        private Vip_ vv&#x3D;new Vip_();&#x2F;&#x2F;客户集</span><br><span class="line">        private cd_ cc&#x3D;new cd_();&#x2F;&#x2F;cd集</span><br><span class="line">        private int money;&#x2F;&#x2F;钱</span><br><span class="line">        public store(int money_)&#123;</span><br><span class="line">            money&#x3D;money_;</span><br><span class="line">        &#125;</span><br><span class="line">        public void add_vip()&#123;</span><br><span class="line">            System.out.println(&quot;----------添加会员----------&quot;);</span><br><span class="line">            Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">            String name_,phone_;</span><br><span class="line">            System.out.println(&quot;请输入新会员姓名：&quot;);</span><br><span class="line">            name_&#x3D;cin.nextLine();</span><br><span class="line">            System.out.println(&quot;请输入新会员手机号：&quot;);</span><br><span class="line">            phone_&#x3D;cin.nextLine();</span><br><span class="line">            Vip newv&#x3D;new Vip(name_,phone_);</span><br><span class="line">            vv.add_vip(newv);</span><br><span class="line">        &#125;</span><br><span class="line">        public void add_cd()&#123;</span><br><span class="line">            System.out.println(&quot;----------添加CD----------&quot;);</span><br><span class="line">            Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">            String name_;</span><br><span class="line">            int price_,num_;</span><br><span class="line">            System.out.println(&quot;请输入新CD名称：&quot;);</span><br><span class="line">            name_&#x3D;cin.nextLine();</span><br><span class="line">            System.out.println(&quot;请输入新CD单价：&quot;);</span><br><span class="line">            price_&#x3D;cin.nextInt();</span><br><span class="line">            System.out.println(&quot;请输入新CD数量：&quot;);</span><br><span class="line">            num_&#x3D;cin.nextInt();</span><br><span class="line">            cd newcd&#x3D;new cd(name_,price_,num_);</span><br><span class="line">            cc.add_cd(newcd);</span><br><span class="line">        &#125;</span><br><span class="line">        public void sold()&#123;</span><br><span class="line">            System.out.println(&quot;----------购买CD----------&quot;);</span><br><span class="line">            Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">            String phone_v,name_c;</span><br><span class="line">            int num_;</span><br><span class="line">            System.out.println(&quot;请输入会员手机号码：&quot;);</span><br><span class="line">            phone_v&#x3D;cin.nextLine();</span><br><span class="line">            System.out.println(&quot;请输入要购买的CD名称：&quot;);</span><br><span class="line">            name_c&#x3D;cin.nextLine();</span><br><span class="line">            System.out.println(&quot;请输入购买数量：&quot;);</span><br><span class="line">            num_&#x3D;cin.nextInt();</span><br><span class="line">            int tmp&#x3D;cc.sold_cd(name_c,num_);</span><br><span class="line">            if(tmp!&#x3D;0)&#123;</span><br><span class="line">                money+&#x3D;tmp;</span><br><span class="line">                vv.buy(phone_v,tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public void rent()&#123;</span><br><span class="line">            System.out.println(&quot;----------租借CD----------&quot;);</span><br><span class="line">            Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">            String phone_v,name_c;</span><br><span class="line">            System.out.println(&quot;请输入会员手机号码：&quot;);</span><br><span class="line">            phone_v&#x3D;cin.nextLine();</span><br><span class="line">            System.out.println(&quot;请输入要租借的CD名称：&quot;);</span><br><span class="line">            name_c&#x3D;cin.nextLine();</span><br><span class="line">            boolean tmp&#x3D;cc.rent_cd(name_c);</span><br><span class="line">            if(tmp)&#123;</span><br><span class="line">                vv.rent(phone_v,name_c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public void back()&#123;</span><br><span class="line">            System.out.println(&quot;----------归还CD----------&quot;);</span><br><span class="line">            Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">            String phone_v,name_c;</span><br><span class="line">            System.out.println(&quot;请输入会员手机号码：&quot;);</span><br><span class="line">            phone_v&#x3D;cin.nextLine();</span><br><span class="line">            System.out.println(&quot;请输入要归还的CD名称：&quot;);</span><br><span class="line">            name_c&#x3D;cin.nextLine();</span><br><span class="line">            boolean tmp&#x3D;cc.back_cd(name_c);</span><br><span class="line">            if(tmp)&#123;</span><br><span class="line">                vv.back(phone_v,name_c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public void show_cds()&#123;</span><br><span class="line">            cc.show_cd();</span><br><span class="line">        &#125;</span><br><span class="line">        public void show_vips()&#123;</span><br><span class="line">            vv.show_vip();</span><br><span class="line">        &#125;</span><br><span class="line">        public void show_money()&#123;</span><br><span class="line">            System.out.println(&quot;商店当前的资金为&quot;+money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>一些作业</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 519 Div.2（A-F）</title>
    <url>/2c002055/</url>
    <content><![CDATA[<p>相当惨的一场。。但是题还是要补的。。不过真的拖了好久啊。。好像是。。一个星期多前的了ORZ 又可以自己钻进辣鸡箱了（；＿；）</p>
<p>终于补完了可以去补java作业了，要不是要体测。。不然就可以修仙仙了</p>
<a id="more"></a>

<hr>
<h1 id="A-Elections（贪心）"><a href="#A-Elections（贪心）" class="headerlink" title="A. Elections（贪心）"></a>A. Elections（贪心）</h1><p><a href="http://codeforces.com/contest/1043/problem/A" target="_blank" rel="noopener">http://codeforces.com/contest/1043/problem/A</a></p>
<p>题意：n个人，每个人都有k票，投给两个人，现在已知这n个人每个人会投给对手a[i]票，其余k-a[i]票投给自己，求最小的k使得自己的票数比对方多</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int v[355],f[45][45][45][45];</span><br><span class="line">int num[5]&#x3D;&#123;0&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,maxx&#x3D;1,c,sum&#x3D;0;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">    	scanf(&quot;%d&quot;,&amp;c);</span><br><span class="line">    	maxx&#x3D;max(maxx,c);</span><br><span class="line">    	sum+&#x3D;c;</span><br><span class="line">    &#125;</span><br><span class="line">    while(n*maxx-sum&lt;&#x3D;sum)maxx++;</span><br><span class="line">    printf(&quot;%d\n&quot;,maxx);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-Lost-Array（循环结）"><a href="#B-Lost-Array（循环结）" class="headerlink" title="B. Lost Array（循环结）"></a>B. Lost Array（循环结）</h1><p><a href="http://codeforces.com/contest/1043/problem/B" target="_blank" rel="noopener">http://codeforces.com/contest/1043/problem/B</a></p>
<p>题意：已知一个数组x[i]可以由下面的变换得到长为n的数组a[i]，<br><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmajjbfxj206y00pa9w.jpg" alt=""><br>现在反过来，先给一个长为n的数组a[i]，求数组x[i]可能的长度，来得到a[i]</p>
<p>不知道为什么不会，就是不会，卡了一个小时乱猜了个结论过了，纸上模拟一下猜应该就是找循环结吧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int a[1005],num[1005];</span><br><span class="line">vector&lt;int&gt;v;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    a[0]&#x3D;0;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">    	scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    	num[i-1]&#x3D;a[i]-a[i-1];</span><br><span class="line">    &#125;</span><br><span class="line">    bool flag;</span><br><span class="line">    v.clear();</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">    	flag&#x3D;true;</span><br><span class="line">    	for(int j&#x3D;0;j&lt;i;j++)&#123;</span><br><span class="line">    		if(!flag)break;</span><br><span class="line">    		int k&#x3D;i;</span><br><span class="line">    		for(int k&#x3D;j;k&lt;n;k+&#x3D;i)&#123;</span><br><span class="line">    			if(num[j]!&#x3D;num[k])&#123;</span><br><span class="line">    				flag&#x3D;false;</span><br><span class="line">    				break;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	if(flag)v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    int ans&#x3D;v.size();</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    for(int i&#x3D;0;i&lt;ans-1;i++)</span><br><span class="line">    	printf(&quot;%d &quot;,v[i]);</span><br><span class="line">    printf(&quot;%d\n&quot;,v[ans-1]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-Smallest-Word（字符串）"><a href="#C-Smallest-Word（字符串）" class="headerlink" title="C. Smallest Word（字符串）"></a>C. Smallest Word（字符串）</h1><p><a href="http://codeforces.com/contest/1043/problem/C" target="_blank" rel="noopener">http://codeforces.com/contest/1043/problem/C</a></p>
<p>题意：给一个由’a’’b’组成的字符串，从前往后可以翻转前缀，要求最后把字符串变为最小的字典序即aa..ab..bb的形式，问需要翻转的前缀是哪些</p>
<p>模拟一下得结论，遇到ab分界就翻转，注意要特殊处理一下最后一个，如果最后一个是a的话就翻，b不翻</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line">int ans[1005];</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    int len&#x3D;s.length();</span><br><span class="line">    for(int i&#x3D;0;i&lt;len-1;i++)</span><br><span class="line">    	if(s[i]!&#x3D;s[i+1])ans[i]&#x3D;1;</span><br><span class="line">    	else ans[i]&#x3D;0;</span><br><span class="line">    if(s[len-1]&#x3D;&#x3D;&#39;a&#39;)ans[len-1]&#x3D;1;</span><br><span class="line">    else ans[len-1]&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;len-1;i++)printf(&quot;%d &quot;,ans[i]);</span><br><span class="line">    printf(&quot;%d\n&quot;,ans[len-1]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-Mysterious-Crime（公共子段）"><a href="#D-Mysterious-Crime（公共子段）" class="headerlink" title="D. Mysterious Crime（公共子段）"></a>D. Mysterious Crime（公共子段）</h1><p><a href="http://codeforces.com/contest/1043/problem/D" target="_blank" rel="noopener">http://codeforces.com/contest/1043/problem/D</a></p>
<p>题意：给m个长度均为n的排列，求共有多少个公共子段，n范围1e5，m范围10，保证每个排列中1～n各出现一次    </p>
<p>首先肯定要找到几个最大公共子段，这里最大的定义是：合法的所有子段都是这些段的子段，那么对于任意一个长度为l的最大子段来说，长度为1的子段有l个，为2的有(l-1)个…为l的有一个，它所贡献的方法数即为<code>1+2+...+l=l*(l+1)/2</code></p>
<p>len[i]表示以i这个数开头的最长的公共子段</p>
<p>然后从1～n各出现一次这个性质入手，在输入的时候直接记录每个数字在某一行的位子，即pos[c][i]=j表示c这个数在第i行出现在第j列，这么记就非常方便后续比较</p>
<p>a[i]表示第一行第i个位置的数，然后就是枚举第一行，从i=1开始，j从i+1开始，如果a[i]和a[j]所对应的数在下面n-1行的距离都和第一行一样，那么j++，继续扩展最长子段，直到出现一个不相同时，就是分出了其中一个最长子段了，那么i=j，继续找下一个最长子段</p>
<p>最后，这个题爆int了要开LL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;100005;</span><br><span class="line">const int M&#x3D;15;</span><br><span class="line">int n,m;</span><br><span class="line">LL pos[N][M],a[N],len[N];</span><br><span class="line">bool ok(int x,int y)&#123;</span><br><span class="line">	int tmp&#x3D;pos[a[y]][1]-pos[a[x]][1];</span><br><span class="line">	for(int i&#x3D;2;i&lt;&#x3D;m;i++)</span><br><span class="line">		if(pos[a[y]][i]-pos[a[x]][i]!&#x3D;tmp)return false;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int c;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">		for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;c);</span><br><span class="line">			pos[c][i]&#x3D;j;</span><br><span class="line">			if(i&#x3D;&#x3D;1)a[j]&#x3D;c;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	memset(len,0,sizeof(len));</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;)&#123;</span><br><span class="line">		len[i]++;</span><br><span class="line">		int j;</span><br><span class="line">		for(j&#x3D;i+1;j&lt;&#x3D;n;j++)&#123;</span><br><span class="line">			if(ok(i,j))len[i]++;</span><br><span class="line">			else break;</span><br><span class="line">		&#125;</span><br><span class="line">		i&#x3D;j;</span><br><span class="line">	&#125;</span><br><span class="line">	LL ans&#x3D;0;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">		if(len[i])</span><br><span class="line">			ans+&#x3D;len[i]*(len[i]+1)&#x2F;2;</span><br><span class="line">	printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E-Train-Hard-Win-Easy（贪心，前缀和）"><a href="#E-Train-Hard-Win-Easy（贪心，前缀和）" class="headerlink" title="E. Train Hard, Win Easy（贪心，前缀和）"></a>E. Train Hard, Win Easy（贪心，前缀和）</h1><p><a href="http://codeforces.com/contest/1043/problem/E" target="_blank" rel="noopener">http://codeforces.com/contest/1043/problem/E</a></p>
<p>题意：共n个人去打比赛，第i个人写第一个题会得xi分，写第二个题得yi分，任意两个人都要一起打一场比赛，一人写一个题，不过这里还有m对人不可以一起打比赛，求最后每个人的总得分最少是多少</p>
<p>如果当前没有限制，那么对于(i,j)两个人来说答案是<code>min(xi+yj,xj+yi)</code>，即i可以做第一题的条件是<code>xi+yj&lt;=xj+yi</code></p>
<p>所以先依据这个条件排个序，对于排序后的第i个人来说，如果它和前i-1个人里的其中一个人组队，他就做第二个题，如果和后面n-i人里的其中一个人组队，他就做第一个题</p>
<p>然后算一下排序后xi和yi的前缀和，那么o(1)就可以算出第i个人对总得分的贡献，最后对于那m对不可以一起打比赛的人来说，o(m)直接减了即可</p>
<p>由于输出每个人的得分贡献要求按照输入的顺序，所以搞个id记一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;3e5+5;</span><br><span class="line">struct ss&#123;</span><br><span class="line">	LL x,y,id;</span><br><span class="line">&#125;a[N],b[N];</span><br><span class="line">int n,m;</span><br><span class="line">LL s1[N],s2[N],ans[N];</span><br><span class="line">bool cmp(ss s1,ss s2)&#123;</span><br><span class="line">	return s1.x+s2.y&lt;s1.y+s2.x;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		scanf(&quot;%lld%lld&quot;,&amp;a[i].x,&amp;a[i].y);</span><br><span class="line">		a[i].id&#x3D;i;</span><br><span class="line">		b[i]&#x3D;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sort(a+1,a+n+1,cmp);</span><br><span class="line">	s1[0]&#x3D;s2[0]&#x3D;0;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		s1[i]&#x3D;s1[i-1]+a[i].x;</span><br><span class="line">		s2[i]&#x3D;s2[i-1]+a[i].y;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">		ans[a[i].id]&#x3D;(i-1)*a[i].y+s1[i-1]+(n-i)*a[i].x+s2[n]-s2[i];</span><br><span class="line">	int u,v;</span><br><span class="line">	for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">		int tmp&#x3D;min(b[u].x+b[v].y,b[u].y+b[v].x);</span><br><span class="line">		ans[u]-&#x3D;tmp;</span><br><span class="line">		ans[v]-&#x3D;tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;1;i&lt;n;i++)printf(&quot;%lld &quot;,ans[i]);</span><br><span class="line">	printf(&quot;%lld\n&quot;,ans[n]);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="F-Make-It-One（dp，容斥，组合数）"><a href="#F-Make-It-One（dp，容斥，组合数）" class="headerlink" title="F. Make It One（dp，容斥，组合数）"></a>F. Make It One（dp，容斥，组合数）</h1><p><a href="http://codeforces.com/contest/1043/problem/F" target="_blank" rel="noopener">http://codeforces.com/contest/1043/problem/F</a></p>
<p>题意：给n个数，选最少的数，使他们的gcd=1，求这个最小子集的大小</p>
<p>看了好久然后才。。突然看懂题解。。另一种莫比乌斯反演的解法。。我还是不会。。</p>
<p><code>2*3*5*7*11*13*17=510510&gt;3e5</code>，所以一个子集里的数字个数一定小于等于7</p>
<p>然后看样例感受一下思路，<code>10 6 15</code>这三个数，<code>2*5</code>和<code>2*3</code>可以干掉3和5，然后2和<code>3*5</code>gcd=1满足条件，也就是说每次两个数合并可以干掉一些不同的质因子，最后要使所有质因子都被干掉</p>
<p>用dp[i][j]表示集合大小为i，gcd为j的集合的方案数，最后要求的答案是<code>dp[i][1]&gt;0</code>的最小值</p>
<p>状态转移方程如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmb1lavnj20ie0380su.jpg" alt=""></p>
<p>num[j]表示集合中能被j整除的数的个数，处理只要o(n^2)扫一遍就可以累加得到，C(num[j],i)就是在这些数中取i个，那么这些数gcd肯定是kj</p>
<p>要使这些数的gcd是j，就要利用容斥的思想减去其他2j,3j,…kj的部分，也就是<code>dp[i][k] (j|k)</code></p>
<p>然后优化一下空间变成一维，因为之前已经证明一个子集里的数字个数一定小于等于7，所以i从1～7枚举，如果当前i对应的的dp[1]&gt;0，直接输出i即可</p>
<p>wa12了好几发。。最后状态转移的时候加了个%p然后过了。。太真实了。。但是。。为什么呢。。。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;3e5;</span><br><span class="line">const int p&#x3D;1e9+7;</span><br><span class="line">LL dp[N+5];</span><br><span class="line">int num[N+5];</span><br><span class="line">LL qpow(LL a,LL b)&#123;</span><br><span class="line">    LL ans&#x3D;1;</span><br><span class="line">    a%&#x3D;p;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            ans&#x3D;ans*a%p;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        b&gt;&gt;&#x3D;1;</span><br><span class="line">        a&#x3D;a*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">LL C(LL n,LL m)&#123;</span><br><span class="line">    if(m&gt;n)return 0;</span><br><span class="line">    LL ans,a&#x3D;1,b&#x3D;1;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">        a&#x3D;(a*(n+i-m)%p)%p;</span><br><span class="line">        b&#x3D;(b*i%p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    ans&#x3D;(a*qpow(b,p-2)%p)%p;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,c;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	memset(num,0,sizeof(num));</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;c);</span><br><span class="line">		num[c]++;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;N;i++)</span><br><span class="line">		for(int j&#x3D;2*i;j&lt;&#x3D;N;j+&#x3D;i)</span><br><span class="line">			num[i]+&#x3D;num[j];</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;7;i++)&#123;</span><br><span class="line">		for(int j&#x3D;N;j&gt;&#x3D;1;j--)&#123;</span><br><span class="line">			dp[j]&#x3D;C(num[j],i);</span><br><span class="line">			for(LL k&#x3D;2*j;k&lt;&#x3D;N;k+&#x3D;j)</span><br><span class="line">				dp[j]&#x3D;(dp[j]-dp[k]+p)%p;</span><br><span class="line">		&#125;</span><br><span class="line">		if(dp[1]&gt;0)&#123;</span><br><span class="line">			printf(&quot;%d\n&quot;,i);</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	puts(&quot;-1&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="G-Speckled-Band"><a href="#G-Speckled-Band" class="headerlink" title="G. Speckled Band"></a>G. Speckled Band</h1><p><a href="http://codeforces.com/contest/1043/problem/G" target="_blank" rel="noopener">http://codeforces.com/contest/1043/problem/G</a></p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>dp</tag>
        <tag>cf</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构第四次作业（delete浅析，约瑟夫环-链表法和公式法，栈Stack）</title>
    <url>/96c4a6fd/</url>
    <content><![CDATA[<p>说好的以前yjf数据结构一个学期才五个作业呢。。。。。。。难道是因为换了助教!?(･-･;?不过好歹这次是周一布置周六交了</p>
<hr>
<h1 id="delete浅析："><a href="#delete浅析：" class="headerlink" title="delete浅析："></a>delete浅析：</h1><p>首先一定要记录一下delete，在第三次被析构函数各种报错各种野指针之后。。我终于= =痛定思痛的去找了找有关delete的东西：（虽然这次出现野指针的问题是因为我delete first之后没有把last指向NULL。。）</p>
<p>delete到底删了什么？为什么delete完指针p指向的地址后，p-&gt;data还可以调用？</p>
<p>这个原理就和把磁盘中的文件删了一样，删文件的时候一下子就删好了，但是事实上，并没有彻底粉碎文件中的数据，操作系统只是把文件所在的区域标记为空闲而已，东西还在里面，所以就有了数据恢复一说，只有等到下次在这个区域写入了新的东西，才算是真正把之前的文件删除</p>
<p>delete也只是把指针指向的某个地址标记上空闲，而一方面指针还是指向那个区域，另一方面那个地址的数据还是保留着（如下图）；唯一的不同是，在后续的进程中，本来向系统申请内存的时候绝不会考虑那个地址，但是现在可以考虑了</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmbohqglj209e03rwer.jpg" alt=""></p>
<p>当然，上面只是sublime下（g++ -std=c++11）测试的结果，vs下的结果可能不同，因为delete之后，网上说vs环境下操作系统会阻止程序访问这个地址，因为这个地址已经用delete归还给操作系统了，这时候的p就是野指针，需要p=NULL操作一番</p>
<hr>
<h1 id="作业一："><a href="#作业一：" class="headerlink" title="作业一："></a>作业一：</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>Josephus问题，n个人围坐成一圈，按顺序编号为1－n，确定一个整数m，从1号开始数数，每数到第m个人出列，剩下的人从下一个人重新开始数，直至只剩下一个人为止</p>
<p>编写程序，对任意输入的n和m，求出最后剩下的人的编号。要求利用线性表保存这n个人，分别用公式化和链表两种描述方法实现。<br>输入：input.txt，两个整数n（3－100），m（1－m）<br>输出：若输入合法，按出列顺序输出人的编号，否则输出“WRONG”。编号之间用一个空格间隔，最后一个编号后不能有空格。两种实现方法各输出一次，用回车间隔，最后输出一个回车。如上述例子的输出应为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 2 8 7 1 4 6 3</span><br><span class="line">5 2 8 7 1 4 6 3</span><br></pre></td></tr></table></figure>

<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="1-链表法"><a href="#1-链表法" class="headerlink" title="1.链表法"></a>1.链表法</h3><p>给单链表加个尾节点last，然后<code>last-&gt;next=first</code>，就可以成环了</p>
<p>然后就移指针啊，然后把指针移到的位置删除，注意下细节就没啥了</p>
<h3 id="2-公式法"><a href="#2-公式法" class="headerlink" title="2.公式法"></a>2.公式法</h3><p><a href="https://allenoris.github.io/2018/11/05/%E3%80%90%E9%80%92%E6%8E%A8%E3%80%91%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/" target="_blank" rel="noopener">AllenOris大佬的博客里有有关约瑟夫环公式的更详细的推导，他那个是从0开始编号的</a></p>
<p>用递推的思路求一下n个人报到m出列，第k个人的编号</p>
<blockquote>
<p>样例n=8,m=5</p>
<p>step1:去4</p>
<p>1 2 3 4 5 6 7 8（旧）</p>
<p>1 2 3 4 6 7 8 </p>
<p>从下一个要报数的人可以映射成一个新的约瑟夫环，即</p>
<p>4 5 6 7 1 2 3（新）</p>
</blockquote>
<p>在旧环中有i人，编号为x的人在新环中编号为y，则有对应关系，y=(x-m+i)%i，那么x=(y+m)%i，即得递推式：f[i]=(f[i-1]+m)%i</p>
<p>那么已知有i-1人时最先出局的是编号为(m-1)%(i-1)+1的人，记为ans，所以可以回推得到此人在i环中的编号是(ans+m)%i，这个人也就是i人环第二个出局的人，一直递推就可以得到任意我们想要的状态</p>
<p>那么n个人报m出局第k个出局的人，相当于求（n-k+1）个人报m出局第一个出局的人，记k’=n-k+1，则k’对应的答案是(m-1)%k’+1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int k&#x3D;n-k+1;</span><br><span class="line">int ans&#x3D;(m-1)%k+1;</span><br><span class="line">	for (int i&#x3D;k+1;i&lt;&#x3D;n;i++)</span><br><span class="line">		ans&#x3D;(ans+m-1)%i+1;</span><br></pre></td></tr></table></figure>

<p>得到递推式后，对于每一个k直接搞个求解，然后把对应编号的节点delete掉即可</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int nn,mm;</span><br><span class="line">struct Node&#123;</span><br><span class="line">	public:</span><br><span class="line">		int id;</span><br><span class="line">		Node *next;</span><br><span class="line">&#125;;</span><br><span class="line">class LinkedList&#123;</span><br><span class="line">	public:</span><br><span class="line">		LinkedList(int n);</span><br><span class="line">		~LinkedList();</span><br><span class="line">		void show();</span><br><span class="line">		int link_Josephus(int n,int m);</span><br><span class="line">		int fun_Josephus(int n,int m);</span><br><span class="line">		int getf(int n,int k,int m);</span><br><span class="line">		void delete_node(int x);</span><br><span class="line">	private:</span><br><span class="line">		Node *first,*last;</span><br><span class="line">&#125;;</span><br><span class="line">LinkedList::LinkedList(int n)&#123;</span><br><span class="line">	Node *tmp&#x3D;new Node;</span><br><span class="line">	tmp-&gt;id&#x3D;1;</span><br><span class="line">	first&#x3D;last&#x3D;tmp;</span><br><span class="line">	for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">		Node *p&#x3D;new Node;</span><br><span class="line">		p-&gt;id&#x3D;i+1;</span><br><span class="line">		last-&gt;next&#x3D;p;</span><br><span class="line">		last&#x3D;last-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	last-&gt;next&#x3D;first;</span><br><span class="line">&#125;</span><br><span class="line">LinkedList::~LinkedList()&#123;</span><br><span class="line">	Node *p&#x3D;first;</span><br><span class="line">	while(first!&#x3D;last)&#123;</span><br><span class="line">		if(p!&#x3D;last)p&#x3D;first-&gt;next;</span><br><span class="line">		delete first;</span><br><span class="line">		first&#x3D;p;</span><br><span class="line">	&#125;</span><br><span class="line">	delete first;</span><br><span class="line">	first&#x3D;last&#x3D;NULL;</span><br><span class="line">&#125;</span><br><span class="line">void LinkedList::show()&#123;</span><br><span class="line">	Node *cur;</span><br><span class="line">	for(cur&#x3D;first;cur!&#x3D;last;cur&#x3D;cur-&gt;next)</span><br><span class="line">		cout&lt;&lt;cur-&gt;id&lt;&lt;&quot; &quot;;</span><br><span class="line">	cout&lt;&lt;cur-&gt;id&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int LinkedList::link_Josephus(int n,int m)&#123;</span><br><span class="line">	Node *p;</span><br><span class="line">	p&#x3D;first;</span><br><span class="line">	for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">		int j&#x3D;1;</span><br><span class="line">		while(j!&#x3D;m)&#123;</span><br><span class="line">			p&#x3D;p-&gt;next;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		Node *cur;</span><br><span class="line">		for(cur&#x3D;first;cur-&gt;next!&#x3D;p;cur&#x3D;cur-&gt;next);</span><br><span class="line">		cur-&gt;next&#x3D;p-&gt;next;</span><br><span class="line">		cur&#x3D;p;</span><br><span class="line">		p&#x3D;p-&gt;next;</span><br><span class="line">		cout&lt;&lt;cur-&gt;id&lt;&lt;&quot; &quot;;</span><br><span class="line">		if(cur&#x3D;&#x3D;first)first&#x3D;first-&gt;next;</span><br><span class="line">		delete cur;</span><br><span class="line">		cur&#x3D;NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;first-&gt;id&lt;&lt;endl;</span><br><span class="line">	last&#x3D;first;</span><br><span class="line">	return (first-&gt;id);</span><br><span class="line">&#125;</span><br><span class="line">int LinkedList::fun_Josephus(int n,int m)&#123;</span><br><span class="line">	Node *p;</span><br><span class="line">	for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">		int ans&#x3D;getf(n,m,i);</span><br><span class="line">		&#x2F;&#x2F;cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">		for(p&#x3D;first;(p-&gt;id)!&#x3D;ans;p&#x3D;p-&gt;next);</span><br><span class="line">		Node *cur;</span><br><span class="line">		for(cur&#x3D;first;cur-&gt;next!&#x3D;p;cur&#x3D;cur-&gt;next);</span><br><span class="line">		cur-&gt;next&#x3D;p-&gt;next;</span><br><span class="line">		cur&#x3D;p;</span><br><span class="line">		p&#x3D;p-&gt;next;</span><br><span class="line">		cout&lt;&lt;cur-&gt;id&lt;&lt;&quot; &quot;;</span><br><span class="line">		if(cur&#x3D;&#x3D;first)first&#x3D;first-&gt;next;</span><br><span class="line">		delete cur;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;first-&gt;id&lt;&lt;endl;</span><br><span class="line">	last&#x3D;first;</span><br><span class="line">	return first-&gt;id;</span><br><span class="line">&#125;</span><br><span class="line">int LinkedList::getf(int n,int m,int k)&#123;</span><br><span class="line">	k&#x3D;n-k+1;</span><br><span class="line">	int ans&#x3D;(m-1)%k+1;</span><br><span class="line">	for (int i&#x3D;k+1;i&lt;&#x3D;n;i++)</span><br><span class="line">		ans&#x3D;(ans+m-1)%i+1;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;nn,&amp;mm);</span><br><span class="line">    LinkedList l1(nn),l2(nn);</span><br><span class="line">    &#x2F;&#x2F;l1.show();</span><br><span class="line">    int ans1&#x3D;l1.link_Josephus(nn,mm);</span><br><span class="line">    int ans2&#x3D;l2.fun_Josephus(nn,mm);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行效果："><a href="#运行效果：" class="headerlink" title="运行效果："></a>运行效果：</h2><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmboj3a7j20bq05n74t.jpg" alt=""></p>
<h1 id="作业二："><a href="#作业二：" class="headerlink" title="作业二："></a>作业二：</h1><h2 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h2><p>利用教材中的Stack类，为其设计外部函数（非成员函数）实现下面<code>delete_all</code>功能，必要时可以使用临时的Stack对象。编写主函数测试<code>delete_all</code>函数，栈元素设定为字符类型即可。<br><code>template &lt;class T&gt; void delete_all(Stack&lt;T&gt; &amp;s, const T &amp;x)</code>——删除栈s中所有等于x的数据项，保持其他数据项顺序不变。<br>输入：input.txt，其第一个字符为x，其后按栈底到栈顶的顺序依次给出栈中字符，字符间用空格、回车或制表符间隔，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">b a t a a e c</span><br></pre></td></tr></table></figure>
<p>表示栈底到栈顶内容为b a t a a e c，要删除内容为a<br>输出：删除后栈中字符内容，从栈顶到栈底的顺序即可，相邻元素间用空格间隔，最后一个元素之后不能有空格。最后输出一个回车。如上例，应为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c e t b</span><br></pre></td></tr></table></figure>

<p>注意：应正确处理输入中空栈等情况。</p>
<h2 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h2><p>数组可太好操作了，就是private类型要多些几个函数获取和赋值显的不优美了点</p>
<h2 id="运行效果：-1"><a href="#运行效果：-1" class="headerlink" title="运行效果："></a>运行效果：</h2><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmboi4cij20bu05z74s.jpg" alt=""></p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class Stack&#123;</span><br><span class="line">	public:</span><br><span class="line">		Stack(int size);</span><br><span class="line">		~Stack()&#123;delete [] s;&#125;</span><br><span class="line">		bool IsEmpty()const&#123;return top&#x3D;&#x3D;-1;&#125;</span><br><span class="line">		bool IsFull()const&#123;return top&#x3D;&#x3D;MaxTop;&#125;</span><br><span class="line">		T Top() const;</span><br><span class="line">		Stack&lt;T&gt;&amp; Push(const T&amp; x);</span><br><span class="line">		Stack&lt;T&gt;&amp; Pop(T&amp; x);</span><br><span class="line">		void show();</span><br><span class="line">		int getMaxTop()&#123;return MaxTop;&#125;</span><br><span class="line">		void setMaxTop(int x)&#123;MaxTop&#x3D;x;&#125;</span><br><span class="line">		int gettop()&#123;return top;&#125;</span><br><span class="line">		void settop(int x)&#123;top&#x3D;x;&#125;</span><br><span class="line">		T getnum(int i)&#123;return s[i];&#125;</span><br><span class="line">		void setnum(int i,T x)&#123;s[i]&#x3D;x;&#125;</span><br><span class="line">	private:</span><br><span class="line">		int top;</span><br><span class="line">		int MaxTop;</span><br><span class="line">		T *s;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Stack&lt;T&gt;::Stack(int size)&#123;</span><br><span class="line">	MaxTop&#x3D;size-1;</span><br><span class="line">	s&#x3D;new T[size];</span><br><span class="line">	top&#x3D;-1;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T Stack&lt;T&gt;::Top()const&#123;</span><br><span class="line">	if(IsEmpty())cout&lt;&lt;&quot;栈是空的昂&quot;&lt;&lt;endl;</span><br><span class="line">	return s[top];</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Stack&lt;T&gt;&amp; Stack&lt;T&gt;::Push(const T&amp; x)&#123;</span><br><span class="line">	if(IsFull())cout&lt;&lt;&quot;栈是满的昂&quot;&lt;&lt;endl;</span><br><span class="line">	s[++top]&#x3D;x;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Stack&lt;T&gt;&amp; Stack&lt;T&gt;::Pop(T&amp; x)&#123;</span><br><span class="line">	if(IsEmpty())cout&lt;&lt;&quot;栈是空的昂&quot;&lt;&lt;endl;</span><br><span class="line">	x&#x3D;s[top--];</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void Stack&lt;T&gt;::show()&#123;</span><br><span class="line">	if(IsEmpty())cout&lt;&lt;&quot;栈是空的昂&quot;&lt;&lt;endl;</span><br><span class="line">	for(int i&#x3D;top;i&gt;&#x3D;1;i--)</span><br><span class="line">		cout&lt;&lt;s[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">	cout&lt;&lt;s[0]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void delete_all(Stack&lt;T&gt; &amp;s,const T &amp;x)&#123;</span><br><span class="line">	if(s.IsEmpty())&#123;</span><br><span class="line">		cout&lt;&lt;&quot;栈是空的昂&quot;&lt;&lt;endl;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	int n&#x3D;s.getMaxTop();</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">		if(s.getnum(i)&#x3D;&#x3D;x)&#123;</span><br><span class="line">			for(int j&#x3D;i+1;j&lt;n;j++)s.setnum(j-1,s.getnum(j));</span><br><span class="line">			n--;</span><br><span class="line">			s.setMaxTop(n);</span><br><span class="line">			s.settop(s.gettop()-1);</span><br><span class="line">			i--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	&#x2F;&#x2F;freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	Stack&lt;char&gt; ss(233);</span><br><span class="line">	char aa,c;</span><br><span class="line">	cin&gt;&gt;aa;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;7;i++)&#123;</span><br><span class="line">		cin&gt;&gt;c;</span><br><span class="line">		ss.Push(c);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;ss.show();</span><br><span class="line">	delete_all(ss,aa);</span><br><span class="line">	ss.show();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>一些作业</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构第?次作业（哈希表 HashTable，暴雪字符串哈希）</title>
    <url>/7f6818b1/</url>
    <content><![CDATA[<p>本来想在这篇深入研究一下暴雪的字符串哈希的，据说是最快的字符串哈希，而且人家可靠性特好，然而。。里面有一堆奇妙的不明所以的常数。。之前写计概论文的时候算那个sqrt的神奇常数0x5f3759df就搞了半天。。现在已经忘了最小二乘法咋写了ಠ_ಠ</p>
<p>更惨的是。。周末就这样过完了TAT，我的模电作业还没写完。。模电啊模电TAT。。完全从最初只是帮人写个数据结构哈希表跑偏了233333</p>
<p>暴雪的hash一些细节留着有空再研究吧，先懂个大概的核心思路，mark一下，顺便膜一下。。暴雪的基础函数都。。好酷的样子啊0.0</p>
<hr>
<h1 id="题目要求："><a href="#题目要求：" class="headerlink" title="题目要求："></a>题目要求：</h1><p>我也不知道题目啥要求╮(￣▽￣””)╭，反正就是写个字符串哈希</p>
<h1 id="hash基本思路："><a href="#hash基本思路：" class="headerlink" title="hash基本思路："></a>hash基本思路：</h1><p>下面这些乱七八糟的一堆东西。。大多都是四处学习<s>复制粘贴</s>的。。虽然很多方法并不优。。就当了解一下了</p>
<p>哈希表（Hash table，也叫散列表），是根据关键码值（Key）而直接进行访问的数据结构</p>
<h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><p>通过某种函数使元素的存储位置与它的key之间能够建立一一映射的关系，那么要查找某个key对应的value的值，本来直接查找的话需要o(n)扫一遍，但是如果可以通过key直接求得value存储的位子，那么o(1)就可以得到value的值</p>
<h2 id="基本操作："><a href="#基本操作：" class="headerlink" title="基本操作："></a>基本操作：</h2><h3 id="1-插入insert："><a href="#1-插入insert：" class="headerlink" title="1.插入insert："></a>1.插入insert：</h3><p>根据待插入元素的key，用某种函数（有很多种hash函数）计算出该元素的存储位置并按此位置进行存放</p>
<h3 id="2-搜索find："><a href="#2-搜索find：" class="headerlink" title="2.搜索find："></a>2.搜索find：</h3><p>对元素的key进行同样的计算，把求得的函数值当做元素的存储位置，在结构中按此位置取元素比较，若关键码相等，则搜索成功</p>
<h2 id="哈希冲突："><a href="#哈希冲突：" class="headerlink" title="哈希冲突："></a>哈希冲突：</h2><p>哈希函数将两个不同的key映射到同一个地方的情况</p>
<p>哈希冲突是不可避免的，如果遇到冲突，最常用的解决办法就是开放定址法和链地址法</p>
<h3 id="1-开放地址法"><a href="#1-开放地址法" class="headerlink" title="1.开放地址法"></a>1.开放地址法</h3><blockquote>
<p>当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有空位置，那么可以把key存放到表中下一个空位中。</p>
<p>寻找下一个空余位置要用到两种方法：线性探测和二次探测</p>
<p>1）线性探测：</p>
<p>从发生冲突的位置开始，依次继续向后探测，直到找到空位置为止</p>
<p>2）二次探测：</p>
<p>研究表明：当表的长度为质数且表装载因子a不超过0.5时，新的表项一定能够插入，而且任何一个位置都不会被探查两次。因此只要表中有一半的空位置，就不会存在表满的问题。在搜索时可以不考虑表装满的情况，但在插入时必须确保表的装载因子a不超过0.5；如果超出必须考虑增容</p>
</blockquote>
<h3 id="2-链地址法"><a href="#2-链地址法" class="headerlink" title="2.链地址法"></a>2.链地址法</h3><blockquote>
<p>首先对key用hash函数计算地址，具有相同地址的key归于同一子集合，每一个子集合称为一个桶，各个桶中的元素通过一个单链表链接起来，各链表的头结点存储在哈希表中</p>
<p>应用链地址法处理溢出，需要增设链接指针，似乎增加了存储开销，然而事实上，由于开地址法必须保持大量的空闲空间以确保搜索效率，而表项所占空间又比指针大的多，所以使用链地址法反而比开地址法节省存储空间</p>
<p>大概就是下图。。如有雷同。。我的图是盗的0.0</p>
</blockquote>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kme65f0bj205q0433yf.jpg" alt=""></p>
<h2 id="哈希函数："><a href="#哈希函数：" class="headerlink" title="哈希函数："></a>哈希函数：</h2><p>BKDRHash，APHash，DJBHash，JSHash，RSHash，SDBMHash，PJWHash，ELFHash</p>
<h3 id="1-直接定址法"><a href="#1-直接定址法" class="headerlink" title="1.直接定址法"></a>1.直接定址法</h3><p>取某个线性函数：<code>hash(key)=A*key+B</code></p>
<p>适合查找比较小且连续的情况</p>
<h3 id="2-除留余数法"><a href="#2-除留余数法" class="headerlink" title="2.除留余数法"></a>2.除留余数法</h3><p>设散列表中允许的地址数为m，取一个不大于m，但最接近或者等于m的质数p作为除数，按照哈希函数：<code>hash(key)=key%p(p&lt;=m)</code>,将关键码转换成哈希地址</p>
<h3 id="3-平方取中法"><a href="#3-平方取中法" class="headerlink" title="3.平方取中法"></a>3.平方取中法</h3><p>假设关键字为1234，对它平方就是1522756，抽取中间的3位227作为哈希地址；</p>
<p>平方取中法比较适合：不知道关键字的分布，而位数又不是很大的情况</p>
<h3 id="4-折叠法"><a href="#4-折叠法" class="headerlink" title="4.折叠法"></a>4.折叠法</h3><p>折叠法是将关键字从左到右分割成位数相等的几部分(最后一部分位数可以短些)，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址</p>
<p>折叠法适合事先不需要知道关键字的分布，适合关键字位数比较多的情况</p>
<h3 id="5-随机数法"><a href="#5-随机数法" class="headerlink" title="5.随机数法"></a>5.随机数法</h3><p>选择一个随机函数，取关键字的随机函数值为它的哈希地址，即H(key)=random(key),其中random为随机数函数通常应用于关键字长度不等时采用此法</p>
<h3 id="6-数学分析法"><a href="#6-数学分析法" class="headerlink" title="6.数学分析法"></a>6.数学分析法</h3><p>名字很牛逼其实就是根据实际数据特点人工分析。。好像没啥用？</p>
<p>例如：假设要存储某家公司员工登记表，如果用手机号作为关键字，那么极有可能前7位都是相同的，那么我们可以选择后面的四位作为散列地址，如果这样的抽取工作还容易出现冲突，还可以对抽取出来的数字进行反转(如1234改成4321)、右环位移(如1234改成4123)、左环移位、前两数与后两数叠加(如1234改成12+34=46)等方法</p>
<p>查了一堆hash函数常用质数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">61,83,113,151,211,281,379,509683,911&#x2F;一千以下</span><br><span class="line"></span><br><span class="line">1217,1627,2179,2909,3881,6907,9209,&#x2F;一万以下</span><br><span class="line"></span><br><span class="line">12281,16381,21841,29123,38833,51787,69061,92083,&#x2F;十万以下</span><br><span class="line"></span><br><span class="line">122777,163729,218357,291143,388211,517619,690163,999983,&#x2F;百万以下</span><br><span class="line"></span><br><span class="line">1226959,1635947,2181271,2908361,3877817,5170427,6893911,9191891,&#x2F;千万以下</span><br><span class="line"></span><br><span class="line">12255871,16341163,21788233,29050993,38734667,51646229,68861641,91815541,&#x2F;一亿以下</span><br><span class="line"></span><br><span class="line">1e9+7和1e9+9&#x2F;&#x2F;十亿左右</span><br><span class="line"></span><br><span class="line">122420729,163227661,217636919,290182597,386910137,515880193,687840301,917120411,&#x2F;十亿以下</span><br><span class="line"></span><br><span class="line">1222827239,1610612741,3221225473ul,4294967291ul&#x2F;十亿以上</span><br></pre></td></tr></table></figure>

<h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><p>哈希冲突用的是链地址法，哈希函数用的time33</p>
<p>因为题目好像真的没啥要求。。所以写了个差不多得了的哈希╮(￣▽￣””)╭</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int size&#x3D;911;&#x2F;&#x2F;随便找了个看得顺眼的常用质数</span><br><span class="line">struct node&#123;</span><br><span class="line">	string key;</span><br><span class="line">	string value;</span><br><span class="line">	node *next;</span><br><span class="line">&#125;;</span><br><span class="line">class Hash_Table&#123;</span><br><span class="line">	public:</span><br><span class="line">		Hash_Table()&#123;</span><br><span class="line">			for(int i&#x3D;0;i&lt;size;i++)&#123;</span><br><span class="line">				HT[i]&#x3D;new node;</span><br><span class="line">				HT[i]&#x3D;NULL;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		int hash(string key);</span><br><span class="line">		bool vis(string key);</span><br><span class="line">		void insert(string key,string value);</span><br><span class="line">		void get_value(string key);</span><br><span class="line">	private:</span><br><span class="line">		node *HT[size];</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;time33</span><br><span class="line">int Hash_Table::hash(string key)&#123;</span><br><span class="line">	int tmp&#x3D;0;</span><br><span class="line">	int len&#x3D;key.length();</span><br><span class="line">	for(int i&#x3D;0;i&lt;len;i++)&#123;</span><br><span class="line">		tmp&#x3D;(tmp*33+(int)key[i])%size;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; cout&lt;&lt;tmp&lt;&lt;endl;</span><br><span class="line">	return tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;是否存过</span><br><span class="line">bool Hash_Table::vis(string key)&#123;</span><br><span class="line">	node* p;</span><br><span class="line">	int index&#x3D;hash(key);</span><br><span class="line">	for(p&#x3D;HT[index];p!&#x3D;NULL;p&#x3D;p-&gt;next)&#123;</span><br><span class="line">		if(key.compare(p-&gt;key)&#x3D;&#x3D;0)return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;插入</span><br><span class="line">void Hash_Table::insert(string key,string value)&#123;</span><br><span class="line">	node *p,*tmp;</span><br><span class="line">	int index&#x3D;hash(key);</span><br><span class="line">	&#x2F;&#x2F; cout&lt;&lt;index&lt;&lt;endl;</span><br><span class="line">	if(!vis(key))&#123;</span><br><span class="line">		if(HT[index]&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">			tmp&#x3D;new node;</span><br><span class="line">			tmp-&gt;key&#x3D;key;</span><br><span class="line">			tmp-&gt;value&#x3D;value;</span><br><span class="line">			tmp-&gt;next&#x3D;NULL;</span><br><span class="line">			HT[index]&#x3D;tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			for(p&#x3D;HT[index];p-&gt;next!&#x3D;NULL;p&#x3D;p-&gt;next);</span><br><span class="line">			tmp&#x3D;new node;</span><br><span class="line">			tmp-&gt;key&#x3D;key;</span><br><span class="line">			tmp-&gt;value&#x3D;value;</span><br><span class="line">			tmp-&gt;next&#x3D;NULL;</span><br><span class="line">			p-&gt;next&#x3D;tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		for(p&#x3D;HT[index];p-&gt;next!&#x3D;NULL;p&#x3D;p-&gt;next)</span><br><span class="line">			if(key.compare(p-&gt;key)&#x3D;&#x3D;0)</span><br><span class="line">				p-&gt;value&#x3D;value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void Hash_Table::get_value(string key)&#123;</span><br><span class="line">	int index&#x3D;hash(key);</span><br><span class="line">	node* p;</span><br><span class="line">	for(p&#x3D;HT[index];p!&#x3D;NULL;p&#x3D;p-&gt;next)&#123;</span><br><span class="line">		if(key.compare(p-&gt;key)&#x3D;&#x3D;0)&#123;</span><br><span class="line">			cout&lt;&lt;&quot;该key对应的value是：&quot;&lt;&lt;p-&gt;value&lt;&lt;endl;</span><br><span class="line">			return;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;&quot;啥玩意儿啊找不着啊QWQ&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	Hash_Table ht;</span><br><span class="line">	int t;</span><br><span class="line">	string kk,vv;</span><br><span class="line">	cout&lt;&lt;&quot;请输入哈希对数：&quot;&lt;&lt;endl;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;t;i++)&#123;</span><br><span class="line">		cout&lt;&lt;&quot;请输入第&quot;&lt;&lt;i&lt;&lt;&quot;组哈希：&quot;&lt;&lt;endl;</span><br><span class="line">		cin&gt;&gt;kk;</span><br><span class="line">		cin&gt;&gt;vv;</span><br><span class="line">		ht.insert(kk,vv);</span><br><span class="line">	&#125;</span><br><span class="line">	string s;</span><br><span class="line">	cout&lt;&lt;&quot;请输入要求的key：&quot;&lt;&lt;endl;</span><br><span class="line">	while(cin&gt;&gt;s)&#123;</span><br><span class="line">		ht.get_value(s);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行效果："><a href="#运行效果：" class="headerlink" title="运行效果："></a>运行效果：</h2><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmegqdqtj20b00dg3zu.jpg" alt=""></p>
<hr>
<h1 id="暴雪字符串哈希"><a href="#暴雪字符串哈希" class="headerlink" title="暴雪字符串哈希"></a>暴雪字符串哈希</h1><p>妙在一个key有三个哈希值，然后就能风驰电掣又准确的单刀直入的完成一些妙妙的比较</p>
<p>两个不同的字符串经过一个hash算法可能得到同一个地址，但用三个不同的hash算法算出的结果都一致，那就是个很小很小很小的概率，据说这个概率是1:18889465931478580854784，对一个游戏程序来说足够安全了</p>
<p>至于其余那些迷之常数，尚未参透0.0</p>
<h2 id="大概思路："><a href="#大概思路：" class="headerlink" title="大概思路："></a>大概思路：</h2><p>一个字符串有三个哈希值，一个用来确定位置，另外两个用来校验</p>
<p>对于一个字符串来说，先哈希函数求的它的位置</p>
<p>1）察看哈希表中的这个位置 </p>
<p>2）若这个位置为空，则该字符串肯定不存在，返回不存在</p>
<p>3）这个位置不为空，则检查其他两个哈希值是否也匹配，假如匹配，则返回存在</p>
<p>4）移到下一个位置，假如越界，则返回不存在</p>
<p>5）检查是不是又回到了原来的位置，假如是，则返回不存在</p>
<p>6）回到2 </p>
<h2 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*********************************StringHash.h*********************************&#x2F;</span><br><span class="line"></span><br><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#define MAXTABLELEN 1024 &#x2F;&#x2F; 默认哈希索引表大小 </span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F; 哈希索引表定义 </span><br><span class="line">typedef struct _HASHTABLE</span><br><span class="line">&#123; </span><br><span class="line">　　long nHashA; </span><br><span class="line">　　long nHashB; </span><br><span class="line">　　bool bExists; </span><br><span class="line">&#125;HASHTABLE, *PHASHTABLE ;</span><br><span class="line"></span><br><span class="line">class StringHash</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">　　StringHash(const long nTableLength &#x3D; MAXTABLELEN);</span><br><span class="line">　　~StringHash(void);</span><br><span class="line">private: </span><br><span class="line">　　unsigned long cryptTable[0x500]; </span><br><span class="line">　　unsigned long m_tablelength; &#x2F;&#x2F; 哈希索引表长度 </span><br><span class="line">　 HASHTABLE *m_HashIndexTable; </span><br><span class="line">private:</span><br><span class="line">　　void InitCryptTable(); &#x2F;&#x2F; 对哈希索引表预处理 </span><br><span class="line">　　unsigned long HashString(const string&amp; lpszString, unsigned long dwHashType); &#x2F;&#x2F; 求取哈希值 </span><br><span class="line">public:</span><br><span class="line">　　bool Hash(string url);</span><br><span class="line">　　unsigned long Hashed(string url); &#x2F;&#x2F; 检测url是否被hash过</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#x2F;*********************************StringHash.cpp*********************************&#x2F;</span><br><span class="line"></span><br><span class="line">#include &quot;StdAfx.h&quot;</span><br><span class="line">#include &quot;StringHash.h&quot;</span><br><span class="line"></span><br><span class="line">StringHash::StringHash(const long nTableLength &#x2F;*&#x3D; MAXTABLELEN*&#x2F;)</span><br><span class="line">&#123;</span><br><span class="line">　　InitCryptTable(); </span><br><span class="line">　　m_tablelength &#x3D; nTableLength; </span><br><span class="line">　　&#x2F;&#x2F;初始化hash表</span><br><span class="line">　　m_HashIndexTable &#x3D; new HASHTABLE[nTableLength]; </span><br><span class="line">　　for ( int i &#x3D; 0; i &lt; nTableLength; i++ ) </span><br><span class="line">　　&#123; </span><br><span class="line">　　　　m_HashIndexTable[i].nHashA &#x3D; -1; </span><br><span class="line">　　　　m_HashIndexTable[i].nHashB &#x3D; -1; </span><br><span class="line">　　　　m_HashIndexTable[i].bExists &#x3D; false; </span><br><span class="line">　　&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StringHash::~StringHash(void)</span><br><span class="line">&#123;</span><br><span class="line">　　&#x2F;&#x2F;清理内存</span><br><span class="line">　　if ( NULL !&#x3D; m_HashIndexTable ) </span><br><span class="line">　　&#123; </span><br><span class="line">　　　　delete []m_HashIndexTable; </span><br><span class="line">　　　　m_HashIndexTable &#x3D; NULL; </span><br><span class="line">　　　　m_tablelength &#x3D; 0; </span><br><span class="line">　　&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;************************************************************************&#x2F;</span><br><span class="line">&#x2F;*函数名：InitCryptTable</span><br><span class="line">&#x2F;*功 能：对哈希索引表预处理 </span><br><span class="line">&#x2F;*返回值：无</span><br><span class="line">&#x2F;************************************************************************&#x2F;</span><br><span class="line">void StringHash::InitCryptTable() </span><br><span class="line">&#123; </span><br><span class="line">　 unsigned long seed &#x3D; 0x00100001, index1 &#x3D; 0, index2 &#x3D; 0, i;</span><br><span class="line"></span><br><span class="line">　　for( index1 &#x3D; 0; index1 &lt; 0x100; index1++ ) </span><br><span class="line">　　&#123; </span><br><span class="line">　　　　for( index2 &#x3D; index1, i &#x3D; 0; i &lt; 5; i++, index2 +&#x3D; 0x100 ) </span><br><span class="line">　　　　&#123; </span><br><span class="line">　　　　　　unsigned long temp1, temp2; </span><br><span class="line">　　　　　　seed &#x3D; (seed * 125 + 3) % 0x2AAAAB; </span><br><span class="line">　　　　　　temp1 &#x3D; (seed &amp; 0xFFFF) &lt;&lt; 0x10; </span><br><span class="line">　　　　　　seed &#x3D; (seed * 125 + 3) % 0x2AAAAB; </span><br><span class="line">　　　　　　temp2 &#x3D; (seed &amp; 0xFFFF); </span><br><span class="line">　　　　　　cryptTable[index2] &#x3D; ( temp1 | temp2 ); </span><br><span class="line">　　　　&#125; </span><br><span class="line">　　&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;************************************************************************&#x2F;</span><br><span class="line">&#x2F;*函数名：HashString</span><br><span class="line">&#x2F;*功 能：求取哈希值 </span><br><span class="line">&#x2F;*返回值：返回hash值</span><br><span class="line">&#x2F;************************************************************************&#x2F;</span><br><span class="line">unsigned long StringHash::HashString(const string&amp; lpszString, unsigned long dwHashType) </span><br><span class="line">&#123; </span><br><span class="line">　　unsigned char *key &#x3D; (unsigned char *)(const_cast&lt;char*&gt;(lpszString.c_str())); </span><br><span class="line">　　unsigned long seed1 &#x3D; 0x7FED7FED, seed2 &#x3D; 0xEEEEEEEE; </span><br><span class="line">　　int ch;</span><br><span class="line"></span><br><span class="line">　　while(*key !&#x3D; 0) </span><br><span class="line">　　&#123; </span><br><span class="line">　　　　ch &#x3D; toupper(*key++);</span><br><span class="line"></span><br><span class="line">　　　　seed1 &#x3D; cryptTable[(dwHashType &lt;&lt; 8) + ch] ^ (seed1 + seed2); </span><br><span class="line">　　　　seed2 &#x3D; ch + seed1 + seed2 + (seed2 &lt;&lt; 5) + 3; </span><br><span class="line">　　&#125; </span><br><span class="line">　　return seed1; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;************************************************************************&#x2F;</span><br><span class="line">&#x2F;*函数名：Hashed</span><br><span class="line">&#x2F;*功 能：检测一个字符串是否被hash过</span><br><span class="line">&#x2F;*返回值：如果存在，返回位置；否则，返回-1</span><br><span class="line">&#x2F;************************************************************************&#x2F;</span><br><span class="line">unsigned long StringHash::Hashed(string lpszString)</span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line">　　const unsigned long HASH_OFFSET &#x3D; 0, HASH_A &#x3D; 1, HASH_B &#x3D; 2; </span><br><span class="line">　 &#x2F;&#x2F;不同的字符串三次hash还会碰撞的几率无限接近于不可能</span><br><span class="line">　　unsigned long nHash &#x3D; HashString(lpszString, HASH_OFFSET); </span><br><span class="line">　 unsigned long nHashA &#x3D; HashString(lpszString, HASH_A); </span><br><span class="line">　　unsigned long nHashB &#x3D; HashString(lpszString, HASH_B); </span><br><span class="line">　 unsigned long nHashStart &#x3D; nHash % m_tablelength, </span><br><span class="line">　　nHashPos &#x3D; nHashStart;</span><br><span class="line"></span><br><span class="line">　　while ( m_HashIndexTable[nHashPos].bExists) </span><br><span class="line">　　&#123; </span><br><span class="line">　　if (m_HashIndexTable[nHashPos].nHashA &#x3D;&#x3D; nHashA &amp;&amp; m_HashIndexTable[nHashPos].nHashB &#x3D;&#x3D; nHashB)</span><br><span class="line">　　　　return nHashPos; </span><br><span class="line">　　else </span><br><span class="line">　　nHashPos &#x3D; (nHashPos + 1) % m_tablelength;</span><br><span class="line"></span><br><span class="line">　　if (nHashPos &#x3D;&#x3D; nHashStart) </span><br><span class="line">　　break; </span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　return -1; &#x2F;&#x2F;没有找到 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;************************************************************************&#x2F;</span><br><span class="line">&#x2F;*函数名：Hash</span><br><span class="line">&#x2F;*功 能：hash一个字符串 </span><br><span class="line">&#x2F;*返回值：成功，返回true；失败，返回false</span><br><span class="line">&#x2F;************************************************************************&#x2F;</span><br><span class="line">bool StringHash::Hash(string lpszString)</span><br><span class="line">&#123; </span><br><span class="line">　　const unsigned long HASH_OFFSET &#x3D; 0, HASH_A &#x3D; 1, HASH_B &#x3D; 2; </span><br><span class="line">　　unsigned long nHash &#x3D; HashString(lpszString, HASH_OFFSET); </span><br><span class="line">　　unsigned long nHashA &#x3D; HashString(lpszString, HASH_A); </span><br><span class="line">　　unsigned long nHashB &#x3D; HashString(lpszString, HASH_B); </span><br><span class="line">　　unsigned long nHashStart &#x3D; nHash % m_tablelength, </span><br><span class="line">　　nHashPos &#x3D; nHashStart;</span><br><span class="line"></span><br><span class="line">　　while ( m_HashIndexTable[nHashPos].bExists) </span><br><span class="line">　　&#123; </span><br><span class="line">　　　　nHashPos &#x3D; (nHashPos + 1) % m_tablelength; </span><br><span class="line">　　　　if (nHashPos &#x3D;&#x3D; nHashStart) &#x2F;&#x2F;一个轮回 </span><br><span class="line">　　　　&#123; </span><br><span class="line">　　　　　　&#x2F;&#x2F;hash表中没有空余的位置了,无法完成hash</span><br><span class="line">　　　　　　return false; </span><br><span class="line">　　　　&#125; </span><br><span class="line">　　&#125; </span><br><span class="line">　　m_HashIndexTable[nHashPos].bExists &#x3D; true; </span><br><span class="line">　　m_HashIndexTable[nHashPos].nHashA &#x3D; nHashA; </span><br><span class="line">　　m_HashIndexTable[nHashPos].nHashB &#x3D; nHashB;</span><br><span class="line"></span><br><span class="line">　　return true; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>一些作业</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构第?次作业（bfs+路径打印）</title>
    <url>/10336297/</url>
    <content><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p>习题内容二：求解布线问题。1如图所示的印刷电路板，将布线区域划分成n×m个方格。布线时，电路只能沿直线或直角布线。“X”号表示电路板上必须避开的区域（如下图中的蓝色区域），“0”表示可布线的区域（如下图中的白色区域）</p>
<a id="more"></a>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmcojyeqj205804sdg0.jpg" alt=""></p>
<p>2输入需要布线的两个位置，如图中a、b的坐标。3求解最短布线方案。算法介绍： 从起始点a开始，进行布线路径查找（遍历）。 起始点作为第一个E结点，不断扩充新的E结点。 如果E结点的编号是k，则与该结点相邻接的未被编号的结点的编号为k+1。 使用一个队列来保存E结点。初始时起始点入队列并进行编号。 循环处理，队头结点出队列，并将其未被编号的邻接结点入队列并进行编号。 如果邻接点到达终点，则按反序依次输出各结点，即为所求</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmcolu2lj205f04rq38.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmcok7g5j206805gglx.jpg" alt=""></p>
<p>如果有多个结果，给出其中一个即可。例如，上图中有两条最佳布线结果</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmdcx2sxj206805gdg5.jpg" alt=""></p>
<h1 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h1><p>my input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 6</span><br><span class="line">000000</span><br><span class="line">00X000</span><br><span class="line">00X000</span><br><span class="line">00X000 </span><br><span class="line">00X000</span><br><span class="line">XXX000</span><br><span class="line">000000</span><br><span class="line"></span><br><span class="line">2 2 5 5</span><br></pre></td></tr></table></figure>

<p>my output</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kmdcxaqij206804vjre.jpg" alt=""></p>
<h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><p>基础bfs，然后递归打印路径</p>
<p>输完图之后一定要再加个<code>scanf(&quot;%s&quot;,str);</code>的，啥玩意儿咋回事。。不然sx就直接读了个0的值，感觉以前没遇到过这问题啊</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;233;</span><br><span class="line">char str[N];</span><br><span class="line">int vis[N][N],mp[N][N];</span><br><span class="line">int sx,sy,ex,ey,n,m;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int x,y;</span><br><span class="line">&#125;ans[N][N];</span><br><span class="line">void bfs()&#123;</span><br><span class="line">	queue&lt;node&gt;Q;</span><br><span class="line">	vis[sx][sy]&#x3D;1;</span><br><span class="line">	node tmp;</span><br><span class="line">	tmp.x&#x3D;sx;tmp.y&#x3D;sy;</span><br><span class="line">	Q.push(tmp);</span><br><span class="line">	while(!Q.empty())&#123;</span><br><span class="line">		tmp&#x3D;Q.front();</span><br><span class="line">		Q.pop();</span><br><span class="line">		if(tmp.x&#x3D;&#x3D;ex&amp;&amp;tmp.y&#x3D;&#x3D;ey)break;</span><br><span class="line">		node u;</span><br><span class="line">		u.x&#x3D;tmp.x+1;</span><br><span class="line">		u.y&#x3D;tmp.y;</span><br><span class="line">		if(mp[u.x][u.y]&amp;&amp;u.x&gt;&#x3D;1&amp;&amp;u.x&lt;&#x3D;n&amp;&amp;u.y&gt;&#x3D;1&amp;&amp;u.y&lt;&#x3D;m&amp;&amp;!vis[u.x][u.y])&#123;</span><br><span class="line">			ans[u.x][u.y].x&#x3D;tmp.x;</span><br><span class="line">			ans[u.x][u.y].y&#x3D;tmp.y;</span><br><span class="line">			vis[u.x][u.y]&#x3D;1;</span><br><span class="line">			Q.push(u);</span><br><span class="line">		&#125;</span><br><span class="line">		u.x&#x3D;tmp.x-1;</span><br><span class="line">		u.y&#x3D;tmp.y;</span><br><span class="line">		if(mp[u.x][u.y]&amp;&amp;u.x&gt;&#x3D;1&amp;&amp;u.x&lt;&#x3D;n&amp;&amp;u.y&gt;&#x3D;1&amp;&amp;u.y&lt;&#x3D;m&amp;&amp;!vis[u.x][u.y])&#123;</span><br><span class="line">			ans[u.x][u.y].x&#x3D;tmp.x;</span><br><span class="line">			ans[u.x][u.y].y&#x3D;tmp.y;</span><br><span class="line">			vis[u.x][u.y]&#x3D;1;</span><br><span class="line">			Q.push(u);</span><br><span class="line">		&#125;</span><br><span class="line">		u.x&#x3D;tmp.x;</span><br><span class="line">		u.y&#x3D;tmp.y-1;</span><br><span class="line">		if(mp[u.x][u.y]&amp;&amp;u.x&gt;&#x3D;1&amp;&amp;u.x&lt;&#x3D;n&amp;&amp;u.y&gt;&#x3D;1&amp;&amp;u.y&lt;&#x3D;m&amp;&amp;!vis[u.x][u.y])&#123;</span><br><span class="line">			ans[u.x][u.y].x&#x3D;tmp.x;</span><br><span class="line">			ans[u.x][u.y].y&#x3D;tmp.y;</span><br><span class="line">			vis[u.x][u.y]&#x3D;1;</span><br><span class="line">			Q.push(u);</span><br><span class="line">		&#125;</span><br><span class="line">		u.x&#x3D;tmp.x;</span><br><span class="line">		u.y&#x3D;tmp.y+1;</span><br><span class="line">		if(mp[u.x][u.y]&amp;&amp;u.x&gt;&#x3D;1&amp;&amp;u.x&lt;&#x3D;n&amp;&amp;u.y&gt;&#x3D;1&amp;&amp;u.y&lt;&#x3D;m&amp;&amp;!vis[u.x][u.y])&#123;</span><br><span class="line">			ans[u.x][u.y].x&#x3D;tmp.x;</span><br><span class="line">			ans[u.x][u.y].y&#x3D;tmp.y;</span><br><span class="line">			vis[u.x][u.y]&#x3D;1;</span><br><span class="line">			Q.push(u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void road(int xx,int yy)&#123;</span><br><span class="line">	if(xx&#x3D;&#x3D;sx&amp;&amp;yy&#x3D;&#x3D;sy)&#123;</span><br><span class="line">		printf(&quot;(%d,%d)\n&quot;,xx,yy);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	road(ans[xx][yy].x,ans[xx][yy].y);</span><br><span class="line">	printf(&quot;(%d,%d)\n&quot;,xx,yy);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		scanf(&quot;%s&quot;,str);</span><br><span class="line">		for(int j&#x3D;1;j&lt;&#x3D;m;j++)&#123;</span><br><span class="line">			if(str[j-1]&#x3D;&#x3D;&#39;X&#39;)mp[i][j]&#x3D;0;</span><br><span class="line">			else mp[i][j]&#x3D;1;</span><br><span class="line">			vis[i][j]&#x3D;0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	scanf(&quot;%s&quot;,str);</span><br><span class="line">	scanf(&quot;%d%d%d%d&quot;,&amp;sx,&amp;sy,&amp;ex,&amp;ey);</span><br><span class="line">	cout&lt;&lt;sx&lt;&lt;sy&lt;&lt;ex&lt;&lt;ey&lt;&lt;endl;</span><br><span class="line">	bfs();</span><br><span class="line">	road(ex,ey);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>一些作业</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构第三次作业（上三角矩阵下三角矩阵转置，稀疏矩阵相乘，单链表实现稀疏矩阵）</title>
    <url>/40687d49/</url>
    <content><![CDATA[<p>感谢队友（da lao）的帮助，可能这种题目简单编译难的题的目的。。就是为了让我会写构造函数析构函数拷贝构造函数重载运算符吧0.0，终于解决了，真实的快乐</p>
<hr>
<h1 id="作业一（29）："><a href="#作业一（29）：" class="headerlink" title="作业一（29）："></a>作业一（29）：</h1><p>扩充类lowerTriangularMatrix，增加矩阵转置方法，返回值是下三角矩阵的转置矩阵，是上三角矩阵，是类upperTriangularMatrix的一个实例，确定时间复杂度</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>下三角：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第i行之前的元素数目：1+2+...+(i–1)&#x3D;i*(i-1)&#x2F;2  </span><br><span class="line">第j列之前的元素数目：j-1  </span><br><span class="line">L(i,j)之前的元素数目：t[i*(i-1)&#x2F;2+j-1]</span><br></pre></td></tr></table></figure>

<p>上三角：（比下三角式子复杂一点，推一下然后代几个数验证就能得到）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第i行之前的元素数目：n+(n-1)+...+...&#x3D;n(i-1)-(i-1)*(i-2)&#x2F;2  </span><br><span class="line">第j列之前的元素数目：j-i</span><br><span class="line">L(i,j)之前的元素数目：t[n*(i-1)-(i-1)*(i-2)&#x2F;2+j-i]</span><br></pre></td></tr></table></figure>

<p>转置：</p>
<p>初始化一个上三角矩阵，给这个上三角矩阵赋值，<code>t[i*(i-1)/2+j-1]</code>是下三角矩阵的L(i,j)，要对应取L(j,i)，<code>t[j*(j-1)/2+i-1]</code>赋值给上三角的<code>shang.t[n*(i-1)-(i-1)*(i-2)/2+j-i]</code>    </p>
<p>可以先写出如下思路的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i&#x3D;1;i&lt;&#x3D;size;i++)</span><br><span class="line">		for(int j&#x3D;i;j&lt;&#x3D;size;j++)&#123;</span><br><span class="line">			shang.t[n*(i-1)-(i-1)*(i-2)&#x2F;2+j-i]&#x3D;t[j*(j-1)&#x2F;2+i-1];</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>然后改写一下利用store函数对上三角矩阵的私有变量赋值即可</p>
<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>就是三角矩阵也就是数组的大小，扫一遍赋值即可，用n表示数组大小则复杂度是o(n)的</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上三角</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class UpperMatrix&#123;</span><br><span class="line">	public:</span><br><span class="line">		UpperMatrix(int size)&#123;</span><br><span class="line">			n&#x3D;size;t&#x3D;new T [n*(n+1)&#x2F;2];</span><br><span class="line">		&#125;</span><br><span class="line">		~UpperMatrix()&#123;delete [] t;&#125;</span><br><span class="line">		UpperMatrix&lt;T&gt;&amp; Store(const T&amp; x,int i,int j);</span><br><span class="line">		T Retrieve(int i,int j) const;</span><br><span class="line">		UpperMatrix&lt;T&gt; operator+(const UpperMatrix&lt;T&gt;&amp; m) const;</span><br><span class="line">        UpperMatrix&lt;T&gt; operator-(const UpperMatrix&lt;T&gt;&amp; m) const;</span><br><span class="line">		void print();</span><br><span class="line">        void get();</span><br><span class="line">	private:</span><br><span class="line">		int n;</span><br><span class="line">		T *t;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">UpperMatrix&lt;T&gt;&amp; UpperMatrix&lt;T&gt;::Store(const T&amp; x,int i,int j)&#123;</span><br><span class="line">	if(i&lt;1||j&lt;1||i&gt;n||j&gt;n)puts(&quot;WRONG!&quot;);</span><br><span class="line">	if(i&lt;&#x3D;j)t[n*(i-1)-(i-1)*(i-2)&#x2F;2+j-i]&#x3D;x;</span><br><span class="line">	else if(x!&#x3D;0)puts(&quot;WRONG!&quot;);</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T UpperMatrix&lt;T&gt;::Retrieve(int i,int j)const&#123;</span><br><span class="line">	if(i&lt;1||j&lt;1||i&gt;n||j&gt;n)puts(&quot;WRONG!&quot;);</span><br><span class="line">	if(i&lt;&#x3D;j)return t[n*(i-1)-(i-1)*(i-2)&#x2F;2+j-i];</span><br><span class="line">	else return 0;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void UpperMatrix&lt;T&gt;::print()&#123;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		for(int j&#x3D;1;j&lt;&#x3D;i-1;j++)cout&lt;&lt;&quot;  &quot;;</span><br><span class="line">		for(int j&#x3D;i;j&lt;&#x3D;n;j++)&#123;</span><br><span class="line">			cout&lt;&lt;t[n*(i-1)-(i-1)*(i-2)&#x2F;2+j-i]&lt;&lt;&quot; &quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void UpperMatrix&lt;T&gt;::get()&#123;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">		for(int j&#x3D;i;j&lt;&#x3D;n;j++)&#123;</span><br><span class="line">			T data;</span><br><span class="line">			cin&gt;&gt;data;</span><br><span class="line">			t[n*(i-1)-(i-1)*(i-2)&#x2F;2+j-i]&#x3D;data;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">UpperMatrix&lt;T&gt; UpperMatrix&lt;T&gt;::operator+(const UpperMatrix&lt;T&gt;&amp; m) const&#123;</span><br><span class="line">	int size&#x3D;n*(n+1)&#x2F;2;</span><br><span class="line">	for(int i&#x3D;0;i&lt;size;i++)this-&gt;t[i]&#x3D;this-&gt;t[i]+m[i];</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">UpperMatrix&lt;T&gt; UpperMatrix&lt;T&gt;::operator-(const UpperMatrix&lt;T&gt;&amp; m) const&#123;</span><br><span class="line">	int size&#x3D;n*(n+1)&#x2F;2;</span><br><span class="line">	for(int i&#x3D;0;i&lt;size;i++)this-&gt;t[i]&#x3D;this-&gt;t[i]-m[i];</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 下三角</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class LowerMatrix&#123;</span><br><span class="line">	public:</span><br><span class="line">		LowerMatrix(int size)&#123;</span><br><span class="line">			n&#x3D;size;t&#x3D;new T [n*(n+1)&#x2F;2];</span><br><span class="line">		&#125;</span><br><span class="line">		~LowerMatrix()&#123;delete [] t;&#125;</span><br><span class="line">		LowerMatrix&lt;T&gt;&amp; Store(const T&amp; x,int i,int j);</span><br><span class="line">		T Retrieve(int i,int j) const;</span><br><span class="line">		LowerMatrix&lt;T&gt; operator+(const LowerMatrix&lt;T&gt;&amp; m) const;</span><br><span class="line">        LowerMatrix&lt;T&gt; operator-(const LowerMatrix&lt;T&gt;&amp; m) const;</span><br><span class="line">        void print();</span><br><span class="line">        void get();</span><br><span class="line">        void zhuanzhi(UpperMatrix&lt;T&gt;&amp; shang);</span><br><span class="line">	private:</span><br><span class="line">		int n;</span><br><span class="line">		T *t;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">LowerMatrix&lt;T&gt;&amp; LowerMatrix&lt;T&gt;::Store(const T&amp; x,int i,int j)&#123;</span><br><span class="line">	if(i&lt;1||j&lt;1||i&gt;n||j&gt;n)puts(&quot;WRONG!&quot;);</span><br><span class="line">	if(i&gt;&#x3D;j)t[i*(i-1)&#x2F;2+j-1]&#x3D;x;</span><br><span class="line">	else if(x!&#x3D;0)puts(&quot;WRONG!&quot;);</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T LowerMatrix&lt;T&gt;::Retrieve(int i,int j)const&#123;</span><br><span class="line">	if(i&lt;1||j&lt;1||i&gt;n||j&gt;n)puts(&quot;WRONG!&quot;);</span><br><span class="line">	if(i&gt;&#x3D;j)return t[i*(i-1)&#x2F;2+j-1];</span><br><span class="line">	else return 0;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void LowerMatrix&lt;T&gt;::print()&#123;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		for(int j&#x3D;1;j&lt;&#x3D;i;j++)&#123;</span><br><span class="line">			cout&lt;&lt;t[i*(i-1)&#x2F;2+j-1]&lt;&lt;&quot; &quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int j&#x3D;i+1;j&lt;&#x3D;n;j++)cout&lt;&lt;&quot;  &quot;;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void LowerMatrix&lt;T&gt;::get()&#123;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">		for(int j&#x3D;1;j&lt;&#x3D;i;j++)&#123;</span><br><span class="line">			T data;</span><br><span class="line">			cin&gt;&gt;data;</span><br><span class="line">			t[i*(i-1)&#x2F;2+j-1]&#x3D;data;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">LowerMatrix&lt;T&gt; LowerMatrix&lt;T&gt;::operator+(const LowerMatrix&lt;T&gt;&amp; m) const&#123;</span><br><span class="line">	int size&#x3D;n*(n+1)&#x2F;2;</span><br><span class="line">	for(int i&#x3D;0;i&lt;size;i++)this-&gt;t[i]&#x3D;this-&gt;t[i]+m[i];</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">LowerMatrix&lt;T&gt; LowerMatrix&lt;T&gt;::operator-(const LowerMatrix&lt;T&gt;&amp; m) const&#123;</span><br><span class="line">	int size&#x3D;n*(n+1)&#x2F;2;</span><br><span class="line">	for(int i&#x3D;0;i&lt;size;i++)this-&gt;t[i]&#x3D;this-&gt;t[i]-m[i];</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void LowerMatrix&lt;T&gt;::zhuanzhi(UpperMatrix&lt;T&gt;&amp; shang)&#123;</span><br><span class="line">	int size&#x3D;n;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;size;i++)</span><br><span class="line">		for(int j&#x3D;i;j&lt;&#x3D;size;j++)&#123;</span><br><span class="line">			T data&#x3D;t[j*(j-1)&#x2F;2+i-1];</span><br><span class="line">			shang.Store(data,i,j);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	UpperMatrix&lt;int&gt; shang(4);</span><br><span class="line">	LowerMatrix&lt;int&gt; xia(4);</span><br><span class="line">	xia.get();</span><br><span class="line">	cout&lt;&lt;&quot;---下三角矩阵---&quot;&lt;&lt;endl;</span><br><span class="line">	xia.print();</span><br><span class="line">	xia.zhuanzhi(shang);</span><br><span class="line">	cout&lt;&lt;&quot;---转置后的上三角矩阵---&quot;&lt;&lt;endl;</span><br><span class="line">	shang.print();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行效果："><a href="#运行效果：" class="headerlink" title="运行效果："></a>运行效果：</h2><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klsvk753j20bf066dg7.jpg" alt=""></p>
<hr>
<h1 id="作业二（45）："><a href="#作业二（45）：" class="headerlink" title="作业二（45）："></a>作业二（45）：</h1><p>编写一个方法，把两个存储在一起的一维数组的稀疏矩阵相乘，假定两个矩阵和结果矩阵都是按行主次序存储</p>
<h2 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h2><p>首先矩阵乘法的式子是<code>c[i][j]=∑a[i][k]*b[k][j]</code></p>
<p>由于个数很少，再怎么乘c[i][j]也没几个，所以直接按顺序暴力枚举，可以知道只有在a(i,k)和b(k,j)有相同的k的时候才会对答案产生贡献，将这些c(i,j)存入一个Term型的数组</p>
<p>由于相乘中可能会有多个c(i,j)具有相同的ij值，所以要把(i,j)相同的相加合并</p>
<p>此外还有一点是，由于相乘操作中可能产生0，所以最后调用去零的成员函数</p>
<p>get函数中输入结束后还要进行一下对于非法数据的处理，也就是去重和去0，因为元素个数最多才10个，所以o(n^2)暴力比较即可，无需使用set去重</p>
<p>去重部分测试结果如图：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klsvkpglj20bf06jjs7.jpg" alt=""></p>
<h2 id="时间复杂度：-1"><a href="#时间复杂度：-1" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>记矩阵当前非0元素个数为n，则复杂度为<code>o(n^2+n^4)</code></p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><p>此代码包括构造函数，拷贝构造函数，析构函数，矩阵转置函数，矩阵相加函数，矩阵相乘函数，输入，显示，去重，去0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">class Term&#123;</span><br><span class="line">	public:</span><br><span class="line">		int row,col;</span><br><span class="line">		T value;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class SparseMatrix&#123;</span><br><span class="line">	public:</span><br><span class="line">		SparseMatrix(int numsize&#x3D;10);</span><br><span class="line">		SparseMatrix(SparseMatrix&lt;T&gt; &amp;b);</span><br><span class="line">		~SparseMatrix() &#123;delete [] t;&#125;</span><br><span class="line">		void Transpose(SparseMatrix&lt;T&gt; &amp;b)const;</span><br><span class="line">		void Add(const SparseMatrix&lt;T&gt; &amp;b,SparseMatrix&lt;T&gt; &amp;c)const;</span><br><span class="line">		void Mul(const SparseMatrix&lt;T&gt; &amp;b,SparseMatrix&lt;T&gt; &amp;c)const;</span><br><span class="line">		void get();</span><br><span class="line">		void show();</span><br><span class="line">		void no_same();</span><br><span class="line">		void no_zero();</span><br><span class="line">	private:</span><br><span class="line">		void Append(const Term&lt;T&gt;&amp; t);</span><br><span class="line">		int hangshu,lieshu,cursize,numsize;</span><br><span class="line">		Term&lt;T&gt; *t;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">SparseMatrix&lt;T&gt;::SparseMatrix(int n)&#123;</span><br><span class="line">	if(n&lt;1)puts(&quot;WRONG!&quot;);</span><br><span class="line">	numsize&#x3D;n;</span><br><span class="line">	t&#x3D;new Term&lt;T&gt; [numsize];</span><br><span class="line">	cursize&#x3D;hangshu&#x3D;lieshu&#x3D;0;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">SparseMatrix&lt;T&gt;::SparseMatrix(SparseMatrix&lt;T&gt; &amp;b)&#123;</span><br><span class="line">	hangshu&#x3D;b.hangshu;lieshu&#x3D;b.lieshu;</span><br><span class="line">	cursize&#x3D;b.cursize;numsize&#x3D;b.numsize;</span><br><span class="line">	for(int i&#x3D;0;i&lt;cursize;i++)&#123;</span><br><span class="line">		t[i].row&#x3D;b.t[i].row;</span><br><span class="line">		t[i].col&#x3D;b.t[i].col;</span><br><span class="line">		t[i].value&#x3D;b.t[i].value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void SparseMatrix&lt;T&gt;::show()&#123;</span><br><span class="line">	cout&lt;&lt;&quot;行数&#x3D;&quot;&lt;&lt;hangshu&lt;&lt;&quot; 列数&#x3D;&quot;&lt;&lt;lieshu&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;当前非0元素个数&#x3D;&quot;&lt;&lt;cursize&lt;&lt;endl;</span><br><span class="line">	for(int i&#x3D;0;i&lt;cursize;i++)</span><br><span class="line">		cout&lt;&lt;&quot;t(&quot;&lt;&lt;t[i].row&lt;&lt;&#39;,&#39;&lt;&lt;t[i].col&lt;&lt;&quot;)&#x3D;&quot;&lt;&lt;t[i].value&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void SparseMatrix&lt;T&gt;::get()&#123;</span><br><span class="line">	cout&lt;&lt;&quot;输入行数列数和非0元素个数：&quot;&lt;&lt;endl;</span><br><span class="line">	cin&gt;&gt;hangshu&gt;&gt;lieshu&gt;&gt;cursize;</span><br><span class="line">	if(cursize&gt;numsize)puts(&quot;空间不足!&quot;);</span><br><span class="line">	for(int i&#x3D;0;i&lt;cursize;i++) &#123;</span><br><span class="line">		cout&lt;&lt;&quot;输入第&quot;&lt;&lt;(i+1)&lt;&lt;&quot;个元素的行号列号和该元素的值：&quot;&lt;&lt;endl;</span><br><span class="line">		cin&gt;&gt;t[i].row&gt;&gt;t[i].col&gt;&gt;t[i].value;</span><br><span class="line">	&#125;</span><br><span class="line">	this-&gt;no_same();</span><br><span class="line">	this-&gt;no_zero();</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void SparseMatrix&lt;T&gt;::no_same()&#123;</span><br><span class="line">	for(int i&#x3D;0;i&lt;cursize;i++)&#123;</span><br><span class="line">		for(int j&#x3D;i+1;j&lt;cursize;j++)&#123;</span><br><span class="line">			if(t[i].row&#x3D;&#x3D;t[j].row&amp;&amp;t[i].col&#x3D;&#x3D;t[j].col)&#123;</span><br><span class="line">				cursize--;</span><br><span class="line">				for(int k&#x3D;j;k&lt;cursize;k++)&#123;</span><br><span class="line">					t[k].row&#x3D;t[k+1].row;</span><br><span class="line">					t[k].col&#x3D;t[k+1].col;</span><br><span class="line">					t[k].value&#x3D;t[k+1].value;</span><br><span class="line">				&#125;</span><br><span class="line">				j--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void SparseMatrix&lt;T&gt;::no_zero()&#123;</span><br><span class="line">	for(int i&#x3D;0;i&lt;cursize;i++)&#123;</span><br><span class="line">		if(t[i].value&#x3D;&#x3D;0)&#123;</span><br><span class="line">			cursize--;</span><br><span class="line">			for(int k&#x3D;i;k&lt;cursize;k++)&#123;</span><br><span class="line">				t[k].row&#x3D;t[k+1].row;</span><br><span class="line">				t[k].col&#x3D;t[k+1].col;</span><br><span class="line">				t[k].value&#x3D;t[k+1].value;</span><br><span class="line">			&#125;</span><br><span class="line">			i--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void SparseMatrix&lt;T&gt;::Transpose(SparseMatrix&lt;T&gt; &amp;b) const&#123;</span><br><span class="line">	if(cursize&gt;b.numsize)puts(&quot;WRONG!&quot;);</span><br><span class="line">	b.lieshu&#x3D;hangshu;</span><br><span class="line">	b.hangshu&#x3D;lieshu;</span><br><span class="line">	b.cursize&#x3D;cursize;</span><br><span class="line">	int *col_nozero,*row_next;</span><br><span class="line">	col_nozero&#x3D;new int[lieshu+1];</span><br><span class="line">	row_next&#x3D;new int[lieshu+1];</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;lieshu;i++)col_nozero[i]&#x3D;0;  </span><br><span class="line">	for(int i&#x3D;0;i&lt;cursize;i++)col_nozero[t[i].col]++;  </span><br><span class="line">	row_next[1]&#x3D;0;</span><br><span class="line">	for(int i&#x3D;2;i&lt;&#x3D;lieshu;i++)row_next[i]&#x3D;row_next[i-1]+col_nozero[i-1];</span><br><span class="line">	for (int i&#x3D;0;i&lt;cursize;i++)&#123;</span><br><span class="line">		int j&#x3D;row_next[t[i].col]++;</span><br><span class="line">		b.t[j].row&#x3D;t[i].col;</span><br><span class="line">		b.t[j].col&#x3D;t[i].row;</span><br><span class="line">		b.t[j].value&#x3D;t[i].value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void SparseMatrix&lt;T&gt;::Append(const Term&lt;T&gt;&amp; tt)&#123;</span><br><span class="line">	if(cursize&gt;numsize)cout&lt;&lt;&quot;溢出溢出！&quot;&lt;&lt;endl;</span><br><span class="line">	t[cursize]&#x3D;tt;</span><br><span class="line">	cursize++;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void SparseMatrix&lt;T&gt;::Add(const SparseMatrix&lt;T&gt; &amp;b,SparseMatrix&lt;T&gt; &amp;c)const&#123;</span><br><span class="line">	if(hangshu!&#x3D;b.hangshu||lieshu!&#x3D;b.lieshu)puts(&quot;WRONG!&quot;);</span><br><span class="line">	c.hangshu&#x3D;hangshu;</span><br><span class="line">	c.lieshu&#x3D;lieshu;</span><br><span class="line">	c.cursize&#x3D;0;</span><br><span class="line">	int ct&#x3D;0,cb&#x3D;0;</span><br><span class="line">	while(ct&lt;cursize&amp;&amp;cb&lt;b.cursize)&#123;</span><br><span class="line">		int indt&#x3D;t[ct].row*lieshu+t[ct].col;</span><br><span class="line">		int indb&#x3D;b.t[cb].row*lieshu+b.t[cb].col;</span><br><span class="line">		if(indt&lt;indb)&#123;</span><br><span class="line">			c.Append(t[ct]);</span><br><span class="line">			ct++;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(indt&#x3D;&#x3D;indb)&#123;</span><br><span class="line">			if(t[ct].value+b.t[cb].value)&#123;</span><br><span class="line">				Term&lt;T&gt; tt;</span><br><span class="line">				tt.row&#x3D;t[ct].row;</span><br><span class="line">				tt.col&#x3D;t[ct].col;</span><br><span class="line">				tt.value&#x3D;t[ct].value+b.t[cb].value;</span><br><span class="line">				c.Append(tt);</span><br><span class="line">			&#125;</span><br><span class="line">			ct++;cb++;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			c.Append(b.t[cb]);</span><br><span class="line">			cb++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for (;ct&lt;cursize;ct++)</span><br><span class="line">	c.Append(t[ct]);</span><br><span class="line">	for (;cb&lt;b.cursize;cb++)</span><br><span class="line">	c.Append(b.t[cb]);</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void SparseMatrix&lt;T&gt;::Mul(const SparseMatrix&lt;T&gt; &amp;b,SparseMatrix&lt;T&gt; &amp;c)const&#123;</span><br><span class="line">	if(lieshu!&#x3D;b.hangshu)puts(&quot;WRONG!&quot;);</span><br><span class="line">	int ji&#x3D;0;</span><br><span class="line">	c.hangshu&#x3D;hangshu;</span><br><span class="line">	c.lieshu&#x3D;b.lieshu;</span><br><span class="line">	c.cursize&#x3D;0;</span><br><span class="line">	Term&lt;T&gt; *tmp;</span><br><span class="line">	tmp&#x3D;new Term&lt;T&gt; [cursize*b.cursize];</span><br><span class="line">	for(int i&#x3D;0;i&lt;&#x3D;cursize;i++)&#123;</span><br><span class="line">		for(int j&#x3D;0;j&lt;b.cursize;j++)&#123;</span><br><span class="line">			if(t[i].col&#x3D;&#x3D;b.t[j].row)&#123;</span><br><span class="line">				tmp[ji].row&#x3D;t[i].row;</span><br><span class="line">				tmp[ji].col&#x3D;b.t[j].col;</span><br><span class="line">				tmp[ji++].value&#x3D;(t[i].value)*(b.t[j].value);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;0;i&lt;ji;i++)&#123;</span><br><span class="line">		for(int j&#x3D;i+1;j&lt;ji;j++)&#123;</span><br><span class="line">			if(tmp[i].row&#x3D;&#x3D;tmp[j].row&amp;&amp;tmp[i].col&#x3D;&#x3D;tmp[j].col)&#123;</span><br><span class="line">				tmp[i].value&#x3D;tmp[i].value+tmp[j].value;</span><br><span class="line">				ji--;</span><br><span class="line">				for(int k&#x3D;j;k&lt;cursize;k++)&#123;</span><br><span class="line">					tmp[k].row&#x3D;tmp[k+1].row;</span><br><span class="line">					tmp[k].col&#x3D;tmp[k+1].col;</span><br><span class="line">					tmp[k].value&#x3D;tmp[k+1].value;</span><br><span class="line">				&#125;</span><br><span class="line">				j--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;0;i&lt;ji;i++)c.Append(tmp[i]);</span><br><span class="line">	c.no_zero();</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cout&lt;&lt;&quot;请输入稀疏矩阵总非0元素个数：&quot;;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	SparseMatrix&lt;int&gt; m1(n),m2(n),m3(n);</span><br><span class="line">	m1.get();</span><br><span class="line">	m1.show();</span><br><span class="line">	m2.get();</span><br><span class="line">	m2.show();</span><br><span class="line">	m1.Mul(m2,m3);</span><br><span class="line">	m3.show();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行效果：-1"><a href="#运行效果：-1" class="headerlink" title="运行效果："></a>运行效果：</h2><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kludf9wwj20b90cf75r.jpg" alt=""></p>
<hr>
<h1 id="作业三（51）："><a href="#作业三（51）：" class="headerlink" title="作业三（51）："></a>作业三（51）：</h1><p>给类linkerMatrix增加下列操作：<br>1）已知一个元素的行，列和数值，存储这个元素<br>2）已知一个元素的行和列，从矩阵中取出这个元素<br>3）两个稀疏矩阵相加<br>4）两个稀疏矩阵相减<br>5）两个稀疏矩阵相乘 </p>
<h2 id="基本思路：-1"><a href="#基本思路：-1" class="headerlink" title="基本思路："></a>基本思路：</h2><p>用单链表的原理存稀疏矩阵，和作业二的数组相比的优点是，不限制稀疏矩阵中非0元素的个数，所以根据单链表的原理添加头节点和尾节点这两个成员</p>
<p>1）存储某元素相当于单链表的Append方法</p>
<p>2）取出某元素相当于单链表的Search方法</p>
<p>3）相加，先判断行数列数合法性，然后我的处理是先把AB中的元素都Append到C中，接着用两个指针循环C，对C中的(i,j)相同的元素执行合并操作，注意最后要去0</p>
<p>4）和相加原理相同</p>
<p>5）相乘，原理同作业二，只有在a(i,k)和b(k,j)有相同的k的时候才会对答案产生贡献，将这些相乘的结果Append到C中，然后两个指针对C做合并的操作，最后去0</p>
<h2 id="时间复杂度：-2"><a href="#时间复杂度：-2" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>存储是o(1)，取出是o(n)，相加是o(2n+n^2)，相减是o(2n+n^2)，相乘是o(n^2+n^4)</p>
<h2 id="遇到问题及解决："><a href="#遇到问题及解决：" class="headerlink" title="遇到问题及解决："></a>遇到问题及解决：</h2><p>1.析构函数运行后出现野指针</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kludf649j20fz03odg7.jpg" alt=""></p>
<p>析构函数在delete first前加个判断，还有注意只有一个first的情况，最后是delete first</p>
<p style="background-color:rgba(255,255,0,0.8)">
2.（高亮高亮）重载输入输出运算符>><<时声明为友元就不能用。。不声明直接定义就能用了。。这是为什么呢！！！</p>

<p>一系列探索之后，问题转化为-&gt;<font size="6" color=#222222>（类模版+友元函数+重载运算符=？声明怎么写）</font></p>
<p>之前是这么声明的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">friend ostream&amp; operator&lt;&lt; &lt;T&gt;(ostream&amp;,LinkedMatrix&amp;);</span><br><span class="line">friend istream&amp; operator&gt;&gt; &lt;T&gt;(istream&amp;,LinkedMatrix&amp;);</span><br></pre></td></tr></table></figure>

<p>在经历了掉头发and掉头发and掉头发之后！！终于找到了资料！如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kludg3xzj20i50edgn5.jpg" alt=""></p>
<p>也就是说，我一开始的写法虽然是个大众方法，但是由于编译环境的不同，<font size="6" color=#222222>和标准库有冲突</font>，在sublime，devc++和codeblocks等是运行不了的</p>
<p>所以怎么办呢？</p>
<p><font size="6" color=#222222>在类中声明friend的时候，要定义一个和T不同的模板参数U</font></p>
<p>如下格式，问题完美解决<del>(≧▽≦)/</del>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class U&gt;</span><br><span class="line">friend ostream&amp; operator&lt;&lt; (ostream&amp;,LinkedMatrix&lt;U&gt;&amp;);</span><br><span class="line">template &lt;class U&gt;</span><br><span class="line">friend istream&amp; operator&gt;&gt; (istream&amp;,LinkedMatrix&lt;U&gt;&amp;);</span><br></pre></td></tr></table></figure>

<p>然后具体定义的时候是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">istream&amp; operator&gt;&gt; (istream&amp; is,LinkedMatrix&lt;T&gt;&amp; L)&#123;</span><br><span class="line">	&#x2F;&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.delete存在没有解决的问题</p>
<p>反正存在问题就是了，我还没懂，结案</p>
<h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">class Node&#123;</span><br><span class="line">public:</span><br><span class="line">	int row,col;</span><br><span class="line">    T value;</span><br><span class="line">    Node&lt;T&gt; *next;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class LinkedMatrix&#123;</span><br><span class="line">	template &lt;class U&gt;</span><br><span class="line">	friend ostream&amp; operator&lt;&lt; (ostream&amp;,LinkedMatrix&lt;U&gt;&amp;);</span><br><span class="line">	template &lt;class U&gt;</span><br><span class="line">	friend istream&amp; operator&gt;&gt; (istream&amp;,LinkedMatrix&lt;U&gt;&amp;);</span><br><span class="line">	public:</span><br><span class="line">		LinkedMatrix()&#123;</span><br><span class="line">			first&#x3D;NULL;last&#x3D;NULL;</span><br><span class="line">			hangshu&#x3D;lieshu&#x3D;cursize&#x3D;0;</span><br><span class="line">		&#125;;</span><br><span class="line">		LinkedMatrix(LinkedMatrix&lt;T&gt; &amp;B);</span><br><span class="line">		~LinkedMatrix();</span><br><span class="line">		LinkedMatrix operator&#x3D;(LinkedMatrix&lt;T&gt; &amp;B);</span><br><span class="line">		int Search(int i,int j,const T&amp; x)const; </span><br><span class="line">		void Append(int i,int j,const T&amp; x);</span><br><span class="line">		LinkedMatrix&lt;T&gt;&amp; Delete(int k);</span><br><span class="line">		void no_zero();</span><br><span class="line">		void Add(const LinkedMatrix&lt;T&gt; &amp;B,LinkedMatrix&lt;T&gt; &amp;C)const;</span><br><span class="line">		void Sub(const LinkedMatrix&lt;T&gt; &amp;B,LinkedMatrix&lt;T&gt; &amp;C)const;</span><br><span class="line">		void Mul(const LinkedMatrix&lt;T&gt; &amp;B,LinkedMatrix&lt;T&gt; &amp;C)const;</span><br><span class="line">		void get();</span><br><span class="line">		void show();</span><br><span class="line">		void Erase();</span><br><span class="line">	public:</span><br><span class="line">		int hangshu,lieshu,cursize;</span><br><span class="line">		Node&lt;T&gt; *first,*last;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">LinkedMatrix&lt;T&gt;::~LinkedMatrix()&#123;</span><br><span class="line">	Node&lt;T&gt; *p;</span><br><span class="line">	while(first-&gt;next!&#x3D;NULL)&#123;</span><br><span class="line">		p&#x3D;first-&gt;next;</span><br><span class="line">		if(first)&#123;</span><br><span class="line">			delete first;</span><br><span class="line">			first&#x3D;NULL;</span><br><span class="line">		&#125;</span><br><span class="line">		first&#x3D;p;</span><br><span class="line">	&#125;</span><br><span class="line">	delete first;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">LinkedMatrix&lt;T&gt;::LinkedMatrix(LinkedMatrix&lt;T&gt; &amp;B)&#123;</span><br><span class="line">	Node&lt;T&gt; *b;</span><br><span class="line">	for(b&#x3D;B.first;b;b&#x3D;b-&gt;next)&#123;</span><br><span class="line">		Node&lt;T&gt; *y&#x3D;new Node&lt;T&gt;;</span><br><span class="line">		y-&gt;row&#x3D;b-&gt;row;</span><br><span class="line">		y-&gt;col&#x3D;b-&gt;col;</span><br><span class="line">		y-&gt;value&#x3D;b-&gt;value;</span><br><span class="line">		if(first!&#x3D;NULL)&#123;</span><br><span class="line">			last-&gt;next&#x3D;y;</span><br><span class="line">			last&#x3D;y;</span><br><span class="line">		&#125;</span><br><span class="line">		else first&#x3D;last&#x3D;y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">LinkedMatrix&lt;T&gt; LinkedMatrix&lt;T&gt;::operator&#x3D;(LinkedMatrix&lt;T&gt; &amp;B)&#123;	</span><br><span class="line">	Node&lt;T&gt; *b;</span><br><span class="line">	for(b&#x3D;B.first;b;b&#x3D;b-&gt;next)&#123;</span><br><span class="line">		Node&lt;T&gt; *y&#x3D;new Node&lt;T&gt;;</span><br><span class="line">		y-&gt;row&#x3D;b-&gt;row;</span><br><span class="line">		y-&gt;col&#x3D;b-&gt;col;</span><br><span class="line">		y-&gt;value&#x3D;b-&gt;value;</span><br><span class="line">		if(first!&#x3D;NULL)&#123;</span><br><span class="line">			last-&gt;next&#x3D;y;</span><br><span class="line">			last&#x3D;y;</span><br><span class="line">		&#125;</span><br><span class="line">		else first&#x3D;last&#x3D;y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">istream&amp; operator&gt;&gt; (istream&amp; is,LinkedMatrix&lt;T&gt;&amp; L)&#123;</span><br><span class="line">	cout&lt;&lt;&quot;输入行数列数和非0元素个数：&quot;&lt;&lt;endl;</span><br><span class="line">	is&gt;&gt;L.hangshu&gt;&gt;L.lieshu&gt;&gt;L.cursize;</span><br><span class="line">	int i,j;</span><br><span class="line">	T data;</span><br><span class="line">	int num&#x3D;L.cursize;</span><br><span class="line">	for(int k&#x3D;0;k&lt;num;k++) &#123;</span><br><span class="line">		cout&lt;&lt;&quot;输入第&quot;&lt;&lt;(k+1)&lt;&lt;&quot;个元素的行号列号和该元素的值：&quot;&lt;&lt;endl;</span><br><span class="line">		is&gt;&gt;i&gt;&gt;j&gt;&gt;data;</span><br><span class="line">		if(i&gt;L.hangshu||j&gt;L.lieshu)&#123;</span><br><span class="line">			cout&lt;&lt;&quot;输入了无效的行列！请重新输入&quot;&lt;&lt;endl;</span><br><span class="line">			k--;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(data&#x3D;&#x3D;0)cout&lt;&lt;&quot;输入0了！这个数据会自动去除&quot;&lt;&lt;endl;</span><br><span class="line">		else L.Append(i,j,data);</span><br><span class="line">	&#125;</span><br><span class="line">	L.no_zero();</span><br><span class="line">	return is;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">ostream&amp; operator&lt;&lt; (ostream&amp; os,LinkedMatrix&lt;T&gt;&amp; L)&#123;</span><br><span class="line">	os&lt;&lt;&quot;行数&#x3D;&quot;&lt;&lt;L.hangshu&lt;&lt;&quot; 列数&#x3D;&quot;&lt;&lt;L.lieshu&lt;&lt;endl;</span><br><span class="line">	os&lt;&lt;&quot;当前非0元素个数&#x3D;&quot;&lt;&lt;L.cursize&lt;&lt;endl;</span><br><span class="line">	Node&lt;T&gt; *current;</span><br><span class="line">	for(current&#x3D;L.first;current;current&#x3D;current-&gt;next)</span><br><span class="line">		os&lt;&lt;&quot;M(&quot;&lt;&lt;current-&gt;row&lt;&lt;&#39;,&#39;&lt;&lt;current-&gt;col&lt;&lt;&quot;)&#x3D;&quot;&lt;&lt;current-&gt;value&lt;&lt;endl;</span><br><span class="line">	return os;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void LinkedMatrix&lt;T&gt;::get()&#123;</span><br><span class="line">	cout&lt;&lt;&quot;输入行数列数和非0元素个数：&quot;&lt;&lt;endl;</span><br><span class="line">	cin&gt;&gt;hangshu&gt;&gt;lieshu&gt;&gt;cursize;</span><br><span class="line">	int i,j;</span><br><span class="line">	T data;</span><br><span class="line">	int num&#x3D;cursize;</span><br><span class="line">	for(int k&#x3D;0;k&lt;num;k++) &#123;</span><br><span class="line">		cout&lt;&lt;&quot;输入第&quot;&lt;&lt;(k+1)&lt;&lt;&quot;个元素的行号列号和该元素的值：&quot;&lt;&lt;endl;</span><br><span class="line">		cin&gt;&gt;i&gt;&gt;j&gt;&gt;data;</span><br><span class="line">		if(i&gt;hangshu||j&gt;lieshu)&#123;</span><br><span class="line">			cout&lt;&lt;&quot;输入了无效的行列！请重新输入&quot;&lt;&lt;endl;</span><br><span class="line">			k--;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(data&#x3D;&#x3D;0)cout&lt;&lt;&quot;输入0了！这个数据会自动去除&quot;&lt;&lt;endl;</span><br><span class="line">		else this-&gt;Append(i,j,data);</span><br><span class="line">	&#125;</span><br><span class="line">	this-&gt;no_zero();</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void LinkedMatrix&lt;T&gt;::show()&#123;</span><br><span class="line">	cout&lt;&lt;&quot;行数&#x3D;&quot;&lt;&lt;hangshu&lt;&lt;&quot; 列数&#x3D;&quot;&lt;&lt;lieshu&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;当前非0元素个数&#x3D;&quot;&lt;&lt;cursize&lt;&lt;endl;</span><br><span class="line">	Node&lt;T&gt; *current;</span><br><span class="line">	for(current&#x3D;first;current;current&#x3D;current-&gt;next)</span><br><span class="line">		cout&lt;&lt;&quot;t(&quot;&lt;&lt;current-&gt;row&lt;&lt;&#39;,&#39;&lt;&lt;current-&gt;col&lt;&lt;&quot;)&#x3D;&quot;&lt;&lt;current-&gt;value&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void LinkedMatrix&lt;T&gt;::Erase()&#123;</span><br><span class="line">	if(cursize&#x3D;&#x3D;0)return;</span><br><span class="line">	Node&lt;T&gt; *p;</span><br><span class="line">	p&#x3D;first;</span><br><span class="line">	while(first-&gt;next!&#x3D;NULL)&#123;</span><br><span class="line">		p&#x3D;first-&gt;next;</span><br><span class="line">		delete first;</span><br><span class="line">		first&#x3D;p;</span><br><span class="line">	&#125;</span><br><span class="line">	delete p;</span><br><span class="line">	hangshu&#x3D;lieshu&#x3D;cursize&#x3D;0;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">int LinkedMatrix&lt;T&gt;::Search(int i,int j,const T &amp;x)const&#123;</span><br><span class="line">    Node&lt;T&gt; *current&#x3D;first;</span><br><span class="line">    int index&#x3D;1;</span><br><span class="line">    while(current&amp;&amp;!(current-&gt;row&#x3D;&#x3D;i&amp;&amp;current-&gt;col&#x3D;&#x3D;j))&#123;</span><br><span class="line">        current&#x3D;current-&gt;next;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(current)&#123;</span><br><span class="line">    	x&#x3D;current-&gt;value;</span><br><span class="line">    	return index;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void LinkedMatrix&lt;T&gt;::Append(int i,int j,const T&amp; x)&#123;</span><br><span class="line">	Node&lt;T&gt; *y&#x3D;new Node&lt;T&gt;;</span><br><span class="line">	y-&gt;value&#x3D;x;y-&gt;row&#x3D;i;y-&gt;col&#x3D;j;</span><br><span class="line">	y-&gt;next&#x3D;NULL;</span><br><span class="line">	if(first!&#x3D;NULL)&#123;</span><br><span class="line">	    last-&gt;next&#x3D;y;</span><br><span class="line">	    last&#x3D;y;</span><br><span class="line">	&#125;</span><br><span class="line">	else first&#x3D;last&#x3D;y;</span><br><span class="line">	cursize++;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">LinkedMatrix&lt;T&gt;&amp; LinkedMatrix&lt;T&gt;::Delete(int k)&#123;</span><br><span class="line">    if(k&lt;1||!first||k&gt;cursize)cout&lt;&lt;&quot;删除出错！&quot;&lt;&lt;endl;</span><br><span class="line">    Node&lt;T&gt; *p&#x3D;first;</span><br><span class="line">    if(k&#x3D;&#x3D;1)first&#x3D;first-&gt;next;</span><br><span class="line">    else&#123;</span><br><span class="line">        Node&lt;T&gt; *q&#x3D;first;</span><br><span class="line">        for(int index&#x3D;1;index&lt;k-1&amp;&amp;q;index++)q&#x3D;q-&gt;next;</span><br><span class="line">        if(!q||!q-&gt;next)cout&lt;&lt;&quot;WORNG&quot;&lt;&lt;endl;</span><br><span class="line">        p&#x3D;q-&gt;next;</span><br><span class="line">        q-&gt;next&#x3D;p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cursize--;</span><br><span class="line">    delete p;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void LinkedMatrix&lt;T&gt;::no_zero()&#123;</span><br><span class="line">	Node&lt;T&gt; *current;</span><br><span class="line">	int ji;</span><br><span class="line">    for(current&#x3D;first,ji&#x3D;1;current;current&#x3D;current-&gt;next,ji++)</span><br><span class="line">    	if(current-&gt;value&#x3D;&#x3D;0)Delete(ji);</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void LinkedMatrix&lt;T&gt;::Add(const LinkedMatrix&lt;T&gt; &amp;B,LinkedMatrix&lt;T&gt; &amp;C)const&#123;</span><br><span class="line">	if(B.hangshu!&#x3D;hangshu||B.lieshu!&#x3D;lieshu)&#123;</span><br><span class="line">		cout&lt;&lt;&quot;WRONG!&quot;&lt;&lt;endl;return;</span><br><span class="line">	&#125;</span><br><span class="line">	C.hangshu&#x3D;hangshu;C.lieshu&#x3D;lieshu;</span><br><span class="line">	Node&lt;T&gt; *a,*b,*c,*p;</span><br><span class="line">	int i,j;</span><br><span class="line">	T data;</span><br><span class="line">	c&#x3D;C.first;</span><br><span class="line">	for(a&#x3D;first;a;a&#x3D;a-&gt;next)&#123;</span><br><span class="line">		i&#x3D;a-&gt;row;j&#x3D;a-&gt;col;data&#x3D;a-&gt;value;</span><br><span class="line">		C.Append(i,j,data);</span><br><span class="line">	&#125;</span><br><span class="line">	for(b&#x3D;B.first;b;b&#x3D;b-&gt;next)&#123;</span><br><span class="line">		i&#x3D;b-&gt;row;j&#x3D;b-&gt;col;data&#x3D;b-&gt;value;</span><br><span class="line">		C.Append(i,j,data);</span><br><span class="line">	&#125;</span><br><span class="line">	for(c&#x3D;C.first,i&#x3D;1;c;c&#x3D;c-&gt;next,i++)&#123;</span><br><span class="line">		for(p&#x3D;c-&gt;next,j&#x3D;i+1;p;j++)&#123;</span><br><span class="line">			if(c-&gt;row&#x3D;&#x3D;p-&gt;row&amp;&amp;c-&gt;col&#x3D;&#x3D;p-&gt;col)&#123;</span><br><span class="line">				c-&gt;value&#x3D;c-&gt;value+p-&gt;value;</span><br><span class="line">				C.Delete(j);</span><br><span class="line">			&#125;</span><br><span class="line">			if(p)p&#x3D;p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	C.no_zero();</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void LinkedMatrix&lt;T&gt;::Sub(const LinkedMatrix&lt;T&gt; &amp;B,LinkedMatrix&lt;T&gt; &amp;C)const&#123;</span><br><span class="line">	if(B.hangshu!&#x3D;hangshu||B.lieshu!&#x3D;lieshu)&#123;</span><br><span class="line">		cout&lt;&lt;&quot;WRONG!&quot;&lt;&lt;endl;return;</span><br><span class="line">	&#125;</span><br><span class="line">	C.hangshu&#x3D;hangshu;C.lieshu&#x3D;lieshu;</span><br><span class="line">	Node&lt;T&gt; *a,*b,*c,*p;</span><br><span class="line">	int i,j;</span><br><span class="line">	T data;</span><br><span class="line">	c&#x3D;C.first;</span><br><span class="line">	for(a&#x3D;first;a;a&#x3D;a-&gt;next)&#123;</span><br><span class="line">		i&#x3D;a-&gt;row;j&#x3D;a-&gt;col;data&#x3D;a-&gt;value;</span><br><span class="line">		C.Append(i,j,data);</span><br><span class="line">	&#125;</span><br><span class="line">	for(b&#x3D;B.first;b;b&#x3D;b-&gt;next)&#123;</span><br><span class="line">		i&#x3D;b-&gt;row;j&#x3D;b-&gt;col;data&#x3D;-(b-&gt;value);</span><br><span class="line">		C.Append(i,j,data);</span><br><span class="line">	&#125;</span><br><span class="line">	for(c&#x3D;C.first,i&#x3D;1;c;c&#x3D;c-&gt;next,i++)&#123;</span><br><span class="line">		for(p&#x3D;c-&gt;next,j&#x3D;i+1;p;j++)&#123;</span><br><span class="line">			if(c-&gt;row&#x3D;&#x3D;p-&gt;row&amp;&amp;c-&gt;col&#x3D;&#x3D;p-&gt;col)&#123;</span><br><span class="line">				c-&gt;value&#x3D;c-&gt;value+p-&gt;value;</span><br><span class="line">				C.Delete(j);</span><br><span class="line">			&#125;</span><br><span class="line">			if(p)p&#x3D;p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	C.no_zero();</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void LinkedMatrix&lt;T&gt;::Mul(const LinkedMatrix&lt;T&gt; &amp;B,LinkedMatrix&lt;T&gt; &amp;C)const&#123;</span><br><span class="line">	if(B.hangshu!&#x3D;lieshu)&#123;</span><br><span class="line">		cout&lt;&lt;&quot;WRONG!&quot;&lt;&lt;endl;return;</span><br><span class="line">	&#125;</span><br><span class="line">	C.hangshu&#x3D;hangshu;C.lieshu&#x3D;B.lieshu;</span><br><span class="line">	Node&lt;T&gt; *a,*b,*c,*p;</span><br><span class="line">	int i,j;</span><br><span class="line">	T data;</span><br><span class="line">	c&#x3D;C.first;</span><br><span class="line">	for(a&#x3D;first;a;a&#x3D;a-&gt;next)&#123;</span><br><span class="line">		for(b&#x3D;B.first;b;b&#x3D;b-&gt;next)&#123;</span><br><span class="line">			if(a-&gt;col&#x3D;&#x3D;b-&gt;row)&#123;</span><br><span class="line">				i&#x3D;a-&gt;row;j&#x3D;b-&gt;col;data&#x3D;(a-&gt;value)*(b-&gt;value);</span><br><span class="line">				C.Append(i,j,data);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(c&#x3D;C.first,i&#x3D;1;c;c&#x3D;c-&gt;next,i++)&#123;</span><br><span class="line">		for(p&#x3D;c-&gt;next,j&#x3D;i+1;p;j++)&#123;</span><br><span class="line">			if(c-&gt;row&#x3D;&#x3D;p-&gt;row&amp;&amp;c-&gt;col&#x3D;&#x3D;p-&gt;col)&#123;</span><br><span class="line">				c-&gt;value&#x3D;c-&gt;value+p-&gt;value;</span><br><span class="line">				C.Delete(j);</span><br><span class="line">			&#125;</span><br><span class="line">			if(p)p&#x3D;p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	C.no_zero();</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	LinkedMatrix&lt;int&gt; A,B,C;</span><br><span class="line">	cin&gt;&gt;A;</span><br><span class="line">	cin&gt;&gt;B;</span><br><span class="line">	A.Add(B,C);</span><br><span class="line">	cout&lt;&lt;&quot;-------A+B-------&quot;&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;C;</span><br><span class="line">	C.Erase();</span><br><span class="line">	A.Sub(B,C);</span><br><span class="line">	cout&lt;&lt;&quot;-------A-B-------&quot;&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;C;</span><br><span class="line">	C.Erase();</span><br><span class="line">	A.Mul(B,C);</span><br><span class="line">	cout&lt;&lt;&quot;-------A*B-------&quot;&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;C;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行效果：-2"><a href="#运行效果：-2" class="headerlink" title="运行效果："></a>运行效果：</h2><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klvivr2nj20cb0fftag.jpg" alt=""></p>
<p>去0效果：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klvixcb0j20dy0c6myk.jpg" alt=""></p>
]]></content>
      <categories>
        <category>一些作业</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>递归 —— 汉诺塔&amp;双色汉诺塔（分离型）</title>
    <url>/a8a3dabc/</url>
    <content><![CDATA[<p>网上甚至连<s>能盗用的</s>好看的双色汉诺塔的图都没有。。只好自己画了ᶘ ᵒᴥᵒᶅ 为啥大佬们总能知道一些奇奇怪怪的有趣的东西</p>
<p>双色的和网上的答案对拍了一下，应该是正解，三色补在这篇了 -&gt; <a href="https://leflacon.github.io/3fcdc8fa/" target="_blank" rel="noopener">递归 —— 三色汉诺塔（分离型）</a></p>
<hr>
<h1 id="1-单色汉诺塔"><a href="#1-单色汉诺塔" class="headerlink" title="1.单色汉诺塔"></a>1.单色汉诺塔</h1><p>首先回忆一下普通汉诺塔的递归原理：</p>
<blockquote>
<p>1）将A上n-1个盘子借助C移到B上</p>
<p>2）把A上剩下的一个盘移到C上</p>
<p>3）将n-1个盘从B借助于A移到C上</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void hanoi(int n,char x,char y,char z)&#123;</span><br><span class="line">    if(n&#x3D;&#x3D;1)cout&lt;&lt;x&lt;&lt;&quot;-&gt;&quot;&lt;&lt;z&lt;&lt;endl;</span><br><span class="line">    else&#123;</span><br><span class="line">        hanoi(n-1,x,z,y);&#x2F;&#x2F;前n-1个盘子从x移动到y上</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;&quot;—&gt;&quot;&lt;&lt;z&lt;&lt;endl;</span><br><span class="line">        &#x2F;&#x2F;将最底下的最后一个盘子从x移动到z上</span><br><span class="line">        hanoi(n-1,y,x,z);&#x2F;&#x2F;将y上的n-1个盘子移动到z上</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-双色汉诺塔"><a href="#2-双色汉诺塔" class="headerlink" title="2.双色汉诺塔"></a>2.双色汉诺塔</h1><p>双色汉诺塔就是下图这个意思，其他条件都和普通汉诺塔一样</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klpwuu03j20lo0ft74w.jpg" alt=""></p>
<h2 id="1）双色汉诺塔基本思路："><a href="#1）双色汉诺塔基本思路：" class="headerlink" title="1）双色汉诺塔基本思路："></a>1）双色汉诺塔基本思路：</h2><p>所以双色汉诺塔的递归思路就是：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klpwty5yj20l907g74g.jpg" alt=""></p>
<p>1.把A上的n-2个借助B移到C上</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klpwvoyaj20lc07ngls.jpg" alt=""></p>
<p>2.把A上的两个大盘移到B</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klqock2pj20l707lmxb.jpg" alt=""></p>
<p>3.把C上的n-2个借助B移回A上</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klqod9cmj20l807iaa9.jpg" alt=""></p>
<p>4.把B上的另一个大圆盘移到C</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klqocnfcj20l407iwen.jpg" alt=""></p>
<p>现在BC的底座都已经放好了，所以变成了一个新的子问题，也就是n-2个盘的双色汉诺塔</p>
<p>所以考虑跑循环(n/2-1)次求解，上面的1，3步骤其实就各相当于一次完整的一色汉诺塔的操作，比如步骤1即相当于一色汉诺塔中把n-2个汉诺塔从a移到c，按照一色汉诺塔的递归步骤来即可</p>
<p>也就是说如果要把n-2个汉诺塔从a移到c，就先把n-4个汉诺塔借助c移到b，然后把第n-2号和n-3号的盘移到c，然后把n-4个汉诺塔借助a移到c（可见，这个子步骤和一色汉诺塔唯一不同的就是，n=1的时候是直接操作两个同宽塔的，要cout两次）</p>
<h2 id="2）代码："><a href="#2）代码：" class="headerlink" title="2）代码："></a>2）代码：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void hanoi(int n,char a,char b,char c)&#123;</span><br><span class="line">	if(n&#x3D;&#x3D;1)&#123;</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		hanoi(n-1,a,c,b);</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">		hanoi(n-1,b,a,c);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void hanoi2(int n,char a,char b,char c)&#123;</span><br><span class="line">	for(int i&#x3D;n&#x2F;2;i&gt;1;i--)&#123;</span><br><span class="line">		hanoi(i-1,a,b,c);</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">		hanoi(i-1,c,b,a);</span><br><span class="line">		cout&lt;&lt;b&lt;&lt;&quot;-&gt;&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;b&lt;&lt;&quot;-&gt;&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int nn;</span><br><span class="line">	cin&gt;&gt;nn;</span><br><span class="line">	char a&#x3D;&#39;A&#39;,b&#x3D;&#39;B&#39;,c&#x3D;&#39;C&#39;;</span><br><span class="line">	hanoi2(nn,a,b,c);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3）运行结果和分析："><a href="#3）运行结果和分析：" class="headerlink" title="3）运行结果和分析："></a>3）运行结果和分析：</h2><p>输出了n=2，4，6，8，10……的情况</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klrmqptyj20g10cg0tm.jpg" alt=""></p>
<p>然后oeis，没有这个序列( ･᷄ὢ･᷅ )怀疑自己是不是错了，然后发现，诶这些数列好像都是接近两倍的关系，不如乱搞一下试试</p>
<p>如果f(0)初始为-1，输出<code>f(n)-f(n-1)*2</code>就会产生如下结果：</p>
<p>嗷真是好看啊٩(˃̶͈̀௰˂̶͈́)و就是它了我觉得OK</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klrysizxj20fz0d375f.jpg" alt=""></p>
<p>这个方法的巧妙之处在于，子递归and两个两个的移动，相当于把2n又回归到了n时的复杂度，因为一阶汉诺塔的次数是<code>f(n)=2^n-1</code>，所以2n小一半差的是根号级别的</p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
  </entry>
  <entry>
    <title>codevs 1068 乌龟棋 2010NOIP（四维dp）</title>
    <url>/e31679e2/</url>
    <content><![CDATA[<h3 id="题目描述-Description"><a href="#题目描述-Description" class="headerlink" title="题目描述 Description"></a>题目描述 Description</h3><p>小明过生日的时候，爸爸送给他一副乌龟棋当作礼物。 乌龟棋的棋盘是一行N个格子，每个格子上一个分数（非负整数）。棋盘第1格是唯一 的起点，第N格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。</p>
<p>…… 1 2 3 4 5 ……N 乌龟棋中M张爬行卡片，分成4种不同的类型（M张卡片中不一定包含所有4种类型 的卡片，见样例），每种类型的卡片上分别标有1、2、3、4四个数字之一，表示使用这种卡 片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择 一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。 游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到 该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的 分数总和。 很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡 片使用顺序使得最终游戏得分最多。 现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到 多少分吗？</p>
<h3 id="输入描述-Input-Description"><a href="#输入描述-Input-Description" class="headerlink" title="输入描述 Input Description"></a>输入描述 Input Description</h3><p>输入的每行中两个数之间用一个空格隔开。 第1行2个正整数N和M，分别表示棋盘格子数和爬行卡片数。 第2行N个非负整数，a1a2……aN</p>
<p>，其中ai表示棋盘第i个格子上的分数。 第3行M个整数，b1b2……bM</p>
<p>，表示M张爬行卡片上的数字。 输入数据保证到达终点时刚好用光M张爬行卡片，即N - 1=∑(1-&gt;M) bi</p>
<p>输出描述 Output Description<br>输出一行一个整数</p>
<h3 id="样例输入-Sample-Input"><a href="#样例输入-Sample-Input" class="headerlink" title="样例输入 Sample Input"></a>样例输入 Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13 8</span><br><span class="line">4 96 10 64 55 13 94 53 5 24 89 8 30</span><br><span class="line">1 1 1 1 1 2 4 1</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-Sample-Output"><a href="#样例输出-Sample-Output" class="headerlink" title="样例输出 Sample Output"></a>样例输出 Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">455</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p><code>1*n</code>个格子，每个格子一个分数，m张卡片，上面标有1，2，3，4，数字几代表向前走几格，每张卡用一次，求起点到终点能获得的最大分数</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>用a,b,c,d表示四类卡片，f[a][b][c][d]表示用了a张1，b张2，c张3，d张4的情况下能获得的最大分数，也就是说当前的位置是<code>a+2*b+3*c+4*d+1</code></p>
<p>所以可以得到状态转移方程为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[a+1][b][c][d]&#x3D;max(dp[a+1][b][c][d],dp[a][b][c][d]+v[(a+1)+2*b+3*c+4*d+1]);</span><br><span class="line">dp[a][b+1][c][d]&#x3D;max(dp[a][b+1][c][d],dp[a][b][c][d]+v[a+2*(b+1)+3*c+4*d+1]);</span><br><span class="line">dp[a][b][c+1][d]&#x3D;max(dp[a][b][c+1][d],dp[a][b][c][d]+v[a+2*b+3*(c+1)+4*d+1]);</span><br><span class="line">dp[a][b][c][d+1]&#x3D;max(dp[a][b][c][d+1],dp[a][b][c][d]+v[a+2*b+3*c+4*(d+1)+1]);</span><br></pre></td></tr></table></figure>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int v[355],dp[42][42][42][42],num[5]&#x3D;&#123;0&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,m,tmp;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)scanf(&quot;%d&quot;,&amp;v[i]);</span><br><span class="line">	for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;tmp);</span><br><span class="line">		num[tmp]++;</span><br><span class="line">	&#125;</span><br><span class="line">	dp[0][0][0][0]&#x3D;v[1];</span><br><span class="line">	for(int a&#x3D;0;a&lt;&#x3D;num[1];a++)</span><br><span class="line">		for(int b&#x3D;0;b&lt;&#x3D;num[2];b++)</span><br><span class="line">			for(int c&#x3D;0;c&lt;&#x3D;num[3];c++)</span><br><span class="line">				for(int d&#x3D;0;d&lt;&#x3D;num[4];d++)&#123;</span><br><span class="line">					dp[a+1][b][c][d]&#x3D;max(dp[a+1][b][c][d],dp[a][b][c][d]+v[(a+1)+2*b+3*c+4*d+1]);</span><br><span class="line">					dp[a][b+1][c][d]&#x3D;max(dp[a][b+1][c][d],dp[a][b][c][d]+v[a+2*(b+1)+3*c+4*d+1]);</span><br><span class="line">					dp[a][b][c+1][d]&#x3D;max(dp[a][b][c+1][d],dp[a][b][c][d]+v[a+2*b+3*(c+1)+4*d+1]);</span><br><span class="line">					dp[a][b][c][d+1]&#x3D;max(dp[a][b][c][d+1],dp[a][b][c][d]+v[a+2*b+3*c+4*(d+1)+1]);</span><br><span class="line">				&#125;</span><br><span class="line">	printf(&quot;%d\n&quot;,dp[num[1]][num[2]][num[3]][num[4]]);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 数据挖掘之k-means算法实现聚类（Ps：万圣节快乐呀🎃）</title>
    <url>/5a29f513/</url>
    <content><![CDATA[<p>临危受命0.0现学现卖。。过神经网络之门而不入。。万事开头难啊，就剩半天了写个kmeans先，有空再试试神经网络吧，不过数据挖掘还蛮有意思的，要是以后有这个课我就去选一个</p>
<p>蟹蟹AllenOris大佬大概给我讲的点思路and愚蠢至极的bug(;´༎ຶД༎ຶ`)，「blood」竟然算某种颜色，我以为是「成分」的意思，找了半个晚上的bug最后竟然是枚举漏了。。</p>
<a id="more"></a>

<hr>
<h1 id="题目背景："><a href="#题目背景：" class="headerlink" title="题目背景："></a>题目背景：</h1><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klikwxf8j20ku0extac.jpg" alt=""></p>
<p>每年的十一月一日是西方国家的万圣节，请用数据建立模型对鬼的类型进行分类</p>
<p>数据样式如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kljmmc9hj20iq05hdja.jpg" alt=""></p>
<p><code>sklearn</code>中的<code>train_test_split()</code>函数就可以直接将矩阵随机划分为训练子集和测试子集，详见<a href="https://leflacon.github.io/8b10921e/" target="_blank" rel="noopener">sklearn随机划分数据函数</a>，当时划分数据部分未做处理，只完成了用数据建立模型对鬼进行分类</p>
<hr>
<h1 id="一-kmeans算法："><a href="#一-kmeans算法：" class="headerlink" title="一.kmeans算法："></a>一.kmeans算法：</h1><h2 id="1-基本思路："><a href="#1-基本思路：" class="headerlink" title="1.基本思路："></a>1.基本思路：</h2><p>1)随机选取k个中心点，也就是把数据分成k类</p>
<blockquote>
<p>这些点的选择会很大程度上影响到最终的结果，如果没选好对结果影响比较大</p>
<p>有两种处理方法，一种是多次取均值，另一种是改进算法（bisecting K-means）</p>
</blockquote>
<p>2)遍历所有数据，将每个数据划分到最近的中心点中</p>
<blockquote>
<p>采用欧式距离作为变量之间的聚类函数，每次朝一个变量ci的方向找到最优解，k-means算法的基础是<strong>最小误差平方和准则</strong></p>
</blockquote>
<p>3)计算每个聚类的平均值，并作为新的中心点</p>
<p>4)重复2-3，直到这k个中心点收敛了或执行了足够多的迭代</p>
<h2 id="2-复杂度："><a href="#2-复杂度：" class="headerlink" title="2.复杂度："></a>2.复杂度：</h2><p>时间复杂度:<code>O(I*n*k*m)</code></p>
<p>空间复杂度:<code>O(n*m)</code></p>
<p>其中m为每个元素字段个数，n为数据量，I为迭代次数，一般情况下I,k,m均可认为是常量，所以时间和空间复杂度可以简化为O(n)</p>
<h1 id="二-题目分析："><a href="#二-题目分析：" class="headerlink" title="二.题目分析："></a>二.题目分析：</h1><h2 id="1-数据处理："><a href="#1-数据处理：" class="headerlink" title="1.数据处理："></a>1.数据处理：</h2><p>小鬼怪有5个属性：<br><code>bone_length,rotting_flesh,hair_length,has_soul,color</code></p>
<p>基本思路就是根据这五个属性建立向量，然后用kmeans求得收敛的中心点，其中前四个属性都是float型的比较好处理，第五个color给的是str类型的数据，笔者的处理方法是将所有类型写出用if……elif……判断，再强制类型转化的赋值0.1～0.6，这种方法比较草率但是实现起来相当简单</p>
<p>而且考虑到其他的数据范围基本都是0～1之间的浮点数，所以求欧式距离的时候不会产生很大的偏差，在这个数据背景下该思路应该是可行的，但是实际上这种方法并不很准确，因为0.1和0.6都代表颜色，但是他们和0.5的差不同，而理论上来说这是有误的</p>
<p>当然这里对于str类型的处理还有一种高级的方法叫「one-hot编码」，写在这篇里面了，<a href="https://leflacon.github.io/d6da51a9" target="_blank" rel="noopener">pandas实现one-hot编码（独热编码）</a> ，如果用one-hot编码的话，相当于是把这个题5个坐标扩充成了10个</p>
<h1 id="三-代码："><a href="#三-代码：" class="headerlink" title="三.代码："></a>三.代码：</h1><p>代码和数据一起丢github上了</p>
<p>数据：<a href="https://github.com/LeFlacon/Simple-Python-Practice/blob/master/Halloween.csv" target="_blank" rel="noopener">https://github.com/LeFlacon/Simple-Python-Practice/blob/master/Halloween.csv</a></p>
<p>代码：<a href="https://github.com/LeFlacon/Simple-Python-Practice/blob/master/Halloween.py" target="_blank" rel="noopener">https://github.com/LeFlacon/Simple-Python-Practice/blob/master/Halloween.py</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from numpy import *</span><br><span class="line"></span><br><span class="line">def loaddata_set(fileName):</span><br><span class="line">    data&#x3D;[]</span><br><span class="line">    f&#x3D;open(fileName)</span><br><span class="line">    ff&#x3D;f.readlines()</span><br><span class="line">    del ff[0]</span><br><span class="line">    for line in ff:</span><br><span class="line">        s&#x3D;line.strip().split(&#39;,&#39;)</span><br><span class="line">        if(&#39;clear&#39; in s[5]):</span><br><span class="line">            s[5]&#x3D;(float)(0.1)</span><br><span class="line">        elif (&#39;green&#39; in s[5]):</span><br><span class="line">            s[5]&#x3D;(float)(0.2)</span><br><span class="line">        elif (&#39;black&#39; in s[5]):</span><br><span class="line">            s[5]&#x3D;(float)(0.3)</span><br><span class="line">        elif (&#39;white&#39; in s[5]):</span><br><span class="line">            s[5]&#x3D;(float)(0.4)</span><br><span class="line">        elif (&#39;blue&#39; in s[5]):</span><br><span class="line">            s[5]&#x3D;(float)(0.5)</span><br><span class="line">        elif (&#39;blood&#39; in s[5]):</span><br><span class="line">            s[5]&#x3D;(float)(0.6)</span><br><span class="line">        del s[6]</span><br><span class="line">        del s[0]</span><br><span class="line">        ll&#x3D;list(map(float,s))</span><br><span class="line">        data.append(ll)</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">#欧几里得距离</span><br><span class="line">def distance_e(vecA, vecB):</span><br><span class="line">    return sqrt(sum(power(vecA-vecB,2)))</span><br><span class="line"></span><br><span class="line">#取k个随机质心</span><br><span class="line">def rand_center(data_set,k):</span><br><span class="line">    n&#x3D;shape(data_set)[1]</span><br><span class="line">    centerr&#x3D;mat(zeros((k,n)))#每个质心n个坐标值</span><br><span class="line">    for j in range(n):</span><br><span class="line">        minj&#x3D;min(data_set[:,j])</span><br><span class="line">        maxj&#x3D;max(data_set[:,j])</span><br><span class="line">        cha&#x3D;float(maxj-minj)</span><br><span class="line">        centerr[:,j]&#x3D;minj+cha*random.rand(k,1)</span><br><span class="line">    return centerr</span><br><span class="line"></span><br><span class="line">#kmeans算法</span><br><span class="line">def kmeans(data_set,k,distMeans&#x3D;distance_e,createCent&#x3D;rand_center):</span><br><span class="line">    m&#x3D;shape(data_set)[0]</span><br><span class="line">    ans_classify&#x3D;mat(zeros((m,2)))</span><br><span class="line">    #第一列存所属的质心，第二列存到质心的距离</span><br><span class="line">    centerr&#x3D;createCent(data_set,k)</span><br><span class="line">    flag&#x3D;True#是否已收敛</span><br><span class="line">    while flag:</span><br><span class="line">        flag&#x3D;False;</span><br><span class="line">        for i in range(m):#把每一个数据点划分到离它最近的质心</span><br><span class="line">            minn&#x3D;inf;</span><br><span class="line">            cur&#x3D;-1;</span><br><span class="line">            for j in range(k):</span><br><span class="line">                juli&#x3D;distMeans(centerr[j,:],data_set[i,:])</span><br><span class="line">                if juli&lt;minn:</span><br><span class="line">                    minn&#x3D;juli;cur&#x3D;j#如果第i个数据点到第j个中心点更近，则将i归属为j</span><br><span class="line">            if ans_classify[i,0]!&#x3D;cur:flag&#x3D;True;  #如果分配发生变化，则需要继续迭代</span><br><span class="line">            ans_classify[i,:]&#x3D;cur,minn**2#将第i个数据点的情况存入字典</span><br><span class="line">        print(centerr)</span><br><span class="line">        for cc in range(k):#重新计算中心点</span><br><span class="line">            ptsInClust&#x3D;data_set[nonzero(ans_classify[:,0].A&#x3D;&#x3D;cc)[0]]#去第一列等于cent的所有列</span><br><span class="line">            centerr[cc,:]&#x3D;mean(ptsInClust,axis&#x3D;0)#算出这些数据的中心点</span><br><span class="line">    return centerr,ans_classify</span><br><span class="line"></span><br><span class="line">data_mat&#x3D;mat(loaddata_set(&#39;Halloween.csv&#39;))</span><br><span class="line">getcenter,get_classify&#x3D;kmeans(data_mat,3)</span><br><span class="line">print(getcenter)</span><br><span class="line">print(get_classify)</span><br></pre></td></tr></table></figure>

<h1 id="四-运行结果："><a href="#四-运行结果：" class="headerlink" title="四.运行结果："></a>四.运行结果：</h1><p>只截取了部分，图中可以看出，最后已经获得了k个收敛的质心，并且后面的数据第一列输出了小鬼怪的种类，第二列输出了它和质心的欧几里得距离</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kljmnamfj20ck0actd2.jpg" alt=""></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kljmnchjj208d0gdtal.jpg" alt=""></h2><h1 id="五-其他："><a href="#五-其他：" class="headerlink" title="五.其他："></a>五.其他：</h1><h2 id="普通方法搭建一个神经网络-BP神经网络模型"><a href="#普通方法搭建一个神经网络-BP神经网络模型" class="headerlink" title="普通方法搭建一个神经网络(BP神经网络模型)"></a>普通方法搭建一个神经网络(BP神经网络模型)</h2><p>啥玩意儿啊咋回事儿啊先放着吧。。mark一下以后耍</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klk3rbrhj20d706bwfc.jpg" alt=""></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python pandas实现one-hot编码（独热编码）</title>
    <url>/d6da51a9/</url>
    <content><![CDATA[<p>对于不同类型的离散特征有两种处理方法：</p>
<p>1）map映射（如果数据之间有大小关系，那么可知直接映射一个值）</p>
<p>2）one-hot编码</p>
<p>one-hot编码使用于离散特征的取值没有什么大小关系的情况，比如color:[black,white,blue]</p>
<p>如果这几项之间并没有大小关系，但是仍需要把他们转化为向量来做聚类分析，这时候可以用pandas对离散型特征进行<code>one-hot</code>编码</p>
<p>如果编码前只有一个特征color，<code>one-hot</code>编码后会得到三个特征<code>color_black,color_white,color_blue</code>，特征值为0或1</p>
<h2 id="测试代码："><a href="#测试代码：" class="headerlink" title="测试代码："></a>测试代码：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">print(&quot;---初始数据集---\n&quot;)</span><br><span class="line">data&#x3D;pd.DataFrame([</span><br><span class="line">    [&#39;red&#39;,&#39;class1&#39;,&#39;yi&#39;,0.233333],</span><br><span class="line">    [&#39;green&#39;,&#39;class2&#39;,&#39;er&#39;,0.654321],</span><br><span class="line">    [&#39;blue&#39;,&#39;class1&#39;,&#39;san&#39;,0.123456]])</span><br><span class="line">data.columns&#x3D;[&#39;color&#39;,&#39;class&#39;,&#39;id&#39;,&#39;value&#39;]</span><br><span class="line">print(data)</span><br><span class="line"></span><br><span class="line">print(&quot;---映射后数据集---\n&quot;)</span><br><span class="line">mapp1&#x3D;&#123;</span><br><span class="line">    &#39;yi&#39;:11,</span><br><span class="line">    &#39;er&#39;:22,</span><br><span class="line">    &#39;san&#39;:33&#125;</span><br><span class="line">data[&#39;id&#39;]&#x3D;data[&#39;id&#39;].map(mapp1)</span><br><span class="line">mapp2&#x3D;&#123;label:idx for idx,label in enumerate(set(data[&#39;class&#39;]))&#125;</span><br><span class="line">data[&#39;class&#39;]&#x3D;data[&#39;class&#39;].map(mapp2)</span><br><span class="line">print(data)</span><br><span class="line"></span><br><span class="line">print(&quot;---「one-hot」后数据集---\n&quot;)</span><br><span class="line">data&#x3D;pd.get_dummies(data)</span><br><span class="line"></span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure>
<h2 id="运行效果如图："><a href="#运行效果如图：" class="headerlink" title="运行效果如图："></a>运行效果如图：</h2><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klikwsekj20fg082dgu.jpg" alt=""></p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>sklearn随机划分数据函数 -- train test split()</title>
    <url>/8b10921e/</url>
    <content><![CDATA[<h2 id="sklearn之train-test-split"><a href="#sklearn之train-test-split" class="headerlink" title="sklearn之train_test_split()"></a><code>sklearn之train_test_split()</code></h2><p><code>train_test_split</code>函数用于将矩阵随机划分为训练子集和测试子集，并返回划分好的训练集测试集样本和训练集测试集标签</p>
<a id="more"></a>

<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X_train,X_test, y_train, y_test&#x3D;cross_validation.train_test_split</span><br><span class="line">(train_data,train_target,test_size&#x3D;0.3, random_state&#x3D;0)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数解释：</p>
<p>train_data：被划分的样本特征集</p>
<p>train_target：被划分的样本标签</p>
<p>test_size：如果是浮点数，在0-1之间，表示样本占比；如果是整数的话就是样本的数量</p>
<p>random_state：是随机数的种子</p>
</blockquote>
<h2 id="测试代码："><a href="#测试代码：" class="headerlink" title="测试代码："></a>测试代码：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line"></span><br><span class="line">X,Y&#x3D;np.arange(24).reshape((8,3)),range(8)</span><br><span class="line"></span><br><span class="line">print(X)</span><br><span class="line"></span><br><span class="line">print(list(Y))</span><br><span class="line"></span><br><span class="line">X_train,X_test,Y_train,Y_test&#x3D;train_test_split(X,Y,test_size&#x3D;0.25,random_state&#x3D;0)</span><br><span class="line"></span><br><span class="line">print(X_train)</span><br><span class="line"></span><br><span class="line">print(X_test)</span><br><span class="line"></span><br><span class="line">print(Y_train)</span><br><span class="line"></span><br><span class="line">print(Y_test)</span><br></pre></td></tr></table></figure>

<h2 id="运行效果如图："><a href="#运行效果如图：" class="headerlink" title="运行效果如图："></a>运行效果如图：</h2><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klikwtz3j20ft0buq44.jpg" alt=""></p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-abbrlink（hexo链接优化）</title>
    <url>/a2c7bf23/</url>
    <content><![CDATA[<p>之前的permalink是这样的<code>permalink: :year/:month/:day/:title/</code></p>
<p>然后在网上看见说这种命名方式太多层了，爬虫不好爬，而且中文命名方式如果要引用自己的链接的话就很麻烦，（因为会重新编码成好长一串），并且中文链接在百度Google权重很低</p>
<p>然后在网上找到了一个大神写的插件<code>hexo-abbrlink</code>，酷，很酷，特别酷</p>
<hr>
<h2 id="hexo-abbrlink"><a href="#hexo-abbrlink" class="headerlink" title="hexo-abbrlink"></a>hexo-abbrlink</h2><h3 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h3><p>对<code>标题+时间</code>进行<code>md5</code>然后再转<code>base64</code>，保存在front-matter中。</p>
<h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><p>安装这个插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>

<p>在站点配置文件<code>_config.yml</code>中修改<code>permalink</code>为如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">permalink: :abbrlink&#x2F;</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32  # 算法：crc16(default) and crc32</span><br><span class="line">  rep: hex    # 进制：dec(default) and hex</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klnkqaudj20br020jrg.jpg" alt=""></p>
<p>该插件的github地址 -&gt; <a href="https://github.com/Rozbo/hexo-abbrlink" target="_blank" rel="noopener">rozbo/hexo-abbrlink</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>poj 2417 Discrete Logging（bsgs算法，baby-step giant-step）</title>
    <url>/163226ed/</url>
    <content><![CDATA[<p>Time Limit: 5000MS        Memory Limit: 65536K</p>
<p>Given a prime P, 2 &lt;= P &lt; 231, an integer B, 2 &lt;= B &lt; P, and an integer N, 1 &lt;= N &lt; P, compute the discrete logarithm of N, base B, modulo P. That is, find an integer L such that<br>    B^L == N (mod P)</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>Read several lines of input, each containing P,B,N separated by a space.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each line print the logarithm on a separate line. If there are several, print the smallest; if there is none, print “no solution”.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 2 1</span><br><span class="line">5 2 2</span><br><span class="line">5 2 3</span><br><span class="line">5 2 4</span><br><span class="line">5 3 1</span><br><span class="line">5 3 2</span><br><span class="line">5 3 3</span><br><span class="line">5 3 4</span><br><span class="line">5 4 1</span><br><span class="line">5 4 2</span><br><span class="line">5 4 3</span><br><span class="line">5 4 4</span><br><span class="line">12345701 2 1111111</span><br><span class="line">1111111121 65537 1111111111</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">0</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">0</span><br><span class="line">no solution</span><br><span class="line">no solution</span><br><span class="line">1</span><br><span class="line">9584351</span><br><span class="line">462803587</span><br></pre></td></tr></table></figure>
<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>The solution to this problem requires a well known result in number theory that is probably expected of you for Putnam but not ACM competitions. It is Fermat’s theorem that states<br>   B(P-1) == 1 (mod P)</p>
<p>for any prime P and some other (fairly rare) numbers known as base-B pseudoprimes. A rarer subset of the base-B pseudoprimes, known as Carmichael numbers, are pseudoprimes for every base between 2 and P-1. A corollary to Fermat’s theorem is that for any m<br>   B(-m) == B(P-1-m) (mod P) .</p>
<h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>Waterloo Local 2002.01.26</p>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给定b,n,p,求最小的非负整数l,满足<code>b^l ≡ n(mod p)</code></p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>学个新东西，bsgs算法（baby step giant step大步小步算法）其实我觉得它的别名<s>北上广深算法拔山盖世算法</s>更好听一点╮(￣▽￣””)╭</p>
<p>不晓得这个算法是怎么被想出来的，大致做法如下：</p>
<p>令<code>l=i*m-j</code>，m=ceil(√p)，ceil()是向上取整</p>
<p>代入原式得</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b^(i*m-j) ≡ n(mod p)</span><br><span class="line">b^(i*m) ≡ n*b^j(mod p)</span><br></pre></td></tr></table></figure>

<p>枚举j[0,m]，将<code>n*b^j(mod p)</code>存入hash表，枚举i[1,m]，在hash表中寻找第一个满足<code>b^(i*m) ≡ n*b^j(mod p)</code>的，<code>l=i*m-j</code>即为答案</p>
<p>看完这个做法还是懵逼的，所以接下来来证明为什么m=ceil(sqrt(p))范围内就可以找到</p>
<p>有<code>l=i*m-j=i*ceil(√p)-j&lt;p</code>，所以实际上是要证明l&lt;=p的范围内就能找到合法的l</p>
<p>再把这个问题转化为用费马小定理证明这个式子：<code>b^(k mod (p-1)) ≡ b^k(mod p)</code></p>
<p>证明：</p>
<p><code>k mod (p-1)</code>等价于<code>k-m(p-1)</code>，则有<code>b^(k-m(p-1)) ≡ b^k(mod p)</code>，化简得<code>b^(m(p-1)) ≡ 1(mod p)</code></p>
<p>由费马小定理，已知：当p为质数且<code>(a,p)=1</code>时，<code>a^(p-1) ≡ 1(mod p)</code></p>
<p>所以当<code>(b,p)!=1</code>有<code>b^(m(p-1)) ≡ b^(p-1)(mod p)</code>，即证<code>b^(k mod (p-1)) ≡ b^k(mod p)</code></p>
<p>m=ceil(sqrt(p))可行</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">LL p,b,l,n,m,ans;</span><br><span class="line">map&lt;LL,int&gt;mp;</span><br><span class="line">LL qpow(LL a,LL b)&#123;</span><br><span class="line">    LL anss&#x3D;1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            anss&#x3D;(anss*a)%p;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        b&#x2F;&#x3D;2;</span><br><span class="line">        a&#x3D;a*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return anss;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(scanf(&quot;%lld%lld%lld&quot;,&amp;p,&amp;b,&amp;n)!&#x3D;EOF)&#123;</span><br><span class="line">        if(b%p&#x3D;&#x3D;0)&#123;</span><br><span class="line">            puts(&quot;no solution&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        mp.clear();</span><br><span class="line">        ans&#x3D;-1;</span><br><span class="line">        m&#x3D;ceil(sqrt(p));</span><br><span class="line">        LL tmp&#x3D;n%p;</span><br><span class="line">        mp[tmp]&#x3D;0;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">            tmp&#x3D;(tmp*b)%p;</span><br><span class="line">            mp[tmp]&#x3D;i;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp&#x3D;1;</span><br><span class="line">        LL num&#x3D;qpow(b,m);</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">            tmp&#x3D;(tmp*num)%p;</span><br><span class="line">            if(mp[tmp])&#123;</span><br><span class="line">                ans&#x3D;i*m-mp[tmp];</span><br><span class="line">                ans&#x3D;(ans%p+p)%p;</span><br><span class="line">                printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ans&#x3D;&#x3D;-1)puts(&quot;no solution&quot;);;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>汉诺塔题集（递归 hdu 1995 1996 2064 2077 2175）</title>
    <url>/655cb7bd/</url>
    <content><![CDATA[<h1 id="汉诺塔基本原理："><a href="#汉诺塔基本原理：" class="headerlink" title="汉诺塔基本原理："></a>汉诺塔基本原理：</h1><p>1）将A上n-1个盘子借助C移到B上；<br>2）把A上剩下的一个盘移到C上；<br>3）将n-1个盘从B借助于A移到C上。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void hanoi(int n,char x,char y,char z)&#123;</span><br><span class="line">    if(n&#x3D;&#x3D;1)cout&lt;&lt;x&lt;&lt;&quot;--&gt;&quot;&lt;&lt;z&lt;&lt;endl;</span><br><span class="line">    else&#123;</span><br><span class="line">        hanoi(n-1,x,z,y);&#x2F;&#x2F;前n-1个盘子从x移动到y上</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;“—&gt;”&lt;&lt;z&lt;&lt;endl;&#x2F;&#x2F;将最底下的最后一个盘子从x移动到z上</span><br><span class="line">        hanoi(n-1,y,x,z);&#x2F;&#x2F;将y上的n-1个盘子移动到z上</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><h2 id="1-hdu-1995-汉诺塔V"><a href="#1-hdu-1995-汉诺塔V" class="headerlink" title="1.hdu 1995 汉诺塔V"></a>1.hdu 1995 汉诺塔V</h2><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>盘子的数目n，盘号k，求汉诺塔之后，k号盘需要的最少的移动次数</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>因为比k小的盘子移动不会牵扯k移动，所以这个问题等价于n-k+1阶汉诺塔中一号盘子的移动次数，然后回到开头的汉诺塔移动原理，由于步骤2）中一号盘子不移动，所以得到递推式<code>f[n]=2*f[n-1]</code></p>
<p>其实就是个等比数列，最后答案是：<code>2^(n-k)</code></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">    	LL a,b;</span><br><span class="line">    	scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b);</span><br><span class="line">    	a-&#x3D;b;</span><br><span class="line">    	printf(&quot;%lld\n&quot;,(LL)pow(2,a));</span><br><span class="line">	&#125; </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-hdu-1996-汉诺塔VI"><a href="#2-hdu-1996-汉诺塔VI" class="headerlink" title="2.hdu 1996 汉诺塔VI"></a>2.hdu 1996 汉诺塔VI</h2><h3 id="题意：-1"><a href="#题意：-1" class="headerlink" title="题意："></a>题意：</h3><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klo5id4nj20fx043js0.jpg" alt=""></p>
<h3 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h3><p>所有可能的序列，其实就是每个盘子可能摆在任意一个柱子上，然后每个柱子都上小下大，即<code>3^n</code></p>
<h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">    	LL a;</span><br><span class="line">    	scanf(&quot;%lld&quot;,&amp;a);</span><br><span class="line">    	printf(&quot;%lld\n&quot;,(LL)pow(3,a));</span><br><span class="line">	&#125; </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-hdu-2064-汉诺塔III"><a href="#3-hdu-2064-汉诺塔III" class="headerlink" title="3.hdu 2064 汉诺塔III"></a>3.hdu 2064 汉诺塔III</h2><h3 id="题意：-2"><a href="#题意：-2" class="headerlink" title="题意："></a>题意：</h3><p>改变游戏的玩法，不允许直接从最左(右)边移到最右(左)边(每次移动一定是移到中间杆或从中间移出)</p>
<h3 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h3><p>设将n层塔从A经B挪到C需要f[n]步</p>
<p>在新规则下的具体步骤是：</p>
<p>将上面n-1层从A经B挪到C需要f[n-1]步，再将第n层从A挪到B，需要一步，再将上n-1层从C经B挪到A，需要f[n-1]步，再将第n层从B挪到C，需要一步，再将上n-1层从A经B挪到C，需要f[n-1]步</p>
<p>即<code>f[n]=3*f[n-1]+2</code></p>
<p>初始化<code>f[1]=2</code></p>
<p>这个题。。好像pow用不了？？得自己写一个。。太久远的代码了。。记不清了</p>
<h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">LL pow(int a,int b)&#123;</span><br><span class="line">	LL ans&#x3D;1;</span><br><span class="line">	for(int i&#x3D;0;i&lt;b;i++)&#123;</span><br><span class="line">		ans*&#x3D;a;</span><br><span class="line">	&#125;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    while(~scanf(&quot;%d&quot;,&amp;n))&#123;</span><br><span class="line">    	printf(&quot;%I64d\n&quot;,pow(3,n)-1);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-hdu-2077-汉诺塔IV"><a href="#4-hdu-2077-汉诺塔IV" class="headerlink" title="4.hdu 2077 汉诺塔IV"></a>4.hdu 2077 汉诺塔IV</h2><h3 id="题意：-3"><a href="#题意：-3" class="headerlink" title="题意："></a>题意：</h3><p>改变游戏的玩法，不允许直接从最左(右)边移到最右(左)边(每次移动一定是移到中间杆或从中间移出)，可以将最大的一个放在上面！</p>
<h3 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h3><p>由hdu2064汉诺塔III已知递推式<code>f[n]=3*f[n-1]+2</code>，那么将n-1个盘子像汉诺塔III的规则一样先移动到B，因为最大盘子可以放上面，所以把最大盘子移到B，再到C，再将B上的移到C，所以和hdu2064相比只是递推式的最后一步变了，只需要在f[n-1]的基础上再加2即可，<code>a[n]=f[n-1]+2</code></p>
<p>至于代码为什么长那个样子，好像是因为我当时是直接看样例猜的就水过去了吧╮(￣▽￣””)╭</p>
<h3 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        printf(&quot;%I64d\n&quot;,(LL)pow(3,n-1)+1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-hdu-2175-汉诺塔IX"><a href="#5-hdu-2175-汉诺塔IX" class="headerlink" title="5.hdu 2175 汉诺塔IX"></a>5.hdu 2175 汉诺塔IX</h2><h3 id="题意：-4"><a href="#题意：-4" class="headerlink" title="题意："></a>题意：</h3><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klo5k1e8j20g102nmxq.jpg" alt=""></p>
<h3 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h3><p>对于第一个盘子从第一次2^0开始,后面每次要等一个盘子移动完它就移动,也就是说1号盘子隔一个移动一次,即1,3,5,7…是它移动的顺序</p>
<p>对于第二个盘子从第二次2^1开始，需要等比它号码高的一个盘子移动后还要等比它号码低的盘子全部移动后才能移动,即2号要等1号移动完,需要等2^1+2^1=2^2次，即2号盘子每次移动的序号是2,6,10,14..</p>
<p>对于第3个盘子从2^2开始,同样需要等比它号码高的一个盘子移动后还要等比它号码低的盘子全部移动完后才能移动,即3号要等1,2号移动完才行，需要等2^1+2^2+2^1=2^3次<br>即3号盘子每次移动的序号是4,12,20…</p>
<p>规律已经出现</p>
<h3 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">int main()&#123;</span><br><span class="line">    int m,n;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)&amp;&amp;(m+n))&#123;</span><br><span class="line">    	int i;</span><br><span class="line">		for(i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">			if(m%2)break;</span><br><span class="line">			m&#x2F;&#x3D;2;</span><br><span class="line">		&#125;</span><br><span class="line">    	printf(&quot;%d\n&quot;,i);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>一点点ACM递推递归题集</title>
    <url>/68a46f0b/</url>
    <content><![CDATA[<a id="more"></a>
<p><a href="https://leflacon.github.io/655cb7bd/" target="_blank" rel="noopener">汉诺塔题集（递归 hdu 1995 1996 2064 2077 2175）</a></p>
<p><a href="http://leflacon.github.io/c0d275b3/" target="_blank" rel="noopener">hdu 2041 超级楼梯</a></p>
<p><a href="http://leflacon.github.io/f47c306c/" target="_blank" rel="noopener">hdu 2046 骨牌铺方格</a></p>
<p><a href="http://leflacon.github.io/894818a5/" target="_blank" rel="noopener">hdu 2044 一只小蜜蜂…</a></p>
<p><a href="https://leflacon.github.io/dbf07d5c/" target="_blank" rel="noopener">51nod 1002 数塔取数问题（dp）</a></p>
<p><a href="http://leflacon.github.io/60992a21" target="_blank" rel="noopener">hdu 2045 不容易系列之(3)—— LELE的RPG难题</a></p>
<p><a href="http://leflacon.github.io/65c1781f/" target="_blank" rel="noopener">hdu 2047 阿牛的EOF牛肉串</a></p>
<p><a href="http://leflacon.github.io/7e7621ef/" target="_blank" rel="noopener">hdu 2048 神、上帝以及老天爷（全错排，递推）</a></p>
<p><a href="http://leflacon.github.io/1d6b220a" target="_blank" rel="noopener">hdu 2049 不容易系列之(4)——考新郎（全错排，递推）</a></p>
<p><a href="http://leflacon.github.io/f699b617/" target="_blank" rel="noopener">hdu 2050 折线分割平面</a></p>
<p><a href="https://leflacon.github.io/de762ff3" target="_blank" rel="noopener">51nod 2000 四边形分割平面（n个m边形分割平面公式推导）</a></p>
<p><a href="http://leflacon.github.io/5c6528a4/" target="_blank" rel="noopener">hdu 5047 Sawtooth（java大数，分割平面问题）</a></p>
<p><a href="http://leflacon.github.io/83978c3d/" target="_blank" rel="noopener">poj 2229 Sumsets（递推，完全背包）</a></p>
<p><a href="https://leflacon.github.io/59d4cd0/" target="_blank" rel="noopener">1073 约瑟夫环（递推）</a></p>
<p><a href="https://leflacon.github.io/bb984cd4/" target="_blank" rel="noopener">Catalan Square – NCPC 2014 （卡特兰数）</a></p>
<p><a href="https://leflacon.github.io/7ecca125" target="_blank" rel="noopener">Best Solver – ICPC 2015 Shenyang（广义斐波那契）</a></p>
<p><a href="https://leflacon.github.io/f1aab9cf/" target="_blank" rel="noopener">ural 1309 Dispute</a></p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 2041 超级楼梯（递推）</title>
    <url>/c0d275b3/</url>
    <content><![CDATA[<p>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？</p>
<a id="more"></a>


<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入数据首先包含一个整数N，表示测试实例的个数，然后是N行数据，每行包含一个整数M（1&lt;=M&lt;=40）,表示楼梯的级数。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每个测试实例，请输出不同走法的数量</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>要走到第n级台阶，要么是n-1级再走一级上来的，要么是n-2级直接走两级上来的</p>
<p>递推式为<code>f[i]=f[i-1]+f[i-2]</code></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p>```<br>#include <algorithm><br>#include <cstdio><br>#include <cstring><br>#include <iostream><br>#include <cmath><br>using namespace std;</p>
<p>int f[50];<br>int main(){<br>    int t,n;<br>    scanf(“%d”,&amp;t);<br>    f[1]=1;f[2]=1;<br>    for(int i=3;i&lt;=40;i++)f[i]=f[i-1]+f[i-2];<br>    while(t–){<br>        scanf(“%d”,&amp;n);<br>        printf(“%d\n”,f[n]);<br>    }<br>    return 0;<br>}<br>```w</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 2050 折线分割平面（分割平面问题）</title>
    <url>/f699b617/</url>
    <content><![CDATA[<p>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>我们看到过很多直线分割平面的题目，今天的这个题目稍微有些变化，我们要求的是n条折线分割平面的最大数目。比如，一条折线可以将平面分成两部分，两条折线最多可以将平面分成7部分，具体如下所示。</p>
<a id="more"></a>

<p><img src="http://acm.hdu.edu.cn/data/images/C40-1008-1.jpg" alt=""></p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入数据的第一行是一个整数C,表示测试实例的个数，然后是C 行数据，每行包含一个整数n<code>(0&lt;n&lt;=10000)</code>,表示折线的数量。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每个测试实例，请输出平面的最大分割数，每个实例的输出占一行。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>也就是求n个“V”型可以把平面分成多少区域</p>
<p><code>ans=2*n*n-n+1</code></p>
<p>首先n条直线可以把平面分成<code>n*(n+1)/2+1</code>个区域，那么对于<code>2*n</code>条直线来说，可以分成<code>n*(2*n+1)+1</code>个域，一个“V”延长出去后，最多会多2块，也就是说因为“V”型的特殊性，每次会少<code>2*n</code>个块，所以答案为<code>2*n*n-n+1</code></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        printf(&quot;%d\n&quot;,2*n*n-n+1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 2049 不容易系列之(4)——考新郎（全错排，递推）</title>
    <url>/1d6b220a/</url>
    <content><![CDATA[<p>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>国庆期间,省城HZ刚刚举行了一场盛大的集体婚礼,为了使婚礼进行的丰富一些,司仪临时想出了有一个有意思的节目,叫做”考新郎”,具体的操作是这样的:</p>
<a id="more"></a>

<p>首先,给每位新娘打扮得几乎一模一样,并盖上大大的红盖头随机坐成一排;<br>然后,让各位新郎寻找自己的新娘.每人只准找一个,并且不允许多人找一个.<br>最后,揭开盖头,如果找错了对象就要当众跪搓衣板…</p>
<p>看来做新郎也不是容易的事情…</p>
<p>假设一共有N对新婚夫妇,其中有M个新郎找错了新娘,求发生这种情况一共有多少种可能.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入数据的第一行是一个整数C,表示测试实例的个数，然后是C行数据，每行包含两个整数N和M(1&lt;M&lt;=N&lt;=20)。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每个测试实例，请输出一共有多少种发生这种情况的可能，每个实例的输出占一行。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2 2</span><br><span class="line">3 2</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>n个数字，求全排列中m个错排的数量</p>
<p>首先需要知道全错排的求法 -&gt;<a href="">hdu 2048 神、上帝以及老天爷（全错排，递推）</a></p>
<p>全错排的递推式是<code>f[n]=(n-1)*(f[n-1]+f[n-2])</code></p>
<p>那么n个人中有m-n个人选对了，剩下的m个全错排，所以只要在n个人中选出m个错误的人然后全错排即可，答案为<code>C(n,m)*f[m]</code></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long </span><br><span class="line">LL f[25];</span><br><span class="line">LL C(LL n,LL m)&#123;</span><br><span class="line">    if(m&gt;n)return 0;</span><br><span class="line">    LL ans&#x3D;1;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">        LL a&#x3D;n+i-m;</span><br><span class="line">        ans&#x3D;ans*a&#x2F;i;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    f[1]&#x3D;0;f[2]&#x3D;1;</span><br><span class="line">    for(int i&#x3D;3;i&lt;&#x3D;20;i++)f[i]&#x3D;(i-1)*(f[i-1]+f[i-2]);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;m,&amp;n);</span><br><span class="line">        if(m&gt;n)swap(m,n);</span><br><span class="line">        printf(&quot;%lld\n&quot;,C(n,m)*f[m]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 2048 神、上帝以及老天爷（全错排，递推）</title>
    <url>/7e7621ef/</url>
    <content><![CDATA[<p>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>HDU 2006’10 ACM contest的颁奖晚会隆重开始了！<br>为了活跃气氛，组织者举行了一个别开生面、奖品丰厚的抽奖活动，这个活动的具体要求是这样的：</p>
<a id="more"></a>

<p>首先，所有参加晚会的人员都将一张写有自己名字的字条放入抽奖箱中；<br>然后，待所有字条加入完毕，每人从箱中取一个字条；<br>最后，如果取得的字条上写的就是自己的名字，那么“恭喜你，中奖了！”</p>
<p>大家可以想象一下当时的气氛之热烈，毕竟中奖者的奖品是大家梦寐以求的Twins签名照呀！不过，正如所有试图设计的喜剧往往以悲剧结尾，这次抽奖活动最后竟然没有一个人中奖！</p>
<p>我的神、上帝以及老天爷呀，怎么会这样呢？</p>
<p>不过，先不要激动，现在问题来了，你能计算一下发生这种情况的概率吗？</p>
<p>不会算？难道你也想以悲剧结尾？！</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入数据的第一行是一个整数C,表示测试实例的个数，然后是C 行数据，每行包含一个整数<code>n(1&lt;n&lt;=20)</code>,表示参加抽奖的人数。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每个测试实例，请输出发生这种情况的百分比，每个实例的输出占一行, 结果保留两位小数(四舍五入)，具体格式请参照sample output。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">50.00%</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>每个人不拿到自己的名字，也就是经典全错排问题</p>
<p>递推的思路，f[i]记为i个人全错排的方法数</p>
<p>如果前n-1个人拿前i-1个名字都没拿到自己名字，那么第n个人必定拿到自己名字，如果要让第n个人拿不到自己的名字，只需要把名字n和前面任意一个人的名字互换即可，总共有n-1种互换方法，即<code>(n-1)*f[n-1]</code></p>
<p>如果前n-1个人恰好有1个人拿到了自己的名字，也就是说有n-2个人拿对应的n-2个名字没有自己名字，那么只要把这个人的名字和第n个人互换，就能满足所有人都拿不到自己名字的情况，即<code>C(n-1,1)*f[n-2]</code></p>
<p>其余情况都是重复的了</p>
<p>所以得到递推式<code>f[n]=(n-1)*(f[n-1]+f[n-2])</code></p>
<p>总排列数为全排列A(n,n)，最后答案为f[n]/A(n,n)</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long </span><br><span class="line">LL f[25],a[25];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    f[1]&#x3D;0;f[2]&#x3D;1;</span><br><span class="line">    a[1]&#x3D;1;</span><br><span class="line">    for(int i&#x3D;2;i&lt;&#x3D;20;i++)a[i]&#x3D;a[i-1]*i;</span><br><span class="line">    for(int i&#x3D;3;i&lt;&#x3D;20;i++)f[i]&#x3D;(i-1)*(f[i-1]+f[i-2]);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        double ans&#x3D;(double)f[n]&#x2F;a[n]*100;</span><br><span class="line">        printf(&quot;%.2lf&quot;,ans);</span><br><span class="line">        cout&lt;&lt;&quot;%&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 2047 阿牛的EOF牛肉串（递推）</title>
    <url>/65c1781f/</url>
    <content><![CDATA[<p>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>今年的ACM暑期集训队一共有18人，分为6支队伍。其中有一个叫做EOF的队伍，由04级的阿牛、XC以及05级的COY组成。在共同的集训生活中，大家建立了深厚的友谊，阿牛准备做点什么来纪念这段激情燃烧的岁月，想了一想，阿牛从家里拿来了一块上等的牛肉干，准备在上面刻下一个长度为n的只由”E” “O” “F”三种字符组成的字符串（可以只有其中一种或两种字符，但绝对不能有其他字符）,阿牛同时禁止在串中出现O相邻的情况，他认为，”OO”看起来就像发怒的眼睛，效果不好。</p>
<a id="more"></a>

<p>你，NEW ACMer,EOF的崇拜者，能帮阿牛算一下一共有多少种满足要求的不同的字符串吗？</p>
<p>PS: 阿牛还有一个小秘密，就是准备把这个刻有 EOF的牛肉干，作为神秘礼物献给杭电五十周年校庆，可以想象，当校长接过这块牛肉干的时候该有多高兴！这里，请允许我代表杭电的ACMer向阿牛表示感谢！</p>
<p>再次感谢！</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入数据包含多个测试实例,每个测试实例占一行,由一个整数n组成，<code>(0&lt;n&lt;40)</code>。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每个测试实例，请输出全部的满足要求的涂法，每个实例的输出占一行。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>用递推的思路求解</p>
<p>考虑第n个字符</p>
<p>如果第n个字符填O，那么n-1个字符的位置只能是E/F，如果n-1的位置是E/F，那么对于一个合法的n-2来说任何情况都可以，不会再出现OO的情况，方法数为<code>f[n-2]*2</code></p>
<p>如果第n个字符填E/F，那么对于一个合法的n-1来说任何情况都可以，方法数为<code>f[n-1]*2</code></p>
<p>所以递推式为：<code>f[n]=2*(f[n-1]+f[n-2])</code></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long </span><br><span class="line">LL f[50];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    f[1]&#x3D;3;f[2]&#x3D;8;</span><br><span class="line">    for(int i&#x3D;3;i&lt;&#x3D;55;i++)f[i]&#x3D;2*(f[i-1]+f[i-2]);</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;n)!&#x3D;EOF)&#123;</span><br><span class="line">        printf(&quot;%lld\n&quot;,f[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 2046 骨牌铺方格（斐波那契）</title>
    <url>/f47c306c/</url>
    <content><![CDATA[<p>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>在2×n的一个长方形方格中,用一个1× 2的骨牌铺满方格,输入n ,输出铺放方案的总数.<br>例如n=3时,为2× 3方格，骨牌的铺放方案有三种,如下图：</p>
<a id="more"></a>

<p><img src="http://acm.hdu.edu.cn/data/images/C40-1003-1.jpg" alt=""> </p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入数据由多行组成，每行包含一个整数n,表示该测试实例的长方形方格的规格是2×n <code>(0&lt;n&lt;=50)</code>。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每个测试实例，请输出铺放方案的总数，每个实例的输出占一行。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p><a href="https://leflacon.github.io/7e7c23c2/" target="_blank" rel="noopener">51nod 1031 骨牌覆盖（斐波那契）</a></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long </span><br><span class="line">LL f[55];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    f[1]&#x3D;1;f[2]&#x3D;2;</span><br><span class="line">    for(int i&#x3D;3;i&lt;&#x3D;55;i++)f[i]&#x3D;f[i-1]+f[i-2];</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;n)!&#x3D;EOF)&#123;</span><br><span class="line">        printf(&quot;%lld\n&quot;,f[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 2045 不容易系列之(3)—— LELE的RPG难题（递推）</title>
    <url>/60992a21/</url>
    <content><![CDATA[<p>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>人称“AC女之杀手”的超级偶像LELE最近忽然玩起了深沉，这可急坏了众多“Cole”（LELE的粉丝,即”可乐”）,经过多方打探，某资深Cole终于知道了原因，原来，LELE最近研究起了著名的RPG难题:</p>
<a id="more"></a>

<p>有排成一行的ｎ个方格，用红(Red)、粉(Pink)、绿(Green)三色涂每个格子，每格涂一色，要求任何相邻的方格不能同色，且首尾两格也不同色．求全部的满足要求的涂法.</p>
<p>以上就是著名的RPG难题.</p>
<p>如果你是Cole,我想你一定会想尽办法帮助LELE解决这个问题的;如果不是,看在众多漂亮的痛不欲生的Cole女的面子上,你也不会袖手旁观吧?</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入数据包含多个测试实例,每个测试实例占一行,由一个整数N组成，<code>(0&lt;n&lt;=50)</code>。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每个测试实例，请输出全部的满足要求的涂法，每个实例的输出占一行。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>考虑第n个格子</p>
<p>如果前n-1个格子直接照搬n-1时的合法涂法，也就是前n-1个格子的1和n-1不同色且相邻不同色，那么对于第n个格子来说，不能涂1也不能涂n-1的颜色，所以只剩一种颜色可以涂</p>
<p>如果前n-2个格子直接照搬n-2时的合法涂法，第n-1个格子涂和1一样的颜色，那么对于第n个格子来说还剩两种颜色可以涂</p>
<p>所以递推式就是<code>dp[n]=dp[n-1]+2*dp[n-2]</code></p>
<p>有个小小的坑点是n=3的时候答案为6，123，132，213，231，312，321，即<code>dp[1]=3,dp[2]=3*2=6,dp[3]=6</code></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">LL dp[55];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    dp[1]&#x3D;3;dp[2]&#x3D;6;dp[3]&#x3D;6;</span><br><span class="line">    for(int i&#x3D;4;i&lt;&#x3D;50;i++)dp[i]&#x3D;dp[i-1]+2*dp[i-2];</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;n)!&#x3D;EOF)&#123;</span><br><span class="line">        printf(&quot;%lld\n&quot;,dp[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 2044 一只小蜜蜂...（递推）</title>
    <url>/894818a5/</url>
    <content><![CDATA[<p>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>有一只经过训练的蜜蜂只能爬向右侧相邻的蜂房，不能反向爬行。请编程计算蜜蜂从蜂房a爬到蜂房b的可能路线数。<br>其中，蜂房的结构如下所示。</p>
<a id="more"></a>

<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入数据的第一行是一个整数N,表示测试实例的个数，然后是N 行数据，每行包含两个整数a和b<code>(0&lt;a&lt;b&lt;50)</code>。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每个测试实例，请输出蜜蜂从蜂房a爬到蜂房b的可能路线数，每个实例的输出占一行。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">3 6</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>水水的递推，对于一个数n来说，能到达它的数就是n-1和n-2，所以<code>dp[n]=dp[n-1]+dp[n-2]</code>，斐波那契，a-&gt;b的实际方法数等同于1-&gt;b-a+1</p>
<p>要开LL</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">LL dp[55];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,a,b;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    dp[1]&#x3D;1;dp[2]&#x3D;1;</span><br><span class="line">    for(int i&#x3D;3;i&lt;50;i++)dp[i]&#x3D;dp[i-1]+dp[i-2];</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">        if(a&gt;&#x3D;b)puts(&quot;0&quot;);</span><br><span class="line">        else printf(&quot;%lld\n&quot;,dp[b-a+1]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>poj 2229 Sumsets（递推，完全背包）</title>
    <url>/83978c3d/</url>
    <content><![CDATA[<p>Time Limit: 2000MS        Memory Limit: 200000K</p>
<p>Farmer John commanded his cows to search for different sets of numbers that sum to a given number. The cows use only numbers that are an integer power of 2. Here are the possible sets of numbers that sum to 7: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1) 1+1+1+1+1+1+1 </span><br><span class="line">2) 1+1+1+1+1+2 </span><br><span class="line">3) 1+1+1+2+2 </span><br><span class="line">4) 1+1+1+4 </span><br><span class="line">5) 1+2+2+2 </span><br><span class="line">6) 1+2+4</span><br></pre></td></tr></table></figure>

<p>Help FJ count all possible representations for a given integer N (1 &lt;= N &lt;= 1,000,000).<br>Input</p>
<p>A single line with a single integer, N.<br>Output</p>
<p>The number of ways to represent N as the indicated sum. Due to the potential huge size of this number, print only last 9 digits (in base 10 representation).</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>
<h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>USACO 2005 January Silver</p>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给一个n，把它分成2的幂次的和，求方法数</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><h4 id="方法1）递推：（63ms）"><a href="#方法1）递推：（63ms）" class="headerlink" title="方法1）递推：（63ms）"></a>方法1）递推：（63ms）</h4><p>记数i的方法数为dp[i]</p>
<p>对于一个n</p>
<p>如果他是奇数，那只能在偶数的基础上加个1，所以答案就是dp[n-1]</p>
<p>如果n是偶数，那么分成两种情况，一种是有1，那么在原来奇数的基础上加1就能变成n，还有一种是没有1，只用除了1以外的2的幂次，这个方法数等于dp[n/2]</p>
<p>为什么是dp[n/2]呢？因为对于任意一个偶数n来说，把(n/2)&lt;&lt;1即可得到n，也就是说，对于（n/2）的任意情况来说，只要把组合中的每个数<code>*2</code>，就可以得到组成n且没有1的情况</p>
<p>随便举个例子1，2，4可以组成7，那么2，4，8就可以组成14</p>
<p>所以偶数的状态转移就是<code>dp[i]=(dp[i-1]+dp[i&gt;&gt;1])%p</code></p>
<p>从1开始递推即得答案</p>
<h4 id="方法2）完全背包（1000ms）"><a href="#方法2）完全背包（1000ms）" class="headerlink" title="方法2）完全背包（1000ms）"></a>方法2）完全背包（1000ms）</h4><p>如果一下子想不出递推式的话，就把这个题当成一个完全背包水题做，物品就是1，2，4，……数量不限</p>
<p>先预处理出2的幂次，然后<code>dp[j]=(dp[j]+dp[j-pow2[i]])%p;</code></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;1e6+5;</span><br><span class="line">const int p&#x3D;1e9;</span><br><span class="line">int dp[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    dp[0]&#x3D;1;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        if(i&amp;1)dp[i]&#x3D;dp[i-1];</span><br><span class="line">        else dp[i]&#x3D;(dp[i-1]+dp[i&gt;&gt;1])%p;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,dp[n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;1e6+5;</span><br><span class="line">const int p&#x3D;1e9;</span><br><span class="line">int pow2[N],dp[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    pow2[0]&#x3D;1;</span><br><span class="line">    dp[0]&#x3D;1;</span><br><span class="line">    for(int i&#x3D;1;i&lt;20;i++)pow2[i]&#x3D;pow2[i-1]&lt;&lt;1;</span><br><span class="line">    for(int i&#x3D;0;i&lt;20;i++)</span><br><span class="line">        for(int j&#x3D;pow2[i];j&lt;&#x3D;n;j++)</span><br><span class="line">            dp[j]&#x3D;(dp[j]+dp[j-pow2[i]])%p;</span><br><span class="line">    printf(&quot;%d\n&quot;,dp[n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>I.Riddle（状压dp）-- 2018 CCPC 秦皇岛</title>
    <url>/e73bae86/</url>
    <content><![CDATA[<p>补题ing ∠( ᐛ 」∠)＿</p>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给一个n个数的数组，数组中的数字可能代表物品，也可能代表背包，a[i]的具体数值代表一个物品或背包的大小，如果a[i]代表背包的话，必须有对应的物品把背包恰好填满才合法，求有多少种合法的可能</p>
<a id="more"></a>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>思路是网上学的，先把任意背包和物品的复杂组合简化一下，只看一个背包，处理出一个背包和装入它的物品的可行性，然后用这些子状态dp，很好的处理手法，具体如下：</p>
<p>状压dp，用二进制表示n位数的状态，dp[i]表示状态i的数组下的方法数</p>
<p>预处理出2^15种组合sum[i]，表示状态i的数值和</p>
<p>然后再求合法的背包大小，比较a[i]和sum[j]，如果<code>sum[j]-a[i]==a[i]</code>，也就是说当前a[i]可以作为背包大小，有某种非自身的组合可以填入这个背包，那么f[j]++，f[i]表示状态为i的能否满足恰好是一个背包和装入该背包的物品的情况（即物品全装入这个背包），如果能，方法数为f[i]，初始化为0</p>
<p>然后枚举2^15个背包打包物品状态i，<code>tmp=(1&lt;&lt;n)-i-1;for(int j=(1&lt;&lt;n)-i-1;;j=(j-1)&amp;tmp)</code>可以依次枚举当前背包状态下合法的剩余状态j</p>
<p>状态转移方程为：<code>dp[i|j]+=dp[j]*f[i];</code></p>
<h3 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">1 1 1</span><br><span class="line">5</span><br><span class="line">1 1 2 2 3</span><br><span class="line">10</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">output</span><br><span class="line">7</span><br><span class="line">15</span><br><span class="line">127</span><br></pre></td></tr></table></figure>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int dp[1&lt;&lt;15|5],f[1&lt;&lt;15|5],a[16],sum[1&lt;&lt;15|5];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">    	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    	for(int i&#x3D;0;i&lt;(1&lt;&lt;n);i++)&#123;</span><br><span class="line">    		dp[i]&#x3D;1;</span><br><span class="line">    		sum[i]&#x3D;f[i]&#x3D;0;</span><br><span class="line">    	&#125;</span><br><span class="line">    	for(int i&#x3D;1;i&lt;&#x3D;n;i++)scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    	for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">    		for(int j&#x3D;1;j&lt;(1&lt;&lt;n);j++)</span><br><span class="line">    			if(j&amp;(1&lt;&lt;(i-1)))sum[j]+&#x3D;a[i];</span><br><span class="line">    	for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">    		for(int j&#x3D;1;j&lt;(1&lt;&lt;n);j++)</span><br><span class="line">    			if(j&amp;(1&lt;&lt;(i-1)))</span><br><span class="line">    				if(sum[j]-a[i]&#x3D;&#x3D;a[i])f[j]++;</span><br><span class="line">    	for(int i&#x3D;1;i&lt;(1&lt;&lt;n);i++)&#123;</span><br><span class="line">    		int tmp&#x3D;(1&lt;&lt;n)-i-1;</span><br><span class="line">    		for(int j&#x3D;tmp;;j&#x3D;(j-1)&amp;tmp)&#123;</span><br><span class="line">    			dp[i|j]+&#x3D;dp[j]*f[i];</span><br><span class="line">    			if(j&#x3D;&#x3D;0)break;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	printf(&quot;%d\n&quot;,dp[(1&lt;&lt;n)-1]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>mac OS下sublime3配置c++环境（支持输入，支持c++11）</title>
    <url>/f292e0b8/</url>
    <content><![CDATA[<p>终于配上了c++11，可以用auto了，快乐～</p>
<p>但是构建好懵逼啊。。一头雾水。。还是得参考<s>=照搬</s>别人的代码</p>
<hr>
<h1 id="新建环境"><a href="#新建环境" class="headerlink" title="新建环境"></a>新建环境</h1><p>【tools-&gt;build system-&gt;new build system】</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klbn8lpwj20cd0gi763.jpg" alt=""></p>
<p>输入以下内容保存</p>
<h1 id="构建系统——json文件"><a href="#构建系统——json文件" class="headerlink" title="构建系统——json文件"></a>构建系统——json文件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;cmd&quot;: [&quot;bash&quot;, &quot;-c&quot;, &quot;g++ &#39;$&#123;file&#125;&#39; -std&#x3D;c++11 -stdlib&#x3D;libc++ -o &#39;$&#123;file_path&#125;&#x2F;$&#123;file_base_name&#125;&#39;&quot;],</span><br><span class="line">    &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;,</span><br><span class="line">    &quot;working_dir&quot;: &quot;$&#123;file_path&#125;&quot;,</span><br><span class="line">    &quot;selector&quot;: &quot;source.c, source.c++&quot;,</span><br><span class="line">    &quot;variants&quot;:</span><br><span class="line">    [</span><br><span class="line">        &#123;</span><br><span class="line">        &quot;name&quot;: &quot;Run&quot;,</span><br><span class="line">        &quot;cmd&quot;: [&quot;bash&quot;, &quot;-c&quot;, &quot;g++ &#39;$&#123;file&#125;&#39; -std&#x3D;c++11 -stdlib&#x3D;libc++ -o &#39;$&#123;file_path&#125;&#x2F;$&#123;file_base_name&#125;&#39; &amp;&amp; open -a Terminal.app &#39;$&#123;file_path&#125;&#x2F;$&#123;file_base_name&#125;&#39;&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Ctrl+Shift+B</code>即可运行</p>
<p>和之前配置的不能c++11的环境比最大差别应该是改了这个<code>-std=c++11 -stdlib=libc++ -o</code></p>
<h1 id="Build-Systems-Batch-Processing"><a href="#Build-Systems-Batch-Processing" class="headerlink" title="Build Systems (Batch Processing)"></a>Build Systems (Batch Processing)</h1><p>下面放一点点解释：</p>
<table>
<thead>
<tr>
<th>标准选项列表</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>cmd</td>
<td>要执行的实际命令行</td>
</tr>
<tr>
<td>file_regex</td>
<td>Perl样式的正则表达式，用于从外部程序的输出中捕获错误信息，比如上面的格式是：文件名，行号，列号和错误消息</td>
</tr>
<tr>
<td>selector</td>
<td>匹配selector文件的范围自动找到活动文件的相应构建系统</td>
</tr>
<tr>
<td>variants</td>
<td>使用variants，可以在同一.sublime-build文件中指定多个构建系统任务</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$file_path</td>
<td>当前文件的目录，例如C：\ Files。</td>
</tr>
<tr>
<td>$file</td>
<td>当前文件的完整路径，例如C：\ Files \ Chapter1.txt。</td>
</tr>
<tr>
<td>$file_name</td>
<td>当前文件的名称部分，例如Chapter1.txt。</td>
</tr>
<tr>
<td>$file_extension</td>
<td>当前文件的扩展部分，例如txt。</td>
</tr>
<tr>
<td>$file_base_name</td>
<td>当前文件的仅名称部分，例如Document。</td>
</tr>
<tr>
<td>$folder</td>
<td>在当前项目中打开的第一个文件夹的路径。</td>
</tr>
<tr>
<td>$project</td>
<td>当前项目文件的完整路径。</td>
</tr>
<tr>
<td>$project_path</td>
<td>当前项目文件的目录。</td>
</tr>
<tr>
<td>$project_name</td>
<td>当前项目文件的名称部分。</td>
</tr>
<tr>
<td>$project_extension</td>
<td>当前项目文件的扩展部分。</td>
</tr>
<tr>
<td>$project_base_name</td>
<td>当前项目文件的仅名称部分。</td>
</tr>
<tr>
<td>$packages    Packages</td>
<td>文件夹的完整路径。</td>
</tr>
</tbody></table>
<h1 id="修改环境"><a href="#修改环境" class="headerlink" title="修改环境"></a>修改环境</h1><p>如果是之前已经配过环境，直接修改然后保存即可</p>
<p>打开<code>xxx.sublime-build</code>的方法如下：</p>
<p>【preferences-&gt;browse packages】</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klbn8x0cj20bf06wwfj.jpg" alt=""></p>
<p><code>xxx.sublime-build</code>在所打开页面的【user】文件夹下</p>
<hr>
<p>最后放上官方文档链接 <a href="http://docs.sublimetext.info/en/latest/file_processing/build_systems.html" target="_blank" rel="noopener">Build Systems (Batch Processing)</a></p>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java第二次作业（线段类）</title>
    <url>/d7ffbd1c/</url>
    <content><![CDATA[<h1 id="线段类"><a href="#线段类" class="headerlink" title="线段类"></a>线段类</h1><p>编写一个线段类MyLine，主要属性有e1,e2,端点类型为Point，编写构造方法，编写成员方法（是否位于第一象限，长度，两线段是否相交，点到线段距离，其他方法）</p>
<a id="more"></a>

<h2 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h2><p>使用<code>java.awt.Point</code>，然后编写线段类MyLine，两个Point类型的私有变量u,v表示两线段端点</p>
<p>构造函数中直接给两个端点赋值就行</p>
<p>xmult函数算叉积，zero函数判断x是否等于0（因为要控制精度所以不能直接写==0，开头声明一个eps来控制精度范围<code>static double eps=1e-6;</code>）</p>
<p>判断线段是否相交（包括端点和重合），利用三个函数，<code>dots_inline</code>判三点共线，<code>dots_online_in</code>判点是否在线段上，包括端点，<code>same_side</code>判两点是否在线段同侧</p>
<p>求点到线段距离，为了避免出现线段是一个点的情况，先特判线段长度是否为0</p>
<h2 id="遇到问题及解决办法："><a href="#遇到问题及解决办法：" class="headerlink" title="遇到问题及解决办法："></a>遇到问题及解决办法：</h2><p>1.<code>The import java.awt cannot be resolve</code></p>
<p>【项目右键-&gt;build path-&gt;configure build path-&gt;library-&gt;add library】</p>
<p>2.<code>The operator || is undefined for the argument type(s) int, int</code></p>
<p>【因为把几个int型函数或起来了，在Java内部只能出现boolean类型的运算使用运算符<code>||</code>，Integer之间使用运算符<code>||</code>时，会报此错误，解决办法，转化为boolean类型进行运算，加个大于0啥的】</p>
<p>3.<code>Syntax error on token &quot;module&quot;, interface expected</code></p>
<p>【直接删掉。。我是谁我在哪我在干嘛。。】</p>
<p>4.<code>No enclosing instance of type Main is accessible.</code></p>
<p>【我写的类以public class开头，是动态的，而主程序public static class main是静态，在Java中，类中的静态方法不能直接调用动态方法，只有将某个内部类修饰为静态类，然后才能够在静态类中调用该类的成员变量与成员方法，直接将public class改为public static class】</p>
<h2 id="运行效果："><a href="#运行效果：" class="headerlink" title="运行效果："></a>运行效果：</h2><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kld53qatj205e05daa9.jpg" alt=""></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package test;</span><br><span class="line">  </span><br><span class="line">import java.io.*;  </span><br><span class="line">import java.math.*;</span><br><span class="line">import java.util.*;</span><br><span class="line">import java.awt.Point;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">	static double eps&#x3D;1e-8;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">        Point p1&#x3D;new Point(),p2&#x3D;new Point(),p3&#x3D;new Point(),p4&#x3D;new Point();</span><br><span class="line">        p1.x&#x3D;cin.nextInt();p1.y&#x3D;cin.nextInt();</span><br><span class="line">        p2.x&#x3D;cin.nextInt();p2.y&#x3D;cin.nextInt();</span><br><span class="line">        p3.x&#x3D;cin.nextInt();p3.y&#x3D;cin.nextInt();</span><br><span class="line">        p4.x&#x3D;cin.nextInt();p4.y&#x3D;cin.nextInt();</span><br><span class="line">        MyLine l1&#x3D;new MyLine(p1,p2);</span><br><span class="line">        MyLine l2&#x3D;new MyLine(p3,p4);</span><br><span class="line">        System.out.println(&quot;1.l1线段是否在第一象限: &quot;);</span><br><span class="line">        l1.check();</span><br><span class="line">        System.out.println(&quot;2.l2的长度: &quot;);</span><br><span class="line">        System.out.println(l2.length());</span><br><span class="line">        System.out.println(&quot;3.l1和l2是否相交: &quot;);</span><br><span class="line">        if(l1.xiangjiao(l2)&#x3D;&#x3D;1)System.out.println(&quot;相交&quot;);</span><br><span class="line">        else System.out.println(&quot;不相交&quot;);</span><br><span class="line">        System.out.println(&quot;4.p1到l2的距离: &quot;);</span><br><span class="line">        System.out.println(l2.juli(p1));</span><br><span class="line">        cin.close();</span><br><span class="line">    &#125;</span><br><span class="line">    public static class MyLine&#123;</span><br><span class="line">    	private Point u,v;</span><br><span class="line">    	MyLine(Point a,Point b)&#123;</span><br><span class="line">    		u&#x3D;a;</span><br><span class="line">    		v&#x3D;b;</span><br><span class="line">    	&#125;</span><br><span class="line">    	public boolean check() &#123;</span><br><span class="line">    		if(u.x&gt;0&amp;&amp;u.y&gt;0&amp;&amp;v.x&gt;0&amp;&amp;v.y&gt;0) &#123;</span><br><span class="line">    			System.out.println(&quot;Yes,线段在第一象限&quot;);</span><br><span class="line">    			return true;</span><br><span class="line">    		&#125;</span><br><span class="line">    		else &#123;</span><br><span class="line">    			System.out.println(&quot;No，线段不在第一象限&quot;);</span><br><span class="line">    			return false;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	public double length() &#123;</span><br><span class="line">    		return (float)Math.sqrt((u.x-v.x)*(u.x-v.x)+(u.y-v.y)*(u.y-v.y));</span><br><span class="line">    	&#125;</span><br><span class="line">    	public double length2(Point p1,Point p2) &#123;</span><br><span class="line">    		return (float)Math.sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));</span><br><span class="line">    	&#125;</span><br><span class="line">    	public double xmult(Point p1,Point p2,Point p0) &#123;</span><br><span class="line">        	return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);</span><br><span class="line">        &#125;</span><br><span class="line">        public int zero(double x) &#123;</span><br><span class="line">        	if(x&gt;0) &#123;</span><br><span class="line">        		if(x&lt;eps)return 1;</span><br><span class="line">        		else return 0;</span><br><span class="line">        	&#125;</span><br><span class="line">        	else &#123;</span><br><span class="line">        		if((-x)&lt;eps)return 1;</span><br><span class="line">        		else return 0;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean dots_inline(Point p1,Point p2,Point p3) &#123;</span><br><span class="line">        	if(zero(xmult(p1,p2,p3))&#x3D;&#x3D;1)return true;</span><br><span class="line">        	else return false;</span><br><span class="line">        &#125;</span><br><span class="line">        public int dots_online_in(Point p,Point l1,Point l2) &#123;</span><br><span class="line">        	if((zero(xmult(p,l1,l2))&#x3D;&#x3D;1)&amp;&amp;(l1.x-p.x)*(l2.x-p.x)&lt;eps&amp;&amp;</span><br><span class="line">        			(l1.y-p.y)*(l2.y-p.y)&lt;eps)return 1;</span><br><span class="line">        	else return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean same_side(MyLine l2) &#123;</span><br><span class="line">        	return (xmult(l2.u,u,l2.v)*xmult(l2.u,v,l2.v))&gt;eps;</span><br><span class="line">        &#125;</span><br><span class="line">        public int xiangjiao(MyLine l2) &#123;</span><br><span class="line">        	if(!dots_inline(u,v,l2.u)||!dots_inline(u,v,l2.v))</span><br><span class="line">        		if(!this.same_side(l2)&amp;&amp;!l2.same_side(this))return 1;</span><br><span class="line">        		else return 0;</span><br><span class="line">        	if(dots_online_in(u,l2.u,l2.v)&gt;0||dots_online_in(v,l2.u,l2.v)&gt;0||</span><br><span class="line">        			dots_online_in(l2.u,u,v)&gt;0||dots_online_in(l2.v,u,v)&gt;0)return 1;</span><br><span class="line">        	else return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        public double juli(Point p) &#123;</span><br><span class="line">        	if(zero(length2(u,v))!&#x3D;1)return Math.abs(xmult(p,u,v)&#x2F;length2(u,v));</span><br><span class="line">        	else return length2(p,u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>一些作业</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java第一次作业（素数，日历）</title>
    <url>/66dd1680/</url>
    <content><![CDATA[<h1 id="1）显示2～100中的质数，每行显示5个"><a href="#1）显示2～100中的质数，每行显示5个" class="headerlink" title="1）显示2～100中的质数，每行显示5个"></a>1）显示2～100中的质数，每行显示5个</h1><h2 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h2><p>写个判素数函数，是素数就输出，当然也可以用埃筛素数</p>
<a id="more"></a>

<h2 id="运行效果："><a href="#运行效果：" class="headerlink" title="运行效果："></a>运行效果：</h2><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klch9oncj203g02s0so.jpg" alt=""></p>
<h2 id="遇到的问题及解决："><a href="#遇到的问题及解决：" class="headerlink" title="遇到的问题及解决："></a>遇到的问题及解决：</h2><p>printf提示参数类型不对，Type The method print(int) in the type ……</p>
<p>因为默认的兼容版本为1.3，在项目属性的java complier中改成1.5以上就ok了</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;  </span><br><span class="line">import java.math.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    	int num&#x3D;1;</span><br><span class="line">        for(int i&#x3D;2;i&lt;&#x3D;100;i++) &#123;</span><br><span class="line">        	if(isprime(i)&amp;&amp;num%5!&#x3D;0) &#123;</span><br><span class="line">        		System.out.printf(&quot;%3s&quot;,i);</span><br><span class="line">        		num++;</span><br><span class="line">        	&#125;</span><br><span class="line">        	else if(isprime(i)&amp;&amp;num%5&#x3D;&#x3D;0) &#123;</span><br><span class="line">        		System.out.printf(&quot;%3s&quot;,i);</span><br><span class="line">        		System.out.println();</span><br><span class="line">        		num++;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static boolean isprime(int n) &#123;</span><br><span class="line">    	for(int i&#x3D;2;i*i&lt;&#x3D;n;i++) &#123;</span><br><span class="line">    		if(n%i&#x3D;&#x3D;0)return false;</span><br><span class="line">    	&#125;</span><br><span class="line">    	return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="2）编写程序，显示出当月日历"><a href="#2）编写程序，显示出当月日历" class="headerlink" title="2）编写程序，显示出当月日历"></a>2）编写程序，显示出当月日历</h1><h2 id="实现思路：-1"><a href="#实现思路：-1" class="headerlink" title="实现思路："></a>实现思路：</h2><p>利用java中的<code>java.util.Calendar</code>，先记录当前年月，然后指向这个月一号，一直输出到当前天月份不为之前记录的月份为止</p>
<h2 id="运行效果：-1"><a href="#运行效果：-1" class="headerlink" title="运行效果："></a>运行效果：</h2><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klch9yhyj206103xwen.jpg" alt=""></p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;  </span><br><span class="line">import java.math.*;</span><br><span class="line">import java.util.*;</span><br><span class="line">import java.text.DateFormatSymbols;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Calendar cal&#x3D;Calendar.getInstance();</span><br><span class="line">        int m&#x3D;cal.get(Calendar.MONTH);</span><br><span class="line">        int y&#x3D;cal.get(Calendar.YEAR);</span><br><span class="line">        System.out.println(y+&quot;年&quot;+(m+1)+&quot;月&quot;);&#x2F;&#x2F;月份记录的是[0,11]</span><br><span class="line">        String wk[]&#x3D;new DateFormatSymbols().getShortWeekdays();&#x2F;&#x2F;星期名数组[1,7]</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;7;i++)</span><br><span class="line">        	System.out.print(wk[i]+&quot; &quot;);</span><br><span class="line">        System.out.println();</span><br><span class="line">        cal.set(Calendar.DAY_OF_MONTH,1);&#x2F;&#x2F;1号</span><br><span class="line">        int w&#x3D;cal.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">        int cur&#x3D;1;</span><br><span class="line">        while(wk[cur]!&#x3D;wk[w]) &#123;</span><br><span class="line">        	System.out.print(&quot;    &quot;);</span><br><span class="line">        	cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        do &#123;</span><br><span class="line">        	int d&#x3D;cal.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        	System.out.printf(&quot;%3s&quot;,d);</span><br><span class="line">        	System.out.print(&quot; &quot;);</span><br><span class="line">        	if(wk[cal.get(Calendar.DAY_OF_WEEK)]&#x3D;&#x3D;wk[7])</span><br><span class="line">        		System.out.println();</span><br><span class="line">        	cal.add(Calendar.DAY_OF_MONTH,1);&#x2F;&#x2F;下一天</span><br><span class="line">        &#125;while(cal.get(Calendar.MONTH)&#x3D;&#x3D;m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>一些作业</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构第二次作业（扩展链表，双向循环链表）</title>
    <url>/6bcdcc46/</url>
    <content><![CDATA[<h1 id="1-扩展链表"><a href="#1-扩展链表" class="headerlink" title="1.扩展链表"></a>1.扩展链表</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>编写一个非成员方法meld，它生成一个新的扩展的链表c，它从a的首元素开始，交替的包含a和b的元素。如果一个链表的元素取完了，就把另一个链表的剩余元素附加到新的扩展链表中，方法的复杂度应与链表a和b的长度具有线性关系</p>
<h2 id="实现方法："><a href="#实现方法：" class="headerlink" title="实现方法："></a>实现方法：</h2><p>加个尾节点last，然后添加成员函数append直接在链表尾部添加节点</p>
<p>用两个指针遍历链表AB，这样就可以通过append函数o(n)填充链表C</p>
<h2 id="写的时候遇到的问题及解决办法："><a href="#写的时候遇到的问题及解决办法：" class="headerlink" title="写的时候遇到的问题及解决办法："></a>写的时候遇到的问题及解决办法：</h2><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klhc7pofj20hc0a8wg9.jpg" alt=""></p>
<p>在SauserHi大佬的解释下，豁然开朗，我好菜啊ORZ</p>
<p>因为我写了析构函数，没有另写拷贝构造函数，所以我的返回值被我自己析构了(#ﾟДﾟ)，以下说明来自百度百科</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klg2wfsij20hc053q3w.jpg" alt=""></p>
<p>解决方法是把写的析构函数给删了，或者写一个拷贝构造函数，代码中我采用了第一种</p>
<h2 id="运行效果："><a href="#运行效果：" class="headerlink" title="运行效果："></a>运行效果：</h2><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klg2x303j20fu05bwfu.jpg" alt=""></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>别的功能都没试过，随手写的或许充满bug╮(￣▽￣””)╭</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">class ChainNode&#123;</span><br><span class="line">public:</span><br><span class="line">    T data;</span><br><span class="line">    ChainNode&lt;T&gt; *next;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class extendedChain&#123;</span><br><span class="line">    public:</span><br><span class="line">        extendedChain()&#123;first&#x3D;NULL;last&#x3D;NULL;&#125;</span><br><span class="line">        bool IsEmpty() const&#123;return first&#x3D;&#x3D;NULL;&#125;</span><br><span class="line">        int Length()const; </span><br><span class="line">        bool Find(int k, T&amp; x)const; </span><br><span class="line">        int Search(const T&amp; x)const; </span><br><span class="line">        extendedChain&lt;T&gt;&amp; Delete(int k,T&amp; x); </span><br><span class="line">        extendedChain&lt;T&gt;&amp; Insert(int k,const T&amp; x);</span><br><span class="line">        void Output(ostream&amp; out)const;</span><br><span class="line">        void Erase();</span><br><span class="line">        extendedChain&lt;T&gt;&amp; Append(const T&amp; x);</span><br><span class="line">    public:</span><br><span class="line">        ChainNode&lt;T&gt; *first,*last;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">int extendedChain&lt;T&gt;::Length() const&#123;</span><br><span class="line">    ChainNode&lt;T&gt; *current&#x3D;first;</span><br><span class="line">    int len&#x3D;0;</span><br><span class="line">    while(current)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        current&#x3D;current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return len;</span><br><span class="line">&#125; </span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">bool extendedChain&lt;T&gt;::Find(int k,T&amp; x) const&#123;</span><br><span class="line">    if(k&lt;1)return false;</span><br><span class="line">    ChainNode&lt;T&gt; *current&#x3D;first;</span><br><span class="line">    int index&#x3D;1;</span><br><span class="line">    while(index&lt;k&amp;&amp;current)&#123;</span><br><span class="line">        current&#x3D;current-&gt;next;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(current)&#123;</span><br><span class="line">        x&#x3D;current-&gt;data;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false; </span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">int extendedChain&lt;T&gt;::Search(const T&amp; x) const&#123;</span><br><span class="line">    ChainNode&lt;T&gt; *current&#x3D;first;</span><br><span class="line">    int index&#x3D;1;</span><br><span class="line">    while(current&amp;&amp;current-&gt;data!&#x3D;x)&#123;</span><br><span class="line">        current&#x3D;current-&gt;next;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(current)return index;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void extendedChain&lt;T&gt;::Output(ostream&amp; out) const&#123;</span><br><span class="line">    ChainNode&lt;T&gt; *current;</span><br><span class="line">    for(current&#x3D;first;current;current&#x3D;current-&gt;next)</span><br><span class="line">        out&lt;&lt;current-&gt;data&lt;&lt;&quot;  &quot;;</span><br><span class="line">&#125;</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; out, const extendedChain&lt;T&gt;&amp; x)&#123;</span><br><span class="line">    x.Output(out);</span><br><span class="line">    return out;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">extendedChain&lt;T&gt;&amp; extendedChain&lt;T&gt;::Delete(int k,T&amp; x)&#123;</span><br><span class="line">    if(k&lt;1||!first)cout&lt;&lt;&quot;WORNG&quot;&lt;&lt;endl;</span><br><span class="line">    ChainNode&lt;T&gt; *p&#x3D;first;</span><br><span class="line">    if(k&#x3D;&#x3D;1)first&#x3D;first-&gt;next;</span><br><span class="line">    else&#123;</span><br><span class="line">        ChainNode&lt;T&gt; *q&#x3D;first;</span><br><span class="line">        for(int index&#x3D;1;index&lt;k-1&amp;&amp;q;index++)q&#x3D;q-&gt;next;</span><br><span class="line">        if(!q||!q-&gt;next)cout&lt;&lt;&quot;WORNG&quot;&lt;&lt;endl;</span><br><span class="line">        p&#x3D;q-&gt;next;</span><br><span class="line">        q-&gt;next&#x3D;p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    x&#x3D;p-&gt;data;</span><br><span class="line">    delete p;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">extendedChain&lt;T&gt;&amp; extendedChain&lt;T&gt;::Insert(int k,const T&amp; x)&#123;</span><br><span class="line">    if(k&lt;0)cout&lt;&lt;&quot;WORNG&quot;&lt;&lt;endl;</span><br><span class="line">    ChainNode&lt;T&gt; *p&#x3D;first;</span><br><span class="line">    for(int index&#x3D;1;index&lt;k&amp;&amp;p;index++)p&#x3D;p-&gt;next;</span><br><span class="line">    if(k&gt;0&amp;&amp;!p)cout&lt;&lt;&quot;WORNG&quot;&lt;&lt;endl;</span><br><span class="line">    ChainNode&lt;T&gt; *y&#x3D;new ChainNode&lt;T&gt;;</span><br><span class="line">    y-&gt;data&#x3D;x;</span><br><span class="line">    if(k&amp;&amp;p-&gt;next&#x3D;&#x3D;NULL)&#123;&#x2F;&#x2F;添加到尾部</span><br><span class="line">        y-&gt;next&#x3D;NULL;</span><br><span class="line">        p-&gt;next&#x3D;y;</span><br><span class="line">        last&#x3D;y;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(k)&#123;</span><br><span class="line">        y-&gt;next&#x3D;p-&gt;next;</span><br><span class="line">        p-&gt;next&#x3D;y;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        y-&gt;next&#x3D;first;</span><br><span class="line">        first&#x3D;y;</span><br><span class="line">        last&#x3D;y;</span><br><span class="line">    &#125;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void extendedChain&lt;T&gt;::Erase()&#123;</span><br><span class="line">    ChainNode&lt;T&gt; *next;</span><br><span class="line">    while(first)&#123;</span><br><span class="line">        next&#x3D;first-&gt;next;</span><br><span class="line">        delete first;</span><br><span class="line">        first&#x3D;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">extendedChain&lt;T&gt;&amp; extendedChain&lt;T&gt;::Append(const T&amp; x)&#123;</span><br><span class="line">    ChainNode&lt;T&gt; *y&#x3D;new ChainNode&lt;T&gt;;</span><br><span class="line">    y-&gt;data&#x3D;x;</span><br><span class="line">    y-&gt;next&#x3D;NULL;</span><br><span class="line">    if(first!&#x3D;NULL)&#123;</span><br><span class="line">        last-&gt;next&#x3D;y;</span><br><span class="line">        last&#x3D;y;</span><br><span class="line">    &#125;</span><br><span class="line">    else first&#x3D;last&#x3D;y;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">extendedChain&lt;T&gt; meld(extendedChain&lt;T&gt; A,extendedChain&lt;T&gt; B)&#123;</span><br><span class="line">    extendedChain&lt;T&gt; C;</span><br><span class="line">    ChainNode&lt;T&gt; *a,*b,*c;</span><br><span class="line">    a&#x3D;A.first;b&#x3D;B.first;</span><br><span class="line">    while(a!&#x3D;NULL&amp;&amp;b!&#x3D;NULL)&#123;</span><br><span class="line">        C.Append(a-&gt;data);</span><br><span class="line">        a&#x3D;a-&gt;next;</span><br><span class="line">        C.Append(b-&gt;data);</span><br><span class="line">        b&#x3D;b-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    if(a&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">        while(b)&#123;</span><br><span class="line">            C.Append(b-&gt;data);</span><br><span class="line">            b&#x3D;b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(b&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">        while(a)&#123;</span><br><span class="line">            C.Append(a-&gt;data);</span><br><span class="line">            a&#x3D;a-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return C;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    extendedChain&lt;int&gt; A,B,C;</span><br><span class="line">    for(int i&#x3D;1;i&lt;50;i++)A.Append(i);</span><br><span class="line">    for(int i&#x3D;1;i&lt;25;i++)B.Append(i);</span><br><span class="line">    A.Output(cout);B.Output(cout);</span><br><span class="line">    C&#x3D;meld(A,B);</span><br><span class="line">    C.Output(cout);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="2-双向循环链表"><a href="#2-双向循环链表" class="headerlink" title="2.双向循环链表"></a>2.双向循环链表</h1><h2 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h2><p>使用带有头节点的双向循环链表</p>
<p>1）编写一个非成员方法split(a,b)，它生成两个链表a和b，a包含c中索引为奇数的元素，b包含c中其余的元素，这个方法不能改变c</p>
<p>2）编写方法chain<T>::split，它与1)的函数类似，然而，它用输入链表<code>*this</code>的空间建立了链表a和b</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p><strong>第一种：非成员函数，分配新的内存空间</strong></p>
<p>和作业17题差不多，用append方法，用一个指针c扫一遍链表C，然后交叉的添加到A,B的尾端，因为是双向循环链表，所以append函数中要处理一下RightEnd</p>
<p>【运行效果】<br><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klg2won3j20fr06swgj.jpg" alt=""></p>
<hr>
<p><strong>第二种：成员函数，直接用链表c的内存空间</strong></p>
<p>比如1 2 3 4 5 6，本来是1⇄2⇄3⇄4⇄5⇄6这样的结构，如果要利用C的内存空间产生AB那么就是1⇄3⇄5，2⇄4⇄6，所以只需要修改一下指针的指向即可，本来[1]-&gt;right=[2],则修改为[1]-&gt;right=[3]，[3]-&gt;left=[1]，还是用指针c遍历一遍，复杂度是o(n)的，头尾节点要特殊处理一下</p>
<p>【运行效果】</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klhqnrkbj20ft059wfq.jpg" alt=""></p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><p>附带了双向循环链表别的成员函数，正确性未知╮(￣▽￣””)╭</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">class DoubleNode &#123;</span><br><span class="line">    public:</span><br><span class="line">        T data;</span><br><span class="line">        DoubleNode&lt;T&gt; *left,*right;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class DoubleChain &#123;</span><br><span class="line">    public:</span><br><span class="line">        DoubleChain() &#123;LeftEnd&#x3D;RightEnd&#x3D;NULL;&#125;;   </span><br><span class="line">        int Length() const; </span><br><span class="line">        bool Find(int k, T&amp; x) const; </span><br><span class="line">        int Search(const T&amp; x) const; </span><br><span class="line">        DoubleChain&lt;T&gt;&amp; Delete(int k,T&amp; x); </span><br><span class="line">        DoubleChain&lt;T&gt;&amp; Insert(int k,const T&amp; x); </span><br><span class="line">        void Output(ostream&amp; out) const;</span><br><span class="line">        DoubleChain&lt;T&gt;&amp; Append(const T&amp; x);</span><br><span class="line">        void split(DoubleChain&lt;T&gt; &amp;A,DoubleChain&lt;T&gt; &amp;B);</span><br><span class="line">    public:</span><br><span class="line">        DoubleNode&lt;T&gt; *LeftEnd,*RightEnd;</span><br><span class="line">&#125;; </span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">int DoubleChain&lt;T&gt;::Length() const&#123;</span><br><span class="line">    DoubleNode&lt;T&gt; *current&#x3D;LeftEnd;</span><br><span class="line">    int len&#x3D;0;</span><br><span class="line">    while(current)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        current&#x3D;current-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    return len;</span><br><span class="line">&#125; </span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">bool DoubleChain&lt;T&gt;::Find(int k,T&amp; x) const&#123;</span><br><span class="line">    if(k&lt;1)return false;</span><br><span class="line">    DoubleNode&lt;T&gt; *current&#x3D;LeftEnd;</span><br><span class="line">    int index&#x3D;1;</span><br><span class="line">    while(index&lt;k&amp;&amp;current)&#123;</span><br><span class="line">        current&#x3D;current-&gt;right;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(current)&#123;</span><br><span class="line">        x&#x3D;current-&gt;data;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false; </span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">int DoubleChain&lt;T&gt;::Search(const T&amp; x) const&#123;</span><br><span class="line">    DoubleNode&lt;T&gt; *current&#x3D;LeftEnd;</span><br><span class="line">    int index&#x3D;1;</span><br><span class="line">    while(current&amp;&amp;current-&gt;data!&#x3D;x)&#123;</span><br><span class="line">        current&#x3D;current-&gt;right;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(current)return index;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void DoubleChain&lt;T&gt;::Output(ostream&amp; out) const&#123;</span><br><span class="line">    DoubleNode&lt;T&gt; *current;</span><br><span class="line">    for(current&#x3D;LeftEnd;current;current&#x3D;current-&gt;right)</span><br><span class="line">        out&lt;&lt;current-&gt;data&lt;&lt;&quot;  &quot;;</span><br><span class="line">&#125;</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; out, const DoubleChain&lt;T&gt;&amp; x)&#123;</span><br><span class="line">    x.Output(out);</span><br><span class="line">    return out;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">DoubleChain&lt;T&gt;&amp; DoubleChain&lt;T&gt;::Delete(int k,T&amp; x)&#123;</span><br><span class="line">    if(k&lt;1||!LeftEnd)cout&lt;&lt;&quot;WORNG&quot;&lt;&lt;endl;</span><br><span class="line">    DoubleNode&lt;T&gt; *p&#x3D;LeftEnd;</span><br><span class="line">    if(k&#x3D;&#x3D;1)LeftEnd&#x3D;LeftEnd-&gt;right;</span><br><span class="line">    else&#123;</span><br><span class="line">        DoubleNode&lt;T&gt; *q&#x3D;LeftEnd;</span><br><span class="line">        for(int index&#x3D;1;index&lt;k-1&amp;&amp;q;index++)q&#x3D;q-&gt;right;</span><br><span class="line">        if(!q||!q-&gt;right)cout&lt;&lt;&quot;WORNG&quot;&lt;&lt;endl;</span><br><span class="line">        p-&gt;left-&gt;right&#x3D;p-&gt;right;</span><br><span class="line">        p-&gt;right-&gt;left&#x3D;p-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    x&#x3D;p-&gt;data;</span><br><span class="line">    delete p;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">DoubleChain&lt;T&gt;&amp; DoubleChain&lt;T&gt;::Insert(int k,const T&amp; x)&#123;</span><br><span class="line">    if(k&lt;0)cout&lt;&lt;&quot;WORNG&quot;&lt;&lt;endl;</span><br><span class="line">    DoubleNode&lt;T&gt; *p&#x3D;LeftEnd;</span><br><span class="line">    for(int index&#x3D;1;index&lt;k&amp;&amp;p;index++)p&#x3D;p-&gt;right;</span><br><span class="line">    if(k&gt;0&amp;&amp;!p)cout&lt;&lt;&quot;WORNG&quot;&lt;&lt;endl;</span><br><span class="line">    DoubleNode&lt;T&gt; *y&#x3D;new DoubleNode&lt;T&gt;;</span><br><span class="line">    y-&gt;data&#x3D;x;</span><br><span class="line">    if(k&amp;&amp;p-&gt;next&#x3D;&#x3D;NULL)&#123;&#x2F;&#x2F;添加到尾部</span><br><span class="line">        y-&gt;right&#x3D;NULL;</span><br><span class="line">        y-&gt;left&#x3D;p;</span><br><span class="line">        p-&gt;right&#x3D;y;</span><br><span class="line">        RightEnd&#x3D;y;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(k)&#123;&#x2F;&#x2F;中间</span><br><span class="line">        y-&gt;left&#x3D;p-&gt;left;</span><br><span class="line">        p-&gt;left-&gt;right&#x3D;y;</span><br><span class="line">        y-&gt;right&#x3D;p;</span><br><span class="line">        p-&gt;left&#x3D;y;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;&#x2F;&#x2F;头部</span><br><span class="line">        y-&gt;left&#x3D;NULL;</span><br><span class="line">        y-&gt;right&#x3D;p;</span><br><span class="line">        p-&gt;left&#x3D;y;</span><br><span class="line">        LeftEnd&#x3D;y;</span><br><span class="line">    &#125;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">DoubleChain&lt;T&gt;&amp; DoubleChain&lt;T&gt;::Append(const T&amp; x)&#123;</span><br><span class="line">    DoubleNode&lt;T&gt; *y&#x3D;new DoubleNode&lt;T&gt;;</span><br><span class="line">    y-&gt;data&#x3D;x;</span><br><span class="line">    y-&gt;right&#x3D;NULL;</span><br><span class="line">    if(RightEnd)&#123;</span><br><span class="line">        RightEnd-&gt;right&#x3D;y;</span><br><span class="line">        y-&gt;left&#x3D;RightEnd;</span><br><span class="line">        RightEnd&#x3D;y;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        y-&gt;left&#x3D;NULL;</span><br><span class="line">        LeftEnd&#x3D;RightEnd&#x3D;y;</span><br><span class="line">    &#125;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void split(DoubleChain&lt;T&gt; C,DoubleChain&lt;T&gt; &amp;A,DoubleChain&lt;T&gt; &amp;B)&#123;</span><br><span class="line">    DoubleNode&lt;T&gt; *y&#x3D;new DoubleNode&lt;T&gt;;</span><br><span class="line">    y&#x3D;C.LeftEnd;</span><br><span class="line">    T tmp;</span><br><span class="line">    while(y)&#123;</span><br><span class="line">        tmp&#x3D;y-&gt;data;</span><br><span class="line">        A.Append(tmp);</span><br><span class="line">        y&#x3D;y-&gt;right;</span><br><span class="line">        if(y)&#123;</span><br><span class="line">            tmp&#x3D;y-&gt;data;</span><br><span class="line">            B.Append(tmp);</span><br><span class="line">            y&#x3D;y-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void DoubleChain&lt;T&gt;::split(DoubleChain&lt;T&gt; &amp;A,DoubleChain&lt;T&gt; &amp;B)&#123;</span><br><span class="line">    DoubleNode&lt;T&gt; *a,*b,*c;</span><br><span class="line">    c&#x3D;a&#x3D;A.LeftEnd&#x3D;this-&gt;LeftEnd;</span><br><span class="line">    c&#x3D;c-&gt;right;</span><br><span class="line">    b&#x3D;B.LeftEnd&#x3D;c;</span><br><span class="line">    B.LeftEnd-&gt;left&#x3D;NULL;</span><br><span class="line">    c&#x3D;c-&gt;right;</span><br><span class="line">    &#x2F;&#x2F;cout&lt;&lt;A.LeftEnd-&gt;data&lt;&lt;&quot; &quot;&lt;&lt;B.LeftEnd-&gt;data&lt;&lt;endl;</span><br><span class="line">    while(c)&#123;</span><br><span class="line">        a-&gt;right&#x3D;c;</span><br><span class="line">        c-&gt;left&#x3D;a;</span><br><span class="line">        a&#x3D;c;</span><br><span class="line">        c&#x3D;c-&gt;right;</span><br><span class="line">        if(c)&#123;</span><br><span class="line">            b-&gt;right&#x3D;c;</span><br><span class="line">            c-&gt;left&#x3D;b;</span><br><span class="line">            b&#x3D;c;</span><br><span class="line">            c&#x3D;c-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a-&gt;right&#x3D;NULL;</span><br><span class="line">    A.RightEnd&#x3D;a;</span><br><span class="line">    b-&gt;right&#x3D;NULL;</span><br><span class="line">    B.RightEnd&#x3D;b;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    DoubleChain&lt;int&gt; A,B,C;</span><br><span class="line">    for(int i&#x3D;1;i&lt;100;i++)C.Append(i);</span><br><span class="line">    C.split(A,B);</span><br><span class="line">    &#x2F;&#x2F;split(C,A,B);</span><br><span class="line">    A.Output(cout);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    B.Output(cout);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    &#x2F;&#x2F;C.Output(cout);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>一些作业</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>bzoj 1085 SCOI2005 骑士精神（暴搜+剪枝,IDA*）</title>
    <url>/67dc8b75/</url>
    <content><![CDATA[<p>Time Limit: 10 Sec  Memory Limit: 162 MB</p>
<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>　　在一个5×5的棋盘上有12个白色的骑士和12个黑色的骑士， 且有一个空位。在任何时候一个骑士都能按照骑<br>士的走法（它可以走到和它横坐标相差为1，纵坐标相差为2或者横坐标相差为2，纵坐标相差为1的格子）移动到空<br>位上。 给定一个初始的棋盘，怎样才能经过移动变成如下目标棋盘： 为了体现出骑士精神，他们必须以最少的步<br>数完成任务。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>　　第一行有一个正整数T(T&lt;=10)，表示一共有N组数据。接下来有T个5×5的矩阵，0表示白色骑士，1表示黑色骑<br>士，*表示空位。两组数据之间没有空行。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>　　对于每组数据都输出一行。如果能在15步以内（包括15步）到达目标状态，则输出步数，否则输出－1。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">10110</span><br><span class="line">01*11</span><br><span class="line">10111</span><br><span class="line">01001</span><br><span class="line">00000</span><br><span class="line">01011</span><br><span class="line">110*1</span><br><span class="line">01110</span><br><span class="line">01010</span><br><span class="line">00100</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>写题十分钟。。找错一下午。。深深绝望</p>
<p><code>IDA*</code></p>
<p>因为如果当前有num个棋子不在应该的位置上，那么至少需要num次移动，所以估价函数就是当前不同的格子数+当前步数&lt;最大步数，否则就return，本质就是暴搜加剪枝</p>
<p>剪完之后跑的飞快～</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int t,a[5][5],x,y,ans;</span><br><span class="line">int res[5][5]&#x3D;&#123;1,1,1,1,1,</span><br><span class="line">               0,1,1,1,1,</span><br><span class="line">               0,0,2,1,1,</span><br><span class="line">               0,0,0,0,1,</span><br><span class="line">               0,0,0,0,0&#125;;</span><br><span class="line">int dx[8]&#x3D;&#123;1,1,-1,-1,2,2,-2,-2&#125;,dy[8]&#x3D;&#123;2,-2,2,-2,1,-1,1,-1&#125;;</span><br><span class="line">char str[6];</span><br><span class="line">int ok()&#123;</span><br><span class="line">    int num&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;5;i++)</span><br><span class="line">        for(int j&#x3D;0;j&lt;5;j++)</span><br><span class="line">            num+&#x3D;(a[i][j]!&#x3D;res[i][j]);</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int d,int xx,int yy)&#123;</span><br><span class="line">    int tmp&#x3D;ok();</span><br><span class="line">    if(tmp&#x3D;&#x3D;0)&#123;</span><br><span class="line">        ans&#x3D;d;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(d+tmp-1&gt;&#x3D;ans)return;</span><br><span class="line">    int nx,ny;</span><br><span class="line">    for(int i&#x3D;0;i&lt;8;i++)&#123;</span><br><span class="line">        int nx&#x3D;xx+dx[i],ny&#x3D;yy+dy[i];</span><br><span class="line">        if(nx&lt;0||nx&gt;4||ny&lt;0||ny&gt;4)continue;</span><br><span class="line">        swap(a[xx][yy],a[nx][ny]);</span><br><span class="line">        dfs(d+1,nx,ny);</span><br><span class="line">        swap(a[xx][yy],a[nx][ny]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        ans&#x3D;16;</span><br><span class="line">        for(int i&#x3D;0;i&lt;5;i++)&#123;</span><br><span class="line">            scanf(&quot;%s&quot;,str);</span><br><span class="line">            for(int j&#x3D;0;j&lt;5;j++)&#123;</span><br><span class="line">                if(str[j]&#x3D;&#x3D;&#39;*&#39;)&#123;</span><br><span class="line">                    x&#x3D;i;y&#x3D;j;</span><br><span class="line">                    a[i][j]&#x3D;2;</span><br><span class="line">                &#125;</span><br><span class="line">                else a[i][j]&#x3D;(int)(str[j]-&#39;0&#39;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(0,x,y);     </span><br><span class="line">        if(ans&#x3D;&#x3D;16)printf(&quot;-1\n&quot;);</span><br><span class="line">        else printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1835 完全图（dp+组合数打表）</title>
    <url>/9562e52/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 40 难度：4级算法题</p>
<p>初始有n个点，任意两个点之间有一条无向边，现在要移除一些无向边（至少一条），问移除后有恰好m个连通块的方案数是多少。</p>
<a id="more"></a>

<p>两个方案不同当且仅当存在至少一条无向边在某个方案中被移除，但是在另一个方案中没被移除。</p>
<p>答案可能很大请模一个998,244,353。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行读入n,m。<br>1&lt;=m&lt;=n&lt;=500</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>第一行输出方案数。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>dp(i,j)表示i个点的完全图分成j个连通块的方案数</p>
<p>首先考虑先固定某个点，比如编号为x的点，那么假设某个连通块一定包含这个点，那么这个连通块所包含的点数范围是[1,i-(j-1)]</p>
<p>假设这个有点x的连通块共有k个点，k的范围是[1,i-(j-1)]，那么dp(i,j)的方法数就是<code>C(i-1,k-1)*dp(k,1)*dp(i-k,j-1)</code></p>
<p>也就是在的剩下的i-1个点中选<code>k-1</code>个和x放一个连通块里，选好后连接的方法数为<code>dp(k,1)</code>，然后剩余点的方法数是<code>dp(i-k,j-1)</code></p>
<p>综上，状态转移方程为：<br><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kknjsdzgj20a601w3yh.jpg" alt=""></p>
<p>然后考虑怎么求dp(k,1)，k个点在1个连通块的方法数，是所有连接的总方法数<code>2^[i*(i-1)/2]</code>（某条边连或不连），减去那些不合法的方法数，也就是形成多个连通块</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kknjx0ufj206z01wa9y.jpg" alt=""></p>
<p>最后wa了一组数据，<code>n=500，m=1</code>，因为题中说“移除一些无向边（至少一条）”，所以<code>m=1</code>的时候要减去完全图的那种情况，特判一下，即<code>m=1</code>时答案是<code>dp(i,1)-1</code></p>
<p>此外，还从别人代码里学了个妙妙的组合数初始化，因为这题所有组合数差不多都要用到，所以先利用组合数性质<code>c[i][j]=c[i-1][j-1]+c[i-1][j]</code>，就可以o(n^2)递推打表～</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int p&#x3D;998244353;</span><br><span class="line">const int N&#x3D;505;</span><br><span class="line">LL dp[N][N],c[N][N];</span><br><span class="line">int n,m;</span><br><span class="line">LL qpow(LL a,LL b)&#123;</span><br><span class="line">    LL ans&#x3D;1;</span><br><span class="line">    a%&#x3D;p;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            ans&#x3D;ans*a%p;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        b&gt;&gt;&#x3D;1;</span><br><span class="line">        a&#x3D;a*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    for(int i&#x3D;0;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        c[i][0]&#x3D;c[i][i]&#x3D;1;</span><br><span class="line">        for(int j&#x3D;1;j&lt;i;j++)</span><br><span class="line">            c[i][j]&#x3D;(c[i-1][j-1]+c[i-1][j])%p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    init();</span><br><span class="line">    dp[1][1]&#x3D;1;</span><br><span class="line">    for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        for(int j&#x3D;2;j&lt;&#x3D;i;j++)&#123;</span><br><span class="line">            dp[i][j]&#x3D;0;</span><br><span class="line">            for(int k&#x3D;1;k&lt;&#x3D;i-j+1;k++)</span><br><span class="line">                dp[i][j]&#x3D;(dp[i][j]+(((c[i-1][k-1]*dp[k][1])%p)*dp[i-k][j-1])%p)%p;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][1]&#x3D;qpow(2,i*(i-1)&#x2F;2);</span><br><span class="line">        for(int j&#x3D;2;j&lt;&#x3D;i;j++)</span><br><span class="line">            dp[i][1]&#x3D;(dp[i][1]-dp[i][j]+p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;,dp[n][m]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1102 面积最大的矩形（单调栈）</title>
    <url>/dd1d064a/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 20 难度：3级算法题</p>
<p>有一个正整数的数组，化为直方图，求此直方图包含的最大矩形面积。例如 2,1,5,6,2,3，对应的直方图如下：</p>
<a id="more"></a>

<p><img src="https://img.51nod.com/upfile/000fbce2/08d164337bdb2808000000000027de17.png" alt=""></p>
<p>面积最大的矩形为5,6组成的宽度为2的矩形，面积为10。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：1个数N，表示数组的长度(0 &lt;= N &lt;= 50000)<br>第2 - N + 1行：数组元素A[i]。(1 &lt;= A[i] &lt;= 10^9)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出最大的矩形面积</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>单调栈</p>
<p>直接对样例操作一波吧，先是0入栈，a[0]&gt;a[1]，算一波先，<code>(1-0)*2=2</code>，然后没了，那么先更新一下a[0]=1，因为延伸过去最高是1格，继续a[2]入栈，a[3]入栈，<code>a[4]&lt;a[3]</code>，然后卡在这里继续算一波，s.top()变为a[3]，<code>(4-3)*6=1</code>，s.top()变为a[2]，<code>(4-2)*5=10</code>，然后出栈，更新a[2]=a[4]=2，因为此时a[2]延伸过去可以到2格，然后a[5]入栈，最后算一波<code>(6-5)*2=2</code>，s.top()变为a[2]，<code>(6-2)*2=8</code></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;50005;</span><br><span class="line">LL a[N];</span><br><span class="line">stack&lt;int&gt;s;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,cur;</span><br><span class="line">    LL ans&#x3D;0,tmp;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    while(!s.empty())s.pop();</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%lld&quot;,&amp;a[i]);</span><br><span class="line">    a[n]&#x3D;-1;</span><br><span class="line">    for(int i&#x3D;0;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        if(s.empty()||a[i]&gt;a[s.top()])s.push(i);</span><br><span class="line">        else if(a[i]&lt;a[s.top()])&#123;</span><br><span class="line">            while(!s.empty()&amp;&amp;a[i]&lt;a[s.top()])&#123;</span><br><span class="line">                tmp&#x3D;(i-s.top())*a[s.top()];</span><br><span class="line">                ans&#x3D;max(ans,tmp);</span><br><span class="line">                cur&#x3D;s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            a[cur]&#x3D;a[i];</span><br><span class="line">            s.push(cur);</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round 516 Div. 2（A-E）</title>
    <url>/aba8e35b/</url>
    <content><![CDATA[<h1 id="1064-A-Make-a-triangle"><a href="#1064-A-Make-a-triangle" class="headerlink" title="1064 A. Make a triangle!"></a>1064 A. Make a triangle!</h1><p><a href="http://codeforces.com/contest/1064/problem/A" target="_blank" rel="noopener">http://codeforces.com/contest/1064/problem/A</a></p>
<a id="more"></a>

<p>题意：给三条边长，每次可以给任意一边长度加一，问组成三角形至少要加几次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a[3];</span><br><span class="line">    scanf(&quot;%d%d%d&quot;,&amp;a[0],&amp;a[1],&amp;a[2]);</span><br><span class="line">    sort(a,a+3);</span><br><span class="line">    if(a[0]+a[1]&gt;a[2])printf(&quot;0\n&quot;);</span><br><span class="line">    else printf(&quot;%d\n&quot;,a[2]-a[1]-a[0]+1);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1064-B-Equations-of-Mathematical-Magic（思维）"><a href="#1064-B-Equations-of-Mathematical-Magic（思维）" class="headerlink" title="1064 B. Equations of Mathematical Magic（思维）"></a>1064 B. Equations of Mathematical Magic（思维）</h1><p><a href="http://codeforces.com/contest/1064/problem/B" target="_blank" rel="noopener">http://codeforces.com/contest/1064/problem/B</a></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kl9w6th5j204000hq2q.jpg" alt=""></p>
<p>题意：给一个a，求满足条件的非负x的个数（式子中那个符号是异或）</p>
<p>也就是<code>a=(a⊕x)+x</code>，那么式子成立的条件是，a为0的位x也为0，a位1的位x为1或0，所以答案就是<code>2^(a中1的个数)</code></p>
<p>我也不知道我干嘛写了个快速幂。。小手一抖就写了，这不重要(･-･;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">LL qpow(LL a,LL b)&#123;</span><br><span class="line">    LL ans&#x3D;1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            ans&#x3D;(ans*a);</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        b&#x2F;&#x3D;2;</span><br><span class="line">        a&#x3D;a*a;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,num;</span><br><span class="line">    LL n,tmp;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%I64d&quot;,&amp;n);</span><br><span class="line">        tmp&#x3D;n;num&#x3D;0;</span><br><span class="line">        while(tmp)&#123;</span><br><span class="line">            if(tmp&amp;1)num++;</span><br><span class="line">            tmp&#x2F;&#x3D;2;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%I64d\n&quot;,qpow(2,num));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1064-C-Oh-Those-Palindromes（字符串）"><a href="#1064-C-Oh-Those-Palindromes（字符串）" class="headerlink" title="1064 C. Oh Those Palindromes（字符串）"></a>1064 C. Oh Those Palindromes（字符串）</h1><p><a href="http://codeforces.com/contest/1064/problem/C" target="_blank" rel="noopener">http://codeforces.com/contest/1064/problem/C</a></p>
<p>题意：给你一个字符串，问它怎么排列能使回文子序列最多</p>
<p>我还在想怎么对称的时候学长秒给思路，tql，字母同样的放一起就行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int a[26];</span><br><span class="line">string s;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    memset(a,0,sizeof(a));</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)a[s[i]-&#39;a&#39;]++;</span><br><span class="line">    for(int i&#x3D;0;i&lt;26;i++)&#123;</span><br><span class="line">        for(int j&#x3D;0;j&lt;a[i];j++)</span><br><span class="line">            printf(&quot;%c&quot;,(char)(i+&#39;a&#39;));</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1064-D-Labyrinth（bfs）"><a href="#1064-D-Labyrinth（bfs）" class="headerlink" title="1064 D. Labyrinth（bfs）"></a>1064 D. Labyrinth（bfs）</h1><p><a href="http://codeforces.com/contest/1064/problem/D" target="_blank" rel="noopener">http://codeforces.com/contest/1064/problem/D</a></p>
<p>题意：给一个nxm的图，图上有空格和障碍格，给一个起点(r,c)（保证起点不是障碍格），给两个值x，y表示最多只能向左x次向右y次，上下不限，求问能到达多少个格子（起点也算）</p>
<p>一下子就写完了bfs，然后就陷入了无穷无尽的wa13，然后各种改乱交了好几发，我就睡着了╭(°A°’’)╮，嗷都是躺椅的锅。。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g2s4spwcl7j30lq05e3ze.jpg" alt=""></p>
<p>因为我bfs的思路有点问题，一个点如果vis了我就直接return掉了，但是可能存在一些情况是，这个点可以在左右次数剩余不同的情况下被vis，那么两个状态实际上都可以继续延伸，需要取更优的那种，所以这里就会出现问题了</p>
<p>看了别人的代码，有一种很巧妙的双端队列的写法，动上下的时候<code>push_front</code>，动左右的时候<code>push_back</code>，这样就可以保证优先性了，妙啊妙啊</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;2005;</span><br><span class="line">int a[N][N],vis[N][N],n,m,l,r,sx,sy,ans;</span><br><span class="line">char str[N];</span><br><span class="line">struct ss&#123;</span><br><span class="line">    int x,y,ll,rr;</span><br><span class="line">    ss(int a,int b,int c,int d)&#123;</span><br><span class="line">        x&#x3D;a;y&#x3D;b;ll&#x3D;c;rr&#x3D;d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void bfs()&#123;</span><br><span class="line">    deque&lt;ss&gt;q;</span><br><span class="line">    q.push_front(ss(sx,sy,l,r));</span><br><span class="line">    vis[sx][sy]&#x3D;1;</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        ss u&#x3D;q.front();</span><br><span class="line">        q.pop_front();</span><br><span class="line">        if(u.x+1&lt;&#x3D;n&amp;&amp;!vis[u.x+1][u.y]&amp;&amp;a[u.x+1][u.y])&#123;</span><br><span class="line">            vis[u.x+1][u.y]&#x3D;1;</span><br><span class="line">            q.push_front(ss(u.x+1,u.y,u.ll,u.rr));</span><br><span class="line">        &#125;</span><br><span class="line">        if(u.x-1&gt;&#x3D;1&amp;&amp;!vis[u.x-1][u.y]&amp;&amp;a[u.x-1][u.y])&#123;</span><br><span class="line">            vis[u.x-1][u.y]&#x3D;1;</span><br><span class="line">            q.push_front(ss(u.x-1,u.y,u.ll,u.rr));</span><br><span class="line">        &#125;</span><br><span class="line">        if(u.y+1&lt;&#x3D;m&amp;&amp;!vis[u.x][u.y+1]&amp;&amp;u.rr&gt;&#x3D;1&amp;&amp;a[u.x][u.y+1])&#123;</span><br><span class="line">            vis[u.x][u.y+1]&#x3D;1;</span><br><span class="line">            q.push_back(ss(u.x,u.y+1,u.ll,u.rr-1));</span><br><span class="line">        &#125;</span><br><span class="line">        if(u.y-1&gt;&#x3D;1&amp;&amp;!vis[u.x][u.y-1]&amp;&amp;u.ll&gt;&#x3D;1&amp;&amp;a[u.x][u.y-1])&#123;</span><br><span class="line">            vis[u.x][u.y-1]&#x3D;1;</span><br><span class="line">            q.push_back(ss(u.x,u.y-1,u.ll-1,u.rr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    cin&gt;&gt;sx&gt;&gt;sy;</span><br><span class="line">    cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%s&quot;,str);</span><br><span class="line">        for(int j&#x3D;1;j&lt;&#x3D;m;j++)&#123;           </span><br><span class="line">            if(str[j-1]&#x3D;&#x3D;&#39;*&#39;)a[i][j]&#x3D;0;</span><br><span class="line">            else a[i][j]&#x3D;1;</span><br><span class="line">            vis[i][j]&#x3D;0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bfs();</span><br><span class="line">    ans&#x3D;0;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">        for(int j&#x3D;1;j&lt;&#x3D;m;j++)</span><br><span class="line">            ans+&#x3D;vis[i][j];</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1064-E-Dwarves-Hats-and-Extrasensory-Abilities（二分-思维）"><a href="#1064-E-Dwarves-Hats-and-Extrasensory-Abilities（二分-思维）" class="headerlink" title="1064 E. Dwarves, Hats and Extrasensory Abilities（二分+思维）"></a>1064 E. Dwarves, Hats and Extrasensory Abilities（二分+思维）</h1><p><a href="http://codeforces.com/contest/1064/problem/E" target="_blank" rel="noopener">http://codeforces.com/contest/1064/problem/E</a></p>
<p>题意：给出n，然后有n次交互，输出一个坐标，然后系统返回是黑色或白色，表明刚刚输入的坐标是黑子或白子，最后要找到一条直线分开所有黑子和白子</p>
<p>没写过交互题0.0，和一般的题差别就是：输出之后要清空缓存区，<code>fflush(stdout);</code></p>
<p>这个题大概算是个思维题吧，用一下二分的思想，画个图其实蛮好想的，而且n&lt;=30巨水，大致构造思路如下：<br>（1，2，3，4记录了线m移动的顺序）</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g2s4suy0e4j30b007xmx8.jpg" alt=""></p>
<p>初始化l，r，m=(l+r)/2，并标记当前棋子颜色，然后每次同色的就使l=m，更新m的位置继续，如果不同色那么就使r=m，更新m继续，不断往中间挤，这样保证能把不同色棋子分到两边</p>
<p>注意这里要记录最后一次线往左移还是往右移，往右移的话最后那个线就是y=-x+b，过(m+0.5,m+0.5)，往左移的话就过(m-0.5,m-0.5)，初始化flag=1，也就是+0.5那种，因为特例只有一个点，那么不能把线移到负坐标轴去</p>
<p>感觉我这题代码写的蛮优美的嘻嘻∠( ᐛ 」∠)＿</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line">int now,n,m,l&#x3D;0,r&#x3D;(1&lt;&lt;29),flag&#x3D;1;</span><br><span class="line">int solve(int x,int y)&#123;</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">    fflush(stdout);</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    return s[0]&#x3D;&#x3D;&#39;b&#39;;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    n--;</span><br><span class="line">    now&#x3D;solve(0,0);</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        m&#x3D;(l+r)&gt;&gt;1;</span><br><span class="line">        if(solve(m,m)&#x3D;&#x3D;now)&#123;</span><br><span class="line">            l&#x3D;m;flag&#x3D;1;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            r&#x3D;m;flag&#x3D;0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag)printf(&quot;%d %d %d %d\n&quot;,m,m+1,m+1,m);</span><br><span class="line">    else printf(&quot;%d %d %d %d\n&quot;,m,m-1,m-1,m);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F-Candies-for-Children"><a href="#F-Candies-for-Children" class="headerlink" title="F. Candies for Children"></a>F. Candies for Children</h1><p><a href="http://codeforces.com/contest/1064/problem/F" target="_blank" rel="noopener">http://codeforces.com/contest/1064/problem/F</a></p>
<p><a href="http://leflacon.github.io/13028674" target="_blank" rel="noopener">CF 516 D. Candies for Children（分类讨论）</a>w</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>字符串</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>ural 1309 Dispute（相当奇妙的递推）</title>
    <url>/f1aab9cf/</url>
    <content><![CDATA[<p style="background-color:rgba(219,233,243,0.7)">周末学一个叫化归的东西٩(˃̶͈̀௰˂̶͈́)و，化归思想就是转化和归结，emmmm大概就是学一下这种解题手法，把一个看起来复杂实际也复杂的数列蜜汁操作一下变成我们熟悉的形式</p>

<a id="more"></a>

<hr>
<p><a href="http://acm.timus.ru/problem.aspx?space=1&amp;num=1309" target="_blank" rel="noopener">http://acm.timus.ru/problem.aspx?space=1&amp;num=1309</a></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kl6ha9uuj20oa0hwn1o.jpg" alt=""></p>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(0) &#x3D; 0,  </span><br><span class="line">f(n) &#x3D; g(n, f(n-1)),  </span><br><span class="line">g(x,y) &#x3D; ((y-1)x^5+x^3–x*y+3x+7y) % 9973  </span><br><span class="line">求f(n)，n是1e8</span><br></pre></td></tr></table></figure>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>先考虑怎么把这个复杂的大问题变成容易解决的小问题</p>
<p>看看这个数列有什么特点</p>
<p><code>g(x,y)=((y-1)x^5+x^3–x*y+3x+7y)%9973</code></p>
<p>然后把这个式子整理一下，把x看作常数，那么这个式子就将变成一个关于y的一阶线性递推数列</p>
<p><code>g(x,y)=((x^5-x+7)y-x^5+x^3+3x)%9973=g(n,f(n-1))</code></p>
<p>也就是<code>f(x)=((x^5-x+7)*f(n-1)-x^5+x^3+3x)%9973</code></p>
<p>令A=(x^5-x+7)，B=(-x^5+x^3+3x)，那么<code>f(n)=An*f(n-1)+Bn</code>，对于An，Bn，周期为p，易求</p>
<p>然后由<code>f(n)=An*f(n-1)+Bn</code>继续往下写出<code>f(n-1)=A(n-1)*f(n-2)+B(n-1)...f(n-p)=A(n-p+1)*f(n-p)+B(n-p+1)</code>，（公式太难打了就不写具体步骤了，纸上算一下答案就有了），代入整理一下最后得：<code>f(n)=An*A(n-1)*...*A(n-p+1)*f(n-p)+An...A2B1+...+AnAn-1Bn-2+AnBn-1</code>（差不多是这样吧。。0.0如有错误请指出），写清爽一点就是<code>f(n)=Pn*f(n-p)+Qn</code>，也就是说f(n)也存在周期p，当然那些一长串的东西变成的Qn,Pn同样也是以p为周期</p>
<p>这样以后问题就解决了，（n/p）和（n%p），先计算f(n%p)，然后继续递推（n/p）次计算f(n)，即转化为两次小递推</p>
<p>写完交了wa在10，输入了0，1，9973，9974这种关键点大概排查了一下，发现是9973有问题，直接输出0了。。改了一点小问题就got an ac啦<code>\(≧▽≦)/</code></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int p&#x3D;9973;</span><br><span class="line">int n,bei;</span><br><span class="line">int getA(int x)&#123;</span><br><span class="line">    int res&#x3D;1;</span><br><span class="line">    for(int i&#x3D;0;i&lt;5;i++)res&#x3D;(res*x)%p;</span><br><span class="line">    res&#x3D;((res-x+7)%p+p)%p;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int getB(int x)&#123;</span><br><span class="line">    int res,tmp5&#x3D;1,tmp3&#x3D;1;</span><br><span class="line">    for(int i&#x3D;0;i&lt;5;i++)tmp5&#x3D;(tmp5*x)%p;</span><br><span class="line">    for(int i&#x3D;0;i&lt;3;i++)tmp3&#x3D;(tmp3*x)%p;</span><br><span class="line">    res&#x3D;((tmp3-tmp5+3*x%p)%p+p)%p; </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int f(int x)&#123;</span><br><span class="line">    if(x&#x3D;&#x3D;0)return 0;</span><br><span class="line">    return (getA(x)*f(x-1)%p+getB(x))%p;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    bei&#x3D;n&#x2F;p;</span><br><span class="line">    n%&#x3D;p;</span><br><span class="line">    int P&#x3D;1,Q&#x3D;0,ans&#x3D;f(n);</span><br><span class="line">    for(int i&#x3D;n+p;i&gt;n;i--)&#123;</span><br><span class="line">        int tmp&#x3D;i%p;</span><br><span class="line">        Q&#x3D;(Q+P*getB(tmp))%p;</span><br><span class="line">        P&#x3D;(P*getA(tmp))%p;         </span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; cout&lt;&lt;P&lt;&lt;&quot; &quot;&lt;&lt;Q&lt;&lt;endl;</span><br><span class="line">    for(int i&#x3D;0;i&lt;bei;i++)</span><br><span class="line">        ans&#x3D;(P*ans+Q)%p;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>「Python+有道」实现简易中译英英译中命令行字典</title>
    <url>/d0f16a5f/</url>
    <content><![CDATA[<p>整理我堆积如山的桌面的时候发现之前还搞了这么个玩意儿——用Python写的命令行字典，虽然Google浏览器可以直接翻译长篇大论，mac右键也可以直接查词，但是玩玩练练手也无妨啦～</p>
<a id="more"></a>

<hr>
<p>先放效果图：</p>
<ul>
<li>英译中：正常查词是可以的，但是搞事情查词我也不晓得会出现什么</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kl9w93z0j209g0bvmxw.jpg" alt=""></p>
<ul>
<li>中译英：只能一个一个词查，不支持翻译句子，否则就会变成hello cute ∠( ᐛ 」∠)＿</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kl9w8e8qj206x02uglm.jpg" alt=""></p>
<h1 id="1-基本思路与可行性分析"><a href="#1-基本思路与可行性分析" class="headerlink" title="1.基本思路与可行性分析"></a>1.基本思路与可行性分析</h1><p>用有道查词可以发现，地址栏其实是没啥变化的，也就是<code>http://dict.youdao.com/w/要查的单词/#keyfrom=dict2.top</code>，所以我们就可以输入一个单词，自己构造出对应的url，然后就能获取对应的网页了</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klab42u7j20fs095t9g.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klab5qk5j20d0077mxl.jpg" alt=""></p>
<p>那么下一个问题是如何获取词义，截了张图（请忽视那些。。乱七八糟的不知道在讲什么的东西(♯｀∧´)）</p>
<p>清清楚楚就这四个，那么关键词就是“详细释义”：（google翻译就不行。。啥都找不着）</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4klab752wj20zr0iqjxh.jpg" alt=""></p>
<p>Python实在是太强了，那么就可以使用正则表达式来查找我们要的词义</p>
<h1 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2.具体实现"></a>2.具体实现</h1><h2 id="1）导入requests模块和re模块"><a href="#1）导入requests模块和re模块" class="headerlink" title="1）导入requests模块和re模块"></a>1）导入requests模块和re模块</h2><p><a href="http://docs.python-requests.org/zh_CN/latest/user/quickstart.html" target="_blank" rel="noopener">Requests官方文档</a> requests用来获取有道的网页</p>
<p>re.findall()用来查找「详细释义」的地方从而找到具体释义</p>
<h2 id="2）获取网页"><a href="#2）获取网页" class="headerlink" title="2）获取网页"></a>2）获取网页</h2><p><code>url=&quot;http://dict.youdao.com/w/&quot;+word+&quot;/#keyfrom=dict2.index&quot;</code></p>
<p>然后用decode()方法对获取的内容解码：</p>
<blockquote>
<p>decode()方法</p>
<ul>
<li>描述</li>
</ul>
<p>Python decode() 方法以 encoding 指定的编码格式解码字符串。默认编码为字符串编码。</p>
<ul>
<li>语法</li>
</ul>
<p>str.decode(encoding=’UTF-8’,errors=’strict’)</p>
<ul>
<li>参数（第二个可省略）</li>
</ul>
<p>encoding – 要使用的编码，如”UTF-8”。</p>
<p>errors – 设置不同错误的处理方案。默认为 ‘strict’,意为编码错误引起一个UnicodeError。 其他可能得值有 ‘ignore’, ‘replace’, ‘xmlcharrefreplace’, ‘backslashreplace’ 以及通过 codecs.register_error() 注册的任何值。</p>
<ul>
<li>返回值</li>
</ul>
<p>该方法返回解码后的字符串。</p>
</blockquote>
<h2 id="3）获取词义以及字符串处理"><a href="#3）获取词义以及字符串处理" class="headerlink" title="3）获取词义以及字符串处理"></a>3）获取词义以及字符串处理</h2><p>re.findall语法如下：（返回形式是一个数组）</p>
<p><code>findall(pattern, string, flags=0)</code></p>
<p>所以获取词义就在之前get()函数获得的内容中寻找<code>&quot;详细释义.+&lt;p class=\&quot;collapse-content\&quot;&gt;&quot;</code>这样的形式，第一步处理的内容放在l1中，接下来还要对l1进行第二步处理，只取里面的字母数子汉字部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l1&#x3D;re.findall(&quot;详细释义.+&lt;p class&#x3D;\&quot;collapse-content\&quot;&gt;&quot;,get(),re.S)</span><br><span class="line"></span><br><span class="line">l2&#x3D;re.findall(&quot;                \w+&quot;,str(l1))</span><br></pre></td></tr></table></figure>

<p>下面顺便贴一下正则表达式里常用字符的意思，因为我记不住啊ORZ</p>
<blockquote>
<p>正则表达式 \w \s \d \b</p>
<p>. 匹配除换行符以外的任意字符</p>
<p>\w 匹配字母或数字或下划线或汉字 等价于 ‘[^A-Za-z0-9_]’</p>
<p>\s 匹配任意的空白符</p>
<p>\d 匹配数字</p>
<p>\b 匹配单词的开始或结束</p>
<p>^ 匹配字符串的开始</p>
<p>$ 匹配字符串的结束</p>
</blockquote>
<p>然后用strip()方法对l2数组里的字符串进行简单处理</p>
<blockquote>
<p>strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列<br>，该方法只能删除开头或是结尾的字符，不能删除中间部分的字符</p>
</blockquote>
<h2 id="4）输出结果"><a href="#4）输出结果" class="headerlink" title="4）输出结果"></a>4）输出结果</h2><p>好像没啥好说的，把l2中的元素print就行了</p>
<h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h1><p>中译英和英译中差不多，直接看代码吧。。</p>
<p>英译中<a href="https://github.com/LeFlacon/Simple-Python-Practice/blob/master/dict.py" target="_blank" rel="noopener">https://github.com/LeFlacon/Simple-Python-Practice/blob/master/dict.py</a></p>
<p>中译英<a href="https://github.com/LeFlacon/Simple-Python-Practice/blob/master/dict2.py" target="_blank" rel="noopener">https://github.com/LeFlacon/Simple-Python-Practice/blob/master/dict2.py</a></p>
<p>丢到github上了，emmmm其实是为了试一下git，因为之前好像没有什么能传的东西来着</p>
<hr>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>《奇遇人生》 第3期：印尼攀峰！窦骁登5000米查亚峰，阿雅因高反放弃痛哭</title>
    <url>/a0e37ddb/</url>
    <content><![CDATA[<p>看完这期觉得窦骁也太棒了吧TAT，虽然我之前没有听说过这个人</p>
<a id="more"></a>

<ul>
<li><p style="background-color:rgba(239,221,236,0.7)">登山可能就这样，就有很多的不确定性，所以我是觉得最可能这种变化，是我们必须要去面对的，在登山过程中，你们要更多的耐心，然后就是永远要期待，更好的事情发生</p>
</li>
<li><p style="background-color:rgba(239,221,236,0.7)">窦骁：今天不行还有明天，放轻松（阿雅：万一明天不行呢？）后天啊，（那万一后天也不行呢？）明日何其多，真的是</p>

</li>
</ul>
<blockquote>
<p>明日复明日，明日何其多 ～ </p>
<p>一个题写不出来没关系，反正明天我也不一定写的出来2333333，但是万一大大大大大后天突然会了呢∠( ᐛ 」∠)＿</p>
</blockquote>
<ul>
<li><p style="background-color:rgba(239,221,236,0.7)">你的预期永远不要说让它，变成一个限定，框住你的一个东西，你是自由的</p>

</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kl6s3otwj20vo0k1gru.jpg" alt=""></p>
<ul>
<li><p style="background-color:rgba(239,221,236,0.7)">窦骁：Yosua，给你，这是她的包，陪她一起走，别催她，无论什么时候，只要她感觉不舒服或者状态不好，就把她带下去</p>

</li>
</ul>
<blockquote>
<p>这段真的被暖到了，窦骁真的太太太贴心了啊</p>
</blockquote>
<ul>
<li><p style="background-color:rgba(239,221,236,0.7)">阿雅：我刚才其实还是很想往上走，可是我就想到我的家人，然后我想到我女儿……所以我就想说，虽然我很想跟大家一起往上走，但是，但是我要为了我爱的人，要保护好自己，可是还是很不甘心</p>

</li>
</ul>
<blockquote>
<p>还是很不甘心，不管怎样，最后我总会妥协，因为我没法拿自己的安全开玩笑，我给不了他们10分的保证，所以只能大哭一场然后若无其事的平静的妥协，我不想这样可是除了这样我别无他法</p>
<p>或许是每一个维特在不同的社会环境不同的时代背景下都会有各自的烦恼吧</p>
</blockquote>
<ul>
<li><p style="background-color:rgba(200,200,230,0.7)">对于我来说每一次登山，都会是一个，新的一个体验，在你不断不断一次次试探自己的过程中，需要有经验，一步一个脚印，建立了勇气，它跟鲁莽是不一样，它跟玩命是不一样的</p>

</li>
</ul>
<hr>
<center><font size="12" color=#5959ff>J</font><font size="12" color=#a5b2ff>’</font><font size="8" color=#8888fd>a</font><font size="8" color=#7762fd>i</font><font size="8" color=#f1a8ce>m</font><font size="8" color=#a97afd>e </font><font size="8" color=#a7a7f5>m</font><font size="8" color=#628dfd>a </font><font size="8" color=#6363ff>v</font><font size="8" color=#8e64ff>i</font><font size="8" color=#ffafc7>e</font></center>

<hr>
]]></content>
      <categories>
        <category>love&amp;peace</category>
      </categories>
  </entry>
  <entry>
    <title>《奇遇人生》 第2期：美国追龙卷风！春夏与阿雅公路捕风，街头听歌落泪</title>
    <url>/df82d1f8/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kl7nrly7j20o50do0vx.jpg" alt=""></p>
<a id="more"></a>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kl7nrgvmj20o70dm0vs.jpg" alt=""></p>
<ul>
<li><p style="background-color:rgba(239,221,236,0.7)">（我听说自闭症的孩子交流的方式很不同）确实，你必须像口译员一样（你经常拥抱她吗）经常拥抱，她也经常拥抱我（那很棒）</p>
</li>
<li><p style="background-color:rgba(239,221,236,0.7)">谢谢，你做的很好，你是摄影师吗？（不是）你可以的，你能成为一名很棒的摄影师（    ..）你当然可以，为什么不会呢（..）拿起相机去拍吧，你可以成为世界闻名的摄影师（..）真的，拿起相机去拍吧（可以，试试看）为什么不呢，你这么年轻，一切皆有可能</p>

</li>
</ul>
<blockquote>
<p>虽然调侃自己的时候会说，我都二十岁啦，已经老了啊，但是其实大多数情况下这是言不由衷，真话是：“为什么不呢，我这么年轻，一切皆有可能 ~ ”</p>
</blockquote>
<ul>
<li><p style="background-color:rgba(239,221,236,0.7)">人的心思就是很微妙，你一定有一个阶段，就是非常希望自己变得普通，当你过了那个阶段，你走到一个位置上，你意识到你只是一个普通人的时候，又非常希望自己不普通</p>
</li>
<li><p style="background-color:rgba(239,221,236,0.7)">春夏：我刚跟马丁说我觉得这是一个窗口，然后马丁说他也这么觉得，然后他说他觉得这个窗口就是上帝，然后他觉得上帝是女孩儿，是女性，我也这么觉得</p>

</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kl7ns9tpj21400jq0wl.jpg" alt=""></p>
<ul>
<li><p style="background-color:rgba(239,221,236,0.7)">春夏：就是因为你那么接近过那个目标，但你就是碰不到它，我觉得生活中大部分时候还是那种，我快要追到了，然后发现我完全没追到，就每天肯定都是，就是你想要的和你拥有的之间，是有很大差距的</p>
</li>
<li><p style="background-color:rgba(239,221,236,0.7)">我觉得追龙卷风的一个乐趣就是，可能我们没有追到风，但是在风的背后，我们可以看到这些美丽的景色，所以不要只关注龙卷风，而是要享受整个过程，就像一个盛大的自助餐</p>

</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kl82estcj20j20bfwfb.jpg" alt=""></p>
<ul>
<li><p style="background-color:rgba(239,221,236,0.7)">我们多么想要一个结果，但是我们追求的目的根本就不纯粹，我们根本没有享受这件事情</p>
</li>
<li><p style="background-color:rgba(200,200,230,0.7)">这块粉红花岗岩石头，是最坚硬的岩石之一，它不是圆形的，因为河水无法打磨它，它太坚硬了，因为我觉得你很坚强，内在坚强就像花岗岩石一样，把它做礼物是想告诉你，你已经拥有坚强的品质，时刻都要坚强，记住你才是自己生活的主人</p>

</li>
</ul>
<hr>
<center><font size="12" color=#5959ff>J</font><font size="12" color=#a5b2ff>’</font><font size="8" color=#8888fd>a</font><font size="8" color=#7762fd>i</font><font size="8" color=#f1a8ce>m</font><font size="8" color=#a97afd>e </font><font size="8" color=#a7a7f5>m</font><font size="8" color=#628dfd>a </font><font size="8" color=#6363ff>v</font><font size="8" color=#8e64ff>i</font><font size="8" color=#ffafc7>e</font></center>

<hr>
]]></content>
      <categories>
        <category>love&amp;peace</category>
      </categories>
  </entry>
  <entry>
    <title>《奇遇人生》 第1期：赞比亚荒野呼唤！阿雅小s探访大象孤儿院，遇残忍盗猎流泪</title>
    <url>/b67f2784/</url>
    <content><![CDATA[<ul>
<li><p style="background-color:rgba(239,221,236,0.7)">唯有足够强大的爱，才能平息这世界的残忍</p>
</li>
<li><p style="background-color:rgba(239,221,236,0.7)">我想我们三个，永远永远永远，不要结婚</p>

</li>
</ul>
<p>虽然为了大晚上的为了防卡开的低清画质，但是总有一天！我也要去看这样的星空</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kl82euzgj20i70bcq3s.jpg" alt=""></p>
<ul>
<li><p style="background-color:rgba(239,221,236,0.7)">小s：就是像我们的小孩如果不见了，（阿雅：你不要这样问），我想说如果是我女儿出门，然后没回家，怎么找都找不到人，我真是崩溃了，我会崩溃的</p>

</li>
</ul>
<blockquote>
<p>我不是不坚强，只是有那么一瞬间真的会很脆弱，感觉自己很脆弱，保护不好自己，也对不起爱我的人</p>
</blockquote>
<ul>
<li><p style="background-color:rgba(239,221,236,0.7)">我认为是的，Chamilando是象群的首领，它妈妈被杀害的时候，它就在旁边，它来到这里之后，每天晚上睡觉都会尖叫，因为它很受伤，它会做噩梦</p>

</li>
</ul>
<blockquote>
<p>以前说人文主义，现在说博爱，当然，不是下图百度字典里的这个博爱，它太粗浅了</p>
</blockquote>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kl8k48ewj205z032mx5.jpg" alt=""></p>
<p>看到大象被猎杀的那个画面真的很难受，何况这只是<code>1/100</code>，只是<code>1/(100*365)</code>，只是<code>1/(100*365*赞比亚荒野)</code>，所以小s说的下面这段话可能就是让我突然想记录下来的原因吧：</p>
<ul>
<li><p style="background-color:rgba(200,200,233,0.7)">生命真的很需要被尊重，千万不要觉得，好像我们只是一点点小力量，做了真的会改变这个世界吗，我觉得不管力量有多小，你就是做，就像你改变了我，我可以再用我微小的力量再改变其他人</p>

</li>
</ul>
<hr>
<center><font size="12" color=#5959ff>J</font><font size="12" color=#a5b2ff>’</font><font size="8" color=#8888fd>a</font><font size="8" color=#7762fd>i</font><font size="8" color=#f1a8ce>m</font><font size="8" color=#a97afd>e </font><font size="8" color=#a7a7f5>m</font><font size="8" color=#628dfd>a </font><font size="8" color=#6363ff>v</font><font size="8" color=#8e64ff>i</font><font size="8" color=#ffafc7>e</font></center>

<hr>
]]></content>
      <categories>
        <category>love&amp;peace</category>
      </categories>
  </entry>
  <entry>
    <title>51nod 1315 合法整数集</title>
    <url>/6f93207a/</url>
    <content><![CDATA[<p>题目来源： TopCoder</p>
<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题</p>
<p>一个整数集合S是合法的，指S的任意子集subS有Fun（SubS）！=X，其中X是一个固定整数，Fun(A)的定义如下：<br>A为一个整数集合，设A中有n个元素，分别为a0，a1，a2,…,an-1,那么定义：Fun(A)=a0 or a1 or … or an-1；Fun({}) = 0,即空集的函数值为0.其中，or为或操作。<br>现在给你一个集合Y与整数X的值，问在集合Y至少删除多少个元素能使集合Y合法？</p>
<p>例如：Y = {1,2,4}，X=7；显然现在的Y不合法，因为 1 or 2 or 4 = 7，但是删除掉任何一个元素后Y将合法。所以，答案是1.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行两个整数N，X，其中N为Y集合元素个数，X如题所述，且1&lt;=N&lt;=50,1&lt;=X&lt;=1,000,000,000.<br>之后N行，每行一个整数yi，即集合Y中的第i个元素，且1&lt;=yi&lt;=1,000,000,000.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一个整数，表示最少删除多少个元素。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 7</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>读不懂题。。静下心来才看懂。。</p>
<p>题意就是给你一个集合，集合的一个子集中的数或起来的值不等于x就是合法，求使集合合法至少要删除集合中几个元素</p>
<p>那么先把集合中的数排除掉一部分，对那些<code>(ai|x)&gt;x</code>的数来说，不管怎样最后都不会等于x的，这些数一定不删除</p>
<p>然后剩下的就是<code>(ai|x)&lt;=x</code>的数，就运用位运算的性质来解决，每个数用二进制表示，然后二进制不进位的相加，比如题中例子1，2，4，7，8就得到1222，每一位都和x对应的位比较，如果x的二进制i位为1，就说明可以通过删除所有包含i位的数来达到目的，也就是a[i]的大小</p>
<p>还有两种特殊情况，如果所有数都是一定不用删除的，特判一下输出0，如果还没删除之前x的i位是1，而没有任何数的i位是1，那么就可以直接输出0</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line">int a[233];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,x,c,cur,num&#x3D;0,len,flag&#x3D;0;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;x);</span><br><span class="line">    memset(a,0,sizeof(a));</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;c);</span><br><span class="line">        if((c|x)&gt;x)continue;</span><br><span class="line">        flag&#x3D;1;</span><br><span class="line">        cur&#x3D;0;</span><br><span class="line">        while(c)&#123;</span><br><span class="line">            if(c&amp;1)a[cur]++;</span><br><span class="line">            c&#x2F;&#x3D;2;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        num&#x3D;max(num,cur);</span><br><span class="line">    &#125;</span><br><span class="line">    if(!flag)&#123;</span><br><span class="line">        puts(&quot;0&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    c&#x3D;x;</span><br><span class="line">    while(c)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        c&#x2F;&#x3D;2;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans&#x3D;INF;</span><br><span class="line">    for(int i&#x3D;0;i&lt;len;i++)&#123;</span><br><span class="line">        if(x&amp;(1&lt;&lt;i))&#123;</span><br><span class="line">            if(a[i]&#x3D;&#x3D;0)&#123;</span><br><span class="line">                puts(&quot;0&quot;);</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            ans&#x3D;min(a[i],ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>如何给个人博客换上专属免费域名[hexo+github+freenom]</title>
    <url>/59f6b91c/</url>
    <content><![CDATA[<p>今天，天气有点冷，风没有往常喧嚣，我，终于有了自己的域名</p>
<a id="more"></a>

<p>又能水一篇博客了，前排感谢<strong>SunriseFox</strong>学长</p>
<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1539358712530&di=36ddec90a850b86e69439fb1510f6087&imgtype=0&src=http%3A%2F%2Fwx2.sinaimg.cn%2Flarge%2F994b6f2egy1fq0vjxputag208c08cqd3.gif" alt=""></p>
<hr>
<p>！！！</p>
<p>前提是你有了一个部署在githubpage上的个人博客，比如这篇文章里写的这样 <a href="http://leflacon.github.io/3ca6f02/" target="_blank" rel="noopener">Mac OS下用「hexo+github」搭建个人博客！</a></p>
<p><font size="5" color="blue">【前排说明!!!】</font></p>
<p>首先是现在freenom似乎是不允许大陆注册和续期了，会报<code>Some of your domains could not be registered because of a technical error. T</code>这样的attention，我之前的<code>leflacon.tk</code>一年期已经到了，所以也就没继续用这个东西了，这篇博客是很久以前的</p>
<p>其次是这个新域名有两种整法</p>
<p>1.一种就是这篇博客之前写的CNAME方法 效果是访问io和新域名都会跳转到新域名<br>但是这种方法存在问题 我之前做的所有SEO优化都是用io做的 换了之后访问量就没了（Google也会搜不到 因为这样子你递交给Google就不是io了）</p>
<p>所以我后来并没有用CMAKE这种方法</p>
<p>2.另有一种方法是我现在使用的方法 我直接对新域名做了重定向（太久远了。。我记得应该是在freenom的控制台可以直接设置） 这样子的话访问io还是访问io 但是也可以访问新域名 会得到io里的内容</p>
<p>所以请大噶按照自身情况取舍0.0</p>
<h1 id="方法一：CMAKE方法"><a href="#方法一：CMAKE方法" class="headerlink" title="方法一：CMAKE方法"></a>方法一：CMAKE方法</h1><h2 id="1-申请一个免费域名"><a href="#1-申请一个免费域名" class="headerlink" title="1.申请一个免费域名"></a>1.申请一个免费域名</h2><p>首先是域名申请网站 <a href="https://www.freenom.com/zh/index.html?lang=zh" target="_blank" rel="noopener">freenom</a></p>
<p>申请好像没啥好说的，就是输入一个自己想要的名字，然后选免费的一年的购买233333，各种注册验证啥的（现在似乎是需要科学上网才能整了）</p>
<p>那么现在已经获得了一个想要的域名：<code>leflacon.tk</code></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kl3h4lcdj20xs09q75n.jpg" alt=""></p>
<h2 id="2-DNS解析"><a href="#2-DNS解析" class="headerlink" title="2.DNS解析"></a>2.DNS解析</h2><p>虽然学长给我讲了一下直接在freenom上面进行DNS解析的方法，但是我好像没咋耍成!?(･_･;?，所以转身寻求第三方DNS工具了</p>
<p>这里用的是<a href="https://www.cloudxns.net/" target="_blank" rel="noopener">CloudXNS</a></p>
<p>点击左上脚添加域名</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kl3h58o7j20ab03q74a.jpg" alt=""></p>
<p>输入获得的域名</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kl3h4mxgj20h107a3yt.jpg" alt=""></p>
<p>这时候会发现接管状态这一项是“X”</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kl3xizstj20us05qdgc.jpg" alt=""></p>
<p>点击域名会跳出如下页面，这里给的四个蓝色链接下面会用到</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kl3xjongj20ue09st9x.jpg" alt=""></p>
<p>这里说要将域名的NS服务器修改，具体步骤如下</p>
<p>打开最右侧<code>manage domain</code>选项</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kl3xiz7dj20rt02nmxe.jpg" alt=""></p>
<p>然后<code>Management Tools-&gt;Nameservers</code></p>
<p>选择<code>Use custom nameservers (enter below)</code>这项，填入之前给的四个蓝色链接</p>
<p>过一会会儿就收到邮件啦，此时接管状态已经显示ok了</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kl4jmj3kj20uq052t96.jpg" alt=""></p>
<p>然后点开域名，如图添加记录</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kl4jq8rlj20ua0743zh.jpg" alt=""></p>
<h2 id="3-新建CNAME文件"><a href="#3-新建CNAME文件" class="headerlink" title="3.新建CNAME文件"></a>3.新建CNAME文件</h2><p>在博客根目录的source文件夹下生成一个无后缀的文件“CNAME”</p>
<p>具体方法如下：</p>
<p>在source打开终端，输入<code>sudo touch CNAME</code></p>
<p>然后打开CNAME文件内输入获得的域名<code>leflacon.tk</code>，我是用sublime的，不会出现啥无法读写的问题</p>
<p>然后在站点配置文件里修改如下两项：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kl4jmcr8j207d00lweb.jpg" alt=""></p>
<p>这个是为了防止这两个文件被渲染</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kl5j1acaj205u01kmx1.jpg" alt=""></p>
<p>然后就是一系列hexo-clean-g-d</p>
<p>等待一下，现在无论在浏览器输入<code>leflacon.tk</code>还是<code>leflacon.github.io</code>都会跳转到<code>leflacon.tk</code>啦～</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>搬运到新域名之后还是有一些些问题的</p>
<p>一个是busuanzi的访客量统计全部清零了(#ﾟДﾟ)简直是让人。。嘤嘤嘤嘤嘤嘤嘤。。。</p>
<p>还有一个是leancloud评论系统不能用了，这是因为没有把新域名添加到leancloud安全中心的Web安全域名中，所以如下进入设置-&gt;安全中心，添加域名再保存即可</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kl5j2m13j20cq0du0u0.jpg" alt=""></p>
<hr>
<p>好了，至此我目前能解决的问题都解决了，开始用新域名愉快的玩耍吧～先向百度Google交个链接∠( ᐛ 」∠)＿</p>
<p>终于能过百度的http认证啦～（因为github禁止百度蜘蛛所以GitHubpage是过不了这个认证的）</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kl5j3sgwj20rk0acmyh.jpg" alt=""></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1033 骨牌覆盖 V2（插头dp，矩阵快速幂）</title>
    <url>/b513d267/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 320 难度：7级算法题</p>
<p>在<code>m*n</code>的一个长方形方格中，用一个<code>1*2</code>的骨牌排满方格。问有多少种不同的排列方法。（n &lt;= 5)</p>
<p>例如：<code>3 * 2</code>的方格，共有3种不同的排法。（由于方案的数量巨大，只输出 Mod 10^9 + 7 的结果）</p>
<p><img src="https://img.51nod.com/upload/000fb99c/08cfb32da97093cc00000644.jpeg" alt=""></p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>2个数M N，中间用空格分隔（2 &lt;= m &lt;= 10^9，2 &lt;= n &lt;= 5）</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出数量 Mod 10^9 + 7</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 3</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>对插头dp还是。。拨云见雾0.0，先会了这题再说</p>
<p>dp[i][j]表示上一列状态为i到这一列状态为j是否合法，也就是两个块能不能插在一起，dfs后会得到一个<code>(2^n)*(2^n)</code>的矩阵</p>
<p>dfs(x,pre,now)代表第x行，pre状态和now状态，那么有三种合法情况，pre的第x行没有/now的第x行有，pre的第x行有/now的第x行没有，pre的第x行和x+1行和now的第x行和x+1行都是0（其实也就相当于两列里面有一个铺了2x1），也就是说无论如何要把x行填满才能继续下去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01001</span><br><span class="line">□■□□■</span><br><span class="line">■□■■□</span><br><span class="line">10110   不想画图_(:з」∠)_反正大概就长成这个样子，可以拼一起就行</span><br></pre></td></tr></table></figure>

<p>比如样例2x3的合法状态有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 7</span><br><span class="line">1 6</span><br><span class="line">2 5</span><br><span class="line">3 4</span><br><span class="line">0 4</span><br><span class="line">4 3</span><br><span class="line">5 2</span><br><span class="line">6 1</span><br><span class="line">7 0</span><br><span class="line">4 0</span><br><span class="line">0 1</span><br><span class="line">1 0</span><br></pre></td></tr></table></figure>
<p>然后就是理解矩阵相乘了，因为最初dp[i][j]存的是两例之间的可达性，最后能形成一列，所以需要矩阵相乘，<code>dp[i][j]=∑dp[i][k]*dp[k][j]</code>，也就是如果ik可达kj可达，那么ij可达，且多一个完整的列，最后的答案是dp[0][(1&lt;&lt;n)-1]，也就是首列是空状态0，末列是满状态<code>(1&lt;&lt;n)-1</code>，总共m+1列，m个列满</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long </span><br><span class="line">typedef vector&lt;LL&gt;row;</span><br><span class="line">typedef vector&lt;row&gt;mat;</span><br><span class="line">const int p&#x3D;1e9+7;</span><br><span class="line">LL dp[1&lt;&lt;5][1&lt;&lt;5];</span><br><span class="line">int n,m;</span><br><span class="line">mat mul(mat a,mat b)&#123;</span><br><span class="line">    mat c(a.size(),row(b[0].size()));</span><br><span class="line">    for(int i&#x3D;0;i&lt;a.size();i++)&#123;</span><br><span class="line">        for(int j&#x3D;0;j&lt;b[0].size();j++)&#123;</span><br><span class="line">            for(int k&#x3D;0;k&lt;b.size();k++)</span><br><span class="line">                c[i][j]&#x3D;(c[i][j]+a[i][k]*b[k][j])%p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line">mat qpow(mat a,int x)&#123;</span><br><span class="line">    mat b(a.size(),row(a.size()));</span><br><span class="line">    for(int i&#x3D;0;i&lt;a.size();i++)b[i][i]&#x3D;1;</span><br><span class="line">    while(x&gt;0)&#123;</span><br><span class="line">        if(x&amp;1)b&#x3D;mul(b,a);</span><br><span class="line">        a&#x3D;mul(a,a);</span><br><span class="line">        x&gt;&gt;&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int x,int pre,int now)&#123;</span><br><span class="line">    if(x&gt;n)return;</span><br><span class="line">    if(x&#x3D;&#x3D;n)&#123;</span><br><span class="line">        dp[pre][now]++;</span><br><span class="line">        &#x2F;&#x2F; cout&lt;&lt;pre&lt;&lt;&quot; &quot;&lt;&lt;now&lt;&lt;endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(x+1,pre&lt;&lt;1,now&lt;&lt;1|1);</span><br><span class="line">    dfs(x+1,pre&lt;&lt;1|1,now&lt;&lt;1);</span><br><span class="line">    dfs(x+2,pre&lt;&lt;2,now&lt;&lt;2);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);</span><br><span class="line">    mat a(1&lt;&lt;n,row(1&lt;&lt;n));</span><br><span class="line">    dfs(0,0,0);</span><br><span class="line">    for(int i&#x3D;0;i&lt;(1&lt;&lt;n);i++)</span><br><span class="line">        for(int j&#x3D;0;j&lt;(1&lt;&lt;n);j++)</span><br><span class="line">            a[i][j]&#x3D;dp[i][j];</span><br><span class="line">    a&#x3D;qpow(a,m+1);</span><br><span class="line">    printf(&quot;%lld\n&quot;,a[0][(1&lt;&lt;n)-1]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1031 骨牌覆盖（斐波那契）</title>
    <url>/7e7c23c2/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题 </p>
<p>在<code>2*N</code>的一个长方形方格中，用一个<code>1*2</code>的骨牌排满方格。<br>问有多少种不同的排列方法。</p>
<a id="more"></a>

<p><img src="https://img.51nod.com/upload/000fb99c/08cfb32da97093cc00000644.jpeg" alt=""><br>例如：<code>2*3</code>的方格，共有3种不同的排法。（由于方案的数量巨大，只输出 Mod 10^9 + 7 的结果）</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入N(N &lt;= 1000)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出数量 Mod 10^9 + 7</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>考虑最左边一列的铺法，因为要铺满，所以如果横向铺两个，方法数加上f[n-2]，如果纵向铺一个，方法数加上f[n-1]，那么f[n]=f[n-1]+f[n-2]，就是个赤裸裸的斐波那契了</p>
<p>初始f[1]=1，只有纵向一个，f[2]=2，纵向两个或者横向两个</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int p&#x3D;1e9+7;</span><br><span class="line">const int N&#x3D;1005;</span><br><span class="line">int f[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    f[1]&#x3D;1;f[2]&#x3D;2;</span><br><span class="line">    for(int i&#x3D;3;i&lt;&#x3D;n;i++)f[i]&#x3D;(f[i-1]+f[i-2])%p;</span><br><span class="line">    printf(&quot;%d\n&quot;,f[n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1007 正整数分组（01背包）</title>
    <url>/ec4e8b99/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题</p>
<p>将一堆正整数分为2组，要求2组的和相差最小。<br>例如：1 2 3 4 5，将1 2 4分为1组，3 5分为1组，两组和相差1，是所有方案中相差最少的。</p>
<a id="more"></a>


<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：一个数N，N为正整数的数量。<br>第2 - N+1行，N个正整数。<br>(N &lt;= 100, 所有正整数的和 &lt;= 10000)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出这个最小差</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>01背包，背包大小sum/2，根据取不取当前数有状态转移方程<code>dp[j]=max(dp[j],dp[j-a[i]]+a[i])</code></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;10005;</span><br><span class="line">int a[N],dp[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,sum&#x3D;0;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">        sum+&#x3D;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    memset(dp,0,sizeof(dp));</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        for(int j&#x3D;sum&#x2F;2;j&gt;&#x3D;a[i];j--)</span><br><span class="line">            dp[j]&#x3D;max(dp[j],dp[j-a[i]]+a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,sum-2*dp[sum&#x2F;2]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1024 矩阵中不重复的元素（暴力）</title>
    <url>/34f920df/</url>
    <content><![CDATA[<p>题目来源： Project Euler<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题</p>
<p>一个<code>m*n</code>的矩阵。</p>
<p>该矩阵的第一列是a^b,(a+1)^b,…..(a + n - 1)^b<br>第二列是a^(b+1),(a+1)^(b+1),…..(a + n - 1)^(b+1)<br>…….<br>第m列是a^(b + m - 1),(a+1)^(b + m - 1),…..(a + n - 1)^(b + m - 1)<br>(a^b表示a的b次方）  </p>
<p>下面是一个<code>4*4</code>的矩阵：</p>
<p>2^2=4, 2^3=8, 2^4=16, 2^5=32<br>3^2=9, 3^3=27, 3^4=81, 3^5=243<br>4^2=16, 4^3=64, 4^4=256, 4^5=1024<br>5^2=25, 5^3=125, 5^4=625, 5^5=3125  </p>
<p>问这个矩阵里有多少不重复的数（比如4^3 = 8^2，这样的话就有重复了)</p>
<p>2^2=4, 2^3=8, 2^4=16, 2^5=32<br>3^2=9, 3^3=27, 3^4=81, 3^5=243<br>4^2=16, 4^3=64, 4^4=256, 4^5=1024</p>
<p>m = 4, n = 3, a = 2, b = 2。其中2^4与4^2是重复的元素。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入数据包括4个数：m,n,a,b。中间用空格分隔。m，n为矩阵的长和宽（2 &lt;= m,n &lt;= 100)。a，b为矩阵的第1个元素，a^b（2 &lt;= a , b &lt;= 100）。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出不重复元素的数量。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3 2 2</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>j^i，对j取log2然后相乘即可，也等同于直接取ln</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">#define eps 1e-6</span><br><span class="line">vector&lt;double&gt;v;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,a,b;</span><br><span class="line">    scanf(&quot;%d%d%d%d&quot;,&amp;m,&amp;n,&amp;a,&amp;b);</span><br><span class="line">    for(int i&#x3D;b;i&lt;&#x3D;b+m-1;i++)&#123;</span><br><span class="line">        for(int j&#x3D;a;j&lt;&#x3D;a+n-1;j++)&#123;</span><br><span class="line">            v.push_back((double)i*log(j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int num&#x3D;v.size(),ans&#x3D;m*n;</span><br><span class="line">    sort(v.begin(),v.end());</span><br><span class="line">    for(int i&#x3D;1;i&lt;num;i++)</span><br><span class="line">        if(v[i]-v[i-1]&lt;eps)ans--;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>51nod 1014 X^2 Mod P（枚举）</title>
    <url>/9fb00d50/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题</p>
<p>X*X mod P = A，其中P为质数。给出P和A，求&lt;=P的所有X。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>两个数P A，中间用空格隔开。(1 &lt;= A &lt; P &lt;= 1000000, P为质数)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出符合条件的X，且0 &lt;= X &lt;= P，如果有多个，按照升序排列，中间用空格隔开。<br>如果没有符合条件的X，输出：No Solution</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13 3</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 9</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>暴力枚举</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">vector&lt;int&gt;v;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int p,a;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;p,&amp;a);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;p;i++)&#123;</span><br><span class="line">        if((LL)i*i%p&#x3D;&#x3D;a)v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    int num&#x3D;v.size();</span><br><span class="line">    if(num&#x3D;&#x3D;0)puts(&quot;No Solution&quot;);</span><br><span class="line">    else&#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;num;i++)printf(&quot;%d &quot;,v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>51nod 1010 只包含因子2 3 5的数（打表+二分，stl）</title>
    <url>/f7f1f3b6/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题 </p>
<p>K的因子中只包含2 3 5。满足条件的前10个数是：  2,3,4,5,6,8,9,10,12,15。<br>所有这样的K组成了一个序列S，现在给出一个数n，求S中 &gt;= 给定数的最小的数。<br>例如：n = 13，S中 &gt;= 13的最小的数是15，所以输出15。</p>
<a id="more"></a>

<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 10000)<br>第2 - T + 1行：每行1个数N(1 &lt;= N &lt;= 10^18)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>共T行，每行1个数，输出&gt;= n的最小的只包含因子2 3 5的数。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">8</span><br><span class="line">13</span><br><span class="line">35</span><br><span class="line">77</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">8</span><br><span class="line">15</span><br><span class="line">36</span><br><span class="line">80</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>打表然后二分答案，也可以直接用stl，lower_bound</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const LL maxx&#x3D;1e18+233;</span><br><span class="line">const int N&#x3D;50005;</span><br><span class="line">LL a[N];</span><br><span class="line">int ji&#x3D;0;</span><br><span class="line">void init()&#123;</span><br><span class="line">    for(LL i&#x3D;1;i&lt;maxx;i*&#x3D;2)</span><br><span class="line">        for(LL j&#x3D;1;i*j&lt;maxx;j*&#x3D;3)</span><br><span class="line">            for(LL k&#x3D;1;k*i*j&lt;maxx;k*&#x3D;5)</span><br><span class="line">                a[ji++]&#x3D;i*j*k;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    sort(a,a+ji);</span><br><span class="line">    int t;</span><br><span class="line">    LL n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">        LL l&#x3D;1,r&#x3D;ji,m;</span><br><span class="line">        while(l&lt;r)&#123;</span><br><span class="line">            m&#x3D;(l+r)&gt;&gt;1;</span><br><span class="line">            if(a[m]&gt;&#x3D;n)r&#x3D;m;</span><br><span class="line">            else l&#x3D;m+1;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%lld\n&quot;,a[l]);</span><br><span class="line">        &#x2F;&#x2F;printf(&quot;%lld\n&quot;,a[lower_bound(a+1,a+ji+1,n)-a]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1050 循环数组最大子段和（dp）</title>
    <url>/1f726e05/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题</p>
<p>N个整数组成的循环序列a[1],a[2],a[3],…,a[n]，求该序列如a[i]+a[i+1]+…+a[j]的连续的子段和的最大值（循环序列是指n个数围成一个圈，因此需要考虑a[n-1],a[n],a[1],a[2]这样的序列）。当所给的整数均为负数时和为0。<br>例如：-2,11,-4,13,-5,-2，和最大的子段为：11,-4,13。和为20。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：整数序列的长度N（2 &lt;= N &lt;= 50000)<br>第2 - N+1行：N个整数 (-10^9 &lt;= S[i] &lt;= 10^9)<br>Output<br>输出循环数组的最大子段和。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">-2</span><br><span class="line">11</span><br><span class="line">-4</span><br><span class="line">13</span><br><span class="line">-5</span><br><span class="line">-2</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>dp[i]表示以a[i]结尾的最大子段和是多少</p>
<p>状态转移方程 dp[i]=max(a[i],dp[i-1]+a[i])</p>
<p>循环数组，那么有两种情况，第一种就是直接取到一个数组的最大子段和，还有一种情况是中间有一段和是特别小的负数，所以首位相连，比较这两种答案取大的那个</p>
<p>第一种情况直接跑一遍最大子段和dp即得，第二种情况就是先求总和sum，然后跑一遍最小子段和，总和减去最小子段和就是首尾相连情况能得到的最大子段和</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;50005;</span><br><span class="line">LL a[N],dp1[N],dp2[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    LL sum&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%lld&quot;,&amp;a[i]);</span><br><span class="line">        sum+&#x3D;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans&#x3D;a[0],res&#x3D;a[0];</span><br><span class="line">    dp1[0]&#x3D;a[0];dp2[0]&#x3D;a[0];</span><br><span class="line">    for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">        dp1[i]&#x3D;max(a[i],dp1[i-1]+a[i]);</span><br><span class="line">        ans&#x3D;max(ans,dp1[i]);</span><br><span class="line">        dp2[i]&#x3D;min(a[i],dp2[i-1]+a[i]);</span><br><span class="line">        res&#x3D;min(res,dp2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;,max(ans,sum-res));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 2516 取石子游戏（斐波那契博弈）</title>
    <url>/7eacad98/</url>
    <content><![CDATA[<p>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>1堆石子有n个,两人轮流取.先取者第1次可以取任意多个，但不能全部取完.以后每次取的石子数不能超过上次取子数的2倍。取完者胜.先取者负输出”Second win”.先取者胜输出”First win”.</p>
<a id="more"></a>

<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入有多组.每组第1行是2&lt;=n&lt;2^31. n=0退出.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>先取者负输出”Second win”. 先取者胜输出”First win”.<br>参看Sample Output.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">13</span><br><span class="line">10000</span><br><span class="line">0</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Second win</span><br><span class="line">Second win</span><br><span class="line">First win</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>斐波那契博弈</p>
<p>证明见这篇 -&gt;<a href="http://leflacon.github.io/891ad037/" target="_blank" rel="noopener">51nod 1070 Bash游戏 V4（斐波那契博弈）</a></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long </span><br><span class="line">int f[100];</span><br><span class="line">int main()&#123;</span><br><span class="line">    f[1]&#x3D;1;f[2]&#x3D;1;</span><br><span class="line">    for(int i&#x3D;3;i&lt;&#x3D;80;i++)f[i]&#x3D;f[i-1]+f[i-2];</span><br><span class="line">    LL n;</span><br><span class="line">    while(scanf(&quot;%lld&quot;,&amp;n)&amp;&amp;n)&#123;</span><br><span class="line">        int flag&#x3D;0;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;80;i++)</span><br><span class="line">            if(f[i]&#x3D;&#x3D;n)&#123;</span><br><span class="line">                flag&#x3D;1;</span><br><span class="line">                puts(&quot;Second win&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        if(!flag)puts(&quot;First win&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1070 Bash游戏 V4（斐波那契博弈）</title>
    <url>/891ad037/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 40 难度：4级算法题</p>
<p>有一堆石子共有N个。A B两个人轮流拿，A先拿。每次拿的数量最少1个，最多不超过对手上一次拿的数量的2倍（A第1次拿时要求不能全拿走）。拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N，问最后谁能赢得比赛。<br>例如N = 3。A只能拿1颗或2颗，所以B可以拿到最后1颗石子。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 1000)<br>第2 - T + 1行：每行1个数N。(1 &lt;= N &lt;= 10^9)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>共T行，如果A获胜输出A，如果B获胜输出B。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B</span><br><span class="line">B</span><br><span class="line">A</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>斐波那契博弈</p>
<p>结论是：斐波那契数列的数1,2,3,5,8,13,21,34,55,89……必败</p>
<p>粗糙的证明（数学归纳法）：</p>
<ul>
<li>先证斐波那契数时先手必败</li>
</ul>
<p>1.n=2时，先手必败，符合</p>
<p>2.假设i&lt;=k时，结论成立，对于i=k+1，<code>f[k+1]=f[k]+f[k-1]</code>，那么把这些石子分成两堆，f[k]和f[k-1]，对于f[k-1]，由假设得后手必胜，那么只需考虑后手取最后一堆最后取几个，以判断在后手取完f[k-1]之后，先手有没有可能一步取完f[k]，如果没有可能的话，由假设得还是先手胜</p>
<p>那么回到f[k-1]，后手取最多的情况是，先手第一次取的数目为<code>x==f[k-1]/3</code>，后手取<code>y=2*f[k-1]/3</code>，那么需要证<code>2*y&lt;f[k]</code>，即<code>4*f[k-1]&lt;3*f[k]</code>，用做差法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3*f[k]-4*f[k-1]</span><br><span class="line">&#x3D;3*f[k-1]+3*f[k-2]-4*f[k-1]</span><br><span class="line">&#x3D;3*f[k-2]-f[k-1]</span><br><span class="line">&#x3D;3*f[k-2]-f[k-2]-f[k-3]</span><br><span class="line">&#x3D;2*f[k-2]-f[k-3]</span><br><span class="line">&#x3D;2*f[k-3]+2*f[k-4]-f[k-3]</span><br><span class="line">&#x3D;f[k-3]+2*f[k-4]&gt;0</span><br></pre></td></tr></table></figure>
<p>由1，2得，假设成立，是斐波那契数必败</p>
<ul>
<li>然后再考虑n不是斐波那契数的情况</li>
</ul>
<p>用一下<strong>“Zeckendorf定理”（齐肯多夫定理）</strong>：任何正整数可以表示为若干个不连续的Fibonacci数之和</p>
<p>即把n分成k堆，<code>n=f[a1]+f[a2]+……+f[ak]（a1&gt;a2&gt;……&gt;ap）</code></p>
<p>先手必胜策略是：先手先取完f[ak]，即最小的这一堆，由于是若干个不连续的Fibonacci数，由斐波那契数列定义有<code>f[k]=f[k-1]+f[k-2]</code>，即<code>2*f[k]&lt;f[k-1]</code>，所以<code>f[a(k-1)]&gt;2*f[ak]</code>，后手只能取f[a(k-1)]这一堆，且不能一次取完，此时后手相当于面临这个子游戏<code>n=f[a(k-1)]</code>，后手必败</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int f[80];</span><br><span class="line">int main()&#123;</span><br><span class="line">    f[1]&#x3D;1;f[2]&#x3D;1;</span><br><span class="line">    for(int i&#x3D;3;i&lt;&#x3D;45;i++)f[i]&#x3D;f[i-1]+f[i-2];</span><br><span class="line">    int t,n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        int flag&#x3D;0;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;45;i++)</span><br><span class="line">            if(f[i]&#x3D;&#x3D;n)&#123;</span><br><span class="line">                flag&#x3D;1;</span><br><span class="line">                puts(&quot;B&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        if(!flag)puts(&quot;A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1068 Bash游戏 V3（巴什博弈）</title>
    <url>/f32e27dd/</url>
    <content><![CDATA[<p>题目来源： Ural 1180</p>
<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 20 难度：3级算法题</p>
<p>有一堆石子共有N个。A B两个人轮流拿，A先拿。每次拿的数量只能是2的正整数次幂，比如(1,2,4,8,16….)，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N，问最后谁能赢得比赛。</p>
<p>例如N = 3。A只能拿1颗或2颗，所以B可以拿到最后1颗石子。（输入的N可能为大数）</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 1000)<br>第2 - T + 1行：每行1个数N。(1 &lt;= N &lt;= 10^1000)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>共T行，如果A获胜输出A，如果B获胜输出B。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br><span class="line">A</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p><a href="https://leflacon.github.io/3d8d44b2/" target="_blank" rel="noopener">hdu 1847 Good Luck in CET-4 Everybody!（巴什博弈）</a></p>
<p>3的倍数必败，这个题给的n是10^1000，所以判断这个数能否被三整除，求一下各项和即可</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,num,len;</span><br><span class="line">    string n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        len&#x3D;n.length();</span><br><span class="line">        num&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;len;i++)num+&#x3D;(n[i]-&#39;0&#39;);</span><br><span class="line">        if(num%3&#x3D;&#x3D;0)puts(&quot;B&quot;);</span><br><span class="line">        else puts(&quot;A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1067 Bash游戏 V2（打表找规律）</title>
    <url>/be97bbf9/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题</p>
<p>有一堆石子共有N个。A B两个人轮流拿，A先拿。每次只能拿1，3，4颗，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N，问最后谁能赢得比赛。  </p>
<a id="more"></a>

<p>例如N = 2。A只能拿1颗，所以B可以拿到最后1颗石子。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 10000)<br>第2 - T + 1行：每行1个数N。(1 &lt;= N &lt;= 10^9)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>共T行，如果A获胜输出A，如果B获胜输出B。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B</span><br><span class="line">A</span><br><span class="line">A</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>这个题每次只能拿1，3，4颗，先根据N/P状态打个表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int f[233];</span><br><span class="line">int main()&#123;</span><br><span class="line">    memset(f,0,sizeof(f));</span><br><span class="line">    f[1]&#x3D;f[3]&#x3D;f[4]&#x3D;1;f[2]&#x3D;-1;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;100;i++)&#123;</span><br><span class="line">        if(f[i+1]&#x3D;&#x3D;0||f[i+1]&#x3D;&#x3D;-1)f[i+1]&#x3D;-f[i];</span><br><span class="line">        if(f[i+3]&#x3D;&#x3D;0||f[i+3]&#x3D;&#x3D;-1)f[i+3]&#x3D;-f[i];</span><br><span class="line">        if(f[i+4]&#x3D;&#x3D;0||f[i+4]&#x3D;&#x3D;-1)f[i+4]&#x3D;-f[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;100;i++)&#123;</span><br><span class="line">        if(f[i]&#x3D;&#x3D;-1)cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><code>2 7 9 14 16 21 23 28 30 35 37 42 44 49 51 56 58 63 65 70 72 77 79 84 86 91 93 98</code></p>
<p>所以答案就是n%7==0或n%7==2先手必败，其余先手必胜</p>
<p>知道结论了可以粗糙的证明一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n&#x3D;7k+1，先手取1，留给后手必败7k</span><br><span class="line">n&#x3D;7k+3，先手取3，留给后手必败7k，或取1，留给后手必败7k+2</span><br><span class="line">n&#x3D;7k+4，先手取4，留给后手必败7k</span><br><span class="line">n&#x3D;7k+5，先手取3，留给后手必败7k+2</span><br><span class="line">n&#x3D;7k+6，先手取4，留给后手必败7k+2</span><br></pre></td></tr></table></figure>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        if(n%7&#x3D;&#x3D;0||n%7&#x3D;&#x3D;2)puts(&quot;B&quot;);</span><br><span class="line">        else puts(&quot;A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1092 回文字符串（dp，lcs）</title>
    <url>/e81fda88/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题</p>
<p>回文串是指aba、abba、cccbccc、aaaa这种左右对称的字符串。每个字符串都可以通过向中间添加一些字符，使之变为回文字符串。<br>例如：abbc 添加2个字符可以变为 acbbca，也可以添加3个变为 abbcbba。方案1只需要添加2个字符，是所有方案中添加字符数量最少的。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入一个字符串Str，Str的长度 &lt;= 1000。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出最少添加多少个字符可以使之变为回文字串。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abbc</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>将字符串翻转，然后求新串和原串的最长公共子序列，和原串长度相减即为所求</p>
<p>基础lcs，dp[i][j]表示s1的前i个和s2的前j个的最长公共子序列，状态转移方程是 <code>dp[i+1][j+1]=max(dp[i+1][j],dp[i][j+1],dp[i][j]+(s1[i]==s2[j]?1:0))</code></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;1005;</span><br><span class="line">string s1,s2;</span><br><span class="line">int dp[N][N],len1,len2;</span><br><span class="line">void lcs()&#123;</span><br><span class="line">    for(int i&#x3D;0;i&lt;len1;i++)&#123;</span><br><span class="line">        for(int j&#x3D;0;j&lt;len2;j++)&#123;</span><br><span class="line">            if(s1[i]&#x3D;&#x3D;s2[j])dp[i+1][j+1]&#x3D;dp[i][j]+1;</span><br><span class="line">            else dp[i+1][j+1]&#x3D;max(dp[i+1][j],dp[i][j+1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;s1;</span><br><span class="line">    s2&#x3D;s1;reverse(s2.begin(),s2.end());</span><br><span class="line">    len1&#x3D;len2&#x3D;s1.length();</span><br><span class="line">    lcs();</span><br><span class="line">    printf(&quot;%d\n&quot;,len1-dp[len1][len1]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>ural 1593 Square Country. Version 2（n最少能表示成几个完全平方数的和）</title>
    <url>/c5057eab/</url>
    <content><![CDATA[<p><a href="http://acm.timus.ru/problem.aspx?space=1&amp;num=1593" target="_blank" rel="noopener">http://acm.timus.ru/problem.aspx?space=1&amp;num=1593</a></p>
<p>Time limit: 1.0 second<br>Memory limit: 64 MB</p>
<p>There live square people in a square country. Everything in this country is square also. Thus, the Square Parliament has passed a law about a land. According to the law each citizen of the country has a right to buy land. A land is sold in squares, surely. Moreover, a length of a square side must be a positive integer amount of meters. Buying a square of land with a side a one pays a2 quadrics (a local currency) and gets a square certificate of a landowner.<br>One citizen of the country has decided to invest all of his N quadrics into the land. He can, surely, do it, buying square pieces 1 × 1 meters. At the same time the citizen has requested to minimize an amount of pieces he buys: “It will be easier for me to pay taxes,” — he has said. He has bought the land successfully.<br>Your task is to find out a number of certificates he has gotten.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The only line contains a positive integer N ≤ 1015 , that is a number of quadrics that the citizen has invested.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>The only line contains a number of certificates that he has gotten.</p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input</span><br><span class="line">344</span><br><span class="line">output</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给一个数n，n&lt;=1e15，求n最少能表示成几个完全平方数的和</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>这个题的基础版：<a href="https://leflacon.github.io/34784cdc/" target="_blank" rel="noopener">ural 1073 Square Country</a></p>
<p>还是用到<strong>四平方和定理</strong>：“每个正整数均可表示为4个整数的平方和”</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kl0v1n0dj20ma058ta0.jpg" alt=""></p>
<p>直接暴力判断1，2，3的情况，其余输出4，但是这题n太大了，毫无意外的t掉了，所以要来点定理优化</p>
<ul>
<li><p><code>n≠4^a*(8m+7)</code>是n可以用三个平方数表示的一个充分必要条件</p>
</li>
<li><p>正整数n能表示为两平方数之和的充要条件，是在它的标准分解式中，形如4k+3的素因数的幂指数是偶数</p>
</li>
<li><p>形如 4k+3 的整数有形如 4k+3 的素因子</p>
</li>
</ul>
<p>先判断1，然后除去n的所有因子2得m，此时如果m%4!=3，也就是说“4k+3的素因数的幂指数是奇数”的情况不存在，那么可以继续判断答案为2的可能，如果m=1那么符合定理要求答案为2，其余情况就要暴力找有没有可能是两个数的平方和，当然这里暴力也是要优化一下的，枚举的范围在<code>[sqrt(n-sqrt(n)*sqrt(n)),sqrt(n)]</code></p>
<p>判断3，4时用到上面第一个定理，因为是充要条件，所以直接判断，不是3就是4，直接干掉快的不行 </p>
<p>最后跑了312ms</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long </span><br><span class="line">int main()&#123;</span><br><span class="line">    LL n,m,sum,tmp1,tmp2;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">    tmp1&#x3D;sqrt(n);</span><br><span class="line">    if(tmp1*tmp1&#x3D;&#x3D;n)&#123;</span><br><span class="line">        puts(&quot;1&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    m&#x3D;n;</span><br><span class="line">    while(!(m&amp;1))m&#x2F;&#x3D;2;</span><br><span class="line">    if(m%4!&#x3D;3)&#123;</span><br><span class="line">        if(m&#x3D;&#x3D;1)&#123;</span><br><span class="line">            puts(&quot;2&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        m&#x3D;n;</span><br><span class="line">        sum&#x3D;n;</span><br><span class="line">        tmp1&#x3D;sqrt(m);</span><br><span class="line">        m&#x3D;m-tmp1*tmp1;</span><br><span class="line">        tmp2&#x3D;sqrt(m);</span><br><span class="line">        for(LL i&#x3D;tmp1;i&gt;&#x3D;tmp2;i--)&#123;</span><br><span class="line">            m&#x3D;sum;</span><br><span class="line">            m&#x3D;m-i*i;</span><br><span class="line">            tmp2&#x3D;sqrt(m);</span><br><span class="line">            if(tmp2*tmp2+i*i&#x3D;&#x3D;sum)&#123;</span><br><span class="line">                puts(&quot;2&quot;);</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m&#x3D;n;</span><br><span class="line">    while(m%4&#x3D;&#x3D;0)m&#x2F;&#x3D;4;</span><br><span class="line">    if(m%8!&#x3D;7)&#123;</span><br><span class="line">        puts(&quot;3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else puts(&quot;4&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>ural 1073 Square Country（四平方和定理，完全背包）</title>
    <url>/34784cdc/</url>
    <content><![CDATA[<p><a href="http://acm.timus.ru/problem.aspx?space=1&amp;num=1073" target="_blank" rel="noopener">http://acm.timus.ru/problem.aspx?space=1&amp;num=1073</a></p>
<p>Time limit: 1.0 second<br>Memory limit: 64 MB</p>
<p>There live square people in a square country. Everything in this country is square also. Thus, the Square Parliament has passed a law about a land. According to the law each citizen of the country has a right to buy land. A land is sold in squares, surely. Moreover, a length of a square side must be a positive integer amount of meters. Buying a square of land with a side a one pays a2 quadrics (a local currency) and gets a square certificate of a landowner.<br>One citizen of the country has decided to invest all of his N quadrics into the land. He can, surely, do it, buying square pieces 1 × 1 meters. At the same time the citizen has requested to minimize an amount of pieces he buys: “It will be easier for me to pay taxes,” — he has said. He has bought the land successfully.<br>Your task is to find out a number of certificates he has gotten.   </p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The only line contains a positive integer N ≤ 60 000 , that is a number of quadrics that the citizen has invested.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>The only line contains a number of certificates that he has gotten.</p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input</span><br><span class="line">344</span><br><span class="line">output</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给一个数n，n&lt;=60000，求n最少能表示成几个完全平方数的和</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>因为这个题n不大，所以有两种方法，而进阶版的题n是1e15，背包的话状态就开不下了，需要用数学性质解决 -&gt; <a href="https://leflacon.github.io/c5057eab/" target="_blank" rel="noopener">1593. Square Country. Version 2</a></p>
<p>一种是当成<strong>完全背包</strong>做，dp[j]代表j最少能表示成几个完全平方数的和，从1-√n枚举i，状态转移方程为<code>dp[j]=min(dp[j],dp[j-i*i]+1)</code></p>
<p>第二种方法是当成一个数论题做，用到<strong>四平方和定理</strong>：“每个正整数均可表示为4个整数的平方和”</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kl0v1n0dj20ma058ta0.jpg" alt=""></p>
<p>所以直接暴力判断1，2，3的情况，其余输出4即可，不过写的时候要注意，如果当前找到了3的一组答案，不能直接输出，因为后续可能有2的答案，之前没考虑这个就wa了一发</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line">const int N&#x3D;60005;</span><br><span class="line">int dp[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    memset(dp,INF,sizeof(dp));</span><br><span class="line">    dp[0]&#x3D;0;</span><br><span class="line">    for(int i&#x3D;1;i*i&lt;&#x3D;n;i++)</span><br><span class="line">        for(int j&#x3D;i*i;j&lt;&#x3D;n;j++)</span><br><span class="line">            dp[j]&#x3D;min(dp[j],dp[j-i*i]+1);</span><br><span class="line">    printf(&quot;%d\n&quot;,dp[n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,flag&#x3D;0,tmp1,tmp2;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;sqrt(n);i&gt;0;i--)&#123;</span><br><span class="line">        tmp1&#x3D;n-i*i;</span><br><span class="line">        if(tmp1&#x3D;&#x3D;0)&#123;</span><br><span class="line">            flag&#x3D;1;</span><br><span class="line">            puts(&quot;1&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            for(int j&#x3D;sqrt(tmp1);j&gt;0;j--)&#123;</span><br><span class="line">                tmp2&#x3D;tmp1-j*j;</span><br><span class="line">                if(tmp2&#x3D;&#x3D;0)&#123;</span><br><span class="line">                    flag&#x3D;1;</span><br><span class="line">                    puts(&quot;2&quot;);</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    int k&#x3D;sqrt(tmp2);</span><br><span class="line">                    if(k*k&#x3D;&#x3D;tmp2)&#123;</span><br><span class="line">                        flag&#x3D;1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!flag)puts(&quot;4&quot;);</span><br><span class="line">    else puts(&quot;3&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 3864 D_num（Pollard Rho大因数分解）</title>
    <url>/71a9f0a2/</url>
    <content><![CDATA[<p>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Oregon Maple was waiting for Bob When Bob go back home. Oregon Maple asks Bob a problem that as a Positive number N, if there are only four Positive number M makes Gcd(N, M) == M then we called N is a D_num. now, Oregon Maple has some Positive numbers, and if a Positive number N is a D_num , he want to know the four numbers M. But Bob have something to do, so can you help Oregon Maple?<br>Gcd is Greatest common divisor.</p>
<a id="more"></a>


<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>Some cases (case &lt; 100);<br>Each line have a numeral N（1&lt;=N&lt;10^18）</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each N, if N is a D_NUM, then output the four M (if M &gt; 1) which makes Gcd(N, M) = M. output must be Small to large, else output <code>“is not a D_num”</code>.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">10</span><br><span class="line">9</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 3 6</span><br><span class="line">2 5 10</span><br><span class="line">is not a D_num</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给一个数n，n范围1e18，如果n有四个因数，输出除1以外的三个因数</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p><a href="https://leflacon.github.io/ffac8316/" target="_blank" rel="noopener">大因数分解 – Pollard Rho算法</a></p>
<p>分解完判断因数，只有两种情况可能有四个因数，一种是<code>1,a,b,a*b</code>，还有一种是<code>1,a,a^2,a^3</code></p>
<p>t了无数发。。因为之前的板子快速幂里面的乘法还是直接乘，然后改成快速乘之后78ms过了。。太可怕了</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">vector&lt;LL&gt;v,ans;</span><br><span class="line">LL mul(LL a,LL b,LL p)&#123;&#x2F;&#x2F;快速乘，防爆LL</span><br><span class="line">    a%&#x3D;p;</span><br><span class="line">    LL res&#x3D;0;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)res&#x3D;(res+a)%p;</span><br><span class="line">        b&gt;&gt;&#x3D;1;</span><br><span class="line">        a&#x3D;(a&lt;&lt;1)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">LL qpow(LL a,LL b,LL p)&#123;&#x2F;&#x2F;快速幂</span><br><span class="line">    a%&#x3D;p;b%&#x3D;p;</span><br><span class="line">    LL ans&#x3D;1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            ans&#x3D;mul(ans,a,p);</span><br><span class="line">        &#125;</span><br><span class="line">        b&gt;&gt;&#x3D;1;</span><br><span class="line">        a&#x3D;mul(a,a,p);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">LL gcd(LL a,LL b)&#123;</span><br><span class="line">    return b&#x3D;&#x3D;0?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">bool Miller_Rabin(LL n)&#123;</span><br><span class="line">    if(n&#x3D;&#x3D;2)return true;</span><br><span class="line">    if(n&lt;2||!(n&amp;1))return false;</span><br><span class="line">    int cishu&#x3D;20,ji&#x3D;0;</span><br><span class="line">    LL m&#x3D;n-1;</span><br><span class="line">    while(!(m&amp;1))&#123;</span><br><span class="line">        ji++;</span><br><span class="line">        m&gt;&gt;&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    srand(100);</span><br><span class="line">    while(cishu--)&#123;</span><br><span class="line">        LL a&#x3D;rand()%(n-1)+1;</span><br><span class="line">        LL x&#x3D;qpow(a,m,n),tmp&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;ji;i++)&#123;</span><br><span class="line">            tmp&#x3D;mul(x,x,n);</span><br><span class="line">            if(tmp&#x3D;&#x3D;1&amp;&amp;x!&#x3D;1&amp;&amp;x!&#x3D;n-1)return false;</span><br><span class="line">            x&#x3D;tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        if(tmp!&#x3D;1)return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">LL Pollard_Rho(LL n,int c)&#123;</span><br><span class="line">    LL i&#x3D;1,k&#x3D;2,x,y;</span><br><span class="line">    x&#x3D;rand()%(n-1)+1;y&#x3D;x;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        x&#x3D;(mul(x,x,n)+c)%n;</span><br><span class="line">        if(y&#x3D;&#x3D;x)return n;</span><br><span class="line">        LL d&#x3D;gcd((y-x+n)%n,n);</span><br><span class="line">        if(d!&#x3D;1&amp;&amp;d!&#x3D;n)return d;     </span><br><span class="line">        if(i&#x3D;&#x3D;k)&#123;</span><br><span class="line">            y&#x3D;x;</span><br><span class="line">            k&lt;&lt;&#x3D;1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void find(LL n)&#123;</span><br><span class="line">    if(n&#x3D;&#x3D;1)return;</span><br><span class="line">    if(Miller_Rabin(n))&#123;</span><br><span class="line">        v.push_back(n);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    LL p&#x3D;n;</span><br><span class="line">    while(p&gt;&#x3D;n)p&#x3D;Pollard_Rho(p,rand()%(n-1)+1);</span><br><span class="line">    find(p);</span><br><span class="line">    find(n&#x2F;p);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    while(scanf(&quot;%lld&quot;,&amp;n)!&#x3D;EOF)&#123;</span><br><span class="line">        v.clear();ans.clear();</span><br><span class="line">        find(n);</span><br><span class="line">        sort(v.begin(),v.end());</span><br><span class="line">        if(v.size()&#x3D;&#x3D;2&amp;&amp;v[0]!&#x3D;v[1])</span><br><span class="line">            printf(&quot;%lld %lld %lld\n&quot;,v[0],v[1],v[0]*v[1]);</span><br><span class="line">        else if(v.size()&#x3D;&#x3D;3&amp;&amp;v[0]&#x3D;&#x3D;v[1]&amp;&amp;v[1]&#x3D;&#x3D;v[2])&#123;</span><br><span class="line">            printf(&quot;%lld %lld %lld\n&quot;,v[0],v[0]*v[0],v[0]*v[0]*v[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        else printf(&quot;is not a D_num\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>大因数分解 -- Pollard Rho算法</title>
    <url>/ffac8316/</url>
    <content><![CDATA[<p>研究了一篇论文，讲的很好，由浅入深，大致记录一下</p>
<h2 id="试除法"><a href="#试除法" class="headerlink" title="试除法"></a>试除法</h2><p>首先如果要对一个数进行因数分解，最直接的做法就是「试除法」</p>
<p>假设N是一个能被分解为<code>p*q</code>的数，就暴力的从i=2（i++）开始判断能否整除n，当然由于一半是偶数，所以可以优化先判断2，然后从3开始（i+=2）继续判断</p>
<p>这种方法可以改的更加暴力，不从i=2开始，直接给一个随机数i然后判断i能否整除n，那么对于<code>n=p*q</code>来说，找出其因数的概率是2/(n-1)，相当小啊，这不是我们要的</p>
<p>所以接下来要开一个叫 <strong>「Birthday Trick」（生日悖论）</strong> 的挂</p>
<h2 id="生日悖论"><a href="#生日悖论" class="headerlink" title="生日悖论"></a>生日悖论</h2><p>生日悖论问题：</p>
<p>如果一个房间里有23个或23个以上的人，那么至少有两个人的生日相同的概率要大于50%。这就意味着在一个典型的标准小学班级(30人)中，存在两人生日相同的可能性更高。对于60或者更多的人，这种概率要大于99%。</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkyal907j20mc06ymxw.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkyalt3oj20md05pgmz.jpg" alt=""></p>
<p>那么举个取随机数的例子，在[1,1000]中随机取一个数，取得42这个数的概率是1/1000，那么现在修改一下这个问题，在[1,1000]中随机取两个数i,j(i!=j)，i-j=42的概率是多少，如下：479/249750，差不多是1/500，快了一半</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkz020ioj20b208egmk.jpg" alt=""></p>
<p>那么大胆假设，如果在[1,1000]中随机取k个数，x1,x2…xk，满足xi-xj=42的概率是多少呢（关于这段论文里的代码我没咋搞明白就懒得试了，mark一下再说吧，先直接丢结果）</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkz0k1zlj20g6086wfb.jpg" alt=""></p>
<p>然后回到之前的试除法，对于<code>n=p*q</code>来说，取一个[1,n]的随机数，直接得到p或q的概率是很小的，但是取k个数，xi-xj整除n的概率就会随着k的增大而增大，上面这种情况当k=√n时，概率已经上升到50%以上</p>
<h2 id="用gcd优化"><a href="#用gcd优化" class="headerlink" title="用gcd优化"></a>用gcd优化</h2><p>对于一个10位整数来说，需要选取k=10^5个随机数（原因大概就是√n的时候的精确度已经差不多了），然而，这并没有优化，因为我们要做k^2=10^10次比较，所以这时候又出现了一个更妙的想法</p>
<p>选取k个数x1,x2…xk，询问是否存在<code>gcd(xi-xj,n)&gt;1</code>，举个例子，如果问有多少个数能整除n，答案只有两个，p和q，如果问有多少个数使得<code>gcd(x,n)&gt;1</code>，答案便很多了p,2p,3p…(q-1)p,q,2q,3q…(p-1)q，也就是说共有p+q-2个数</p>
<p>所以思路就是在[2,n-1]中随机选k个数，x1,x2…xk，判读是否存在gcd(xi-xj,n)&gt;1，若存在，则gcd(xi-xj,n)是n的一个因子，即之前举例的p或q</p>
<h2 id="伪随机数："><a href="#伪随机数：" class="headerlink" title="伪随机数："></a>伪随机数：</h2><p>生成10^5个随机数要用到伪随机数的神奇函数<code>f(i)=(x^2+a)mod n</code></p>
<p>可以自己指定a，也可以用rand()生成，f1=2（别的也行）</p>
<p>对于大多数数字，这个函数都是完全ok的，但是对于某些特殊数字，会陷入循环0.0，也就是传说中的f环，然后就找不到因子了，比如x1=2，a=1，n=8051就会出现f环，所以需要探测环的出现</p>
<p>一种方法用一个vis数组记录当前产生的所有数，但是如果n变大，内存就炸了</p>
<p>所以又要开挂了，<strong>Floyd周期检测策略</strong>，Floyd好厉害啊ʕ •ᴥ•ʔ</p>
<h2 id="探测f环（Floyd周期检测策略）："><a href="#探测f环（Floyd周期检测策略）：" class="headerlink" title="探测f环（Floyd周期检测策略）："></a>探测f环（Floyd周期检测策略）：</h2><p>假设我们在一个很长很长的圆形轨道上行走，我们如何知道我们已经走完了一圈呢？机智的方法是让A和B，从同一起点开始往前走，B的速度是A的速度的两倍，那么当B第一次赶上A时(套圈)，B就已经走了至少一圈了</p>
<p>所以如果有环，重新给个种子a就ok了</p>
<h2 id="Pollard’s-Rho-算法-："><a href="#Pollard’s-Rho-算法-：" class="headerlink" title="Pollard’s Rho 算法 ："></a>Pollard’s Rho 算法 ：</h2><p>以上都结合起来，就差不多是Pollard’s Rho 算法了</p>
<p>复杂度o(玄学n^(1/4))，不想看复杂度证明了╮(￣▽￣””)╭</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">vector&lt;LL&gt;v;</span><br><span class="line">LL mul(LL a,LL b,LL p)&#123;&#x2F;&#x2F;快速乘，防爆LL</span><br><span class="line">    a%&#x3D;p;</span><br><span class="line">    LL res&#x3D;0;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)res&#x3D;(res+a)%p;</span><br><span class="line">        b&gt;&gt;&#x3D;1;</span><br><span class="line">        a&#x3D;(a&lt;&lt;1)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">LL qpow(LL a,LL b,LL p)&#123;&#x2F;&#x2F;快速幂</span><br><span class="line">    a%&#x3D;p;b%&#x3D;p;</span><br><span class="line">    LL ans&#x3D;1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            ans&#x3D;mul(ans,a,p);</span><br><span class="line">        &#125;</span><br><span class="line">        b&gt;&gt;&#x3D;1;</span><br><span class="line">        a&#x3D;mul(a,a,p);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">LL gcd(LL a,LL b)&#123;</span><br><span class="line">    return b&#x3D;&#x3D;0?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">bool Miller_Rabin(LL n)&#123;</span><br><span class="line">    if(n&#x3D;&#x3D;2)return true;</span><br><span class="line">    if(n&lt;2||!(n&amp;1))return false;</span><br><span class="line">    int cishu&#x3D;20,ji&#x3D;0;</span><br><span class="line">    LL m&#x3D;n-1;</span><br><span class="line">    while(!(m&amp;1))&#123;</span><br><span class="line">        ji++;</span><br><span class="line">        m&gt;&gt;&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    srand(100);</span><br><span class="line">    while(cishu--)&#123;</span><br><span class="line">        LL a&#x3D;rand()%(n-1)+1;</span><br><span class="line">        LL x&#x3D;qpow(a,m,n),tmp&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;ji;i++)&#123;</span><br><span class="line">            tmp&#x3D;mul(x,x,n);</span><br><span class="line">            if(tmp&#x3D;&#x3D;1&amp;&amp;x!&#x3D;1&amp;&amp;x!&#x3D;n-1)return false;</span><br><span class="line">            x&#x3D;tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        if(tmp!&#x3D;1)return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">LL Pollard_Rho(LL n,int c)&#123;</span><br><span class="line">    LL i&#x3D;1,k&#x3D;2,x,y;</span><br><span class="line">    x&#x3D;rand()%(n-1)+1;y&#x3D;x;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        x&#x3D;(mul(x,x,n)+c)%n;</span><br><span class="line">        if(y&#x3D;&#x3D;x)return n;</span><br><span class="line">        LL d&#x3D;gcd((y-x+n)%n,n);</span><br><span class="line">        if(d!&#x3D;1&amp;&amp;d!&#x3D;n)return d;     </span><br><span class="line">        if(i&#x3D;&#x3D;k)&#123;</span><br><span class="line">            y&#x3D;x;</span><br><span class="line">            k&lt;&lt;&#x3D;1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void find(LL n)&#123;</span><br><span class="line">    if(n&#x3D;&#x3D;1)return;</span><br><span class="line">    if(Miller_Rabin(n))&#123;</span><br><span class="line">        v.push_back(n);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    LL p&#x3D;n;</span><br><span class="line">    while(p&gt;&#x3D;n)p&#x3D;Pollard_Rho(p,rand()%(n-1)+1);</span><br><span class="line">    find(p);</span><br><span class="line">    find(n&#x2F;p);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    find(n);</span><br><span class="line">    sort(v.begin(),v.end());</span><br><span class="line">    for(int i&#x3D;0;i&lt;v.size();i++)&#123;</span><br><span class="line">        cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终于搞定了睡觉去～<code>\(≧▽≦)/</code>明天去搞两个题耍耍，最后附上那篇论文的链接 -&gt;  <a href="http://files.cnblogs.com/files/Doggu/Pollard-rho%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.pdf" target="_blank" rel="noopener">A Quick Tutorial on Pollard’s Rho Algorithm </a></p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>busuanzi计数功能失效及解决办法</title>
    <url>/589bd519/</url>
    <content><![CDATA[<p>上课前水一篇博客</p>
<p>这两天发现博客的计数区不计数了，如图：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkxmf5bwj20ep03bwej.jpg" alt=""></p>
<a id="more"></a>

<p>然后上了一下<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">busuanzi的官网</a>，发现是js文件转移了</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkxmgm4wj20h701rq2y.jpg" alt=""></p>
<p>所以在foot.swig里改一下以前的开头即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script async src&#x3D;&quot;https:&#x2F;&#x2F;dn-lbstatics.qbox.me&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">改为</span><br><span class="line">&lt;script async src&#x3D;&quot;&#x2F;&#x2F;busuanzi.ibruce.info&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1094 和为k的连续区间（前缀和，map）</title>
    <url>/205f0ecd/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题</p>
<p>一整数数列a1, a2, … , an（有正有负），以及另一个整数k，求一个区间[i, j]，(1 &lt;= i &lt;= j &lt;= n)，使得a[i] + … + a[j] = k。</p>
<a id="more"></a>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：2个数N,K。N为数列的长度。K为需要求的和。(2 &lt;= N &lt;= 10000，-10^9 &lt;= K &lt;= 10^9)<br>第2 - N + 1行：A[i]<code>(-10^9 &lt;= A[i] &lt;= 10^9</code>。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>如果没有这样的序列输出No Solution。<br>输出2个数i, j，分别是区间的起始和结束位置。如果存在多个，输出i最小的。如果i相等，输出j最小的。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 10</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 4</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>前缀和 o(n^2)暴力竟然过了，看了讨论区还可以再用map优化一下，优化后的代码也放下面了，62ms-&gt;15ms(・ω・)ノ</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p>o(n^2)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;1e4+5;</span><br><span class="line">LL a[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,flag&#x3D;0;</span><br><span class="line">    LL k,c;</span><br><span class="line">    scanf(&quot;%d%lld&quot;,&amp;n,&amp;k);</span><br><span class="line">    a[0]&#x3D;0;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%lld&quot;,&amp;c);</span><br><span class="line">        a[i]&#x3D;a[i-1]+c;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;0;i&lt;&#x3D;n-1;i++)&#123;</span><br><span class="line">        if(flag)break;</span><br><span class="line">        for(int j&#x3D;i+1;j&lt;&#x3D;n;j++)</span><br><span class="line">            if(a[j]-a[i]&#x3D;&#x3D;k)&#123;</span><br><span class="line">                flag&#x3D;1;</span><br><span class="line">                printf(&quot;%d %d\n&quot;,i+1,j);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!flag)printf(&quot;No Solution&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;1e4+5;</span><br><span class="line">LL a[N];</span><br><span class="line">map&lt;LL,LL&gt;m;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,flag&#x3D;0;</span><br><span class="line">    LL k,c;</span><br><span class="line">    scanf(&quot;%d%lld&quot;,&amp;n,&amp;k);</span><br><span class="line">    a[0]&#x3D;0;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%lld&quot;,&amp;c);</span><br><span class="line">        a[i]&#x3D;a[i-1]+c;</span><br><span class="line">        m[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;0;i&lt;&#x3D;n-1;i++)&#123;</span><br><span class="line">        if(flag)break;</span><br><span class="line">        if(m[a[i]+k])&#123;</span><br><span class="line">            for(int j&#x3D;i+1;j&lt;&#x3D;n;j++)</span><br><span class="line">                if(a[j]-a[i]&#x3D;&#x3D;k)&#123;</span><br><span class="line">                    flag&#x3D;1;</span><br><span class="line">                    printf(&quot;%d %d\n&quot;,i+1,j);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    if(!flag)printf(&quot;No Solution&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>51nod 1095 Anigram单词（map）</title>
    <url>/cbd59ef1/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题 </p>
<p>一个单词a如果通过交换单词中字母的顺序可以得到另外的单词b，那么定义b是a的Anigram，例如单词army和mary互为Anigram。另：相同的2个单词不算Anigram。现在给定一个字典，输入Q个单词，从给出的字典中找出这些单词的Anigram。</p>
<a id="more"></a>

<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：1个数N，表示字典中单词的数量。(1 &lt;= N &lt;= 10000)<br>第2 - N + 1行，字典中的单词，单词长度 &lt;= 10。<br>第N + 2行：查询的数量Q。(1 &lt;= Q &lt;= 10000)<br>第N + 3 - N + Q - 2行：用作查询的单词，单词长度 &lt;= 10。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>共Q行，输出Anigram的数量，如果没有输出0。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">add</span><br><span class="line">dad</span><br><span class="line">bad</span><br><span class="line">cad</span><br><span class="line">did</span><br><span class="line">3</span><br><span class="line">add</span><br><span class="line">cac</span><br><span class="line">dda</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>stl好厉害啊</p>
<p>用两个map，一个记录某字符串个数，一个记录某字符串排序后的串的个数，对于某串来说，能变成的串的个数就是上述两数相减</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">map&lt;string,int&gt;m1,m2;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,q,len;</span><br><span class="line">    char s[11];</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%s&quot;,s);</span><br><span class="line">        len&#x3D;strlen(s);</span><br><span class="line">        m1[s]++;</span><br><span class="line">        sort(s,s+len);</span><br><span class="line">        m2[s]++;</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;q);</span><br><span class="line">    int t1,t2;</span><br><span class="line">    for(int i&#x3D;0;i&lt;q;i++)&#123;</span><br><span class="line">        scanf(&quot;%s&quot;,s);</span><br><span class="line">        len&#x3D;strlen(s);</span><br><span class="line">        t1&#x3D;m1[s];</span><br><span class="line">        sort(s,s+len);</span><br><span class="line">        t2&#x3D;m2[s];</span><br><span class="line">        printf(&quot;%d\n&quot;,t2-t1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>51nod 1126 1119 机器人走方格 V2</title>
    <url>/bb4502fa/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题 </p>
<p><code>M * N</code>的方格，一个机器人从左上走到右下，只能向右或向下走。有多少种不同的走法？由于方法数量可能很大，只需要输出Mod 10^9 + 7的结果。</p>
<a id="more"></a>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行，2个数M,N，中间用空格隔开。（2 &lt;= m,n &lt;= 1000000)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出走法的数量 Mod 10^9 + 7。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 3</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>c(m+n-2,m-1)</p>
<p>用费马小定理求组合数的板子交了一发200ms+(#ﾟДﾟ)</p>
<p>写了个扩展欧几里得的板子交还是200ms+…</p>
<p>然后看了下榜里的板子，研究了一下人家的15ms，发现是我求组合数那个函数跑得慢，之前写的那个循环m次每次都求了逆元再相乘，其实可以直接先相乘得到分母，最后求一次逆元即可，改了一下，现在两个都是15ms了(￣▽￣)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LL C(LL n,LL m)&#123;</span><br><span class="line">    if(m&gt;n)return 0;</span><br><span class="line">    LL ans&#x3D;1;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">        LL a&#x3D;(n+i-m)%p;</span><br><span class="line">        LL b&#x3D;i%p;</span><br><span class="line">        ans&#x3D;ans*(a*qpow(b,p-2)%p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int p&#x3D;1e9+7;</span><br><span class="line">LL qpow(LL a,LL b)&#123;</span><br><span class="line">    LL ans&#x3D;1;</span><br><span class="line">    a%&#x3D;p;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            ans&#x3D;ans*a%p;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        b&gt;&gt;&#x3D;1;</span><br><span class="line">        a&#x3D;a*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">LL C(LL n,LL m)&#123;</span><br><span class="line">    if(m&gt;n)return 0;</span><br><span class="line">    LL ans,a&#x3D;1,b&#x3D;1;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">        a&#x3D;(a*(n+i-m)%p)%p;</span><br><span class="line">        b&#x3D;(b*i%p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    ans&#x3D;(a*qpow(b,p-2)%p)%p;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    LL m,n;</span><br><span class="line">    scanf(&quot;%lld%lld&quot;,&amp;m,&amp;n);</span><br><span class="line">    printf(&quot;%lld\n&quot;,C(m+n-2,m-1));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int p&#x3D;1e9+7;</span><br><span class="line">void ex_gcd(LL a,LL b,LL &amp;d,LL &amp;x,LL &amp;y)&#123;</span><br><span class="line">    if(b&#x3D;&#x3D;0)&#123;</span><br><span class="line">        x&#x3D;1;y&#x3D;0;d&#x3D;a;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ex_gcd(b,a%b,d,y,x);</span><br><span class="line">    y-&#x3D;x*(a&#x2F;b);</span><br><span class="line">&#125;</span><br><span class="line">LL inv(LL a)&#123;</span><br><span class="line">    LL x,y,d;</span><br><span class="line">    ex_gcd(a,p,d,x,y);</span><br><span class="line">    if(d!&#x3D;1)return 0;</span><br><span class="line">    return (x%p+p)%p;</span><br><span class="line">&#125;</span><br><span class="line">LL C(LL n,LL m)&#123;</span><br><span class="line">    if(m&gt;n)return 0;</span><br><span class="line">    LL ans,a&#x3D;1,b&#x3D;1;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">        a&#x3D;(a*(n+i-m)%p)%p;</span><br><span class="line">        b&#x3D;(b*i%p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    ans&#x3D;(a*inv(b)%p)%p;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    LL m,n;</span><br><span class="line">    scanf(&quot;%lld%lld&quot;,&amp;m,&amp;n);</span><br><span class="line">    printf(&quot;%lld\n&quot;,C(m+n-2,m-1));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1126 求递推序列的第N项（找循环结，矩阵快速幂）</title>
    <url>/e4d2c7ba/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题</p>
<p>有一个序列是这样定义的：f(1) = 1, f(2) = 1, <code>f(n) = (A * f(n - 1) + B * f(n - 2))</code> mod 7.<br>给出A，B和N，求f(n)的值。</p>
<a id="more"></a>

<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入3个数：A,B,N。数字之间用空格分割。(-10000 &lt;= A, B &lt;= 10000, 1 &lt;= N &lt;= 10^9)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出f(n)的值。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 -1 5</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>和这个题差不多 -&gt; <a href="https://leflacon.github.io/7ecca125/" target="_blank" rel="noopener">Best Solver – ACM-ICPC 2015 Shenyang（推公式，广义斐波那契）</a></p>
<p><strong>找循环结</strong>，因为模7所以按理说很快就能找到然后return的，但是下面这种写法又t又wa</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kl02mnr6j20a6026mx7.jpg" alt=""></p>
<p>存在以下三个问题：</p>
<p>1.负数取模的问题</p>
<p>改成<code>f[i]=((a*f[i-1]%7+b*f[i-2])%7+7)%7;</code></p>
<p>2.刚好是循环结倍数的特殊情况</p>
<p>当n%x=0，n+=x</p>
<p>3.循环条件问题</p>
<p>改成这样才行<code>for(int i=3;i&lt;N;i++)</code>，不然会t。。一开始不知道为啥，打表了这组数据<code>2322 -6048 525119718</code>，发现第三项开始是546231546231……，好特殊啊，自己半路循环了起来0.0</p>
<p>都改完之后那组数据还是re，<code>2322 -6048 525119718</code>，把<code>return i-2</code>改成了break，在最后return，然后就。。ac了。。ac了。。ac了。。(╯°□°）╯︵ ┻━┻ 嗯共计交了21发，下次再写循环结0.0我一定不要wa了</p>
<p>还有一个方法是<strong>矩阵快速幂</strong>，构造如下矩阵然后套板子，代码也放下面了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">( F(n)  ) &#x3D; ( a b )*( F(n-1) )</span><br><span class="line">  F(n-1)      1 0     F(n-2)</span><br></pre></td></tr></table></figure>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;2333; </span><br><span class="line">int f[N],a,b,n;</span><br><span class="line">int getnum()&#123;</span><br><span class="line">    f[0]&#x3D;1;f[1]&#x3D;1;f[2]&#x3D;1;</span><br><span class="line">    int i;</span><br><span class="line">    for(i&#x3D;3;i&lt;N;i++)&#123;</span><br><span class="line">        f[i]&#x3D;((a*f[i-1]%7+b*f[i-2])%7+7)%7;</span><br><span class="line">        if(f[i]&#x3D;&#x3D;1&amp;&amp;f[i-1]&#x3D;&#x3D;1)break;</span><br><span class="line">    &#125;</span><br><span class="line">    return i-2;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;n);</span><br><span class="line">    int x&#x3D;getnum();</span><br><span class="line">    n%&#x3D;x;</span><br><span class="line">    if(n&#x3D;&#x3D;0)n+&#x3D;x;</span><br><span class="line">    printf(&quot;%d\n&quot;,f[n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef vector&lt;int&gt;row;</span><br><span class="line">typedef vector&lt;row&gt;mat;</span><br><span class="line">const int p&#x3D;7;</span><br><span class="line">mat mul(mat a,mat b)&#123;</span><br><span class="line">    mat c(a.size(),row(b[0].size()));</span><br><span class="line">    for(int i&#x3D;0;i&lt;a.size();i++)&#123;</span><br><span class="line">        for(int j&#x3D;0;j&lt;b[0].size();j++)&#123;</span><br><span class="line">            for(int k&#x3D;0;k&lt;b.size();k++)</span><br><span class="line">                c[i][j]&#x3D;(c[i][j]+a[i][k]*b[k][j])%p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line">mat qpow(mat a,int x)&#123;</span><br><span class="line">    mat b(a.size(),row(a.size()));</span><br><span class="line">    for(int i&#x3D;0;i&lt;a.size();i++)b[i][i]&#x3D;1;</span><br><span class="line">    while(x&gt;0)&#123;</span><br><span class="line">        if(x&amp;1)b&#x3D;mul(b,a);</span><br><span class="line">        a&#x3D;mul(a,a);</span><br><span class="line">        x&gt;&gt;&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,aa,bb;</span><br><span class="line">    scanf(&quot;%d%d%d&quot;,&amp;aa,&amp;bb,&amp;n);</span><br><span class="line">    while(aa&lt;0)aa+&#x3D;p;</span><br><span class="line">    while(bb&lt;0)bb+&#x3D;p;</span><br><span class="line">    mat a(2,row(2)),b(2,row(1)),c(2,row(1));</span><br><span class="line">    a[0][0]&#x3D;aa;a[0][1]&#x3D;bb;a[1][0]&#x3D;1;a[1][1]&#x3D;0;</span><br><span class="line">    b[0][0]&#x3D;1;b[1][0]&#x3D;1;</span><br><span class="line">    if(n&gt;&#x3D;3)&#123;</span><br><span class="line">        a&#x3D;qpow(a,n-2);</span><br><span class="line">        c&#x3D;mul(a,b);</span><br><span class="line">        printf(&quot;%d\n&quot;,c[0][0]);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        printf(&quot;1\n&quot;);</span><br><span class="line">    &#125;    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1133 不重叠的线段（贪心）</title>
    <url>/c1989cb5/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题</p>
<p>X轴上有N条线段，每条线段有1个起点S和终点E。最多能够选出多少条互不重叠的线段。（注：起点或终点重叠，不算重叠）。</p>
<a id="more"></a>

<p>例如：[1 5][2 3][3 6]，可以选[2 3][3 6]，这2条线段互不重叠。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：1个数N，线段的数量(2 &lt;= N &lt;= 10000)<br>第2 - N + 1行：每行2个数，线段的起点和终点(-10^9 &lt;= S,E &lt;= 10^9)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出最多可以选择的线段数量。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 5</span><br><span class="line">2 3</span><br><span class="line">3 6</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>n条线段最大没有交点的线段数</p>
<p>贪心，按照线段右端点排序，然后遍历判断</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;10005; </span><br><span class="line">struct node&#123;</span><br><span class="line">    int l,r;</span><br><span class="line">&#125;a[N*2];</span><br><span class="line">bool cmp(struct node x,struct node y)&#123;</span><br><span class="line">    return x.r&lt;y.r;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d%d&quot;,&amp;a[i].l,&amp;a[i].r);</span><br><span class="line">    sort(a,a+n,cmp);</span><br><span class="line">    int ans&#x3D;1,tmp&#x3D;a[0].r;</span><br><span class="line">    for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">        if(a[i].l&gt;&#x3D;tmp)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            tmp&#x3D;a[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1138 连续整数的和</title>
    <url>/fab7cb46/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题</p>
<p>给出一个正整数N，将N写为若干个连续数字和的形式(长度 &gt;= 2)。例如N = 15，可以写为1 + 2 + 3 + 4 + 5，也可以写为4 + 5 + 6，或7 + 8。如果不能写为若干个连续整数的和，则输出No Solution。</p>
<a id="more"></a>

<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入1个数N(3 &lt;= N &lt;= 10^9)。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出连续整数中的第1个数，如果有多个按照递增序排列，如果不能分解为若干个连续整数的和，则输出No Solution。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">4</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>先等差数列求和公式一下</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkzitoo2j208601tmx2.jpg" alt=""></p>
<p>要求的是首项a1</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkzitj01j204o01r0sk.jpg" alt=""></p>
<p>从<code>sqrt(2*sum)</code>开始枚举n即可，遇到整数a1就输出</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int sum,flag&#x3D;0;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;sum);</span><br><span class="line">    int m&#x3D;(int)sqrt(2*sum);</span><br><span class="line">    for(int i&#x3D;m;i&gt;&#x3D;2;i--)&#123;</span><br><span class="line">        if((2*sum+i-i*i)%(2*i)&#x3D;&#x3D;0&amp;&amp;(2*sum+i-i*i)&gt;0)&#123;</span><br><span class="line">            flag&#x3D;1;</span><br><span class="line">            printf(&quot;%d\n&quot;,(2*sum+i-i*i)&#x2F;(2*i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!flag)puts(&quot;No Solution&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1266 蚂蚁（贪心）</title>
    <url>/62f8e345/</url>
    <content><![CDATA[<p>题目来源： Poj</p>
<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 20 难度：2级算法题</p>
<p>n只蚂蚁以每秒1cm的速度在长为Lcm的竿子上爬行。当蚂蚁爬到竿子的端点时就会掉落。由于竿子太细，两只蚂蚁相遇时，它们不能交错通过，只能各自反向爬回去。对于每只蚂蚁，我们知道它距离竿子左端的距离xi，但不知道它当前的朝向。请计算各种情况当中，所有蚂蚁落下竿子所需的最短时间和最长时间。</p>
<p>例如：竿子长10cm，3只蚂蚁位置为2 6 7，最短需要4秒(左、右、右)，最长需要8秒（右、右、右）。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：2个整数N和L，N为蚂蚁的数量，L为杆子的长度(1 &lt;= L &lt;= 10^9, 1 &lt;= N &lt;= 50000)<br>第2 - N + 1行：每行一个整数A[i]，表示蚂蚁的位置(0 &lt; A[i] &lt; L)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出2个数，中间用空格分隔，分别表示最短时间和最长时间。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 10</span><br><span class="line">2</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 8</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>水题，最短时间就是分两边下，最长时间就是所有蚂蚁同向下</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;50005; </span><br><span class="line">int a[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,l,minn,maxx,z;</span><br><span class="line">    int zl,zr,ans1,ans2;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;l);</span><br><span class="line">    minn&#x3D;l;maxx&#x3D;0;z&#x3D;l&#x2F;2;zl&#x3D;zr&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">        minn&#x3D;min(minn,a[i]);</span><br><span class="line">        maxx&#x3D;max(maxx,a[i]);</span><br><span class="line">        if(a[i]&gt;&#x3D;z)zr&#x3D;max(zr,l-a[i]);</span><br><span class="line">        else zl&#x3D;max(zl,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ans1&#x3D;max(zl,zr);</span><br><span class="line">    ans2&#x3D;max(l-minn,maxx);</span><br><span class="line">    printf(&quot;%d %d\n&quot;,ans1,ans2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1278 相离的圆（贪心）</title>
    <url>/eba1fb1b/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题</p>
<p>平面上有N个圆，他们的圆心都在X轴上，给出所有圆的圆心和半径，求有多少对圆是相离的。</p>
<p>例如：4个圆分别位于1, 2, 3, 4的位置，半径分别为1, 1, 2, 1，那么{1, 2}, {1, 3} {2, 3} {2, 4} {3, 4}这5对都有交点，只有{1, 4}是相离的。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：一个数N，表示圆的数量(1 &lt;= N &lt;= 50000)<br>第2 - N + 1行：每行2个数P, R中间用空格分隔，P表示圆心的位置，R表示圆的半径(1 &lt;= P, R &lt;= 10^9)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出共有多少对相离的圆。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 1</span><br><span class="line">2 1</span><br><span class="line">3 2</span><br><span class="line">4 1</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>把圆相离转化一下问题就变成了给n条线段[l,r]，求没有交点的线段个数</p>
<p>可以和这个题联系起来 -&gt; <a href="https://leflacon.github.io/f0e39cec/" target="_blank" rel="noopener">n条线段最多重叠个数</a></p>
<p>里面提供的这种记录入点出点再排序的思路在这个题上同样适用</p>
<p>要注意的是上面那个题在端点重合时是出点排入点前，而这个题相切的圆不算向离，所以入点排出点前，先少一个能相离的圆再结算前面的圆</p>
<p>令num=圆的个数，排序后遍历，遇到入点说明少一个能相离的圆num–，遇到出点ans+=num，妙啊妙啊</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;50005; </span><br><span class="line">struct node&#123;</span><br><span class="line">    int t,v;</span><br><span class="line">&#125;a[N*2];</span><br><span class="line">bool cmp(struct node x,struct node y)&#123;</span><br><span class="line">    if(x.v!&#x3D;y.v)return x.v&lt;y.v;</span><br><span class="line">    else return x.t&lt;y.t;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,p,r;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;p,&amp;r);</span><br><span class="line">        a[i].v&#x3D;p-r;a[i+n].v&#x3D;p+r;</span><br><span class="line">        a[i].t&#x3D;0;a[i+n].t&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a,a+2*n,cmp);</span><br><span class="line">    int num&#x3D;n,ans&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;2*n;i++)&#123;</span><br><span class="line">        if(a[i].t&#x3D;&#x3D;0)num--;</span><br><span class="line">        else ans+&#x3D;num;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1279 扔盘子（stack）</title>
    <url>/650f0a27/</url>
    <content><![CDATA[<p>题目来源： Codility</p>
<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题</p>
<p>有一口井，井的高度为N，每隔1个单位它的宽度有变化。现在从井口往下面扔圆盘，如果圆盘的宽度大于井在某个高度的宽度，则圆盘被卡住（恰好等于的话会下去）。<br>盘子有几种命运：1、掉到井底。2、被卡住。3、落到别的盘子上方。<br>盘子的高度也是单位高度。给定井的宽度和每个盘子的宽度，求最终落到井内的盘子数量。  </p>
<p>如图井和盘子信息如下：<br>井：5 6 4 3 6 2 3<br>盘子：2 3 5 2 4</p>
<p>最终有4个盘子落在井内。</p>
<p>本题由 @javaman 翻译。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：2个数N, M中间用空格分隔，N为井的深度，M为盘子的数量(1 &lt;= N, M &lt;= 50000)。<br>第2 - N + 1行，每行1个数，对应井的宽度Wi(1 &lt;= Wi &lt;= 10^9)。<br>第N + 2 - N + M + 1行，每行1个数，对应盘子的宽度Di(1 &lt;= Di &lt;= 10^9)  </p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出最终落到井内的盘子数量。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 5</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>正常思路是对每一个盘子从上往下遍历井，这样复杂度是o(n^2)过不了，然后想一下怎么优化</p>
<p>考虑到一个盘子，如果能过宽的层下面的窄层，那么上面那个宽层肯定能过，所以从上往下的时候决定它能不能过的其实是一个宽度递减的序列，所以先预处理一下井，改为递减，存入栈中，比如样例<code>5 6 4 3 6 2 3</code>处理后就是<code>5 5 4 3 3 2 2</code>，然后逆向思考，从最下面的那个宽度开始遍历，复杂度o(n)，优美～</p>
<p>一种是单调栈的写法125ms，还有一种不利用stl直接在输入的时候更新写法</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line">const int N&#x3D;50005;</span><br><span class="line">int w[N],d[N];</span><br><span class="line">stack&lt;int&gt;s;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,ans&#x3D;0,tmp&#x3D;INF;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;w[i]);</span><br><span class="line">    for(int i&#x3D;0;i&lt;m;i++)scanf(&quot;%d&quot;,&amp;d[i]);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        if(w[i]&lt;&#x3D;tmp)tmp&#x3D;w[i];</span><br><span class="line">        s.push(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    int cur&#x3D;0;</span><br><span class="line">    while(!s.empty()&amp;&amp;cur&lt;m)&#123;</span><br><span class="line">        if(s.top()&lt;d[cur])&#123;</span><br><span class="line">            s.pop();</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        ans++;</span><br><span class="line">        s.pop();</span><br><span class="line">        cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line">const int N&#x3D;50005;</span><br><span class="line">int w[N],d;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,ans&#x3D;0;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;w[0]);</span><br><span class="line">    for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;w[i]);</span><br><span class="line">        w[i]&#x3D;min(w[i],w[i-1]);</span><br><span class="line">    &#125;</span><br><span class="line">    int ji&#x3D;n;</span><br><span class="line">    for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;d);</span><br><span class="line">        while(w[ji]&lt;d&amp;&amp;ji&gt;&#x3D;0)ji--;</span><br><span class="line">        if(ji&gt;&#x3D;0)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            ji--;</span><br><span class="line">        &#125;</span><br><span class="line">        else break;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1417 天堂里的游戏（博弈）</title>
    <url>/455762c8/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题</p>
<p>……此处省略一堆没啥用的题面</p>
<p>让我们各自亮出硬币的一面，或正或反。如果我们都是正面，那么我给你A元，如果我们都是反面，我给你B元（A + B为偶数）。剩下的情况你给我（A + B） / 2元就可以了</p>
<p>Noder知道这个游戏他多半要输，可他并不在乎，他只想让自己输的慢一点。</p>
<p>那么你来帮美女计算一下，她选择出正面的概率应该是多少（以最简分数形式输出）？</p>
<p>关于样例的解释：</p>
<p>美女采取了(3/8,5/8)这个方案，不论Noder采用什么方案，都是不能改变局面的。如果全部出正面，每次的期望收益是 (3+3+3-2-2-2-2-2)/8=-1/8元；如果全部出反面，每次的期望收益也是(-2-2-2+1+1+1+1+1)/8=-1/8元。而任何策略无非只是上面两种策略的线性组合，所以期望还是-1/8元。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：一个数T，表示后面用作输入测试的数的数量（1 &lt;= T &lt;= 20)。<br>第2 - T + 1行：每行2个数A, B中间用空格分隔。(1 &lt;= A, B &lt;= 10^9，且A + B为偶数)。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出共T行，对应美女选择正面的概率，以最简分数形式输出，具体请参看输出样例。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3 1</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3&#x2F;8</span><br><span class="line">5&#x2F;8</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>样例解释暗示的很清楚了，取最优策略时，对方无论出正面还是反面期望都一样</p>
<p>假设美女出正面概率为x/y，那么若对方全出正面，期望为<code>(x*a-(y-x)*(a+b)/2)/y</code>，若对方全出反面，期望为<code>((y-x)*b-x*(a+b)/2)/y</code></p>
<p><code>(x*a-(y-x)*(a+b)/2)/y=((y-x)*b-x*(a+b)/2)/y</code>，解得<code>x/y=(a+3b)/(4a+4b)</code>，gcd一下即得答案，注意要开LL</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">LL gcd(LL a,LL b)&#123;</span><br><span class="line">    return b&#x3D;&#x3D;0?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    LL a,b,x,y,tmp;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b);</span><br><span class="line">        x&#x3D;a+3*b;y&#x3D;4*(a+b);</span><br><span class="line">        tmp&#x3D;gcd(x,y);</span><br><span class="line">        x&#x2F;&#x3D;tmp;y&#x2F;&#x3D;tmp;</span><br><span class="line">        printf(&quot;%lld&#x2F;%lld\n&quot;,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1428 活动安排问题（贪心）</title>
    <url>/f0e39cec/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题</p>
<p>有若干个活动，第i个开始时间和结束时间是[Si,fi)，同一个教室安排的活动之间不能交叠，求要安排所有活动，最少需要几个教室？ </p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行一个正整数n (n &lt;= 10000)代表活动的个数。<br>第二行到第(n + 1)行包含n个开始时间和结束时间。<br>开始时间严格小于结束时间，并且时间都是非负整数，小于1000000000</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一行包含一个整数表示最少教室的个数。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br><span class="line">2 9</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>就是问最多重叠区间有几个，一开始没想到什么特优美的做法，就去翻了下评论区，下面这个做法蛮妙的</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkwshnpkj20oz04qq3w.jpg" alt=""></p>
<p>注意端点重合是不算的，所以cmp函数位置相同的还要对入点出点排下序，出点在前</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;10005; </span><br><span class="line">struct node&#123;</span><br><span class="line">    int t,v;</span><br><span class="line">&#125;a[N*2];</span><br><span class="line">bool cmp(struct node x,struct node y)&#123;</span><br><span class="line">    if(x.v!&#x3D;y.v)return x.v&lt;y.v;</span><br><span class="line">    else return x.t&gt;y.t;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;a[i].v,&amp;a[i+n].v);</span><br><span class="line">        a[i].t&#x3D;0;a[i+n].t&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a,a+2*n,cmp);</span><br><span class="line">    int num&#x3D;0,ans&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;2*n;i++)&#123;</span><br><span class="line">        if(a[i].t&#x3D;&#x3D;0)num++;</span><br><span class="line">        else num--;</span><br><span class="line">        ans&#x3D;max(ans,num);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1432 独木舟（贪心）</title>
    <url>/a74119db/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题</p>
<p>n个人，已知每个人体重。独木舟承重固定，每只独木舟最多坐两个人，可以坐一个人或者两个人。显然要求总重量不超过独木舟承重，假设每个人体重也不超过独木舟承重，问最少需要几只独木舟？</p>
<a id="more"></a>

<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含两个正整数n <code>(0&lt;n&lt;=10000)</code>和m <code>(0&lt;m&lt;=2000000000)</code>，表示人数和独木舟的承重。<br>接下来n行，每行一个正整数，表示每个人的体重。体重不超过1000000000，并且每个人的体重不超过m。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一行一个整数表示最少需要的独木舟数。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 6</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>最多只能坐两个人，先排个序再贪心即可，如果当前最重的加最轻的能上一条船就上，不能上就重的自己先走，然后找下一个重的人</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;10005;</span><br><span class="line">LL a[N],m;</span><br><span class="line">int n;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%lld&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%lld&quot;,&amp;a[i]);</span><br><span class="line">    sort(a,a+n);</span><br><span class="line">    int cur&#x3D;0,ans&#x3D;0;</span><br><span class="line">    for(int i&#x3D;n-1;i&gt;&#x3D;cur;i--)&#123;</span><br><span class="line">        if(i&#x3D;&#x3D;cur)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if(a[i]+a[cur]&lt;&#x3D;m)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        else ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>C. Stretching Streamers（NAIPC 2017）（记忆化dp）</title>
    <url>/ef2a130f/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkuutvpjj20o70bu416.jpg" alt=""></p>
<a id="more"></a>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkuus5xsj20gn0c1dgg.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkuuthmuj20n70c9q5k.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input</span><br><span class="line">4</span><br><span class="line">30</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">45</span><br><span class="line">output</span><br><span class="line">1</span><br><span class="line">input</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">30</span><br><span class="line">2</span><br><span class="line">45</span><br><span class="line">output</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>n个点有次序的围成一圈，每个点有一个权值a[i]，只有gcd&gt;1的两个数之间才能连线，每个点都要被连到且任意线之间不交叉，求方法数</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>先n^2跑一遍建个图，表明i，j间能否相连</p>
<p>然后dp(i,j,c)，c表示ij是否相连，考虑某两个点i,j <code>(i&lt;j)</code></p>
<p>如果ij已经相连，那么i和j-1相连或者j和i+1相连或者不连都是可行的，方案数要先加上dp(i,j-1,0)+dp(i,j-1,1)+dp(i+1,j,0)+dp(i+1,j,1)，(先把这四个处理掉，因为后面相乘没它们什么事)，其余情况是在[i+1,j-2]中找个点m，i连不连m都行，m+1连不连j也都行，两种方法数相乘</p>
<p>如果ij不相连，那么必须有一个m和i相连，（如果i不连m的话往后dp就再没有人和i相连了），然后m连不连j都行继续讨论下去，两种方法数相乘</p>
<p>return的时候记忆化一下，注意一下边界判断和dp顺序，别的好像没啥了</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int p&#x3D;1e9+7;</span><br><span class="line">const int N&#x3D;305;</span><br><span class="line">int a[N],n,ans[N][N][2];</span><br><span class="line">bool g[N][N];</span><br><span class="line">int gcd(int a,int b)&#123;</span><br><span class="line">    return b&#x3D;&#x3D;0?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">LL dp(int i,int j,int c)&#123;   </span><br><span class="line">    if(ans[i][j][c]!&#x3D;-1)return ans[i][j][c]; </span><br><span class="line">    if(i&gt;j)return 0;</span><br><span class="line">    if(i&#x3D;&#x3D;j)return 1;</span><br><span class="line">    if(c&#x3D;&#x3D;1&amp;&amp;!g[i][j])return 0;</span><br><span class="line">    if(j-i&#x3D;&#x3D;1&amp;&amp;c&#x3D;&#x3D;1)return g[i][j]?1:0;&#x2F;&#x2F;加边缘</span><br><span class="line">    if(j-i&#x3D;&#x3D;1&amp;&amp;c&#x3D;&#x3D;0)return 0;      </span><br><span class="line">    LL res&#x3D;0;</span><br><span class="line">    if(c)&#123;&#x2F;&#x2F;连了ij</span><br><span class="line">        res&#x3D;(res+dp(i,j-1,0)+dp(i,j-1,1)+dp(i+1,j,0)+dp(i+1,j,1))%p;</span><br><span class="line">        for(int m&#x3D;j-2;m&gt;&#x3D;i+1;m--)&#123;</span><br><span class="line">            LL l&#x3D;dp(i,m,0)+dp(i,m,1),r&#x3D;dp(m+1,j,0)+dp(m+1,j,1);</span><br><span class="line">            res&#x3D;(res+l*r)%p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;&#x2F;&#x2F;没连ij</span><br><span class="line">        for(int m&#x3D;j-1;m&gt;&#x3D;i+1;m--)&#123;</span><br><span class="line">            LL l&#x3D;dp(i,m,1),r&#x3D;(dp(m,j,0)+dp(m,j,1))%p;</span><br><span class="line">            res&#x3D;(res+l*r)%p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans[i][j][c]&#x3D;res;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">        for(int j&#x3D;i+1;j&lt;n;j++)</span><br><span class="line">            if(gcd(a[i],a[j])&gt;1)g[i][j]&#x3D;g[j][i]&#x3D;true;</span><br><span class="line">            else g[i][j]&#x3D;g[j][i]&#x3D;false;</span><br><span class="line">    memset(ans,-1,sizeof(ans));</span><br><span class="line">    printf(&quot;%lld\n&quot;,(dp(0,n-1,0)+dp(0,n-1,1))%p);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>CF 327 C. Magic Five（等比数列求和）</title>
    <url>/784bc526/</url>
    <content><![CDATA[<p>There is a long plate s containing n digits. Iahub wants to delete some digits (possibly none, but he is not allowed to delete all the digits) to form his “magic number” on the plate, a number that is divisible by 5. Note that, the resulting number may contain leading zeros.</p>
<p>Now Iahub wants to count the number of ways he can obtain magic number, modulo 1000000007 (109 + 7). Two ways are different, if the set of deleted positions in s differs.</p>
<p>Look at the input part of the statement, s is given in a special form.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>In the first line you’re given a string a (1 ≤ |a| ≤ 105), containing digits only. In the second line you’re given an integer k (1 ≤ k ≤ 109). The plate s is formed by concatenating k copies of a together. That is n = |a|·k.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Print a single integer — the required number of ways modulo 1000000007 (109 + 7).</p>
<h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input</span><br><span class="line">1256</span><br><span class="line">1</span><br><span class="line">output</span><br><span class="line">4</span><br><span class="line">input</span><br><span class="line">13990</span><br><span class="line">2</span><br><span class="line">output</span><br><span class="line">528</span><br><span class="line">input</span><br><span class="line">555</span><br><span class="line">2</span><br><span class="line">output</span><br><span class="line">63</span><br></pre></td></tr></table></figure>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>In the first case, there are four possible ways to make a number that is divisible by 5: 5, 15, 25 and 125.</p>
<p>In the second case, remember to concatenate the copies of a. The actual plate is 1399013990.</p>
<p>In the third case, except deleting all digits, any choice will do. Therefore there are 26 - 1 = 63 possible ways to delete digits.</p>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给一个字符串a，循环k次，得到数字n</p>
<p>删去其中部分数字，使得到的数字是5的倍数，求方法数</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>首先结尾是0或5的数字能被5整除，若a[i]=0或5，那么以a[i]结尾的数共有2^(i-1)个</p>
<p>那么k=1的答案很好求，问题在于数字n是a循环k次，而k很大，冷静一下推个公式玩玩</p>
<p>若a[i]=0或5,因为<code>a[i+len],a[i+len*2]……a[i+len*(k-1)]</code>都等于a[i]，所以他们的个数等比数列求和为：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kku82v2zj20d901vwef.jpg" alt=""></p>
<p>大数取模分子逆元一下，就乘以pow(2^len-1,p-2)</p>
<p>最后，啥玩意儿啊精度问题也太可怕了吧。。wa5了好多发，最后ans三个乘一起再取模是使不得的(#ﾟДﾟ) 必须得前两个先取模，不然就爆LL了</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int p&#x3D;1e9+7;</span><br><span class="line">string a;</span><br><span class="line">int k,len;</span><br><span class="line">LL ans&#x3D;0;</span><br><span class="line">LL qpow(LL a,LL b)&#123;</span><br><span class="line">    LL ans&#x3D;1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            ans&#x3D;(ans*a)%p;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        b&#x2F;&#x3D;2;</span><br><span class="line">        a&#x3D;a*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123; </span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;k);</span><br><span class="line">    len&#x3D;a.length();</span><br><span class="line">    for(int i&#x3D;0;i&lt;len;i++)&#123;</span><br><span class="line">        if(a[i]&#x3D;&#x3D;&#39;0&#39;||a[i]&#x3D;&#x3D;&#39;5&#39;)</span><br><span class="line">            ans&#x3D;(ans+qpow(2,i))%p;</span><br><span class="line">    &#125;</span><br><span class="line">    LL fm&#x3D;qpow(2,len),fz&#x3D;qpow(fm,k);</span><br><span class="line">    fm&#x3D;(fm-1+p)%p;fz&#x3D;(fz-1+p)%p;</span><br><span class="line">    ans&#x3D;((ans*fz)%p*qpow(fm,p-2))%p;</span><br><span class="line">    printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1561 The more, The Better（树型dp，依赖背包）</title>
    <url>/c40a717a/</url>
    <content><![CDATA[<p>Time Limit: 6000/2000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>ACboy很喜欢玩一种战略游戏，在一个地图上，有N座城堡，每座城堡都有一定的宝物，在每次游戏中ACboy允许攻克M个城堡并获得里面的宝物。但由于地理位置原因，有些城堡不能直接攻克，要攻克这些城堡必须先攻克其他某一个特定的城堡。你能帮ACboy算出要获得尽量多的宝物应该攻克哪M个城堡吗？</p>
<a id="more"></a>

<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>每个测试实例首先包括2个整数，N,M.(1 &lt;= M &lt;= N &lt;= 200);在接下来的N行里，每行包括2个整数，a,b. 在第 i 行，a 代表要攻克第 i 个城堡必须先攻克第 a 个城堡，如果 a = 0 则代表可以直接攻克第 i 个城堡。b 代表第 i 个城堡的宝物数量, b &gt;= 0。当N = 0, M = 0输入结束。 </p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每个测试实例，输出一个整数，代表ACboy攻克M个城堡所获得的最多宝物的数量。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br><span class="line">0 3</span><br><span class="line">7 4</span><br><span class="line">2 2</span><br><span class="line">0 1</span><br><span class="line">0 4</span><br><span class="line">2 1</span><br><span class="line">7 1</span><br><span class="line">7 6</span><br><span class="line">2 2</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">13</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给n个点，要求选m个且权值最大，如果某点被选择则某点父亲也要被选择</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>m++，加一个0号点，森林变成树，森林的根都是0号点的儿子</p>
<p><code>dp[i][j]</code>表示选取i点及子树的点，共j个的最大权值，然后在有儿子的节点上01背包<code>dp[x][j]=max(dp[x][j],dp[x][j-k]+dp[son][k])</code></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;205;</span><br><span class="line">int dp[N][N],n,m,a,b;</span><br><span class="line">vector&lt;int&gt;g[N];</span><br><span class="line">void dfs(int x)&#123;</span><br><span class="line">    for(int i&#x3D;0;i&lt;g[x].size();i++)&#123;</span><br><span class="line">        int son&#x3D;g[x][i];</span><br><span class="line">        if(g[son].size())dfs(son);</span><br><span class="line">        for(int j&#x3D;m;j&gt;1;j--)</span><br><span class="line">            for(int k&#x3D;1;k&lt;j;k++)</span><br><span class="line">                dp[x][j]&#x3D;max(dp[x][j],dp[x][j-k]+dp[son][k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123; </span><br><span class="line">    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!&#x3D;EOF&amp;&amp;(n&amp;&amp;m))&#123;</span><br><span class="line">        memset(dp,0,sizeof(dp));</span><br><span class="line">        for(int i&#x3D;0;i&lt;&#x3D;n;i++)g[i].clear();</span><br><span class="line">        m++;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">            g[a].push_back(i);</span><br><span class="line">            for(int j&#x3D;1;j&lt;&#x3D;m;j++)dp[i][j]&#x3D;b;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(0);</span><br><span class="line">        printf(&quot;%d\n&quot;,dp[0][m]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1413 权势二进制（CF 538 B. Quasi Binary）</title>
    <url>/73d62e33/</url>
    <content><![CDATA[<p>题目来源： CodeForces<a href="http://codeforces.com/problemset/problem/538/B" target="_blank" rel="noopener">http://codeforces.com/problemset/problem/538/B</a></p>
<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题</p>
<p>一个十进制整数被叫做权势二进制，当他的十进制表示的时候只由0或1组成。例如0，1，101，110011都是权势二进制而2，12，900不是。</p>
<p>当给定一个n的时候，计算一下最少要多少个权势二进制相加才能得到n。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>单组测试数据。<br>第一行给出一个整数n (1&lt;=n&lt;=1,000,000)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出答案占一行。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>这个题放二级里有点太水了。。</p>
<p>就是取所有位中出现的最大的那个数字</p>
<p>然后写了一下cf原题，原题里还有一个要求是要输出这些权值二进制。。写的一点都不优美的代码也放下面了0.0</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123; </span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    int ans&#x3D;1,len&#x3D;s.length();</span><br><span class="line">    for(int i&#x3D;0;i&lt;len;i++)ans&#x3D;max(ans,s[i]-&#39;0&#39;);</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int f(int w)&#123;</span><br><span class="line">    if(w&#x3D;&#x3D;1)return 1;</span><br><span class="line">    else if(w&#x3D;&#x3D;2)return 10;</span><br><span class="line">    else if(w&#x3D;&#x3D;3)return 100;</span><br><span class="line">    else if(w&#x3D;&#x3D;4)return 1000;</span><br><span class="line">    else if(w&#x3D;&#x3D;5)return 10000;</span><br><span class="line">    else if(w&#x3D;&#x3D;6)return 100000;</span><br><span class="line">    else return 1000000;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123; </span><br><span class="line">    int n,wei,tmp,ans[11],ji&#x3D;0,res; </span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n); </span><br><span class="line">    while(n)&#123;</span><br><span class="line">        wei&#x3D;0;tmp&#x3D;n;res&#x3D;0;</span><br><span class="line">        while(tmp)&#123;</span><br><span class="line">            tmp&#x2F;&#x3D;10;wei++;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp&#x3D;n;</span><br><span class="line">        for(int i&#x3D;wei;i&gt;0;i--)&#123;</span><br><span class="line">            if(tmp&#x2F;f(i))&#123;</span><br><span class="line">                tmp-&#x3D;f(i);res+&#x3D;f(i);</span><br><span class="line">            &#125;</span><br><span class="line">            if(tmp&#x2F;f(i))tmp%&#x3D;f(i);</span><br><span class="line">        &#125;</span><br><span class="line">        n-&#x3D;res;</span><br><span class="line">        ans[ji++]&#x3D;res;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ji);</span><br><span class="line">    for(int i&#x3D;0;i&lt;ji-1;i++)printf(&quot;%d &quot;,ans[i]);</span><br><span class="line">    printf(&quot;%d\n&quot;,ans[ji-1]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1433 0和5（CF 352 A. Jeff and Digits）</title>
    <url>/50df051/</url>
    <content><![CDATA[<p>题目来源： CodeForces<a href="http://codeforces.com/problemset/problem/352/A" target="_blank" rel="noopener">http://codeforces.com/problemset/problem/352/A</a></p>
<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题</p>
<p>小K手中有n张牌，每张牌上有一个一位数的数，这个字数不是0就是5。小K从这些牌在抽出任意张（不能抽0张），排成一行这样就组成了一个数。使得这个数尽可能大，而且可以被90整除。</p>
<p>注意：</p>
<p>1.这个数没有前导0，</p>
<p>2.小K不需要使用所有的牌。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>每个测试数据输入共2行。<br>第一行给出一个n，表示n张牌。(1&lt;=n&lt;=1000)<br>第二行给出n个整数a[0],a[1],a[2],…,a[n-1] ，a[i]是0或5 ，表示牌上的数字。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>共一行，表示由所给牌组成的可以被90整除的最大的数，如果没有答案则输出”-1”（没有引号）</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">5 0 5 0</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>水题。。然而wa了十几发。。原地爆炸。。</p>
<p>各项和相加是9的倍数的数才能被9整除</p>
<blockquote>
<p>证明：</p>
<p>先假设一个三位数abc能被9整除，即有<code>100*a+10*b+c=9k</code>，移项得：<code>a+b+c=9k-99a-9b=9(k-11a-b)</code>，即各项和能被9整除</p>
<p>再假设一个n位数ab……yz，有<code>10……0*a+……+10y+z=9k</code>，<code>a+b+……+z=9k-99……9a-……-9y</code>，各项和能被9整除</p>
</blockquote>
<p>所以要被90整除的话，必须有一个0在末尾，num5的个数贪心的取能取到的最大的9的倍数</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;  </span><br><span class="line">    int n,num5&#x3D;0,x,num0;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">        if(x&#x3D;&#x3D;5)num5++;</span><br><span class="line">    &#125;</span><br><span class="line">    num0&#x3D;n-num5;</span><br><span class="line">    if(num0&#x3D;&#x3D;0)puts(&quot;-1&quot;);</span><br><span class="line">    else if(num5&lt;9)puts(&quot;0&quot;);</span><br><span class="line">    else&#123;       </span><br><span class="line">        num5&#x3D;(int)(num5&#x2F;9)*9;</span><br><span class="line">        for(int i&#x3D;0;i&lt;num5;i++)printf(&quot;5&quot;);</span><br><span class="line">        for(int i&#x3D;0;i&lt;num0;i++)printf(&quot;0&quot;);</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1629 B君的圆锥（推公式，三分）</title>
    <url>/e5ffcbea/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题 </p>
<p>B君要用一个表面积为S的圆锥将白山云包起来。</p>
<a id="more"></a>

<p>B君希望包住的白山云体积尽量大，B君想知道体积最大可以是多少。</p>
<p>注意圆锥的表面积包括底面和侧面。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>一行一个整数，表示表面积S。(1 &lt;= S &lt;= 10^9)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一行一个实数，表示体积。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.504506</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>懒得打公式了。。直接写吧</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkwc8u3nj21400u0q8m.jpg" alt=""></p>
<p>这是个上凸函数，所以还有一种方法是三分，因为没有写过三分的题所以虽然上面那种推公式的方法很方便，不过还是去写了三分法（我记得之前有个三分的题没补来着(#ﾟДﾟ)然而忘了什么题了）</p>
<p>初始三分的时候，要注意保证半径的合法性<code>l=0,r=sqrt(s/(2*pai))</code>，也就是极限情况h=∞或h=0</p>
<p>两种方法跑的都很快快</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define pai M_PI</span><br><span class="line">int main()&#123;</span><br><span class="line">    double s,rr;</span><br><span class="line">    scanf(&quot;%lf&quot;,&amp;s);</span><br><span class="line">    rr&#x3D;s&#x2F;(4*pai);</span><br><span class="line">    printf(&quot;%lf\n&quot;,(double)sqrt(rr*s*s-2*pai*s*rr*rr)&#x2F;3);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define eps 1e-6</span><br><span class="line">#define pai M_PI</span><br><span class="line">double s;</span><br><span class="line">double v(double r)&#123;</span><br><span class="line">    return (double)sqrt(r*r*s*s-2*pai*s*r*r*r*r)&#x2F;3;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;    </span><br><span class="line">    scanf(&quot;%lf&quot;,&amp;s);</span><br><span class="line">    double l&#x3D;0,r&#x3D;sqrt(s&#x2F;(2*pai)),m,rm;</span><br><span class="line">    while(r-l&gt;eps)&#123;</span><br><span class="line">        m&#x3D;(l+r)&#x2F;2.0;rm&#x3D;(m+r)&#x2F;2.0;</span><br><span class="line">        if(v(m)&gt;&#x3D;v(rm))r&#x3D;rm;</span><br><span class="line">        else l&#x3D;m;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lf\n&quot;,v(l));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1489 蜥蜴和地下室（CF 6 D. Lizards and Basements 2）</title>
    <url>/61acc2f3/</url>
    <content><![CDATA[<p>题目来源： CodeForces<a href="http://codeforces.com/contest/6/problem/D" target="_blank" rel="noopener">http://codeforces.com/contest/6/problem/D</a></p>
<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题</p>
<p>哈利喜欢玩角色扮演的电脑游戏《蜥蜴和地下室》。此时，他正在扮演一个魔术师。在最后一关，他必须和一排的弓箭手战斗。他唯一能消灭他们的办法是一个火球咒语。如果哈利用他的火球咒语攻击第i个弓箭手（他们从左到右标记），这个弓箭手会失去a点生命值。同时，这个咒语使与第i个弓箭手左右相邻的弓箭手（如果存在）分别失去b(1 ≤ b &lt; a ≤ 10)点生命值。</p>
<p>因为两个端点的弓箭手（即标记为1和n的弓箭手）与你相隔较远，所以火球不能直接攻击他们。但是哈利能用他的火球攻击其他任何弓箭手。</p>
<p>每个弓箭手的生命值都已知。当一个弓箭手的生命值小于0时，这个弓箭手会死亡。请求出哈利杀死所有的敌人所需使用的最少的火球数。</p>
<p>如果弓箭手已经死亡，哈利仍旧可以将他的火球扔向这个弓箭手。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含3个整数 n, a, b (3 ≤ n ≤ 10; 1 ≤ b &lt; a ≤ 10)，第二行包含n个整数——h1，h2，…，hn (1 ≤ hi ≤ 15)， hi 是第i个弓箭手所拥有的生命力。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>以一行输出t——所需要的最少的火球数。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2 1</span><br><span class="line">2 2 2</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>因为不能直接打1和n，所以开头先通过打2和n-1来打爆1和n，然后剩下的[2,n-1]dfs，dfs(cur,num)表示直接打第cur个，那么对于cur-1来说只能用b打爆，而对于cur来说可以用a打爆，也可以通过打cur+1来用b打爆，枚举[x,y]次数即可</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line">int n,a,b,h[15],res;</span><br><span class="line">void dfs(int cur,int num)&#123;</span><br><span class="line">    if(cur&#x3D;&#x3D;n)&#123;</span><br><span class="line">        res&#x3D;min(res,num);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(h[cur-1]&lt;0)dfs(cur+1,num);</span><br><span class="line">    int x&#x3D;h[cur-1]&#x2F;b+1,y&#x3D;h[cur]&#x2F;a+1;</span><br><span class="line">    if(x&lt;0)x&#x3D;0;</span><br><span class="line">    for(int i&#x3D;x;i&lt;&#x3D;y;i++)&#123;</span><br><span class="line">        h[cur-1]-&#x3D;i*b;h[cur]-&#x3D;i*a;h[cur+1]-&#x3D;i*b;</span><br><span class="line">        dfs(cur+1,num+i);</span><br><span class="line">        h[cur-1]+&#x3D;i*b;h[cur]+&#x3D;i*a;h[cur+1]+&#x3D;i*b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;a,&amp;b);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)scanf(&quot;%d&quot;,&amp;h[i]);</span><br><span class="line">    int num,ans&#x3D;0;</span><br><span class="line">    res&#x3D;INF; </span><br><span class="line">    num&#x3D;h[1]&#x2F;b+1;ans+&#x3D;num;</span><br><span class="line">    h[1]-&#x3D;num*b;h[2]-&#x3D;num*a;h[3]-&#x3D;num*b;</span><br><span class="line">    if(h[n]&gt;&#x3D;0)&#123;</span><br><span class="line">        num&#x3D;h[n]&#x2F;b+1;ans+&#x3D;num;</span><br><span class="line">        h[n]-&#x3D;num*b;h[n-1]-&#x3D;num*a;</span><br><span class="line">        h[n-2]-&#x3D;num*b;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(2,0);</span><br><span class="line">    printf(&quot;%d\n&quot;,res+ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 5983 Pocket Cube（模拟）</title>
    <url>/9fe4182d/</url>
    <content><![CDATA[<p>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The Pocket Cube, also known as the Mini Cube or the Ice Cube, is the <code>2 × 2 × 2</code> equivalence of a Rubik’s Cube.</p>
<a id="more"></a>

<p>The cube consists of 8 pieces, all corners.<br>Each piece is labeled by a three dimensional coordinate (h, k, l) where h, k, l ∈ {0, 1}. Each of the six faces owns four small faces filled with a positive integer.</p>
<p>For each step, you can choose a certain face and turn the face ninety degrees clockwise or counterclockwise.</p>
<p>You should judge that if one can restore the pocket cube in one step. We say a pocket cube has been restored if each face owns four same integers.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of input contains one integer N(N ≤ 30) which is the number of test cases.<br>For each test case, the first line describes the top face of the pocket cube, which is the common 2 × 2 face of pieces<br>labelled by (0, 0, 1),(0, 1, 1),(1, 0, 1),(1, 1, 1). Four integers are given corresponding to the above pieces.<br>The second line describes the front face, the common face of (1, 0, 1),(1, 1, 1),(1, 0, 0),(1, 1, 0). Four integers are<br>given corresponding to the above pieces.<br>The third line describes the bottom face, the common face of (1, 0, 0),(1, 1, 0),(0, 0, 0),(0, 1, 0). Four integers are<br>given corresponding to the above pieces.<br>The fourth line describes the back face, the common face of (0, 0, 0),(0, 1, 0),(0, 0, 1),(0, 1, 1). Four integers are<br>given corresponding to the above pieces.<br>The fifth line describes the left face, the common face of (0, 0, 0),(0, 0, 1),(1, 0, 0),(1, 0, 1). Four integers are given<br>corresponding to the above pieces.<br>The six line describes the right face, the common face of (0, 1, 1),(0, 1, 0),(1, 1, 1),(1, 1, 0). Four integers are given<br>corresponding to the above pieces.<br>In other words, each test case contains 24 integers a, b, c to x. You can flat the surface to get the surface development<br>as follows.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ - + - + - + - + - + - +</span><br><span class="line">| q | r | a | b | u | v |</span><br><span class="line">+ - + - + - + - + - + - +</span><br><span class="line">| s | t | c | d | w | x |</span><br><span class="line">+ - + - + - + - + - + - +</span><br><span class="line">        | e | f |</span><br><span class="line">        + - + - +</span><br><span class="line">        | g | h |</span><br><span class="line">        + - + - +</span><br><span class="line">        | i | j |</span><br><span class="line">        + - + - +</span><br><span class="line">        | k | l |</span><br><span class="line">        + - + - +</span><br><span class="line">        | m | n |</span><br><span class="line">        + - + - +</span><br><span class="line">        | o | p |</span><br><span class="line">        + - + - +</span><br></pre></td></tr></table></figure>

<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, output YES if can be restored in one step, otherwise output NO.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 1 1 1</span><br><span class="line">2 2 2 2</span><br><span class="line">3 3 3 3</span><br><span class="line">4 4 4 4</span><br><span class="line">5 5 5 5</span><br><span class="line">6 6 6 6</span><br><span class="line">6 6 6 6</span><br><span class="line">1 1 1 1</span><br><span class="line">2 2 2 2</span><br><span class="line">3 3 3 3</span><br><span class="line">5 5 5 5</span><br><span class="line">4 4 4 4</span><br><span class="line">1 4 1 4</span><br><span class="line">2 1 2 1</span><br><span class="line">3 2 3 2</span><br><span class="line">4 3 4 3</span><br><span class="line">5 5 5 5</span><br><span class="line">6 6 6 6</span><br><span class="line">1 3 1 3</span><br><span class="line">2 4 2 4</span><br><span class="line">3 1 3 1</span><br><span class="line">4 2 4 2</span><br><span class="line">5 5 5 5</span><br><span class="line">6 6 6 6</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>


<h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>2016ACM/ICPC亚洲区青岛站-重现赛（感谢中国石油大学）</p>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给一个二阶魔方，问能否一部还原</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>六个面六种转法，顺时针一次或逆时针一次（即顺时针三次），暴力模拟，特判不用转的情况</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int a[7][5],b[7][5];</span><br><span class="line">bool ok()&#123;</span><br><span class="line">    int flag&#x3D;1;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;6;i++)&#123;</span><br><span class="line">        int tmp&#x3D;b[i][1];</span><br><span class="line">        if(!flag)break;</span><br><span class="line">        for(int j&#x3D;2;j&lt;&#x3D;4;j++)&#123;</span><br><span class="line">            if(b[i][j]!&#x3D;tmp)&#123;</span><br><span class="line">                flag&#x3D;0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br><span class="line">void zhuan(int m)&#123;</span><br><span class="line">    int t1,t2;</span><br><span class="line">    if(m&#x3D;&#x3D;1)&#123;</span><br><span class="line">        t1&#x3D;b[2][1];t2&#x3D;b[2][2];</span><br><span class="line">        b[2][1]&#x3D;b[5][2];b[2][2]&#x3D;b[5][4];</span><br><span class="line">        b[5][2]&#x3D;b[4][4];b[5][4]&#x3D;b[4][3];</span><br><span class="line">        b[4][4]&#x3D;b[6][3];b[4][3]&#x3D;b[6][1];</span><br><span class="line">        b[6][3]&#x3D;t1;b[6][1]&#x3D;t2;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(m&#x3D;&#x3D;2)&#123;</span><br><span class="line">        t1&#x3D;b[1][3];t2&#x3D;b[1][4];</span><br><span class="line">        b[1][3]&#x3D;b[6][3];b[1][4]&#x3D;b[6][4];</span><br><span class="line">        b[6][3]&#x3D;b[3][2];b[6][4]&#x3D;b[3][1];</span><br><span class="line">        b[3][2]&#x3D;b[5][3];b[3][1]&#x3D;b[5][4];</span><br><span class="line">        b[5][3]&#x3D;t1;b[5][4]&#x3D;t2;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(m&#x3D;&#x3D;3)&#123;</span><br><span class="line">        t1&#x3D;b[2][3];t2&#x3D;b[2][4];</span><br><span class="line">        b[2][3]&#x3D;b[6][4];b[2][4]&#x3D;b[6][2];</span><br><span class="line">        b[6][4]&#x3D;b[4][2];b[6][2]&#x3D;b[4][1];</span><br><span class="line">        b[4][2]&#x3D;b[5][1];b[4][1]&#x3D;b[5][3];</span><br><span class="line">        b[5][1]&#x3D;t1;b[5][3]&#x3D;t2;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(m&#x3D;&#x3D;4)&#123;</span><br><span class="line">        t1&#x3D;b[1][2];t2&#x3D;b[1][1];</span><br><span class="line">        b[1][2]&#x3D;b[6][2];b[1][1]&#x3D;b[6][1];</span><br><span class="line">        b[6][2]&#x3D;b[3][3];b[6][1]&#x3D;b[3][4];</span><br><span class="line">        b[3][3]&#x3D;b[5][2];b[3][4]&#x3D;b[5][1];</span><br><span class="line">        b[5][2]&#x3D;t1;b[5][1]&#x3D;t2;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(m&#x3D;&#x3D;5)&#123;</span><br><span class="line">        t1&#x3D;b[1][1];t2&#x3D;b[1][3];</span><br><span class="line">        b[1][1]&#x3D;b[4][1];b[1][3]&#x3D;b[4][3];</span><br><span class="line">        b[4][1]&#x3D;b[3][1];b[4][3]&#x3D;b[3][3];</span><br><span class="line">        b[3][1]&#x3D;b[2][1];b[3][3]&#x3D;b[2][3];</span><br><span class="line">        b[2][1]&#x3D;t1;b[2][3]&#x3D;t2;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(m&#x3D;&#x3D;6)&#123;</span><br><span class="line">        t1&#x3D;b[1][4];t2&#x3D;b[1][2];</span><br><span class="line">        b[1][4]&#x3D;b[2][4];b[1][2]&#x3D;b[2][2];</span><br><span class="line">        b[2][4]&#x3D;b[3][4];b[2][2]&#x3D;b[3][2];</span><br><span class="line">        b[3][4]&#x3D;b[4][4];b[3][2]&#x3D;b[4][2];</span><br><span class="line">        b[4][4]&#x3D;t1;b[4][2]&#x3D;t2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,flag;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        flag&#x3D;0;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;6;i++)&#123;</span><br><span class="line">            for(int j&#x3D;1;j&lt;&#x3D;4;j++)</span><br><span class="line">                scanf(&quot;%d&quot;,&amp;a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j&#x3D;1;j&lt;&#x3D;6;j++)</span><br><span class="line">                for(int k&#x3D;1;k&lt;&#x3D;4;k++)</span><br><span class="line">                    b[j][k]&#x3D;a[j][k];</span><br><span class="line">        if(ok())&#123;</span><br><span class="line">            puts(&quot;YES&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;6;i++)&#123;</span><br><span class="line">            for(int j&#x3D;1;j&lt;&#x3D;6;j++)</span><br><span class="line">                for(int k&#x3D;1;k&lt;&#x3D;4;k++)</span><br><span class="line">                    b[j][k]&#x3D;a[j][k];</span><br><span class="line">            zhuan(i);</span><br><span class="line">            if(ok())&#123;</span><br><span class="line">                flag&#x3D;1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            zhuan(i);zhuan(i);</span><br><span class="line">            if(ok())&#123;</span><br><span class="line">                flag&#x3D;1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag)puts(&quot;YES&quot;);</span><br><span class="line">        else puts(&quot;NO&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1521 一维战舰（CF 567 D. One-Dimensional Battle Ships）</title>
    <url>/ca3f6ac0/</url>
    <content><![CDATA[<p>题目来源： CodeForces<a href="http://codeforces.com/contest/567/problem/D" target="_blank" rel="noopener">http://codeforces.com/contest/567/problem/D</a></p>
<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题 </p>
<p>爱丽丝和鲍博喜欢玩一维战舰的游戏。他们在一行有n个方格的纸上玩这个游戏（也就是1×n的表格）。</p>
<p>在游戏开始的时候，爱丽丝放k个战舰在这个表格中，并不把具体位置告诉鲍博。每一只战舰的形状是 1×a 的长方形（也就是说，战舰会占据a个连续的方格）。这些战舰不能相互重叠，也不能相接触。</p>
<p>然后鲍博会做一系列的点名。当他点到某个格子的时候，爱丽丝会告诉他那个格子是否被某只战舰占据。如果是，就说hit，否则就说miss。</p>
<p>但是这儿有一个问题！爱丽丝喜欢撒谎。他每次都会告诉鲍博miss。</p>
<p>请你帮助鲍博证明爱丽丝撒谎了，请找出哪一步之后爱丽丝肯定撒谎了。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>单组测试数据。<br>第一行有三个整数n,k和a(1≤n,k,a≤2*10^5)，表示表格的大小，战舰的数目，还有战舰的大小。输入的n,k,a保证是能够在1×n的表格中放入k只大小为a的战舰，并且他们之间不重叠也不接触。<br>第二行是一个整数m(1≤m≤n)，表示鲍博的点名次数。<br>第三行有m个不同的整数x1,x2,…,xm，xi是鲍博第i次点名的格子编号。格子从左到右按照1到n编号。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一个整数，表示最早一次能够证明爱丽丝一定撒谎的点名编号。如果不能证明，输出-1。点名的编号依次从1到m编号。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">样例1</span><br><span class="line">11 3 3</span><br><span class="line">5</span><br><span class="line">4 8 6 1 11</span><br><span class="line"></span><br><span class="line">样例2</span><br><span class="line">5 1 3</span><br><span class="line">2</span><br><span class="line">1 5</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">样例输出1</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">样例输出2</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>脑子不转了已经。。半天没想通0.0 还是纸上模拟一下靠谱</p>
<p>因为战舰不能接触，也就是说两个战舰中间要有一个空格，所以1xn的格子能放的最多战舰数是<code>(n+1)/(a+1)</code>，然后如果当前格子i是miss，那么从i向左右拓展，知道遇到被标记的分隔l,r，然后先减去这个l～r区间内能放的战舰数，再加上l～x和x～r两个区间内能放的战舰数</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;200005;</span><br><span class="line">bool vis[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,k,a,m,c;</span><br><span class="line">    scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;k,&amp;a,&amp;m);</span><br><span class="line">    memset(vis,false,sizeof(vis));</span><br><span class="line">    vis[0]&#x3D;vis[n+1]&#x3D;true;</span><br><span class="line">    int num&#x3D;(n+1)&#x2F;(a+1),l,r,flag&#x3D;1;</span><br><span class="line">    for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;c);</span><br><span class="line">        vis[c]&#x3D;true;</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            for(l&#x3D;c-1;l&gt;&#x3D;0&amp;&amp;!vis[l];l--);</span><br><span class="line">            for(r&#x3D;c+1;r&lt;&#x3D;n&amp;&amp;!vis[r];r++);</span><br><span class="line">            int tmp&#x3D;(r-l)&#x2F;(a+1);</span><br><span class="line">            num-&#x3D;tmp;</span><br><span class="line">            num+&#x3D;(c-l)&#x2F;(a+1)+(r-c)&#x2F;(a+1);</span><br><span class="line">            if(num&lt;k)&#123;</span><br><span class="line">                flag&#x3D;0;</span><br><span class="line">                printf(&quot;%d\n&quot;,i+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    if(flag)printf(&quot;-1\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>C. Greetings!（枚举，贪心，dfs） -- The North American Invitational Programming Contest 2016</title>
    <url>/9ee158e1/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkvjbtbbj20j90gzq8i.jpg" alt=""></p>
<a id="more"></a>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkvjbsc0j20ia04xwfy.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkvjatmpj20ia0hlq4e.jpg" alt=""></p>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>有n种卡片，每种卡片长/宽/个数分别为wi，hi，qi</p>
<p>有k种大小的信封，大小任意，要求把卡片装到信封里，定义浪费值为信封大小减去卡片大小，求最小的浪费值</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>不同的卡片放在同一种信封里信封的最优大小一般不同，所以首先枚举2^n个状态，预处理出每种状态的浪费值，肯定是贪心的取当前最大的长和宽作为这个信封的长和宽，浪费值存入st[i]</p>
<p>dfs(now,k)和ans[now][k]代表状态now的卡片装k种信封的最小浪费值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i&#x3D;now;i&gt;0;i&#x3D;(i-1)&amp;now)</span><br><span class="line">    res&#x3D;min(res,st[i]+dfs(now-i,k-1));</span><br></pre></td></tr></table></figure>

<p><code>i=(i-1)&amp;now</code>就可以枚举完<code>k-&gt;k-1</code>的所有情况了，比如当前<code>now=11001</code>，那么k-1下共有<code>11000,10001,10000,01001,01000,00001</code>这六种情况，取最小的那一种返回，继续dfs至<code>now=0||k=1</code>为止</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;15;</span><br><span class="line">const LL INF&#x3D;9223372036854775807;</span><br><span class="line">LL st[(1&lt;&lt;N)],ans[(1&lt;&lt;N)][16];</span><br><span class="line">struct aaa&#123;</span><br><span class="line">    LL w,h,q;</span><br><span class="line">&#125;a[N];</span><br><span class="line">LL dfs(int now,int k)&#123;   </span><br><span class="line">    if(ans[now][k]&gt;&#x3D;0)return ans[now][k];</span><br><span class="line">    if(k&#x3D;&#x3D;1)&#123;</span><br><span class="line">        ans[now][k]&#x3D;st[now];</span><br><span class="line">        return ans[now][k];</span><br><span class="line">    &#125;</span><br><span class="line">    if(now&#x3D;&#x3D;0)return 0;</span><br><span class="line">    LL res&#x3D;INF;</span><br><span class="line">    for(int i&#x3D;now;i&gt;0;i&#x3D;(i-1)&amp;now)</span><br><span class="line">        res&#x3D;min(res,st[i]+dfs(now-i,k-1));</span><br><span class="line">    ans[now][k]&#x3D;res;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,k;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">        scanf(&quot;%lld%lld%lld&quot;,&amp;a[i].w,&amp;a[i].h,&amp;a[i].q);</span><br><span class="line">    memset(ans,-1,sizeof(ans));</span><br><span class="line">    st[0]&#x3D;0;</span><br><span class="line">    for(int i&#x3D;1;i&lt;(1&lt;&lt;n);i++)&#123;</span><br><span class="line">        LL chang&#x3D;0,kuan&#x3D;0;</span><br><span class="line">        st[i]&#x3D;0;</span><br><span class="line">        for(int j&#x3D;0;j&lt;n;j++)&#123;</span><br><span class="line">            if(i&amp;(1&lt;&lt;j))&#123;</span><br><span class="line">                chang&#x3D;max(chang,a[j].w);</span><br><span class="line">                kuan&#x3D;max(kuan,a[j].h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j&#x3D;0;j&lt;n;j++)&#123;</span><br><span class="line">            if(i&amp;(1&lt;&lt;j))</span><br><span class="line">                st[i]+&#x3D;a[j].q*(chang*kuan-a[j].w*a[j].h);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;,dfs((1&lt;&lt;n)-1,k));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1596 搬货物（CF 587 A. Duff and Weight Lifting）</title>
    <url>/6e572fe1/</url>
    <content><![CDATA[<p>题目来源： CodeForces<a href="http://codeforces.com/contest/587/problem/A" target="_blank" rel="noopener">http://codeforces.com/contest/587/problem/A</a></p>
<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题</p>
<p>现在有n个货物，第i个货物的重量是 2^(wi) 。每次搬的时候要求货物重量的总和是一个2的幂。问最少要搬几次能把所有的货物搬完。</p>
<p>样例解释：</p>
<p>1，1，2作为一组。</p>
<p>3，3作为一组。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>单组测试数据。<br>第一行有一个整数n (1≤n≤10^6)，表示有几个货物。<br>第二行有n个整数 w1,w2,…,wn，(0≤wi≤10^6)。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出最少的运货次数。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">样例输入1</span><br><span class="line">5</span><br><span class="line">1 1 2 3 3</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">样例输出1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>一开始不会写。。我好菜啊咋就想不到呢。。看了别人的题解恍然大悟。。其实是个水题。。</p>
<p>二进制，模拟一下就知道两个1可以变成一个2，两个2可以变成一个3 …… 从小到大以此类推，扫一遍的o(n)做法</p>
<p>注意数组开1e6+5是不够的，wa了两个测试点，比如极限数据1e6个1e6，那么向后推要到log2(1e6)，大概是2^20左右，所以数组开大一点就行了</p>
<p>然后讨论区说这题卡输入输出，自己加个挂就行</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;1000025;</span><br><span class="line">int w[N];</span><br><span class="line">void read(int &amp;x)&#123;</span><br><span class="line">    char ch&#x3D;getchar();x&#x3D;0;</span><br><span class="line">    for(;ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;;ch&#x3D;getchar());</span><br><span class="line">    for(;ch&gt;&#x3D;&#39;0&#39;&amp;&amp;ch&lt;&#x3D;&#39;9&#39;;ch&#x3D;getchar())x&#x3D;x*10+ch-&#39;0&#39;;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,c;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    memset(w,0,sizeof(w));</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        read(c);</span><br><span class="line">        w[c]++;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;N;i++)&#123;</span><br><span class="line">        if(w[i]&gt;1)&#123;</span><br><span class="line">            w[i+1]+&#x3D;w[i]&#x2F;2;</span><br><span class="line">            w[i]%&#x3D;2;</span><br><span class="line">        &#125;</span><br><span class="line">        if(w[i]&#x3D;&#x3D;1)ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1873 初中的算术（java高精度）</title>
    <url>/ff888e9d/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkscgughj20o40cnjtn.jpg" alt=""></p>
<a id="more"></a>

<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">样例输入1</span><br><span class="line">0.4321 20</span><br><span class="line">样例输入2</span><br><span class="line">1.0100 12</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">样例输出1</span><br><span class="line">.00000005148554641076956121994511276767154838481760200726351203835429763013462401</span><br><span class="line">样例输出2</span><br><span class="line">1.126825030131969720661201</span><br></pre></td></tr></table></figure>
<hr>
<p>又水了一题 java虽然没有很快 但是它写的快呀╮(￣▽￣””)╭</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;  </span><br><span class="line">import java.math.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">        BigDecimal a&#x3D;cin.nextBigDecimal();</span><br><span class="line">        int n&#x3D;cin.nextInt();</span><br><span class="line">        a&#x3D;a.pow(n);</span><br><span class="line">        String res&#x3D;a.stripTrailingZeros().toPlainString();</span><br><span class="line">        if(res.startsWith(&quot;0&quot;))&#123;</span><br><span class="line">     	   res&#x3D;res.substring(1);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">        cin.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1649 齐头并进（CF 601 A. The Two Routes）</title>
    <url>/b8d3ced1/</url>
    <content><![CDATA[<p>题目来源： CodeForces<a href="http://codeforces.com/contest/601/problem/A" target="_blank" rel="noopener">http://codeforces.com/contest/601/problem/A</a></p>
<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题</p>
<p>在一个叫奥斯汀的城市，有n个小镇（从1到n编号），这些小镇通过m条双向火车铁轨相连。当然某些小镇之间也有公路相连。为了保证每两个小镇之间的人可以方便的相互访问，市长就在那些没有铁轨直接相连的小镇之间建造了公路。在两个直接通过公路或者铁路相连的小镇之间移动，要花费一个小时的时间。</p>
<p>现在有一辆火车和一辆汽车同时从小镇1出发。他们都要前往小镇n，但是他们中途不能同时停在同一个小镇（但是可以同时停在小镇n）。火车只能走铁路，汽车只能走公路。</p>
<p>现在请来为火车和汽车分别设计一条线路；所有的公路或者铁路可以被多次使用。使得火车和汽车尽可能快的到达小镇n。即要求他们中最后到达小镇n的时间要最短。输出这个最短时间。(最后火车和汽车可以同时到达小镇n，也可以先后到达。)</p>
<p>样例解释：</p>
<p>在样例中，火车可以按照 1⟶3⟶4 行驶，汽车 1⟶2⟶4 按照行驶，经过2小时后他们同时到过小镇4。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>单组测试数据。<br>第一行有两个整数n 和 m (2≤n≤400, 0≤m≤n*(n-1)/2) ，表示小镇的数目和铁轨的数目。<br>接下来m行，每行有两个整数u 和 v，表示u和v之间有一条铁路。(1≤u,v≤n, u≠v)。<br>输入中保证两个小镇之间最多有一条铁路直接相连。  </p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一个整数，表示答案，如果没有合法的路线规划，输出-1。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 2</span><br><span class="line">1 3</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>仔细读题会发现“为了保证每两个小镇之间的人可以方便的相互访问，市长就在那些没有铁轨直接相连的小镇之间建造了公路”，所以其实不会出现题中那个“中途不能同时停在同一个小镇”的问题，要么铁路一步直达公路绕路，要么铁路不能一步直达公路必一步直达，想通这点就好做了</p>
<p>先判断一下公路1-n有无一步直达，然后跑一遍dijkstra即可</p>
<p>去榜里找了个有注释的Dijkstra的模版。。</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kksoij67j20ek0b53zt.jpg" alt=""></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;505;</span><br><span class="line">const int INF&#x3D;0x3f3f3f3f;</span><br><span class="line">int d[N],a[N][N];</span><br><span class="line">bool vis[N];</span><br><span class="line">int n,m;</span><br><span class="line">void dijkstra()&#123; </span><br><span class="line">    memset(d,INF,sizeof(d));</span><br><span class="line">    memset(vis,false,sizeof(vis));</span><br><span class="line">    d[1]&#x3D;0;</span><br><span class="line">    int minn,tmp;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        minn&#x3D;INF;</span><br><span class="line">        for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;</span><br><span class="line">            if(!vis[j]&amp;&amp;d[j]&lt;minn)&#123;</span><br><span class="line">                tmp&#x3D;j;</span><br><span class="line">                minn&#x3D;d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[tmp]&#x3D;true;</span><br><span class="line">        for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;</span><br><span class="line">            if(!vis[j]&amp;&amp;a[tmp][j]+d[tmp]&lt;d[j])</span><br><span class="line">                d[j]&#x3D;a[tmp][j]+d[tmp];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    memset(a,INF,sizeof(a));</span><br><span class="line">    int u,v;</span><br><span class="line">    for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">        a[u][v]&#x3D;1;</span><br><span class="line">        a[v][u]&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(a[1][n]&#x3D;&#x3D;1)&#123;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">            for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;</span><br><span class="line">                a[i][j]&#x3D;(a[i][j]&#x3D;&#x3D;1?INF:1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra();</span><br><span class="line">    printf(&quot;%d\n&quot;,d[n]&#x3D;&#x3D;INF?-1:d[n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1003 阶乘后面0的数量（勒让德定理）</title>
    <url>/37192e8b/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 5 难度：1级算法题 </p>
<p>n的阶乘后面有多少个0？<br><code>6的阶乘 = 1*2*3*4*5*6 = 720</code>，720后面有1个0。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>一个数N(1 &lt;= N &lt;= 10^9)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出0的数量</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>n是1e9，一开始的做法是暴力枚举所有数，先除以10，再算因数2的个数，再算因数5的个数，因为<code>2*5=10</code>，果不其然的又t又wa了。。</p>
<p>然后看了讨论区 知道了一个叫勒让德定理的东西</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkt8imqyj20fv01tt8q.jpg" alt=""></p>
<p>证明如下：（其实直接理解也行。。还是蛮好想的）</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkt8jspaj20mh04eq3v.jpg" alt=""></p>
<p>有了这个东西只要计算因数2和因数5的个数然后取小的那个即可</p>
<p>然后因为因数2肯定比5多，所以最后其实只要算因数5的个数即可</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,num5&#x3D;0,tmp&#x3D;0;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    tmp&#x3D;5;</span><br><span class="line">    while(tmp&lt;&#x3D;n)&#123;</span><br><span class="line">        num5+&#x3D;n&#x2F;tmp;</span><br><span class="line">        tmp*&#x3D;5;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,num5);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1002 数塔取数问题（dp）</title>
    <url>/dbf07d5c/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 5 难度：1级算法题</p>
<p>一个高度为N的由正整数组成的三角形，从上走到下，求经过的数字和的最大值。<br>每次只能走到下一层相邻的数上，例如从第3层的6向下走，只能走到第4层的2或9上。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   5</span><br><span class="line">  8 4</span><br><span class="line"> 3 6 9</span><br><span class="line">7 2 9 5</span><br></pre></td></tr></table></figure>
<p>例子中的最优方案是：5 + 8 + 6 + 9 = 28</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：N，N为数塔的高度。(2 &lt;= N &lt;= 500)<br>第2 - N + 1行：每行包括1层数塔的数字，第2行1个数，第3行2个数……第k+1行k个数。数与数之间用空格分隔（0 &lt;= A[i] &lt;= 10^5) 。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出最大值</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">5</span><br><span class="line">8 4</span><br><span class="line">3 6 9</span><br><span class="line">7 2 9 5</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">28</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>dp水题 从上一层的状态递推下一层</p>
<p>状态转移方程为 <code>dp[i][j]=max(dp[i-1][j-1],dp[i-1][j])+a[i][j]</code></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;505;</span><br><span class="line">int a[N][N],dp[N][N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        for(int j&#x3D;1;j&lt;&#x3D;i;j++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(dp,0,sizeof(dp));</span><br><span class="line">    dp[1][1]&#x3D;a[1][1];</span><br><span class="line">    for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        for(int j&#x3D;1;j&lt;&#x3D;i;j++)&#123;</span><br><span class="line">            dp[i][j]&#x3D;max(dp[i-1][j-1],dp[i-1][j])+a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans&#x3D;dp[n][1];</span><br><span class="line">    for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        ans&#x3D;max(ans,dp[n][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1001 数组中和等于K的数对</title>
    <url>/f1a4e5b1/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 5 难度：1级算法题</p>
<p>给出一个整数K和一个无序数组A，A的元素为N个互不相同的整数，找出数组A中所有和等于K的数对。例如K = 8，数组A：{-1,6,5,3,4,2,9,0,8}，所有和等于8的数对包括(-1,9)，(0,8)，(2,6)，(3,5)。</p>
<a id="more"></a>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：用空格隔开的2个数，K N，N为A数组的长度。(2 &lt;= N &lt;= 50000，-10^9 &lt;= K &lt;= 10^9)<br>第2 - N + 1行：A数组的N个元素。（-10^9 &lt;= A[i] &lt;= 10^9) </p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>第1 - M行：每行2个数，要求较小的数在前面，并且这M个数对按照较小的数升序排列。<br>如果不存在任何一组解则输出：No Solution。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8 9</span><br><span class="line">-1</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">9</span><br><span class="line">0</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1 9</span><br><span class="line">0 8</span><br><span class="line">2 6</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>先排序，然后选定a[i]，用一个指针从后往前寻找是否存在对应的a[j]</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;50005;</span><br><span class="line">int a[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int k,n;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;k,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    sort(a,a+n);</span><br><span class="line">    int cur&#x3D;n-1,flag&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        if(cur&gt;i)&#123;</span><br><span class="line">            while(a[i]+a[cur]&gt;k)cur--;</span><br><span class="line">            if(a[i]+a[cur]&#x3D;&#x3D;k&amp;&amp;cur!&#x3D;i)&#123;</span><br><span class="line">                flag&#x3D;1;</span><br><span class="line">                printf(&quot;%d %d\n&quot;,a[i],a[cur]);</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    if(!flag)printf(&quot;No Solution&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>CF 1029 F. Multicolored Markers（暴力）</title>
    <url>/531fe264/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkrmoivgj20pa09hq4n.jpg" alt=""></p>
<a id="more"></a>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkrmopp5j20oh0gqdiw.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkrmp3nej20op056t9n.jpg" alt=""></p>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给a个红色方格，b个紫色方格，要求拼成矩形且红色块或紫色块中有一个也为矩形，看题目里的图应该比较清楚吧</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>写了个最垃圾的做法。。直接暴力枚举0.0</p>
<p>感觉大家好像有一些妙妙的做法300ms+就过了。。我这个跑了1200ms+啊啊啊啊啊留下了咸鱼的泪水</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">vector&lt;LL&gt;v;</span><br><span class="line">LL getnum(LL a,LL b)&#123;</span><br><span class="line">    v.clear();</span><br><span class="line">    LL ans&#x3D;(a+b+1)*2;</span><br><span class="line">    for(LL i&#x3D;1;i*i&lt;&#x3D;a;i++)</span><br><span class="line">        if(a%i&#x3D;&#x3D;0)v.push_back(i);</span><br><span class="line">    int ji&#x3D;v.size();</span><br><span class="line">    for(LL i&#x3D;1;i*i&lt;&#x3D;(a+b);i++)&#123;</span><br><span class="line">        if((a+b)%i&#x3D;&#x3D;0)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;ji;j++)&#123;</span><br><span class="line">                if(v[j]&lt;&#x3D;i)&#123;</span><br><span class="line">                    if(a&#x2F;v[j]&lt;&#x3D;(a+b)&#x2F;i)</span><br><span class="line">                        ans&#x3D;min(ans,2*(i+(a+b)&#x2F;i));</span><br><span class="line">                &#125;</span><br><span class="line">                else break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    LL a,b;</span><br><span class="line">    scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b);</span><br><span class="line">    LL res&#x3D;min(getnum(a,b),getnum(b,a));</span><br><span class="line">    printf(&quot;%lld\n&quot;,res);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>51nod 1004 n^n的末位数字（快速幂）</title>
    <url>/a20ca391/</url>
    <content><![CDATA[<p>题目来源： Author Ignatius.L (Hdu 1061)<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 5 难度：1级算法题<br>给出一个整数N，输出N^N（N的N次方）的十进制表示的末位数字。</p>
<a id="more"></a>

<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>一个数N（1 &lt;= N &lt;= 10^9）</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出N^N的末位数字</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<hr>
<p>水一发快速幂</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">LL qpow(LL a,LL b,int p)&#123;</span><br><span class="line">    LL ans&#x3D;1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            ans&#x3D;(ans*a)%p;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        b&#x2F;&#x3D;2;</span><br><span class="line">        a&#x3D;a*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">    printf(&quot;%lld\n&quot;,qpow(n,n,10));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1080 两个数的平方和</title>
    <url>/22830a9e/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 5 难度：1级算法题 </p>
<p>给出一个整数N，将N表示为2个整数i与j的平方之和（i &lt;= j)，如果有多种表示，按照i的递增序输出。<br>例如：N = 130，130 = 3^2 + 11^2 = 7^2 + 9^2（注：3^2 + 11^2同11^2 + 3^2算1种）</p>
<a id="more"></a>

<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>一个数N(1 &lt;= N &lt;= 10^9)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>共K行：每行2个数，i j，表示N = i^2 + j^2（0 &lt;= i &lt;= j)。<br>如果无法分解为2个数的平方和，则输出No Solution</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">130</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 11</span><br><span class="line">7 9</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>水题，最大也就根号n</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    int m&#x3D;sqrt(n),flag&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">        int tmp&#x3D;sqrt(n-i*i);</span><br><span class="line">        if(tmp&lt;i)break;</span><br><span class="line">        if(tmp*tmp+i*i&#x3D;&#x3D;n)&#123;</span><br><span class="line">            printf(&quot;%d %d\n&quot;,i,tmp);</span><br><span class="line">            flag&#x3D;1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!flag)printf(&quot;No Solution\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>51nod 1015 水仙花数</title>
    <url>/61030f3f/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 5 难度：1级算法题 </p>
<p>水仙花数是指一个 n 位数 ( n &gt;= 3 )，它的每个位上的数字的 n 次幂之和等于它本身。（例如：1^3 + 5^3 + 3^3 = 153）  </p>
<a id="more"></a>

<p>给出一个整数M，求 &gt;= M的最小的水仙花数。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>一个整数M（10 &lt;= M &lt;= 1000）</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出&gt;= M的最小的水仙花数</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">99</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">153</span><br></pre></td></tr></table></figure>
<hr>
<p>水。。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int m;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">    m&#x3D;max(m,100);</span><br><span class="line">    for(int i&#x3D;m;;i++)&#123;</span><br><span class="line">        int sum&#x3D;0,x&#x3D;i,a,n;</span><br><span class="line">        if(x&#x2F;1000)n&#x3D;4;</span><br><span class="line">        else if(x&#x2F;100)n&#x3D;3;</span><br><span class="line">        while(x)&#123;</span><br><span class="line">            a&#x3D;x%10;</span><br><span class="line">            sum+&#x3D;pow(a,n);</span><br><span class="line">            x&#x2F;&#x3D;10;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum&#x3D;&#x3D;i)&#123;</span><br><span class="line">            printf(&quot;%d\n&quot;,i);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1082 与7无关的数（打表）</title>
    <url>/cdd10d6d/</url>
    <content><![CDATA[<p>题目来源： 有道难题<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 5 难度：1级算法题</p>
<p>一个正整数，如果它能被7整除，或者它的十进制表示法中某个位数上的数字为7，则称其为与7相关的数。求所有小于等于N的与7无关的正整数的平方和。  </p>
<a id="more"></a>

<p>例如：N = 8，&lt;= 8与7无关的数包括：1 2 3 4 5 6 8，平方和为：155。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 1000)<br>第2 - T + 1行：每行1个数N。（1 &lt;= N &lt;= 10^6)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>共T行，每行一个数，对应T个测试的计算结果。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">30</span><br><span class="line">55</span><br><span class="line">91</span><br><span class="line">91</span><br><span class="line">155</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>暴力打个表然后输出</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;1e6+5;</span><br><span class="line">LL ans[N];</span><br><span class="line">bool f(int x)&#123;</span><br><span class="line">    if(x%7&#x3D;&#x3D;0)return false;</span><br><span class="line">    while(x)&#123;</span><br><span class="line">        if(x%10&#x3D;&#x3D;7)return false;</span><br><span class="line">        x&#x2F;&#x3D;10;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,n;</span><br><span class="line">    LL res&#x3D;0;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;1e6;i++)&#123;</span><br><span class="line">        if(f(i))res+&#x3D;(LL)i*i;</span><br><span class="line">        ans[i]&#x3D;res;</span><br><span class="line">    &#125;</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        printf(&quot;%lld\n&quot;,ans[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>51nod 1083 矩阵取数问题（dp)</title>
    <url>/2d58815c/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 5 难度：1级算法题 </p>
<p>一个<code>N*N</code>矩阵中有不同的正整数，经过这个格子，就能获得相应价值的奖励，从左上走到右下，只能向下向右走，求能够获得的最大价值。  </p>
<a id="more"></a>

<p>例如：<code>3 * 3</code>的方格。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 3 3</span><br><span class="line">2 1 3</span><br><span class="line">2 2 1</span><br></pre></td></tr></table></figure>

<p>能够获得的最大价值为：11。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：N，N为矩阵的大小。(2 &lt;= N &lt;= 500)<br>第2 - N + 1行：每行N个数，中间用空格隔开，对应格子中奖励的价值。（1 &lt;= N[i] &lt;= 10000)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出能够获得的最大价值。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 3 3</span><br><span class="line">2 1 3</span><br><span class="line">2 2 1</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>水。。dp</p>
<p>dp[i][j]表示在(i,j)这个位置能够获得的最大价值</p>
<p>来自两个方向，状态转移方程为<code>dp[i][j]=max(dp[i][j-1]+a[i][j],dp[i-1][j]+a[i][j])</code></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;505;</span><br><span class="line">int dp[N][N],a[N][N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    memset(dp,0,sizeof(dp));</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">        for(int j&#x3D;1;j&lt;&#x3D;n;j++)</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;a[i][j]);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;</span><br><span class="line">            dp[i][j]&#x3D;max(dp[i][j-1]+a[i][j],dp[i-1][j]+a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,dp[n][n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1087 1 10 100 1000</title>
    <url>/7ee1bb3b/</url>
    <content><![CDATA[<p>题目来源： Ural 1209<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 5 难度：1级算法题 </p>
<p>1,10,100,1000…组成序列1101001000…，求这个序列的第N位是0还是1。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 10000)<br>第2 - T + 1行：每行1个数N。（1 &lt;= N &lt;= 10^9)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>共T行，如果该位是0，输出0，如果该位是1，输出1。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>水题暴力一发。。200ms+。。</p>
<p>然后1，3，6，10……高斯求和再水一发15ms</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;v;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    int x&#x3D;1,ji&#x3D;1;</span><br><span class="line">    v.push_back(1);</span><br><span class="line">    while(x&lt;&#x3D;1e9)&#123;</span><br><span class="line">        x+&#x3D;ji;</span><br><span class="line">        v.push_back(x);</span><br><span class="line">        ji++;</span><br><span class="line">    &#125;</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        if(find(v.begin(),v.end(),n)!&#x3D;v.end())puts(&quot;1&quot;);</span><br><span class="line">        else puts(&quot;0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        if(n&#x3D;&#x3D;1)&#123;</span><br><span class="line">            puts(&quot;1&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        int tmp&#x3D;sqrt(2*(n-1));</span><br><span class="line">        if(tmp*(tmp+1)&#x3D;&#x3D;2*(n-1))puts(&quot;1&quot;);</span><br><span class="line">        else puts(&quot;0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1267 4个数和为0（暴力+二分）</title>
    <url>/34ddef5a/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 20 难度：3级算法题</p>
<p>给出N个整数，你来判断一下是否能够选出4个数，他们的和为0，可以则输出”Yes”，否则输出”No”。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行，1个数N，N为数组的长度(4 &lt;= N &lt;= 1000)<br>第2 - N + 1行：A[i]（-10^9 &lt;= A[i] &lt;= 10^9)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>如果可以选出4个数，使得他们的和为0，则输出”Yes”，否则输出”No”。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">-1</span><br><span class="line">1</span><br><span class="line">-5</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>n^4暴力肯定华丽丽的t掉 ╮(￣▽￣””)╭</p>
<p>学了个妙妙的o(n^2)的方法，先排序，然后枚举前两个数，后两个数在[j+1,n-1]的范围内找，用两个指针，二分的原理，如果当前sum&gt;0说明需要一个小一点的数，那么就取a[–r]，如果sum&lt;0说明要取一个大一点的数，即a[++l]</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;1005;</span><br><span class="line">int a[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    sort(a,a+n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        for(int j&#x3D;i+1;j&lt;n;j++)&#123;</span><br><span class="line">            int l,r,sum;</span><br><span class="line">            l&#x3D;j+1;r&#x3D;n-1;</span><br><span class="line">            while(l&lt;r)&#123;</span><br><span class="line">                sum&#x3D;a[i]+a[j]+a[l]+a[r];</span><br><span class="line">                if(sum&gt;0)r--;</span><br><span class="line">                else if(sum&lt;0)l++;</span><br><span class="line">                else&#123;</span><br><span class="line">                    puts(&quot;Yes&quot;);</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;No&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1090 3个数和为0（暴力，二分）</title>
    <url>/fb0210e3/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 5 难度：1级算法题</p>
<p>给出一个长度为N的无序数组，数组中的元素为整数，有正有负包括0，并互不相等。从中找出所有和 = 0的3个数的组合。如果没有这样的组合，输出No Solution。如果有多个，按照3个数中最小的数从小到大排序，如果最小的数相等则按照第二小的数排序。</p>
<a id="more"></a>

<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行，1个数N，N为数组的长度(0 &lt;= N &lt;= 1000)<br>第2 - N + 1行：A[i]（-10^9 &lt;= A[i] &lt;= 10^9)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>如果没有符合条件的组合，输出No Solution。<br>如果有多个，按照3个数中最小的数从小到大排序，如果最小的数相等则继续按照第二小的数排序。每行3个数，中间用空格分隔，并且这3个数按照从小到大的顺序排列。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">-3</span><br><span class="line">-2</span><br><span class="line">-1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-3 0 3</span><br><span class="line">-3 1 2</span><br><span class="line">-2 -1 3</span><br><span class="line">-2 0 2</span><br><span class="line">-1 0 1</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>o(n^3)暴力竟然水过去了？？？好弱。。</p>
<p><a href="https://leflacon.github.io/34ddef5a/" target="_blank" rel="noopener">1267 4个数和为0</a><br>这个题暴力就水不过去了0.0，所以还是要想优化的，方法类似四个数的和这个题</p>
<p>先排序，然后枚举第一个数，剩下两个数在[i+1,n-1]里选，用两个指针，二分的原理，如果当前sum&gt;0说明需要一个小一点的数，那么就取a[–r]，如果sum&lt;0说明要取一个大一点的数，即a[++l]</p>
<p>就有一组数据一直过不去，然后下载了数据发现。。输出No Solution我直接puts(“No”)了。。行吧自闭了</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;1005;</span><br><span class="line">int a[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    sort(a,a+n);</span><br><span class="line">    int flag&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n-2;i++)&#123;</span><br><span class="line">        for(int j&#x3D;i+1;j&lt;n-1;j++)&#123;</span><br><span class="line">            for(int k&#x3D;j+1;k&lt;n;k++)&#123;</span><br><span class="line">                if(a[i]+a[j]+a[k]&#x3D;&#x3D;0)&#123;</span><br><span class="line">                    flag&#x3D;1;</span><br><span class="line">                    printf(&quot;%d %d %d\n&quot;,a[i],a[j],a[k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!flag)printf(&quot;No Solution\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;1005;</span><br><span class="line">int a[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    sort(a,a+n);</span><br><span class="line">    int flag&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n-1;i++)&#123;</span><br><span class="line">        int l,r,sum;</span><br><span class="line">        l&#x3D;i+1;r&#x3D;n-1;</span><br><span class="line">        while(l&lt;r)&#123;</span><br><span class="line">            sum&#x3D;a[i]+a[l]+a[r];</span><br><span class="line">            if(sum&gt;0)r--;</span><br><span class="line">            else if(sum&lt;0)l++;</span><br><span class="line">            else&#123;</span><br><span class="line">                flag&#x3D;1;</span><br><span class="line">                printf(&quot;%d %d %d\n&quot;,a[i],a[l],a[r]);</span><br><span class="line">                l++;r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!flag)puts(&quot;No Solution&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1091 线段的重叠（贪心）</title>
    <url>/ddee45d/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 5 难度：1级算法题</p>
<p>X轴上有N条线段，每条线段包括1个起点和终点。线段的重叠是这样来算的，[10 20]和[12 25]的重叠部分为[12 20]。<br>给出N条线段的起点和终点，从中选出2条线段，这两条线段的重叠部分是最长的。输出这个最长的距离。如果没有重叠，输出0。</p>
<a id="more"></a>

<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：线段的数量N(2 &lt;= N &lt;= 50000)。<br>第2 - N + 1行：每行2个数，线段的起点和终点。(0 &lt;= s , e &lt;= 10^9)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出最长重复区间的长度。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 5</span><br><span class="line">2 4</span><br><span class="line">2 8</span><br><span class="line">3 7</span><br><span class="line">7 9</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>贪心</p>
<p>先排序，按左端点从小到大排，如果相同的按右端点大的优先</p>
<p>然后记录一个maxr，拿样例模拟一下，如果当前的r大于maxr，那么应该是区间交错的情况，比如[1,5][2,8]，那么重叠部分就是maxr-l，更新maxr，反之如果r小于maxr，比如[2,8][3,7]，那么重叠部分就是r-l</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;50005;</span><br><span class="line">struct q&#123;</span><br><span class="line">    int l,r;</span><br><span class="line">&#125;q[N];</span><br><span class="line">bool cmp(struct q q1,struct q q2)&#123;</span><br><span class="line">    if(q1.l!&#x3D;q2.l)return q1.l&lt;q2.l;</span><br><span class="line">    else return q1.r&gt;q2.r;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d%d&quot;,&amp;q[i].l,&amp;q[i].r);</span><br><span class="line">    sort(q,q+n,cmp);</span><br><span class="line">    int ans&#x3D;0,maxr&#x3D;q[0].r;</span><br><span class="line">    for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">        if(maxr&gt;q[i].r)ans&#x3D;max(ans,q[i].r-q[i].l);</span><br><span class="line">        else&#123;</span><br><span class="line">            ans&#x3D;max(ans,maxr-q[i].l);</span><br><span class="line">            maxr&#x3D;q[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1182 完美字符串</title>
    <url>/f8170462/</url>
    <content><![CDATA[<p>题目来源： Facebook Hacker Cup选拔<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 5 难度：1级算法题</p>
<p>约翰认为字符串的完美度等于它里面所有字母的完美度之和。每个字母的完美度可以由你来分配，不同字母的完美度不同，分别对应一个1-26之间的整数。</p>
<p>约翰不在乎字母大小写（也就是说字母A和a的完美度相同）。给定一个字符串，输出它的最大可能的完美度。例如：dad，你可以将26分配给d，25分配给a，这样整个字符串完美度为77。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入一个字符串S(S的长度 &lt;= 10000)，S中没有除字母外的其他字符。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>由你将1-26分配给不同的字母，使得字符串S的完美度最大，输出这个完美度。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dad</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">77</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>水。。贪心，出现越多的字母分配越大的数字</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char s[10005];</span><br><span class="line">int a[26];</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%s&quot;,s);</span><br><span class="line">    int len&#x3D;strlen(s),ans&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;26;i++)a[i]&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;len;i++)&#123;</span><br><span class="line">        if(s[i]&gt;&#x3D;&#39;A&#39;&amp;&amp;s[i]&lt;&#x3D;&#39;Z&#39;)a[s[i]-&#39;A&#39;]++;</span><br><span class="line">        else a[s[i]-&#39;a&#39;]++;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a,a+26);</span><br><span class="line">    for(int i&#x3D;0;i&lt;26;i++)ans+&#x3D;a[i]*(i+1);</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1283 最小周长</title>
    <url>/d6ce1fc2/</url>
    <content><![CDATA[<p>题目来源： Codility<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 5 难度：1级算法题 </p>
<p>一个矩形的面积为S，已知该矩形的边长都是整数，求所有满足条件的矩形中，周长的最小值。例如：S = 24，那么有{1 24} {2 12} {3 8} {4 6}这4种矩形，其中{4 6}的周长最小，为20。</p>
<a id="more"></a>

<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入1个数S(1 &lt;= S &lt;= 10^9)。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出最小周长。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">24</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>水。。从根号n开始找就行</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    int a&#x3D;sqrt(n);</span><br><span class="line">    while(n%a!&#x3D;0)a--;</span><br><span class="line">    printf(&quot;%d\n&quot;,2*a+2*(n&#x2F;a));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1284 2 3 5 7的倍数（容斥）</title>
    <url>/9f1d8b77/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 5 难度：1级算法题 </p>
<p>给出一个数N，求1至N中，有多少个数不是2 3 5 7的倍数。 例如N = 10，只有1不是2 3 5 7的倍数。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入1个数N(1 &lt;= N &lt;= 10^18)。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出不是2 3 5 7的倍数的数共有多少。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>容斥水题</p>
<p>是2，3，5，7的倍数的数的个数为：</p>
<p><code>n/2+n/3+n/5+n/7-n/6-n/10-n/14-n/15-n/21-n/35+n/30+n/42+n/70+n/105-n/210</code></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">int main()&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">    LL ans&#x3D;n&#x2F;2+n&#x2F;3+n&#x2F;5+n&#x2F;7-n&#x2F;6-n&#x2F;10-n&#x2F;14-n&#x2F;15-n&#x2F;21-n&#x2F;35+n&#x2F;30+n&#x2F;42+n&#x2F;70+n&#x2F;105-n&#x2F;210;</span><br><span class="line">    printf(&quot;%lld\n&quot;,n-ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1289 大鱼吃小鱼（stack）</title>
    <url>/d971ae59/</url>
    <content><![CDATA[<p>题目来源： Codility<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 5 难度：1级算法题 </p>
<p>有N条鱼每条鱼的位置及大小均不同，他们沿着X轴游动，有的向左，有的向右。游动的速度是一样的，两条鱼相遇大鱼会吃掉小鱼。从左到右给出每条鱼的大小和游动的方向（0表示向左，1表示向右）。问足够长的时间之后，能剩下多少条鱼？</p>
<a id="more"></a>

<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：1个数N，表示鱼的数量(1 &lt;= N &lt;= 100000)。<br>第2 - N + 1行：每行两个数A[i], B[i]，中间用空格分隔，分别表示鱼的大小及游动的方向(1 &lt;= A[i] &lt;= 10^9，B[i] = 0 或 1，0表示向左，1表示向右）。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出1个数，表示最终剩下的鱼的数量。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">4 0</span><br><span class="line">3 1</span><br><span class="line">2 0</span><br><span class="line">1 0</span><br><span class="line">5 0</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>用栈模拟</p>
<p>向右游的鱼入栈，向左的鱼判断吃或被吃</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">stack&lt;int&gt;s;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,c,d;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    int ans&#x3D;n;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;c,&amp;d);</span><br><span class="line">        if(d&#x3D;&#x3D;1)s.push(c);</span><br><span class="line">        else&#123;</span><br><span class="line">            while(!s.empty())&#123;</span><br><span class="line">                if(s.top()&lt;c)&#123;</span><br><span class="line">                    s.pop();</span><br><span class="line">                    ans--;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    ans--;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1305 Pairwise Sum and Divide（思维）</title>
    <url>/b6db0c64/</url>
    <content><![CDATA[<p>题目来源： HackerRank<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 5 难度：1级算法题</p>
<p>有这样一段程序，fun会对整数数组A进行求值，其中Floor表示向下取整：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun(A)</span><br><span class="line">    sum &#x3D; 0</span><br><span class="line">    for i &#x3D; 1 to A.length</span><br><span class="line">        for j &#x3D; i+1 to A.length</span><br><span class="line">            sum &#x3D; sum + Floor((A[i]+A[j])&#x2F;(A[i]*A[j])) </span><br><span class="line">    return sum</span><br></pre></td></tr></table></figure>
<p>给出数组A，由你来计算fun(A)的结果。例如：A = {1, 4, 1}，fun(A) = [5/4] + [2/1] + [5/4] = 1 + 2 + 1 = 4。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：1个数N，表示数组A的长度(1 &lt;= N &lt;= 100000)。<br>第2 - N + 1行：每行1个数A[i]（1 &lt;= A[i] &lt;= 10^9)。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出fun(A)的计算结果。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 4 1</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>暴力是不可能的</p>
<p>首先考虑把<code>Floor((A[i]+A[j])/(A[i]*A[j]))</code>转化成<code>Floor(1/A[i]+1/A[j])</code>，然后就会发现如果a[i]=1那么1/a[i]就是答案加一，总共会加n-1次，如果a[i]=2，只有a[j]=2同时成立的时候，才会有答案加一，其余情况向下取整都是0</p>
<p>所以统计a[i]=1的个数，每次加n-1，统计a[i]=2的个数num，最后加上C(num,2)</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,num&#x3D;0;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    LL ans&#x3D;0,c;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%lld&quot;,&amp;c);</span><br><span class="line">        if(c&#x3D;&#x3D;1)ans+&#x3D;n-1;</span><br><span class="line">        else if(c&#x3D;&#x3D;2)num++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;,ans+num*(num-1)&#x2F;2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1344 走格子</title>
    <url>/c2424f60/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 5 难度：1级算法题 </p>
<p>有编号1-n的n个格子，机器人从1号格子顺序向后走，一直走到n号格子，并需要从n号格子走出去。机器人有一个初始能量，每个格子对应一个整数A[i]，表示这个格子的能量值。如果A[i] &gt; 0，机器人走到这个格子能够获取A[i]个能量，如果A[i] &lt; 0，走到这个格子需要消耗相应的能量，如果机器人的能量 &lt; 0，就无法继续前进了。问机器人最少需要有多少初始能量，才能完成整个旅程。</p>
<p>例如：n = 5。{1，-2，-1，3，4} 最少需要2个初始能量，才能从1号走到5号格子。途中的能量变化如下3 1 0 3 7。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：1个数n，表示格子的数量。(1 &lt;= n &lt;= 50000)<br>第2 - n + 1行：每行1个数A[i]，表示格子里的能量值(-1000000000 &lt;= A[i] &lt;= 1000000000)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出1个数，对应从1走到n最少需要多少初始能量。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">-2</span><br><span class="line">-1</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>水题，贪心思路，找到那个最小的前缀和即可</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    LL sum&#x3D;0,c,ans&#x3D;INF;</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        scanf(&quot;%lld&quot;,&amp;c);</span><br><span class="line">        sum+&#x3D;c;</span><br><span class="line">        ans&#x3D;min(sum,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    if(ans&lt;0)printf(&quot;%lld\n&quot;,-ans);</span><br><span class="line">    else printf(&quot;%lld\n&quot;,0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1347 旋转字符串</title>
    <url>/ada46a5d/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 5 难度：1级算法题</p>
<p>S[0…n-1]是一个长度为n的字符串，定义旋转函数Left(S)=S[1…n-1]+S[0].比如S=”abcd”,Left(S)=”bcda”.一个串是对串当且仅当这个串长度为偶数，前半段和后半段一样。比如”abcabc”是对串,”aabbcc”则不是。</p>
<p>现在问题是给定一个字符串，判断他是否可以由一个对串旋转任意次得到。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：给出一个字符串（字符串非空串，只包含小写字母，长度不超过1000000）</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每个测试用例，输出结果占一行，如果能，输出YES，否则输出NO。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aa</span><br><span class="line">ab</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>一开始以为要枚举旋转前前半段和后半段的分界线，然后判断是否有相同的情况，但是这样1e6太长了啊。。拿abcabc旋转一下，bcabca，cabcab，可以发现一个对串不管怎么旋转都还是个对串，发现这点问题就解决了，直接判断对串即可</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;1e6+5;</span><br><span class="line">char s[1000005];</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(scanf(&quot;%s&quot;,s)!&#x3D;EOF)&#123;</span><br><span class="line">        int len&#x3D;strlen(s);</span><br><span class="line">        if(len&amp;1)&#123;</span><br><span class="line">            puts(&quot;NO&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            int flag&#x3D;1;</span><br><span class="line">            for(int i&#x3D;0;i&lt;len&#x2F;2;i++)&#123;</span><br><span class="line">                if(s[i]!&#x3D;s[len&#x2F;2+i])&#123;</span><br><span class="line">                    puts(&quot;NO&quot;);</span><br><span class="line">                    flag&#x3D;0;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag)puts(&quot;YES&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1381 硬币游戏</title>
    <url>/ff9df0f5/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 5 难度：1级算法题</p>
<p>有一个简单但是很有趣的游戏。在这个游戏中有一个硬币还有一张桌子，这张桌子上有很多平行线（如下图所示）。两条相邻平行线之间的距离是1，硬币的半径是R，然后我们来抛硬币到桌子上，抛下之后硬币有时候会和一些直线相交（相切的情况也算是相交），有时候不会。</p>
<p>请你来计算一下抛一次硬币之后，该硬币和直线相交数目的期望。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行给出一个整数T，表示有T组数据(1&lt;=T&lt;=10000)。<br>第2行到T+1，每行给出一个整数R。(0&lt; R &lt;= 10,000,000,000)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每一个数据，在一行中输出答案的整数部分即可。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>反正只要求期望的整数部分，所以圆的直径就是期望值</p>
<p>官方证明严谨些</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g2s4gton4wj30of0e2gmn.jpg" alt=""></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    LL r;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123; </span><br><span class="line">        scanf(&quot;%lld&quot;,&amp;r);</span><br><span class="line">        printf(&quot;%lld\n&quot;,r&lt;&lt;1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>51nod 2020 排序相减（6174猜想）</title>
    <url>/6f66f8f8/</url>
    <content><![CDATA[<p>题目来源： syu练习题</p>
<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 5 难度：1级算法题</p>
<p>“排序相减”操作是指对于任意一个四位数n，将四个数字分别进行顺序排序和逆序排序，得到两个数取相减后结果的绝对值n1，然后继续将n1中的四个数字进行顺序排序和逆序排序，得到两个数取相减后结果的绝对值n2,以此类推，最后总会得到一个数字黑洞，无法跳出。</p>
<p>例如:样例2中4176 = 6532 - 2356</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行输入一个整数T，表示数据组数（1&lt;T&lt;10000）；<br>第二行输入一个正整数n(1000&lt;=n&lt;=9999)和一个正整数  k（1&lt;=k&lt;=100）,表示操作次数；  </p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每组数据，输出对于开始的数据n在第k次“排序相减”后结果绝对值。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1234 2</span><br><span class="line">3562 1</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8352</span><br><span class="line">4176</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>水之后随便试了几个样例，发现循环多次之后黑洞竟然都是6174，然后就去查了一下，百度百科还真有这玩意儿</p>
<p>6174猜想 ，1955年，卡普耶卡(D.R.Kaprekar)研究了对四位数的一种变换：任给出四位数k0,用它的四个数字由大到小重新排列成一个四位数m,再减去它的反序数rev(m),得出数k1=m-rev(m),然后，继续对k1重复上述变换，得数k2.如此进行下去，卡普耶卡发现，无论k0是多大的四位数， 只要四个数字不全相同，最多进行7次上述变换，就会出现四位数6174.</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n,m,k;</span><br><span class="line">void f()&#123;</span><br><span class="line">    int a[4];</span><br><span class="line">    a[3]&#x3D;n%10;</span><br><span class="line">    a[2]&#x3D;(n&#x2F;10)%10;</span><br><span class="line">    a[1]&#x3D;(n&#x2F;100)%10;</span><br><span class="line">    a[0]&#x3D;n&#x2F;1000;</span><br><span class="line">    sort(a,a+4);</span><br><span class="line">    n&#x3D;a[0]*1000+a[1]*100+a[2]*10+a[3];</span><br><span class="line">    m&#x3D;a[3]*1000+a[2]*100+a[1]*10+a[0];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)&#123; </span><br><span class="line">        cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        while(k--)&#123;</span><br><span class="line">            f();</span><br><span class="line">            if(n&lt;m)swap(n,m);</span><br><span class="line">            n&#x3D;n-m;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1675 序列变换（莫比乌斯函数）</title>
    <url>/cd27113b/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkq0e6ujj20i50f0tab.jpg" alt=""></p>
<a id="more"></a>

<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 1 1</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>

<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>虽然学了莫比乌斯但是没写过题就不咋会用(⌒-⌒; )</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkq0ere0j20ln0hqdhw.jpg" alt=""></p>
<p><a href="http://vfleaking.blog.uoj.ac/slide/87#/" target="_blank" rel="noopener">炫酷反演魔术</a> 这篇还没看懂0.0 mark一下</p>
<p>然后丢个官方题解吧</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkq0ei1ij20jl0ebjtn.jpg" alt=""></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;1e5+5;</span><br><span class="line">int a[N],b[N],prime[N],num[N],mu[N],n;</span><br><span class="line">bool vis[N];</span><br><span class="line">void mobius()&#123;</span><br><span class="line">    memset(vis,false,sizeof(vis));</span><br><span class="line">    mu[1]&#x3D;1;</span><br><span class="line">    int ji&#x3D;0;</span><br><span class="line">    for(int i&#x3D;2;i&lt;N;i++)&#123;</span><br><span class="line">        if(!vis[i])&#123;</span><br><span class="line">            prime[ji++]&#x3D;i;</span><br><span class="line">            mu[i]&#x3D;-1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j&#x3D;0;j&lt;ji;j++)&#123;</span><br><span class="line">            if(i*prime[j]&gt;N)break;</span><br><span class="line">            vis[i*prime[j]]&#x3D;true;</span><br><span class="line">            if(i%prime[j]&#x3D;&#x3D;0)&#123;</span><br><span class="line">                mu[i*prime[j]]&#x3D;0;break;</span><br><span class="line">            &#125;</span><br><span class="line">            else mu[i*prime[j]]&#x3D;-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">LL solve(int x)&#123;</span><br><span class="line">    LL res&#x3D;0;</span><br><span class="line">    for(int i&#x3D;x;i&lt;&#x3D;n;i+&#x3D;x)num[b[a[i]]]++;</span><br><span class="line">    for(int i&#x3D;x;i&lt;&#x3D;n;i+&#x3D;x)res+&#x3D;num[a[b[i]]];</span><br><span class="line">    for(int i&#x3D;x;i&lt;&#x3D;n;i+&#x3D;x)num[b[a[i]]]--;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    mobius();</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)scanf(&quot;%d&quot;,&amp;b[i]);</span><br><span class="line">    LL ans&#x3D;0;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)ans+&#x3D;mu[i]*solve(i);</span><br><span class="line">    printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 6304 Chiaki Sequence Revisited（二分）</title>
    <url>/3a23cc5c/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkonednhj20rh06dt9q.jpg" alt=""></p>
<a id="more"></a>

<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>数列定义如上，求前n项和</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>打个表 然后oeis一下 然后。。就没有然后了0.0<br><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkonf3daj20ll0380tm.jpg" alt=""></p>
<p>先记录一下数字i的出现次数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数字 1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  ……</span><br><span class="line">次数 2  2  1  3  1  2  1  4  1  2   1   3   1   2   1   ……</span><br><span class="line">最后出现该数字的</span><br><span class="line">项数 2  4  5  8  9  11 12 16 17 19  20  23  21  23  24 </span><br><span class="line"></span><br><span class="line">1次: (1),3,5,7,9,... 公差为２（1特例先不管）</span><br><span class="line">2次: 2,6,10,14,... 公差为４</span><br><span class="line">3次: 4,12,20,28,... 公差为８</span><br><span class="line">4次: 8,24,40,56... 公差为16</span><br></pre></td></tr></table></figure>
<p>可以发现i的出现次数为<img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkondrm0j204d00ta9v.jpg" alt="">（1除外）</p>
<p>可以推出最后出现该数字的项数，即下文f(i)，比如最后出现数字5的项数为8，即f(5)=5+2+1=8，联系上述规律代码很好理解</p>
<p>sum(i)表示数字i出现完为止的和是多少，就是高斯求和一下乘个倍数，注意大数取模所以除以二要改成乘以inv2</p>
<p>先二分小于等于n的fun(x)的最大的x是多少，那么多出的部分全都是<code>x+1</code>，所以多出部分答案为<code>(n-fun(x)-1)*(x+1)+1</code>（1多出现了一次）</p>
<p>然后再加上前面的sum(x)即可</p>
<p>精度问题wa了好多发</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const LL inv2&#x3D;5e8+4;</span><br><span class="line">const int N&#x3D;1e5+5;</span><br><span class="line">const int p&#x3D;1e9+7;</span><br><span class="line">void read(LL &amp;x)&#123;</span><br><span class="line">    char ch&#x3D;getchar();x&#x3D;0;</span><br><span class="line">    for(;ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;;ch&#x3D;getchar());</span><br><span class="line">    for(;ch&gt;&#x3D;&#39;0&#39;&amp;&amp;ch&lt;&#x3D;&#39;9&#39;;ch&#x3D;getchar())x&#x3D;x*10+ch-&#39;0&#39;;</span><br><span class="line">&#125;</span><br><span class="line">LL f(LL x)&#123;</span><br><span class="line">    LL res&#x3D;0;</span><br><span class="line">    while(x)&#123;</span><br><span class="line">        res+&#x3D;x;</span><br><span class="line">        x&gt;&gt;&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">LL sum(LL x)&#123;</span><br><span class="line">    LL res&#x3D;0,tmp&#x3D;1;</span><br><span class="line">    while(x)&#123;</span><br><span class="line">        res&#x3D;(res+x%p*((x+1)%p)%p*inv2%p*tmp%p)%p;</span><br><span class="line">        x&gt;&gt;&#x3D;1;</span><br><span class="line">        tmp&#x3D;tmp*2%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    LL n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        read(n);</span><br><span class="line">        LL l&#x3D;1,r&#x3D;n,m;</span><br><span class="line">        while(l&lt;&#x3D;r)&#123;</span><br><span class="line">            m&#x3D;(l+r)&gt;&gt;1;</span><br><span class="line">            if(f(m)+1&lt;&#x3D;n)l&#x3D;m+1;</span><br><span class="line">            else r&#x3D;m-1;</span><br><span class="line">        &#125;</span><br><span class="line">        LL ans&#x3D;((n-f(r)-1)%p)*((r+1)%p)%p;</span><br><span class="line">        ans&#x3D;(ans+sum(r)+1)%p;</span><br><span class="line">        printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 6301 Distinct Values（贪心，set）</title>
    <url>/5a4c73da/</url>
    <content><![CDATA[<p>Chiaki has an array of n positive integers. You are told some facts about the array: for every two elements ai and aj in the subarray al..r <code>(l≤i&lt;j≤r)</code>, ai≠aj holds.<br>Chiaki would like to find a lexicographically minimal array which meets the facts.</p>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>构造一个长为n的整数序列，给m个要求，每个要求给出一个[l,r]区间，区间内任意两个数不相等，求满足这m个限制且字典序最小的序列</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>如果没有限制，那么构造的序列显然就是n个1，假如[l,r]有限制，那么[l,r]内就应该被替换成2，3，4，5，……就是贪心的思路，但是。。我不知道咋写。。还是看标程去了，标程真的好妙啊(つД`)ノ</p>
<p>首先如果大区间包含小区间的话，小区间相当于没有用，所以q[i]数组存的是以i为左端点的最大右端点位子</p>
<p>然后从q[1]开始处理，q[i]即当前需要处理到的位子，l,r两个指针，r表示当前已经处理到的位子，l右移更新set中待填入的元素，如果<code>r&lt;q[i]</code>那么就从集合中取出数字构造答案</p>
<p>l右移更新那段真的妙，我只能靠纸上模拟。。mark以后再想想吧</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;100005;</span><br><span class="line">int q[N],ans[N];</span><br><span class="line">set&lt;int&gt;s;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,n,m,l,r;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        s.clear();</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;n;i++)q[i]&#x3D;i;</span><br><span class="line">        while(m--)&#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;l,&amp;r);</span><br><span class="line">            q[l]&#x3D;max(q[l],r);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;n;i++)s.insert(i);</span><br><span class="line">        l&#x3D;1;r&#x3D;0;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">            if(r&gt;q[i])continue;</span><br><span class="line">            while(l&lt;i)&#123;</span><br><span class="line">                s.insert(ans[l]);</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            while(r&lt;q[i])&#123;</span><br><span class="line">                ans[++r]&#x3D;*s.begin();</span><br><span class="line">                s.erase(ans[r]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;1;i&lt;n;i++)printf(&quot;%d &quot;,ans[i]);</span><br><span class="line">        printf(&quot;%d\n&quot;,ans[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 6300 Triangle Partition（构造）</title>
    <url>/3fb087ea/</url>
    <content><![CDATA[<p>Chiaki has 3n points p1,p2,…,p3n. It is guaranteed that no three points are collinear.<br>Chiaki would like to construct n disjoint triangles where each vertex comes from the 3n points.</p>
<a id="more"></a>

<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给出<code>3*n</code>个点，保证没有三点共线，要求构造n个互不相交的三角形</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>水题。。因为说了没有三点共线，所以直接按照x排个序，三个三个的取形成的三角形肯定不相交</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;1005;</span><br><span class="line">struct sjx&#123;</span><br><span class="line">    int x,y,num;</span><br><span class="line">&#125;a[N*3];</span><br><span class="line">bool cmp(struct sjx s1,struct sjx s2)&#123;</span><br><span class="line">    return s1.x&lt;s2.x;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        for(int i&#x3D;0;i&lt;3*n;i++)&#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;a[i].x,&amp;a[i].y);</span><br><span class="line">            a[i].num&#x3D;i+1;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a,a+3*n,cmp);</span><br><span class="line">        for(int i&#x3D;0;i&lt;3*n-1;i++)printf(&quot;%d &quot;,a[i].num);</span><br><span class="line">        printf(&quot;%d\n&quot;,a[3*n-1].num);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 6299 Balanced Sequence（贪心）</title>
    <url>/420f3cff/</url>
    <content><![CDATA[<p>Chiaki has n strings s1,s2,…,sn consisting of ‘(‘ and ‘)’. A string of this type is said to be balanced:</p>
<a id="more"></a>

<ul>
<li>if it is the empty string</li>
<li>if A and B are balanced, AB is balanced,</li>
<li>if A is balanced, (A) is balanced.</li>
</ul>
<p>Chiaki can reorder the strings and then concatenate them get a new string t. Let f(t) be the length of the longest balanced subsequence (not necessary continuous) of t. Chiaki would like to know the maximum value of f(t) for all possible t.</p>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>定义合法括号序列是：()  ()()   (())</p>
<p>给n个包含’(‘和’)’的字符串，可以重新调整这n个串的顺序，求最长合法序列</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>写了一发过了样例然后wa了，好真实。。然后改啊改又wa了好几发。。更真实了0.0最后a了但是思路和第一遍完全一样啊摔◡ ヽ(`Д´)ﾉ ┻━┻</p>
<p>对于任意一个串来说，刨去合法的序列，最后剩下的一定是)))(((这种形式，所以记录一下剩下的左右括号数，然后贪心的交换序列来使这些括号能更多的和别的串的括号组合</p>
<p>对于任意两个处理完的串贪心策略如下：如果k1的左括号比右括号多，而k2的左括号比右括号少，比如))(((((和))))))((，那么肯定是把k1放前面，反之k2在前，这样二者中间才能形成更多括号，同理如果k1，k2都是左括号少右括号多，即))))))(((和)))))))))))((，那么左括号多的在前面，如果k1，k2都是左括号多右括号少，即))((((((((((和)))((((((((，右括号少的在前面</p>
<p>排序之后然后l记录当前已有的左括号数，然后和后续的右括号配对，每次更新l，具体见代码，还是很好理解的</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;100005;</span><br><span class="line">char s[N];</span><br><span class="line">struct kh&#123;</span><br><span class="line">    int l,r;</span><br><span class="line">&#125;a[N];</span><br><span class="line">bool cmp(struct kh k1,struct kh k2)&#123;</span><br><span class="line">    if(k1.l&gt;k1.r&amp;&amp;k2.l&lt;&#x3D;k2.r)return true;</span><br><span class="line">    else if(k1.l&lt;&#x3D;k1.r&amp;&amp;k2.l&gt;k2.r)return false;</span><br><span class="line">    else if(k1.l&lt;&#x3D;k1.r&amp;&amp;k2.l&lt;&#x3D;k2.r)return k1.l&gt;k2.l;</span><br><span class="line">    else return k1.r&lt;k2.r;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,n,l,r;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        int ans&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            scanf(&quot;%s&quot;,s);</span><br><span class="line">            int len&#x3D;strlen(s);</span><br><span class="line">            l&#x3D;0;r&#x3D;0;</span><br><span class="line">            for(int j&#x3D;0;j&lt;len;j++)&#123;</span><br><span class="line">                if(s[j]&#x3D;&#x3D;&#39;(&#39;)l++;</span><br><span class="line">                else if(s[j]&#x3D;&#x3D;&#39;)&#39;&amp;&amp;l&gt;0)&#123;</span><br><span class="line">                    ans++;l--;</span><br><span class="line">                &#125;</span><br><span class="line">                else r++;</span><br><span class="line">            &#125;</span><br><span class="line">            a[i].l&#x3D;l;</span><br><span class="line">            a[i].r&#x3D;r;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a,a+n,cmp);</span><br><span class="line">        l&#x3D;0;</span><br><span class="line">        for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">            l+&#x3D;a[i-1].l;</span><br><span class="line">            if(a[i].r&gt;l)&#123;</span><br><span class="line">                ans+&#x3D;l;l&#x3D;0;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                ans+&#x3D;a[i].r;</span><br><span class="line">                l-&#x3D;a[i].r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,ans*2);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 6298 Maximum Multiple</title>
    <url>/5b7386c2/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6298" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6298</a></p>
<p>Given an integer n, Chiaki would like to find three positive integers x, y and z such that: n=x+y+z, x∣n, y∣n, z∣n and xyz is maximum.</p>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给一个整数n，找到三个整数x，y，z满足n=x+y+z, x∣n, y∣n, z∣n ，且<code>x*y*z</code>max</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>把n看成单位1，因为要满足n=x+y+z, x∣n, y∣n, z∣n，所以其实也就下面这三种情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#x3D;1&#x2F;3+1&#x2F;3+1&#x2F;3</span><br><span class="line">1&#x3D;1&#x2F;2+1&#x2F;4+1&#x2F;4</span><br><span class="line">1&#x3D;1&#x2F;2+1&#x2F;3+1&#x2F;6</span><br></pre></td></tr></table></figure>

<p>又因为如果n能被3整除的话，那么第一种得到的结果肯定比第三种大，所以就不用判断第三种了，先第一种在第二种即可</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        if(n%3&#x3D;&#x3D;0)&#123;</span><br><span class="line">            LL ans&#x3D;(LL)n*n*n&#x2F;27;</span><br><span class="line">            printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(n%4&#x3D;&#x3D;0)&#123;</span><br><span class="line">            LL ans&#x3D;(LL)n*n*n&#x2F;32;</span><br><span class="line">            printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        else printf(&quot;-1\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1557 两个集合（STL set）</title>
    <url>/4a010063/</url>
    <content><![CDATA[<p>题目来源： CodeForces 468 B. Two Sets<a href="http://codeforces.com/contest/468/problem/B" target="_blank" rel="noopener">http://codeforces.com/contest/468/problem/B</a></p>
<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 40 难度：4级算法题 </p>
<p>小X有n个互不相同的整数： p1,p2,…,pn 。他想把这些整数分到两个集合A和B里边。但是要符合下面两个条件。</p>
<p>·        如果x属于A，那么a-x也肯定属于A。</p>
<p>·        如果x属于B，那么b-x也肯定属于B。</p>
<p>判断一下是否存在一种方案来分配这些数字到集合A，B中。</p>
<p>注意：如果一个集合为空也是可以的。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>单组测试数据。<br>第一行有三个整数n,a,b (1≤n≤10^5; 1≤a,b≤10^9)。<br>第二行有n个不一样的整数 p1,p2,…,pn (1≤pi≤10^9).  </p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>如果可行，那么输出YES，否则输出NO。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 5 9</span><br><span class="line">2 3 4 5</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>这题评论区好像有很多种做法，但是感觉都好麻烦啊。。我喜欢那种只要想通了写一点点代码就行的题 _ (:з」∠) _</p>
<p>思路如下：</p>
<p>因为属于a集合的话那么x,a-x相当于被绑定成封闭的一对了，放哪其实无所谓，所以一开始直白的写了个如果任何数既没有a-x又没有b-x就输出no，然后wa了五个测试点。。</p>
<p>因为还有一种情况，a-x和b-x都存在的时候，如果x属于a，那么a-x属于a，且x不属于b，b-(a-x)不属于b属于a，同理，若x属于b，会得到a-(b-x)属于b</p>
<p>所以如果a-x和b-x都存在的时候，b-(a-x)和a-(b-x)必须有一项存在</p>
<p>然后还是wa了发现是自己愚蠢的漏写了<code>x=*it</code>这种致命的话(T ^ T)我咋老是干这种事。。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">set&lt;int&gt;s,v;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin.tie(0);ios_base::sync_with_stdio(false);</span><br><span class="line">    int n,a,b,x;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        s.insert(x);</span><br><span class="line">    &#125;</span><br><span class="line">    set&lt;int&gt;::iterator it;</span><br><span class="line">    for(it&#x3D;s.begin();it!&#x3D;s.end();it++)&#123;</span><br><span class="line">        x&#x3D;*it;</span><br><span class="line">        if(!s.count(a-x)&amp;&amp;!s.count(b-x))&#123;</span><br><span class="line">            puts(&quot;NO&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s.count(a-x)&amp;&amp;s.count(b-x))&#123;</span><br><span class="line">            if(!s.count(a-b+x)&amp;&amp;!s.count(b-a+x))&#123;</span><br><span class="line">                puts(&quot;NO&quot;);</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;YES&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>51nod 1791 合法括号子段（dp）</title>
    <url>/dd814372/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 40 难度：4级算法题 </p>
<p>有一个括号序列，现在要计算一下它有多少非空子段是合法括号序列。</p>
<a id="more"></a>

<p>合法括号序列的定义是：</p>
<p>1.空序列是合法括号序列。</p>
<p>2.如果S是合法括号序列，那么(S)是合法括号序列。<br>3.如果A和B都是合法括号序列，那么AB是合法括号序列。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>多组测试数据。<br>第一行有一个整数T（1&lt;=T&lt;=1100000），表示测试数据的数量。<br>接下来T行，每一行都有一个括号序列，是一个由’(‘和’)’组成的非空串。<br>所有输入的括号序列的总长度不超过1100000。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出T行，每一行对应一个测试数据的答案。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">(</span><br><span class="line">()</span><br><span class="line">()()</span><br><span class="line">(()</span><br><span class="line">(())</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>dp[i]表示以i结尾的子段数量</p>
<p>手动模拟几个</p>
<p>状态转移方程为dp[i]=dp[pos[i]+1]+1，pos[i]表示左括号i配对的右括号所在的位置，pos初始化为-1</p>
<p>要从后往前dp，因为右括号无所谓，但是一旦遇到左括号，就开始有值</p>
<p>答案为所有dp之和</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;1000005;</span><br><span class="line">int dp[N],pos[N];</span><br><span class="line">char s[N];</span><br><span class="line">stack&lt;int&gt;sk;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%s&quot;,s);</span><br><span class="line">        n&#x3D;strlen(s);</span><br><span class="line">        while(!sk.empty())sk.pop();</span><br><span class="line">        LL ans&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i]&#x3D;0;pos[i]&#x3D;-1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            if(s[i]&#x3D;&#x3D;&#39;(&#39;)&#123;</span><br><span class="line">                sk.push(i);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(sk.empty())continue;</span><br><span class="line">            else pos[sk.top()]&#x3D;i;sk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;n-1;i&gt;&#x3D;0;i--)&#123;</span><br><span class="line">            if(pos[i]!&#x3D;-1)&#123;</span><br><span class="line">                dp[i]&#x3D;dp[pos[i]+1]+1;</span><br><span class="line">                ans+&#x3D;dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1574 排列转换（CF 584 E.Anton and Ira）</title>
    <url>/6a5982f6/</url>
    <content><![CDATA[<p>题目来源： CodeForces <a href="http://codeforces.com/contest/584/problem/E" target="_blank" rel="noopener">http://codeforces.com/contest/584/problem/E</a></p>
<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 40 难度：4级算法题</p>
<p>现在有两个长度为n的排列p和s。要求通过交换使得p变成s。交换 pi 和 pj 的代价是|i-j|。要求使用最少的代价让p变成s。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>单组测试数据。<br>第一行有一个整数n (1≤n≤200000)，表示排列的长度。<br>第二行有n个范围是1到n的整数，表示排列p。每个整数只出现一次。<br>第三行有n个范围是1到n的整数，表示排列s。每个整数只出现一次。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一个整数，表示从排列p变到s最少要多少代价。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">4 2 1 3</span><br><span class="line">3 2 4 1</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>下面这个来自评论区的思路我一直都没咋理解。。可能是放假静不下心吧。。先mark着（鸽巢原理）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">猜了一下结论,居然对了..........</span><br><span class="line">具体操作是:</span><br><span class="line">假设排列s是1,2,3,...,n</span><br><span class="line">k为排列p中最大的 没有放到正确位置的数,k的位置为pos</span><br><span class="line">k的右边一定有一个数x&lt;&#x3D;pos(因为&lt;&#x3D;pos的数有pos个,不可能全挤在pos-1个位置里)</span><br><span class="line">交换k和x,两个数都离目标更近了且没有走远路.</span><br><span class="line">重复这个步骤</span><br></pre></td></tr></table></figure>

<p>我的思路如下：</p>
<p>一个数c要到它的目标位置，最短代价就是i和a[c]的距离，所以只要证明每个数都只需要移动abs(i-a[c])最终可以使整个数列达到要求</p>
<p>那么递推的想，对于两个数来说，如果他们是刚好需要互换位子的，直接换即可</p>
<p>对于三个数1，2，3来说，如果他们都不在自己的位子上，比如2，3，1，那么2要向右1个单位，3向右1个单位，1向左2个单位，1向左的可以借助2，3向右的完成，所以总移动距离是4</p>
<p>对于n个都不在各自位子上的数来说，无论如何所有需要向左的都可以借助需要向右的数来完成，而满足他们不会走多余的路</p>
<p>又因为这题代价是双方交换，所以最后的答案是总移动距离除以2</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;200005;</span><br><span class="line">int a[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin.tie(0);ios_base::sync_with_stdio(false);</span><br><span class="line">    int n,c;</span><br><span class="line">    LL ans&#x3D;0;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;c;</span><br><span class="line">        a[c]&#x3D;i;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;c;</span><br><span class="line">        ans+&#x3D;abs(i-a[c]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;(ans&gt;&gt;1)&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1580 铺管道（CF 518 F.Pasha and Pipe）</title>
    <url>/15885f20/</url>
    <content><![CDATA[<p>题目来源： CodeForces <a href="http://codeforces.com/contest/518/problem/F" target="_blank" rel="noopener">http://codeforces.com/contest/518/problem/F</a></p>
<p>基准时间限制：1.5 秒 空间限制：131072 KB 分值: 40 难度：4级算法题 </p>
<p>现在要在一个城市中铺设管道。</p>
<p>这个城市是由 n×m 小方格组成的。每一个小方格要么是空的（管道可以铺设在上面），要么是实的（管道不能铺在上面）。空的用’.’表示，实的用’#’表示。</p>
<p>管道铺设的规则如下：</p>
<p>·        整条管道是形状是宽度为1的折线；</p>
<p>·        管道只能铺设在空的格子上面；</p>
<p>·        管道的两个端点只能在边缘上，但是不能在角上；</p>
<p>·        管道最多只能转两个弯（90度）；</p>
<p>·        在管道上的格子有且只能有两个是在边缘上的；</p>
<p>·        如果管道是一条直线，那么他的两个端点必须是落在不同的边上；</p>
<p>·        对于管道上的非边缘格子，每一个格子会有且仅有两个相邻的其它格子在管道上；</p>
<p>·        对于管道上处于边缘的格子，仅有一个相邻的格子处于管道上。</p>
<p>下面有一些合法的管道铺设例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">....#           ....#            .*..#</span><br><span class="line">*****           ****.            .***.</span><br><span class="line">..#..           ..#*.            ..#*.</span><br><span class="line">#...#           #..*#            #..*#</span><br><span class="line">.....           ...*.            ...*.</span><br></pre></td></tr></table></figure>

<p>下面是一些非法铺设的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.**.#            *...#            .*.*#</span><br><span class="line">.....            ****.            .*.*.</span><br><span class="line">..#..            ..#*.            .*#*.</span><br><span class="line">#...#            #..*#            #*.*#</span><br><span class="line">.....            ...*.            .***.</span><br></pre></td></tr></table></figure>

<p>这些例子中管道用’*’表示。</p>
<p>现在给定城市的地图，请计算一下有多少种方法铺设管道。</p>
<p>样例解释：</p>
<p>在这个样例中，有三种方法铺设管道（管道用’*’表示）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.*.        .*.        ...</span><br><span class="line">.*#        **#        **#</span><br><span class="line">.*.        ...        .*.</span><br></pre></td></tr></table></figure>

<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>单组测试数据。<br>第一行有两个整数 n,m (2≤n,m≤2000)，表示城市地图的高和宽。<br>接下来n行，每一行有m个字母，表示城市地图。<br>如果字符是’.’，表示该格子是空的，管道可以铺设。<br>如果字符是’#’，表示该格子是实的，管道不能铺设。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一个整数，表示管道铺设方案的种数。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">...</span><br><span class="line">..#</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>好题，放空了好久好久才解决。。好难啊不会。。然后就没出息的找题解去了。。◡ ヽ(`Д´)ﾉ ┻━┻</p>
<p>看了大佬的代码才知道原来这种题是这么做的<a href="https://www.cnblogs.com/dancer16/p/7351701.html" target="_blank" rel="noopener">https://www.cnblogs.com/dancer16/p/7351701.html</a>妙啊妙啊</p>
<p>就大佬博文里的那四种情况，直上直下，一个折，两个折同向，两个折反向，然后再把图转向做一遍，思路很简单但是代码不好写啊。。</p>
<p>a[i][j]false表示空，true表示实</p>
<p>先预处理d[i][j]和u[i][j]两个数组，分别表示t[1][j]-&gt;t[i][j]下达和t[n][j]-&gt;t[i][j]上达</p>
<p>因为起点只能在边缘上，折线也不是很复杂，所以枚举起点然后累加方法数，具体见代码注释，要是自己写好像还是写不出来。。mark</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;2005;</span><br><span class="line">int n,m;</span><br><span class="line">char s[N];</span><br><span class="line">bool a[N][N],b[N][N],d[N][N],u[N][N];</span><br><span class="line">LL ans&#x3D;0;</span><br><span class="line">void solve(bool t[][N],int nn,int mm,int flag)&#123;</span><br><span class="line">    memset(d,false,sizeof(d));</span><br><span class="line">    memset(u,false,sizeof(u));</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;nn;i++)</span><br><span class="line">        &#x2F;&#x2F;down，t[i-1][j]-&gt;t[i][j]</span><br><span class="line">        &#x2F;&#x2F;其实是t[1][j]-&gt;t[i][j]，合法为0</span><br><span class="line">        for(int j&#x3D;1;j&lt;&#x3D;mm;j++)</span><br><span class="line">            d[i][j]&#x3D;d[i-1][j]|t[i][j];</span><br><span class="line">    for(int i&#x3D;nn;i&gt;0;i--)</span><br><span class="line">        &#x2F;&#x2F;up，t[i+1][j]-&gt;t[i][j]</span><br><span class="line">        &#x2F;&#x2F;其实是t[n][j]-&gt;t[i][j]，合法为0</span><br><span class="line">        for(int j&#x3D;1;j&lt;&#x3D;mm;j++)</span><br><span class="line">            u[i][j]&#x3D;u[i+1][j]|t[i][j];</span><br><span class="line">    for(int i&#x3D;2;i&lt;nn;i++)&#123;</span><br><span class="line">        int tmp&#x3D;0;</span><br><span class="line">        if(!t[i][1]&amp;&amp;flag)tmp&#x3D;1;</span><br><span class="line">        d[i][1]&#x3D;u[i][1]&#x3D;1;&#x2F;&#x2F;管道上处于边缘的格子，仅有一个相邻的格子处于管道上</span><br><span class="line">        for(int j&#x3D;2;j&lt;mm;j++)&#123;</span><br><span class="line">            if(t[i][j])&#123;</span><br><span class="line">                tmp&#x3D;0;continue;</span><br><span class="line">            &#125;</span><br><span class="line">            ans+&#x3D;((!d[i][j])+(!u[i][j]))*tmp;</span><br><span class="line">            &#x2F;&#x2F;上[右……右]下，下[右……右]上，上[右……右]上，下[右……右]下，</span><br><span class="line">            &#x2F;&#x2F;[右……右]下，[右……右]上</span><br><span class="line">            ans+&#x3D;(!d[i][j]&amp;&amp;!u[i][j-1])+(!u[i][j]&amp;&amp;!d[i][j-1]);</span><br><span class="line">            &#x2F;&#x2F;上右上，下右下</span><br><span class="line">            tmp+&#x3D;(!d[i][j-1])+(!u[i][j-1]);</span><br><span class="line">            &#x2F;&#x2F;算能到达第i行的部分数配合下一次循环使用</span><br><span class="line">        &#125;</span><br><span class="line">        if(!t[i][mm]&amp;&amp;flag)</span><br><span class="line">            ans+&#x3D;tmp+(!d[i][mm-1])+(!u[i][mm-1]);</span><br><span class="line">        &#x2F;&#x2F;下[右……右]，上[右……右]，左右直达</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag)&#123;&#x2F;&#x2F;左右直达在别的里面求了，所以不用</span><br><span class="line">        for(int j&#x3D;2;j&lt;mm;j++)ans+&#x3D;(!d[nn][j]);&#x2F;&#x2F;上下直达</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%s&quot;,s+1);</span><br><span class="line">        for(int j&#x3D;1;j&lt;&#x3D;m;j++)a[i][j]&#x3D;s[j]&#x3D;&#x3D;&#39;#&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    solve(a,n,m,1);</span><br><span class="line">    &#x2F;&#x2F;把图转过来再来一遍</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">        for(int j&#x3D;1;j&lt;&#x3D;m;j++)</span><br><span class="line">            b[j][i]&#x3D;a[i][j];</span><br><span class="line">    solve(b,m,n,0);</span><br><span class="line">    printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1799 二分答案（二分，阶乘分块打表）</title>
    <url>/6e6d7226/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 40 难度：4级算法题</p>
<p>lyk最近在研究二分答案类的问题。<br>对于一个有n个互不相同的数且从小到大的正整数数列a（其中最大值不超过n），若要找一个在a中出现过的数字m，一个正确的二分程序是这样子的：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l&#x3D;1; r&#x3D;n; mid&#x3D;(l+r)&#x2F;2;</span><br><span class="line">while (l&lt;&#x3D;r)</span><br><span class="line">&#123;</span><br><span class="line">    if (a[mid]&lt;&#x3D;m) l&#x3D;mid+1; else r&#x3D;mid-1;</span><br><span class="line">    mid&#x3D;(l+r)&#x2F;2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终a[r]一定等于m。<br>但是这个和谐的程序被熊孩子打乱了。<br>熊孩子在一开始就将a数组打乱顺序。（共有n!种可能）<br>lyk想知道最终r=k的期望。<br>由于小数点非常麻烦，所以你只需输出将答案乘以n!后对1000000007取模就可以了。  </p>
<p>在样例中，共有2个数，被熊孩子打乱后的数列共有两种可能(1,2)或者(2,1)，其中(1,2)经过上述操作后r=1，(2,1)经过上述操作后r=0。r=k的期望为0.5，<code>0.5*2!=1</code>，所以输出1。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>3个整数n,m,k(1&lt;=m&lt;=n&lt;=10^9,0&lt;=k&lt;=n)。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一行表示答案</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 1 1</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>刚开始读题读了好久，一直没读懂，后来才发现没理解第一句话，“有n个互不相同的数且从小到大的正整数数列a（其中最大值不超过n）”，其实就是1-n这n个数。。</p>
<p>那就可以做了，运用一下二分的原理，如果确定最后要走到k那个位置的话，其实二分的路径实际上是已经确定了的，就是一个mid点跳到另一个mid点…最后到的mid点是k，所以只要求出大于k的位置的mid的个数和小于k的位置的mid的个数</p>
<p>对于小于等于k的位置的small个数来说，可以填比m小或等于m的数，即有A(m,small)种情况，对于大于k的位置的big个数来说，可以填比m大的数，即有A(n-m,big)种情况</p>
<p>对于剩下非mid的位置来说，就是求剩余数字的阶乘</p>
<p>这题求阶乘也要用技巧，毕竟1e9太大了，所以要分块打表，1e7到1e9，每隔1e7打一个，这样求大点的数阶乘可以在1e7内次循环求出，代码也放在下面了</p>
<p>还有一个注意点就是乘的时候要强制类型转化成LL，否则会wa</p>
<p>这个题做了很久才想通。。还是我太菜了见的太少了啊T^T不过还是有收获哒(・ω・)ノ</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int p&#x3D;1000000007;</span><br><span class="line">int main()&#123;</span><br><span class="line">	LL ans&#x3D;1;</span><br><span class="line">	int n&#x3D;1e7;</span><br><span class="line">	for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		ans&#x3D;ans*i%p;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">	while(n&lt;&#x3D;1e9)&#123;</span><br><span class="line">		for(int i&#x3D;n+1;i&lt;&#x3D;n+1e7;i++)&#123;</span><br><span class="line">			ans&#x3D;(LL)ans*i%p;</span><br><span class="line">		&#125;</span><br><span class="line">		n+&#x3D;1e7;</span><br><span class="line">		printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long </span><br><span class="line">const int p&#x3D;1000000007;</span><br><span class="line">const int N&#x3D;10000000;</span><br><span class="line">const int num[]&#x3D;&#123;1,682498929,491101308,76479948,723816384,</span><br><span class="line">    67347853,27368307,625544428,199888908,888050723,</span><br><span class="line">    927880474,281863274,661224977,623534362,970055531,</span><br><span class="line">    261384175,195888993,66404266,547665832,109838563,</span><br><span class="line">    933245637,724691727,368925948,268838846,136026497,</span><br><span class="line">    112390913,135498044,217544623,419363534,500780548,</span><br><span class="line">    668123525,128487469,30977140,522049725,309058615,</span><br><span class="line">    386027524,189239124,148528617,940567523,917084264,</span><br><span class="line">    429277690,996164327,358655417,568392357,780072518,</span><br><span class="line">    462639908,275105629,909210595,99199382,703397904,</span><br><span class="line">    733333339,97830135,608823837,256141983,141827977,</span><br><span class="line">    696628828,637939935,811575797,848924691,131772368,</span><br><span class="line">    724464507,272814771,326159309,456152084,903466878,</span><br><span class="line">    92255682,769795511,373745190,606241871,825871994,</span><br><span class="line">    957939114,435887178,852304035,663307737,375297772,</span><br><span class="line">    217598709,624148346,671734977,624500515,748510389,</span><br><span class="line">    203191898,423951674,629786193,672850561,814362881,</span><br><span class="line">    823845496,116667533,256473217,627655552,245795606,</span><br><span class="line">    586445753,172114298,193781724,778983779,83868974,</span><br><span class="line">    315103615,965785236,492741665,377329025,847549272,698611116&#125;;</span><br><span class="line">int getnum(int n)&#123;</span><br><span class="line">    if(!n)return 1;</span><br><span class="line">    int tmp&#x3D;num[n&#x2F;N];</span><br><span class="line">    for(int i&#x3D;n&#x2F;N*N+1;i&lt;&#x3D;n;i++)tmp&#x3D;(LL)tmp*i%p;</span><br><span class="line">    return tmp;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,k,l,r,mid,big,small;</span><br><span class="line">    int ans&#x3D;1;</span><br><span class="line">    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    l&#x3D;1;r&#x3D;n;big&#x3D;small&#x3D;0;</span><br><span class="line">    while(l&lt;&#x3D;r)&#123;</span><br><span class="line">        mid&#x3D;(l+r)&#x2F;2;</span><br><span class="line">        if(mid&lt;&#x3D;k)&#123;</span><br><span class="line">            l&#x3D;mid+1;small++;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            r&#x3D;mid-1;big++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;m-small+1;i&lt;&#x3D;m;i++)ans&#x3D;(LL)ans*i%p;</span><br><span class="line">    for(int i&#x3D;n-m-big+1;i&lt;&#x3D;n-m;i++)ans&#x3D;(LL)ans*i%p;</span><br><span class="line">    ans&#x3D;(LL)ans*getnum(n-big-small)%p;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1717 好数（找规律）</title>
    <url>/d34e925e/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 40 难度：4级算法题 </p>
<p>有n个数  a[1],a[2],…,a[n]开始都是0<br>现在进行操作 t从1~n依次增加<br>每次把下标时t的倍数的数都反转（0变成1,1变成0）<br>如果最后a[i]为0，那么称此时的i为好数。<br>现在对于给定的n，求这时候的好数个数。<br><code>n&lt;=1e15</code></p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>一个数n，表示有n个数。（n&lt;=1e15）</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一个数，表示好数的个数。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>先模拟一下，跑一下下面这段代码，找“好数”的规律</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">bool a[105];</span><br><span class="line">int main()&#123;</span><br><span class="line">    memset(a,false,sizeof(a));</span><br><span class="line">    for(int i&#x3D;1;i&lt;105;i++)&#123;</span><br><span class="line">        for(int j&#x3D;i;j&lt;105;j+&#x3D;i)a[j]&#x3D;!a[j];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;1;i&lt;105;i++)</span><br><span class="line">        if(a[i])printf(&quot;%d &quot;,i);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出<code>1 4 9 16 25 36 49 64 81 100</code></p>
<p>可以发现有且只有完全平方数不是好数</p>
<p>那么答案就是<code>n-sqrt(n)</code></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">int main()&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">    printf(&quot;%lld\n&quot;,(LL)(n-sqrt(n)+1));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>51nod 1637 幸运数字转换（死循环）</title>
    <url>/835a9757/</url>
    <content><![CDATA[<p>题目来源： CodeForces<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 40 难度：4级算法题  </p>
<p>比得喜欢幸运数字。这里所说的幸运数字是由4和7组成的正整数。比如，数字47，744，4是幸运数字，而5，17，467就不是。</p>
<p>比得有一个没有前导0的n位数的整数。他用了一个数组d来表示这个整数。数组的第一个编号从数字的最高位开始，下标从1开始。比得想对d进行以下操作k次：</p>
<p>查找最小的x(1≤x＜n)使得 dx ＝ 4 且 dx+1 ＝ 7 ，如果x是奇数，则让 dx ＝ dx+1 ＝ 4 ，否则，让 dx ＝ dx+1 ＝ 7 。</p>
<p>如果没有找到相应的x，则此次操作作为最后一次操作，数组保持不变。</p>
<p>现在，给定初始数字作为数组d，和数字k。帮助比得计算k次操作后的结果。</p>
<p>样例解释：<br>在样例中，数组的变化如下：</p>
<p>4727447→4427447→4427477→4427447→4427477。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>单组测试数据<br>第一行包含两个整数n和k（1≤n≤10^5，0≤k≤10^9）。<br>分别表示给定数字的位数，和操作的次数。<br>第二行有一个n位数的整数，代表数组d。第1位数代表d1。<br>题目保证数字的第1位数不为0。  </p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>共一行，代表对数组d进行k次操作后的结果。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 4</span><br><span class="line">4727447</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4427477</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>1e9那么大的k，不是循环结就是死循环了，这题就是死循环，题目中那个样例解释已经提示了，其实就是只要出现447或者477，两个就会一直卡在那里循环来循环去，所以对于47来说，如果变成44就判断下一位是不是7，如果变成77就判断前一位是不是4，如果出现这两种的话判断一下剩下的k来决定最终是447还是477</p>
<p>第一遍先字符串读入然后存入数组了，200ms+，后来改成直接char，15ms</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;100005;</span><br><span class="line">char a[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,k;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);</span><br><span class="line">    scanf(&quot;%s&quot;,a+1);</span><br><span class="line">    for(int i&#x3D;1;i&lt;n&amp;&amp;k!&#x3D;0;i++)&#123;</span><br><span class="line">        if(a[i]&#x3D;&#x3D;&#39;4&#39;&amp;&amp;a[i+1]&#x3D;&#x3D;&#39;7&#39;)&#123;</span><br><span class="line">            k--;</span><br><span class="line">            if(i&amp;1)&#123;</span><br><span class="line">                a[i+1]&#x3D;&#39;4&#39;;</span><br><span class="line">                if(a[i+2]&#x3D;&#x3D;&#39;7&#39;)&#123;</span><br><span class="line">                    if(k&amp;1)a[i+1]&#x3D;&#39;7&#39;;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                a[i]&#x3D;&#39;7&#39;;</span><br><span class="line">                if(a[i-1]&#x3D;&#x3D;&#39;4&#39;)&#123;</span><br><span class="line">                    if(k&amp;1)a[i]&#x3D;&#39;4&#39;;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%s\n&quot;,a+1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1829 函数（斯特林数）</title>
    <url>/6ed0cc8f/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 40 难度：4级算法题 </p>
<p>想知道f:A-&gt;B这个函数（其中|A|=n, |B|=m）的所有映射关系要使B的每个元素都要被A的一个元素覆盖到。<br>数字可能很大你只要输出方案数模1,000,000,007即可。</p>
<a id="more"></a>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>一共一行两个数，n和m。（1&lt;=n,m&lt;=1,000,000)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一共一行包含一个方案数。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 2</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>其实就是n个不同球放到m个不同盒子中，且任意一个盒子都不为空，求方法数的问题</p>
<p>先把问题转化一下，n个不同球放到m个相同盒子中，且任意一个盒子都不为空，那么这显然是个第二类斯特林数S(n,m)</p>
<p>关于斯特林数百度百科讲的很详细 <a href="https://baike.baidu.com/item/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/4938529" target="_blank" rel="noopener">斯特林数</a></p>
<p>放段斯特林数直接dp递推的代码，当然这个复杂度and内存做题肯定是不行的。。只是记录一下这个dp思路而已</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int dp[N][N];</span><br><span class="line">void init()&#123;</span><br><span class="line">    for(int i&#x3D;0;i&lt;N;i++)&#123;</span><br><span class="line">        dp[i][i]&#x3D;1;</span><br><span class="line">        dp[i][0]&#x3D;0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int Stirling(int n,int m)&#123;</span><br><span class="line">    for(int i&#x3D;2;i&lt;&#x3D;n;i++)</span><br><span class="line">        for(int j&#x3D;1;j&lt;&#x3D;m;j++)</span><br><span class="line">            dp[i][j]&#x3D;dp[i-1][j-1]+dp[i-1][j]*j;</span><br><span class="line">    return dp[n][m];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    init();</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    printf(&quot;%d\n&quot;,Stirling(n,m));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再回到原问题，n个不同球放到m个不同盒子中，答案已经出来了<code>ans=m!*S(n,m)</code></p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g2s4eerssij307h01d745.jpg" alt=""></p>
<p><code>ans=∑(-1)^i*c(m,i)*(m-i)^n {i=0~m}</code></p>
<p>组合数要用逆元求，逆元要先线性与处理，如果直接跑循环求组合数的话会T</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const LL p&#x3D;1000000007;</span><br><span class="line">const int N&#x3D;1000005;</span><br><span class="line">LL mul[N],inv[N];</span><br><span class="line">void init()&#123;&#x2F;&#x2F;线性求逆元</span><br><span class="line">    mul[0]&#x3D;1;</span><br><span class="line">    for(int i&#x3D;1; i&lt;N; i++)</span><br><span class="line">        mul[i]&#x3D;mul[i-1]*i%p;</span><br><span class="line">    inv[0]&#x3D;inv[1]&#x3D;1;</span><br><span class="line">    for(int i&#x3D;2; i&lt;N; i++)</span><br><span class="line">        inv[i]&#x3D;(LL)(p-p&#x2F;i)*inv[p%i]%p;</span><br><span class="line">    for(int i&#x3D;1; i&lt;N; i++)</span><br><span class="line">        inv[i]&#x3D;inv[i-1]*inv[i]%p;</span><br><span class="line">&#125;</span><br><span class="line">LL qpow(LL a,LL b,LL p)&#123;</span><br><span class="line">    LL ans&#x3D;1;</span><br><span class="line">    a%&#x3D;p;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            ans&#x3D;ans*a%p;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        b&gt;&gt;&#x3D;1;</span><br><span class="line">        a&#x3D;a*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">LL C(LL n,LL m)&#123;</span><br><span class="line">    return mul[n]*inv[m]%p*inv[n-m]%p;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    init();</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    LL ans&#x3D;0;</span><br><span class="line">    for(LL i&#x3D;0;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">        if(i&amp;1)ans&#x3D;(ans-C(m,i)*qpow(m-i,n,p)%p+p)%p;</span><br><span class="line">        else ans&#x3D;(ans+C(m,i)*qpow(m-i,n,p)%p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1946 特殊表示法（斐波那契性质，卡输入输出）</title>
    <url>/7d2b0472/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 40 难度：4级算法题 </p>
<p>众所周知，斐波那契数列是人们常用来讨论的一个递推式系数为整数而具有无理数递推式的数列。</p>
<p>F[0]=1;F[1]=1;F[2]=2;F[3]=3;F[4]=5;…..</p>
<p>下面规定，对一个数n，它的特殊表示法为    <code>a[1]*F[1]+a[2]*F[2]+...a[n]*F[n]</code>。其中a[1..n]为一个取值0/1的数列。（不包括F[0]）<br>同时，规定a数列不存在两个相邻的1，并且a[n]=1。<br>现在给两个数A和B的特殊表示法，需要你求出A+B的特殊表示法。<br>保证n,m&lt;=1,000,000  </p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行一个数n，表示A的特殊表示法的长度。<br>第二行n个数，表示A的特殊表示法。<br>第三行一个数m，表示B的特殊表示法的长度。<br>第四行m个数，表示B的特殊表示法。  </p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>第一行一个数L，表示A+B的特殊表示法的长度。<br>第二行L个数，表示A+B的特殊表示法。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">0 1</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">0 0 1</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>整整t了一个晚上一个早上加一个中午啊啊啊，一开始没思路就去看题解了，然后题解给了斐波那契的三个性质，说按照性质模拟即可，我只会用两个，然后t了，scanf改成读入挂read()，又t了，然后开始怀疑人生。。是不是因为没用第三个性质所以卡不过去？？然后就陷入了。。无边无际的发呆之中。。这个题卡的我TAT完全刷新了对输入输出的认识，总之最后读入直接getchar，输出putchar，ac。。</p>
<p>下面讲思路：</p>
<p>题解是说利用斐波那契的这三个性质：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F[i]+F[i+1]&#x3D;F[i+2]</span><br><span class="line">2f(i)&#x3D;F(i-2)+F(i+1)</span><br><span class="line">∑f(i)&#123;i&#x3D;1~n&#125;&#x3D;f(n+2)-2</span><br></pre></td></tr></table></figure>

<p>做这题之前还真没发现斐波那契数列有第三个性质，推导过程如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(0)+f(1)&#x3D;f(2)</span><br><span class="line">f(1)+f(2)&#x3D;f(3)</span><br><span class="line">f(2)+f(3)&#x3D;f(4)</span><br><span class="line">...</span><br><span class="line">f(n-2)+f(n-1)&#x3D;f(n)</span><br><span class="line">f(n-1)+f(n)&#x3D;f(n+1)</span><br><span class="line">f(n)+f(n+1)&#x3D;f(n+2)</span><br><span class="line"></span><br><span class="line">叠加抵消得∑f(i)&#123;i&#x3D;1~n&#125;&#x3D;f(n+2)-f(1)-f(0)，即∑f(i)&#x3D;f(n+2)-2，</span><br></pre></td></tr></table></figure>

<p>但是事实是。。我用不来啊。。懵逼</p>
<p>所以就利用第一二个性质，因为特殊表示只有0，1存在，所以相加后的数组，有2出现的话都是要处理掉的，问题在于怎么处理能不遗漏且最简</p>
<p>先从前往后把2处理一遍，处理方法用性质1和2，每次处理都要更新n，因为如果有操作i+1之类的话，最后的长度会变大，然后对于a[1]，a[2]来说需要特判，这里有个问题0.0，我后来看了榜里别人的代码，在对于a[2]=3的处理中，我认为应该是下面这样，但是我看了两个人的代码他们写的都是a[2]–，虽然两种都ac了，但是？？？？？。。。。。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(a[2]&#x3D;&#x3D;3)&#123;</span><br><span class="line">    a[3]++;a[2]-&#x3D;2;a[1]++;</span><br><span class="line">    n&#x3D;max(n,3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>倒着处理完了之后，再正着处理几遍，原理很简单就利用性质1，比如样例1 1，就是0 0 1，一直往后推，直到磨几遍把这个序列都摊成01就可以了</p>
<p>读入直接getchar，输出putchar<br>读入直接getchar，输出putchar<br>读入直接getchar，输出putchar   </p>
<p>好了至此这个题就a掉了，应该没啥坑点了0.0</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;1000005;</span><br><span class="line">int a[N];</span><br><span class="line">void read(int &amp;x)&#123;</span><br><span class="line">    char ch&#x3D;getchar();x&#x3D;0;</span><br><span class="line">    for(;ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;;ch&#x3D;getchar());</span><br><span class="line">    for(;ch&gt;&#x3D;&#39;0&#39;&amp;&amp;ch&lt;&#x3D;&#39;9&#39;;ch&#x3D;getchar())x&#x3D;x*10+ch-&#39;0&#39;;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,c;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);getchar();</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)a[i]&#x3D;getchar()-&#39;0&#39;,getchar();</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;m);getchar();</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">        c&#x3D;getchar()-&#39;0&#39;,getchar();</span><br><span class="line">        a[i]+&#x3D;c;</span><br><span class="line">    &#125;</span><br><span class="line">    n&#x3D;max(m,n);</span><br><span class="line">    for(int i&#x3D;n;i&gt;&#x3D;3;i--)&#123;</span><br><span class="line">        if(a[i]&gt;&#x3D;2)&#123;</span><br><span class="line">            a[i+1]++;a[i]-&#x3D;2;a[i-2]++;</span><br><span class="line">            n&#x3D;max(n,i+1);</span><br><span class="line">        &#125;</span><br><span class="line">        if(a[i]&amp;&amp;a[i-1])&#123;</span><br><span class="line">            a[i+1]++;a[i]--;a[i-1]--;</span><br><span class="line">            n&#x3D;max(n,i+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;for(int i&#x3D;1;i&lt;&#x3D;n;i++)printf(&quot;%d &quot;,a[i]);</span><br><span class="line">    if(a[2]&#x3D;&#x3D;3)&#123;</span><br><span class="line">        a[3]++;a[2]-&#x3D;2;a[1]++;</span><br><span class="line">        n&#x3D;max(n,3);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(a[1]&gt;&#x3D;2&amp;&amp;!a[2])&#123;</span><br><span class="line">        a[2]++;a[1]-&#x3D;2;</span><br><span class="line">        n&#x3D;max(n,2);</span><br><span class="line">    &#125;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        bool flag&#x3D;0;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">            if(a[i]&amp;&amp;a[i+1]&amp;&amp;!a[i+2])&#123;</span><br><span class="line">                a[i+2]++;a[i]--;a[i+1]--;</span><br><span class="line">                n&#x3D;max(n,i+2);</span><br><span class="line">                flag&#x3D;1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!flag)break;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,n);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)putchar(a[i]+48),putchar(&#39; &#39;);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 2000 四边形分割平面（n个m边形分割平面公式推导）</title>
    <url>/de762ff3/</url>
    <content><![CDATA[<p>题目来源： syu比赛题<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 40 难度：4级算法题 </p>
<p>用N个四边方形最多可以把平面分成几个区域?</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行输入一个整数T，表示数据组数（1&lt;=T&lt;=10000）；<br>第二行输入一个正整数n(1&lt;=n&lt;=1000)；</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每组数据，请输出结果。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>这题可以扩展为n个m边形最多可以把平面分成几个区域</p>
<p>首先f(1)=2对任意m都成立</p>
<p>然后求递推式<code>f(n)=f(n-1)+2*m(n-1)</code>，就拿四边形来举例</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkn0wzm8j20b007xweo.jpg" alt=""></p>
<p>要加上第三个四边形的时候，四条边一条一条加，看图可以发现多加的红边实际上就是切割了已有的两个四边形的角，从而产生了四个蓝圈内的新区域，总共可以加四条红边，所以每加一个四边形增加的区域数就是<code>2*4*(n-1)</code></p>
<p>所以对m边形来说，每加一个m边形增加的区域数为<code>2*m(n-1)</code>，即证</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long </span><br><span class="line">const int N&#x3D;1005;</span><br><span class="line">LL f[N];</span><br><span class="line">void init()&#123;</span><br><span class="line">    f[1]&#x3D;2;</span><br><span class="line">    for(int i&#x3D;2;i&lt;N;i++)f[i]&#x3D;f[i-1]+8*(i-1);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,n;</span><br><span class="line">    init();</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        printf(&quot;%lld\n&quot;,f[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1960 范德蒙矩阵（贪心）</title>
    <url>/e98fffcf/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 40 难度：4级算法题</p>
<p>LYK最近在研究范德蒙矩阵与矩阵乘法，一个范德蒙矩阵的形式如下：</p>
<p><img src="https://img.51nod.com/upload/000FC14D/08D3F342F1D99F0D0000000000000101.png" alt=""></p>
<p>它想通过构造一个含有<code>1~nm</code>的<code>n*m</code>的矩阵G，使得<code>G*V</code>得到的<code>n*n</code>的矩阵T中所有位置上的元素之和最大。其中<code>n,m&lt;=100000，ai&lt;=2*10^9</code><br>你只需输出这个值对1e9+7取模后的结果。</p>
<p>在样例中，矩阵G为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 4</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>
<p>当然可能存在其它的方法使得答案最大。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行两个数n,m，接下来一行m个数表示ai。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一个数表示答案</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 2</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">37</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>不会写_ (:з」∠) _ ，看了题解的，矩阵忘的差不多了。。</p>
<p>其实不难，只要发现G矩阵中Gij对答案的贡献是<code>Gij*V&#39;中第j行所有元素</code>之和，那就可以想到贪心获取最大值了</p>
<p>贪心思路是：先给ai排个序，1-mn中大的数肯定优先和大的ai乘</p>
<p>第j行所有元素之和可以直接用等比数列搞一搞，要注意a=1和a&gt;=mod的特殊情况，也就是(a1^n-1)/(a1-1)，这里有除法就要用一下逆元，费马小定理，最后按照贪心顺序存入b数组中</p>
<p>最后的答案就是:<br><code>b[0]*∑[1~n]+b[1]*∑[n+1~2n]+b[2]*∑[2n+1~3n]+...+b[m-1]*[n*(m-1)+1~mn]</code></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long </span><br><span class="line">const LL p&#x3D;1000000007;</span><br><span class="line">const int N&#x3D;100005;</span><br><span class="line">LL a[N],b[N],res,n,m;</span><br><span class="line">LL qpow(LL a,LL b)&#123;</span><br><span class="line">    LL ans&#x3D;1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            ans&#x3D;(ans*a)%p;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        b&gt;&gt;&#x3D;1;</span><br><span class="line">        a&#x3D;a*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i&#x3D;0;i&lt;m;i++)scanf(&quot;%lld&quot;,&amp;a[i]);</span><br><span class="line">    sort(a,a+m);</span><br><span class="line">    for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">        a[i]&#x3D;(a[i]+p)%p;</span><br><span class="line">        if(a[i]&#x3D;&#x3D;0)b[i]&#x3D;1;</span><br><span class="line">        else if(a[i]&#x3D;&#x3D;1)b[i]&#x3D;n;</span><br><span class="line">        else b[i]&#x3D;(qpow(a[i],n)-1+p)*qpow(a[i]-1,p-2)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    res&#x3D;0;</span><br><span class="line">    LL num&#x3D;(n*(n+1)&#x2F;2)%p;</span><br><span class="line">    for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">        res&#x3D;(res+num*b[i]%p)%p;</span><br><span class="line">        num&#x3D;(num+n*n)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;,res);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 2133 排队接水（贪心）</title>
    <url>/d2c81766/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 5 难度：1级算法题</p>
<p>n个人一起排队接水，第i个人需要b[i]的时间来接水。<br>1 &lt;= n &lt;= 1000<br>0 &lt;= b[i] &lt;= 1000<br>同时只能有一个人接水，正在接水的人和没有接水的人都需要等待。<br>完成接水的人会立刻消失，不会继续等待。<br>你可以决定所有人接水的顺序，并希望最小化所有人等待时间的总和。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行一个整数n</p>
<p>接下来n行，每行一个整数表示b[i]</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一行一个整数，表示所有人等待时间的总和的最小值</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>水。。</p>
<p>贪心，等待时间长的人先打水，这样这个数字要乘上的次数就小</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long </span><br><span class="line">const int N&#x3D;1005;</span><br><span class="line">int a[N];</span><br><span class="line">bool cmp(int a,int b)&#123;</span><br><span class="line">    return a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    sort(a,a+n,cmp);</span><br><span class="line">    LL ans&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        ans+&#x3D;a[i]*(i+1);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>1019 逆序数（树状数组，归并排序）</title>
    <url>/cf682b8e/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB </p>
<p>在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的逆序数。</p>
<a id="more"></a>

<p>如2 4 3 1中，2 1，4 3，4 1，3 1是逆序，逆序数是4。给出一个整数序列，求该序列的逆序数。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：N，N为序列的长度（n &lt;= 50000)<br>第2 - N + 1行：序列中的元素（0 &lt;= A[i] &lt;= 10^9）</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出逆序数</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>先是树状数组，原理就是排序思想加上区间求和和点更新，（用线段树也有一样的效果），62ms</p>
<p>首先一般的排序思想是这样的：比如对4 2 3 1这个序列来说，先找最小的1，在他前面有三个数，那么记下+3，把这个1变成0，然后找2，在他前面有一个数，记下+1，把2变成0，然后3前面有一个数，记下+1，3变成0，答案就是3+1+1=5</p>
<p>怎么和树状数组联系到一块呢，比如当前4 2 3 1对应着1 1 1 1，然后第四个位置前面有三个1，区间求和，答案加3</p>
<p>树状数组具体操作是倒过来的，一开始都是0 0 0 0，然后第一位的数字是“4”，是第四小，先更新为1，即0 0 0 1，然后求和[1,4]得1，答案加上（i-1=0），然后第二位数字是“2”，是第二小，更新为1，即0 1 0 1，然后求和[1,2]得1，答案加上（i-1=1），第三位数字是3，是第三小，更新为1，即0 1 1 1，求和[1,3]得2，答案加上（i-2=1），第四位数字是1，第一小，1 1 1 1，求和[1,1]得1，答案加上（i-1=3），所以逆序数就是0+1+1+3=5，</p>
<p>要先离散化一波，具体见代码</p>
<hr>
<p>第二种方法是归并排序，冒泡儿水不过去╮(￣▽￣””)╭</p>
<p>那么问题在于归并排序的逆序数咋求，这时候就要在“并”里加句妙妙的话，<code>ans+=(m-q)</code>，见代码</p>
<p>举个例子:</p>
<table>
<thead>
<tr>
<th>1</th>
<th>3</th>
<th>4</th>
<th></th>
<th>2</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody><tr>
<td>l</td>
<td></td>
<td>mid</td>
<td></td>
<td>mid+1</td>
<td></td>
<td>r</td>
</tr>
</tbody></table>
<p>填入1，然后判断3&gt;2在右边选择2填的时候，3和3后面的所有数（即3，4）都大于2，所以这时候逆序数就加2</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;50005;</span><br><span class="line">int c[N],n,tmp[N];</span><br><span class="line">int lowbit(int x)&#123;</span><br><span class="line">    return (x&amp;-x);</span><br><span class="line">&#125;</span><br><span class="line">LL sum(int x)&#123;&#x2F;&#x2F;求和1～x</span><br><span class="line">    LL ans&#x3D;0;</span><br><span class="line">    while(x&gt;0)&#123;</span><br><span class="line">        ans+&#x3D;c[x];</span><br><span class="line">        x-&#x3D;lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">void add(int x,int d)&#123;&#x2F;&#x2F;更新</span><br><span class="line">    while(x&lt;&#x3D;n)&#123;</span><br><span class="line">        c[x]+&#x3D;d;</span><br><span class="line">        x+&#x3D;lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    pair&lt;int,int&gt;a[N];</span><br><span class="line">    int ans&#x3D;0;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;&#x2F;&#x2F;first记录数字，second记录数字所在位子</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i].first);</span><br><span class="line">        a[i].second&#x3D;i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+1,a+1+n);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)tmp[a[i].second]&#x3D;i;</span><br><span class="line">    &#x2F;&#x2F;tmp[i]存的是第i位上的数排第几小</span><br><span class="line">    &#x2F;&#x2F;和上面结合起来其实是做了离散化的操作</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        add(tmp[i],1);</span><br><span class="line">        ans+&#x3D;i-sum(tmp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;100005;</span><br><span class="line">int ans&#x3D;0,a[N],c[N];</span><br><span class="line">void merges(int l,int mid,int r)&#123;&#x2F;&#x2F;并</span><br><span class="line">    int p&#x3D;l,q&#x3D;l,m&#x3D;mid+1;</span><br><span class="line">    while(p&lt;&#x3D;mid&amp;&amp;m&lt;&#x3D;r)&#123;</span><br><span class="line">        if(a[p]&lt;&#x3D;a[m])c[q++]&#x3D;a[p++];</span><br><span class="line">        else&#123;</span><br><span class="line">            c[q++]&#x3D;a[m++];</span><br><span class="line">            ans+&#x3D;(m-q);&#x2F;&#x2F;计算逆序数</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(p&lt;&#x3D;mid)c[q++]&#x3D;a[p++];</span><br><span class="line">    while(m&lt;&#x3D;r)c[q++]&#x3D;a[m++];</span><br><span class="line">    for(int i&#x3D;l;i&lt;q;i++)a[i]&#x3D;c[i];</span><br><span class="line">&#125;</span><br><span class="line">void merge_sort(int l,int r)&#123;&#x2F;&#x2F;归</span><br><span class="line">    if(l&lt;r)&#123;</span><br><span class="line">        int m&#x3D;(l+r)&#x2F;2;</span><br><span class="line">        merge_sort(l,m);</span><br><span class="line">        merge_sort(m+1,r);</span><br><span class="line">        merges(l,m,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    merge_sort(0,n-1);</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>1005 大数加法</title>
    <url>/1076b80c/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB </p>
<p>给出2个大整数A,B，计算A+B的结果。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：大数A<br>第2行：大数B<br>(A,B的长度 &lt;= 10000 需注意：A B有可能为负数）</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出A + B</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">68932147586</span><br><span class="line">468711654886</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">537643802472</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;  </span><br><span class="line">import java.math.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">        int t;</span><br><span class="line">        BigInteger a,b,c;</span><br><span class="line">        a&#x3D;cin.nextBigInteger();</span><br><span class="line">        b&#x3D;cin.nextBigInteger();</span><br><span class="line">        c&#x3D;a.add(b);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">        cin.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>1008 N的阶乘 mod P</title>
    <url>/ba46f35b/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB</p>
<p>输入N和P（P为质数），求N! Mod P = ? (Mod 就是求模 %)</p>
<a id="more"></a>

<p>例如：n = 10， P = 11，10! = 3628800<br>3628800 % 11 = 10</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>两个数N,P，中间用空格隔开。(N &lt; 10000, P &lt; 10^9)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出N! mod P的结果。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 11</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">int main()&#123;</span><br><span class="line">	LL n,p,ans&#x3D;1;</span><br><span class="line">	scanf(&quot;%lld%lld&quot;,&amp;n,&amp;p);</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		ans&#x3D;(ans*i)%p;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>1000 A + B</title>
    <url>/9c67c163/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB </p>
<p>给出2个整数A和B，计算两个数的和。</p>
<a id="more"></a>

<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>2个整数A B，中间用空格分割。（0 &lt;= A, B &lt;= 10^9）</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出A + B的计算结果。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<hr>
<p>不集齐全部题目。。就有点。。难受</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">int main()&#123;</span><br><span class="line">	LL a,b;</span><br><span class="line">	scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b);</span><br><span class="line">	printf(&quot;%lld\n&quot;,a+b);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>1012 最小公倍数LCM</title>
    <url>/ec404005/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB</p>
<p>输入2个正整数A，B，求A与B的最小公倍数。</p>
<a id="more"></a>

<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>2个数A,B，中间用空格隔开。(1&lt;= A,B &lt;= 10^9)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出A与B的最小公倍数。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">30 105</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">210</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">LL gcd(LL a,LL b)&#123;</span><br><span class="line">    return b&#x3D;&#x3D;0?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	LL a,b;</span><br><span class="line">	scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b);</span><br><span class="line">	printf(&quot;%lld\n&quot;,a*b&#x2F;gcd(a,b));</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>1018 排序</title>
    <url>/5fc91746/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB </p>
<p>给出N个整数，对着N个整数进行排序</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：整数的数量N（1 &lt;= N &lt;= 50000)<br>第2 - N + 1行：待排序的整数（-10^9 &lt;= A[i] &lt;= 10^9）</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>共n行，按照递增序输出排序好的数据。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<hr>
<p>归并排序</p>
<p>sort</p>
<p>原来不写一堆头文件会变快的么0.0？？sort那个去了一堆头文件之后从203ms到了15ms。。。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;50005;</span><br><span class="line">int a[N],c[N];</span><br><span class="line">void merges(int l,int mid,int r)&#123;&#x2F;&#x2F;并</span><br><span class="line">    int p&#x3D;l,q&#x3D;l,m&#x3D;mid+1;</span><br><span class="line">    while(p&lt;&#x3D;mid&amp;&amp;m&lt;&#x3D;r)&#123;</span><br><span class="line">        if(a[p]&lt;&#x3D;a[m])c[q++]&#x3D;a[p++];</span><br><span class="line">        else&#123;</span><br><span class="line">            c[q++]&#x3D;a[m++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(p&lt;&#x3D;mid)c[q++]&#x3D;a[p++];</span><br><span class="line">    while(m&lt;&#x3D;r)c[q++]&#x3D;a[m++];</span><br><span class="line">    for(int i&#x3D;l;i&lt;q;i++)a[i]&#x3D;c[i];</span><br><span class="line">&#125;</span><br><span class="line">void merge_sort(int l,int r)&#123;&#x2F;&#x2F;归</span><br><span class="line">    if(l&lt;r)&#123;</span><br><span class="line">        int m&#x3D;(l+r)&#x2F;2;</span><br><span class="line">        merge_sort(l,m);</span><br><span class="line">        merge_sort(m+1,r);</span><br><span class="line">        merges(l,m,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    merge_sort(0,n-1);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)printf(&quot;%d\n&quot;,a[i]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;50005;</span><br><span class="line">int a[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    sort(a,a+n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)printf(&quot;%d\n&quot;,a[i]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>1011 最大公约数GCD</title>
    <url>/57427b30/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB</p>
<p>输入2个正整数A，B，求A与B的最大公约数。</p>
<a id="more"></a>

<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>2个数A,B，中间用空格隔开。(1&lt;= A,B &lt;= 10^9)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出A与B的最大公约数。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">30 105</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure>
<hr>
<p>毫无意义的水了一发。。只是想把51nod基础题那个分类凑齐而已。。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int gcd(int a,int b)&#123;</span><br><span class="line">    return b&#x3D;&#x3D;0?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int a,b;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">	printf(&quot;%d\n&quot;,gcd(a,b));</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>1027 大数乘法（java大数）</title>
    <url>/47a64668/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB </p>
<p>给出2个大整数A,B，计算<code>A*B</code>的结果。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：大数A<br>第2行：大数B<br>(A,B的长度 &lt;= 1000，A,B &gt;= 0）</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出A * B</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123456</span><br><span class="line">234567</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">28958703552</span><br></pre></td></tr></table></figure>
<hr>
<p>水。。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;  </span><br><span class="line">import java.math.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">        BigInteger a,b;</span><br><span class="line">        a&#x3D;cin.nextBigInteger();</span><br><span class="line">        b&#x3D;cin.nextBigInteger();</span><br><span class="line">        System.out.println(a.multiply(b));</span><br><span class="line">        cin.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>1006 最长公共子序列Lcs（dp+路径打印）</title>
    <url>/6bb0247a/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB </p>
<p>给出两个字符串A B，求A与B的最长公共子序列（子序列不要求是连续的）。</p>
<a id="more"></a>

<p>比如两个串为：</p>
<p>abcicba<br>abdkscab</p>
<p>ab是两个串的子序列，abc也是，abca也是，其中abca是这两个字符串最长的子序列。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：字符串A</p>
<p>第2行：字符串B</p>
<p>(A,B的长度 &lt;= 1000)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出最长的子序列，如果有多个，随意输出1个。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abcicba</span><br><span class="line">abdkscab</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abca</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>基础lcs加上一个路径打印</p>
<p>dp[i][j]表示s1的前i个和s2的前j个的最长公共子序列</p>
<p>状态转移方程是 dp[i+1][j+1]=max(dp[i+1][j],dp[i][j+1],dp[i][j]+(s1[i]==s2[j]?1:0))</p>
<p>路径打印见代码注释，根据dp关系写出路径</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;1005;</span><br><span class="line">char s1[N],s2[N],ans[N];</span><br><span class="line">int dp[N][N],len1,len2;</span><br><span class="line">void lcs()&#123;</span><br><span class="line">    for(int i&#x3D;0;i&lt;len1;i++)&#123;</span><br><span class="line">        for(int j&#x3D;0;j&lt;len2;j++)&#123;</span><br><span class="line">            if(s1[i]&#x3D;&#x3D;s2[j])dp[i+1][j+1]&#x3D;dp[i][j]+1;</span><br><span class="line">            else dp[i+1][j+1]&#x3D;max(dp[i+1][j],dp[i][j+1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%s %s&quot;,s1,s2);</span><br><span class="line">    len1&#x3D;strlen(s1);len2&#x3D;strlen(s2);</span><br><span class="line">    lcs();</span><br><span class="line">    int c1&#x3D;len1-1,c2&#x3D;len2-1;</span><br><span class="line">    int ji&#x3D;0;</span><br><span class="line">    while(c1&gt;&#x3D;0&amp;&amp;c2&gt;&#x3D;0)&#123;</span><br><span class="line">        if(s1[c1]&#x3D;&#x3D;s2[c2])&#123;</span><br><span class="line">            ans[ji++]&#x3D;s1[c1];</span><br><span class="line">            c1--;c2--;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(dp[c1+1][c2]&gt;&#x3D;dp[c1][c2+1])c2--;</span><br><span class="line">        &#x2F;&#x2F;说明答案出自s1的[0,c1]和s2的[0,c2-1]</span><br><span class="line">        else c1--;</span><br><span class="line">        &#x2F;&#x2F;同理答案出自s1的[0,c1-1]和s2的[0,c2]</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;ji-1;i&gt;&#x3D;0;i--)printf(&quot;%c&quot;,ans[i]);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>1066 Bash游戏（巴什博弈）</title>
    <url>/f715085c/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB </p>
<p>有一堆石子共有N个。A B两个人轮流拿，A先拿。每次最少拿1颗，最多拿K颗，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N和K，问最后谁能赢得比赛。</p>
<a id="more"></a>

<p>例如N = 3，K = 2。无论A如何拿，B都可以拿到最后1颗石子。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 10000)</p>
<p>第2 - T + 1行：每行2个数N，K。中间用空格分隔。（1 &lt;= N,K &lt;= 10^9)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>共T行，如果A获胜输出A，如果B获胜输出B。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">3 2</span><br><span class="line">4 2</span><br><span class="line">7 3</span><br><span class="line">8 3</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p><a href="https://leflacon.github.io/a4b21e43/" target="_blank" rel="noopener">hdu 1846 Brave Game（巴什博弈）
</a></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        int n,k;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;n,&amp;k);</span><br><span class="line">        if(n%(k+1)&#x3D;&#x3D;0)puts(&quot;B&quot;);</span><br><span class="line">        else puts(&quot;A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>1046 A^B Mod C（快速幂）</title>
    <url>/3c67f84b/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB </p>
<p>给出3个正整数A B C，求A^B Mod C。</p>
<p>例如，3 5 8，3^5 Mod 8 = 3。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>3个正整数A B C，中间用空格分隔。(1 &lt;= A,B,C &lt;= 10^9)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出计算结果</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 5 8</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long </span><br><span class="line">LL qpow(LL a,LL b,LL p)&#123;</span><br><span class="line">    LL ans&#x3D;1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            ans&#x3D;(ans*a)%p;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        b&gt;&gt;&#x3D;1;</span><br><span class="line">        a&#x3D;a*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    LL a,b,c;</span><br><span class="line">    scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    printf(&quot;%lld\n&quot;,qpow(a,b,c));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>1069 Nim游戏（尼姆博弈）</title>
    <url>/c2af3f7c/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB</p>
<p>有N堆石子。A B两个人轮流拿，A先拿。每次只能从一堆中取若干个，可将一堆全取走，但不可不取，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N及每堆石子的数量，问最后谁能赢得比赛。</p>
<p>例如：3堆石子，每堆1颗。A拿1颗，B拿1颗，此时还剩1堆，所以A可以拿到最后1颗石子。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：一个数N，表示有N堆石子。（1 &lt;= N &lt;= 1000)</p>
<p>第2 - N + 1行：N堆石子的数量。(1 &lt;= A[i] &lt;= 10^9)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>如果A获胜输出A，如果B获胜输出B。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>[hdu 2176 取(m堆)石子游戏（尼姆博弈）]<a href="https://leflacon.github.io/42b4455d/" target="_blank" rel="noopener">https://leflacon.github.io/42b4455d/</a></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;200005;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    int sum&#x3D;0,c[N];</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;c[i]);</span><br><span class="line">        sum^&#x3D;c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    if(sum&#x3D;&#x3D;0)printf(&quot;B\n&quot;);</span><br><span class="line">    else printf(&quot;A\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>1049 最大子段和（dp）</title>
    <url>/84babd30/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB </p>
<p>N个整数组成的序列a[1],a[2],a[3],…,a[n]，求该序列如a[i]+a[i+1]+…+a[j]的连续子段和的最大值。当所给的整数均为负数时和为0。</p>
<a id="more"></a>

<p>例如：-2,11,-4,13,-5,-2，和最大的子段为：11,-4,13。和为20。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：整数序列的长度N（2 &lt;= N &lt;= 50000)<br>第2 - N + 1行：N个整数（-10^9 &lt;= A[i] &lt;= 10^9）</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出最大子段和。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">-2</span><br><span class="line">11</span><br><span class="line">-4</span><br><span class="line">13</span><br><span class="line">-5</span><br><span class="line">-2</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>dp[i]表示以a[i]结尾的最大子段和是多少</p>
<p>状态转移方程 dp[i]=max(a[i],dp[i-1]+a[i])，也就是说如果dp[i-1]小于0，那么前面都不要了直接从a[i]继续连</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;50005;</span><br><span class="line">LL a[N],dp[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%lld&quot;,&amp;a[i]);</span><br><span class="line">    LL ans&#x3D;a[0];</span><br><span class="line">    dp[0]&#x3D;a[0];</span><br><span class="line">    for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">        dp[i]&#x3D;max(a[i],dp[i-1]+a[i]);</span><br><span class="line">        ans&#x3D;max(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>1072 威佐夫游戏</title>
    <url>/ec8b12a4/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB </p>
<p>有2堆石子。A B两个人轮流拿，A先拿。每次可以从一堆中取任意个或从2堆中取相同数量的石子，但不可不取。拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出2堆石子的数量，问最后谁能赢得比赛。</p>
<p>例如：2堆石子分别为3颗和5颗。那么不论A怎样拿，B都有对应的方法拿到最后1颗。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 10000)</p>
<p>第2 - T + 1行：每行2个数分别是2堆石子的数量，中间用空格分隔。(1 &lt;= N &lt;= 2000000)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>共T行，如果A获胜输出A，如果B获胜输出B。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">3 5</span><br><span class="line">3 4</span><br><span class="line">1 9</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B</span><br><span class="line">A</span><br><span class="line">A</span><br></pre></td></tr></table></figure>
<hr>
<p>水。。</p>
<p>威佐夫博弈原理在博客的这篇里  –&gt;  hdu 2177 取(2堆)石子游戏（威佐夫博弈）<br><a href="https://leflacon.github.io/eb18b91b/" target="_blank" rel="noopener">https://leflacon.github.io/eb18b91b/</a></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a,b,t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">        if(a&gt;b)&#123;</span><br><span class="line">            int temp&#x3D;a;a&#x3D;b;b&#x3D;temp;</span><br><span class="line">        &#125;</span><br><span class="line">        if((int)((sqrt(5)+1)*(b-a)&#x2F;2)&#x3D;&#x3D;a)printf(&quot;B\n&quot;);</span><br><span class="line">        else printf(&quot;A\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>1057 N的阶乘（java大数）</title>
    <url>/d377a60d/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB</p>
<p>输入N求N的阶乘的准确值。</p>
<a id="more"></a>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入N(1 &lt;= N &lt;= 10000)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出N的阶乘</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">120</span><br></pre></td></tr></table></figure>
<hr>
<p>水一发java。。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;  </span><br><span class="line">import java.math.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">        BigInteger n;</span><br><span class="line">        n&#x3D;cin.nextBigInteger();</span><br><span class="line">        int num&#x3D;n.intValue();</span><br><span class="line">        for(int i&#x3D;1;i&lt;num;i++)n&#x3D;n.multiply(BigInteger.valueOf(i));</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        cin.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>1088 最长回文子串（Manacher算法）</title>
    <url>/b4c7585b/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB</p>
<p>回文串是指aba、abba、cccbccc、aaaa这种左右对称的字符串。<br>输入一个字符串Str，输出Str里最长回文子串的长度。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入Str（Str的长度 &lt;= 1000）</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出最长回文子串的长度L。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daabaac</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>这题数据范围水。。不用马拉车也能水过去，1089那题必须用o(n)的马拉车</p>
<p><a href="https://segmentfault.com/a/1190000003914228" target="_blank" rel="noopener">最长回文子串——Manacher 算法</a></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;100005;</span><br><span class="line">int p[N&lt;&lt;1],ji,len,ans&#x3D;0,maxl&#x3D;0,cur&#x3D;0;</span><br><span class="line">char s[N],ss[N&lt;&lt;1];</span><br><span class="line">void init()&#123;</span><br><span class="line">    ji&#x3D;0;</span><br><span class="line">    ss[ji]&#x3D;&#39;@&#39;;</span><br><span class="line">    for(int i&#x3D;0;i&lt;len;i++)&#123;</span><br><span class="line">        ss[++ji]&#x3D;&#39;#&#39;;</span><br><span class="line">        ss[++ji]&#x3D;s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ss[++ji]&#x3D;&#39;#&#39;;</span><br><span class="line">&#125;</span><br><span class="line">void manacher()&#123;</span><br><span class="line">    len&#x3D;ji;</span><br><span class="line">    for(int i&#x3D;1;i&lt;ji;i++)&#123;</span><br><span class="line">        if(i&lt;maxl)p[i]&#x3D;min(maxl-i,p[2*cur-i]);&#x2F;&#x2F;小于最长边界</span><br><span class="line">        else p[i]&#x3D;1;&#x2F;&#x2F;边界外，初始化为1，然后扩展直到不配对</span><br><span class="line">        while(ss[i+p[i]]&#x3D;&#x3D;ss[i-p[i]])p[i]++;&#x2F;&#x2F;直到不配对</span><br><span class="line">        ans&#x3D;max(ans,p[i]);&#x2F;&#x2F;更新答案</span><br><span class="line">        if(p[i]+i&gt;maxl)&#123;&#x2F;&#x2F;更新最长边界</span><br><span class="line">            cur&#x3D;i;</span><br><span class="line">            maxl&#x3D;p[i]+i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%s&quot;,s);</span><br><span class="line">    len&#x3D;strlen(s);</span><br><span class="line">    init();</span><br><span class="line">    manacher();</span><br><span class="line">    printf(&quot;%d\n&quot;,ans-1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>1089 最长回文子串 V2（Manacher算法）</title>
    <url>/e4c2cc13/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB </p>
<p>回文串是指aba、abba、cccbccc、aaaa这种左右对称的字符串。</p>
<p>输入一个字符串Str，输出Str里最长回文子串的长度。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入Str（Str的长度 &lt;= 100000)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出最长回文子串的长度L。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daabaac</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>对马拉车算法的原理还是半知半解乱七八糟。。以后再想吧。。</p>
<p><a href="https://segmentfault.com/a/1190000003914228" target="_blank" rel="noopener">最长回文子串——Manacher 算法</a></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;100005;</span><br><span class="line">int p[N&lt;&lt;1],ji,len,ans&#x3D;0,maxl&#x3D;0,cur&#x3D;0;</span><br><span class="line">char s[N],ss[N&lt;&lt;1];</span><br><span class="line">void init()&#123;</span><br><span class="line">    ji&#x3D;0;</span><br><span class="line">    ss[ji]&#x3D;&#39;@&#39;;</span><br><span class="line">    for(int i&#x3D;0;i&lt;len;i++)&#123;</span><br><span class="line">        ss[++ji]&#x3D;&#39;#&#39;;</span><br><span class="line">        ss[++ji]&#x3D;s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ss[++ji]&#x3D;&#39;#&#39;;</span><br><span class="line">&#125;</span><br><span class="line">void manacher()&#123;</span><br><span class="line">    len&#x3D;ji;</span><br><span class="line">    for(int i&#x3D;1;i&lt;ji;i++)&#123;</span><br><span class="line">        if(i&lt;maxl)p[i]&#x3D;min(maxl-i,p[2*cur-i]);&#x2F;&#x2F;小于最长边界</span><br><span class="line">        else p[i]&#x3D;1;&#x2F;&#x2F;边界外，初始化为1，然后扩展直到不配对</span><br><span class="line">        while(ss[i+p[i]]&#x3D;&#x3D;ss[i-p[i]])p[i]++;&#x2F;&#x2F;直到不配对</span><br><span class="line">        ans&#x3D;max(ans,p[i]);&#x2F;&#x2F;更新答案</span><br><span class="line">        if(p[i]+i&gt;maxl)&#123;&#x2F;&#x2F;更新最长边界</span><br><span class="line">            cur&#x3D;i;</span><br><span class="line">            maxl&#x3D;p[i]+i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%s&quot;,s);</span><br><span class="line">    len&#x3D;strlen(s);</span><br><span class="line">    init();</span><br><span class="line">    manacher();</span><br><span class="line">    printf(&quot;%d\n&quot;,ans-1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>1058 N的阶乘的长度（斯特林公式）</title>
    <url>/d51ad0f1/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB </p>
<p>输入N求N的阶乘的10进制表示的长度。例如6! = 720，长度为3。</p>
<a id="more"></a>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入N(1 &lt;= N &lt;= 10^6)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出N的阶乘的长度</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<hr>
<p>又水了一题。。</p>
<p>关于斯特林公式的解释看这篇<a href="https://leflacon.github.io/41d56d9c/" target="_blank" rel="noopener">1130 N的阶乘的长度 V2（斯特林公式取n阶乘位数）</a></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const double PI&#x3D;asin(1.0)*2,e&#x3D;2.718281828459;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    LL ans&#x3D;0.5*log10(2.0*PI*n)+n*log10(1.0*n&#x2F;e)+1;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>1081 子段求和（前缀和，树状数组，线段树）</title>
    <url>/304f1fc6/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB </p>
<p>给出一个长度为N的数组，进行Q次查询，查询从第i个元素开始长度为l的子段所有元素之和。<br>例如，1 3 7 9 -1，查询第2个元素开始长度为3的子段和，1 {3 7 9} -1。3 + 7 + 9 = 19，输出19。</p>
<a id="more"></a>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：一个数N，N为数组的长度(2 &lt;= N &lt;= 50000)。</p>
<p>第2 至 N + 1行：数组的N个元素。(-10^9 &lt;= N[i] &lt;= 10^9)<br>第N + 2行：1个数Q，Q为查询的数量。</p>
<p>第N + 3 至 N + Q + 2行：每行2个数，i，l（1 &lt;= i &lt;= N，i + l &lt;= N)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>共Q行，对应Q次查询的计算结果。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">7</span><br><span class="line">9</span><br><span class="line">-1</span><br><span class="line">4</span><br><span class="line">1 2</span><br><span class="line">2 2</span><br><span class="line">3 2</span><br><span class="line">1 5</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">10</span><br><span class="line">16</span><br><span class="line">19</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>第一段先水一波前缀和,281ms</p>
<p>第二段再水一波树状数组，281ms</p>
<p>之前一直不是很懂树状数组原理，看了这篇突然有点懂了0.0 <a href="https://blog.csdn.net/int64ago/article/details/7429868" target="_blank" rel="noopener">搞懂树状数组</a></p>
<p>第三段最后水一波线段树，312ms</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;50005;</span><br><span class="line">LL sum[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,q,l,r;</span><br><span class="line">    LL c;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    sum[0]&#x3D;0;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%lld&quot;,&amp;c);</span><br><span class="line">        sum[i]&#x3D;sum[i-1]+c;</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;q);</span><br><span class="line">    while(q--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;l,&amp;r);</span><br><span class="line">        printf(&quot;%lld\n&quot;,sum[l+r-1]-sum[l-1]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;50005;</span><br><span class="line">LL c[N],a[N],n;</span><br><span class="line">int lowbit(int x)&#123;</span><br><span class="line">    return (x&amp;-x);</span><br><span class="line">&#125;</span><br><span class="line">LL sum(int x)&#123;&#x2F;&#x2F;求和1～x</span><br><span class="line">    LL ans&#x3D;0;</span><br><span class="line">    while(x&gt;0)&#123;</span><br><span class="line">        ans+&#x3D;c[x];</span><br><span class="line">        x-&#x3D;lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">void add(int x,int d)&#123;&#x2F;&#x2F;更新</span><br><span class="line">    while(x&lt;&#x3D;n)&#123;</span><br><span class="line">        c[x]+&#x3D;d;</span><br><span class="line">        x+&#x3D;lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int q,l,r;</span><br><span class="line">    LL c;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%lld&quot;,&amp;a[i]);</span><br><span class="line">        add(i,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;q);</span><br><span class="line">    while(q--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;l,&amp;r);</span><br><span class="line">        printf(&quot;%lld\n&quot;,sum(l+r-1)-sum(l-1));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">#define lson l,m,rt&lt;&lt;1</span><br><span class="line">#define rson m+1,r,rt&lt;&lt;1|1</span><br><span class="line">const int N&#x3D;50005;</span><br><span class="line"></span><br><span class="line">LL sum[N&lt;&lt;2];</span><br><span class="line">void pushup(int rt)&#123;</span><br><span class="line">    sum[rt]&#x3D;sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1];</span><br><span class="line">&#125; </span><br><span class="line">void build(int l,int r,int rt)&#123;</span><br><span class="line">    if(l&#x3D;&#x3D;r)&#123;</span><br><span class="line">        scanf(&quot;%lld&quot;,&amp;sum[rt]);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int m&#x3D;(l+r)&gt;&gt;1;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line">void update(int p,int add,int l,int r,int rt)&#123;</span><br><span class="line">    if(l&#x3D;&#x3D;r)&#123;</span><br><span class="line">        sum[rt]+&#x3D;add;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int m&#x3D;(l+r)&gt;&gt;1;</span><br><span class="line">    if(p&lt;&#x3D;m)update(p,add,lson);</span><br><span class="line">    else update(p,add,rson);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line">LL query(int L,int R,int l,int r,int rt)&#123;</span><br><span class="line">    if(L&lt;&#x3D;l&amp;&amp;R&gt;&#x3D;r)&#123;</span><br><span class="line">        return sum[rt];</span><br><span class="line">    &#125; </span><br><span class="line">    int m&#x3D;(l+r)&gt;&gt;1;</span><br><span class="line">    LL ans&#x3D;0;</span><br><span class="line">    if(L&lt;&#x3D;m)ans+&#x3D;query(L,R,lson);</span><br><span class="line">    if(R&gt;m)ans+&#x3D;query(L,R,rson);</span><br><span class="line">    return ans;</span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    build(1,n,1);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        int a,b;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">        printf(&quot;%lld\n&quot;,query(a,a+b-1,1,n,1));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>1257 背包问题 V3（分数规划，二分）</title>
    <url>/f0565075/</url>
    <content><![CDATA[<p>基准时间限制：3 秒 空间限制：131072 KB 51nod5级算法题</p>
<p>N个物品的体积为W1，W2……Wn（Wi为整数），与之相对应的价值为P1,P2……Pn（Pi为整数），从中选出K件物品（K &lt;= N)，使得单位体积的价值最大。</p>
<a id="more"></a>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：包括2个数N, K(1 &lt;= K &lt;= N &lt;= 50000)</p>
<p>第2 - N + 1行：每行2个数Wi, Pi（1 &lt;= Wi, Pi &lt;= 50000)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出单位体积的价值（用约分后的分数表示）。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">2 2</span><br><span class="line">5 3</span><br><span class="line">2 1</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3&#x2F;4</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>一开始以为是贪心，直接取pi/wi最大的那k个，然后想想不对，因为如果p1=1,p2=101,w1=1000,w2=100000,如果照这种贪心策略就取第二个，但是这样体积很大，假如当前最优的W，P还需这两个之中的一个，那么(1+P)/(1000+W)可能比(101+P)/(100000+W)更优</p>
<p>所以贪心只能保证个体最优，却不能保证全局最优</p>
<p>这题的思路应当是二分单位体积最大价值，然后判断是否合法即可，也有用到贪心，不过不是上面那种贪心思路</p>
<p>判断是否合法的方法是，假设单位体积最大价值是p，<code>wp[i].v=wp[i].p-wp[i].w*p</code>，<code>wp[i].w*p</code>是当前物品体积需要的价值，然后就是贪心取最大的k个将其v值相加，判断是否大于等于0即可，因为反正多退少补的原则，大于等于0就合法</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">#define eps 1e-6</span><br><span class="line">const int N&#x3D;50005;</span><br><span class="line">LL x,y;</span><br><span class="line">int n,k;</span><br><span class="line">struct WP&#123;</span><br><span class="line">    int w,p;</span><br><span class="line">    double v;</span><br><span class="line">&#125;wp[N];</span><br><span class="line">bool cmp(struct WP wp1,struct WP wp2)&#123;</span><br><span class="line">    return wp1.v&gt;wp2.v;</span><br><span class="line">&#125;</span><br><span class="line">LL gcd(LL a,LL b)&#123;</span><br><span class="line">    return b&#x3D;&#x3D;0?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">bool ok(double p)&#123;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)wp[i].v&#x3D;wp[i].p-wp[i].w*p;</span><br><span class="line">    sort(wp,wp+n,cmp);</span><br><span class="line">    x&#x3D;0;y&#x3D;0;double lp&#x3D;0.0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;k;i++)&#123;</span><br><span class="line">        x+&#x3D;wp[i].p;</span><br><span class="line">        y+&#x3D;wp[i].w;</span><br><span class="line">        lp+&#x3D;wp[i].v;</span><br><span class="line">    &#125;</span><br><span class="line">    if(lp&gt;&#x3D;0)return true;</span><br><span class="line">    else return false;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d%d&quot;,&amp;wp[i].w,&amp;wp[i].p);</span><br><span class="line">    double l&#x3D;0,r&#x3D;50000,m;</span><br><span class="line">    LL fz,fm;</span><br><span class="line">    while(fabs(l-r)&gt;eps)&#123;</span><br><span class="line">        m&#x3D;(l+r)&#x2F;2;</span><br><span class="line">        if(ok(m))&#123;</span><br><span class="line">            l&#x3D;m;</span><br><span class="line">            fz&#x3D;x;fm&#x3D;y;</span><br><span class="line">        &#125;</span><br><span class="line">        else r&#x3D;m;</span><br><span class="line">    &#125;</span><br><span class="line">    LL G&#x3D;gcd(max(fz,fm),min(fz,fm));</span><br><span class="line">    fz&#x2F;&#x3D;G;</span><br><span class="line">    fm&#x2F;&#x3D;G;</span><br><span class="line">    printf(&quot;%lld&#x2F;%lld\n&quot;,fz,fm);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1086 背包问题 V2（二进制优化多重背包）</title>
    <url>/e7b555f8/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB  51nod4级算法题</p>
<p>有N种物品，每种物品的数量为C1，C2……Cn。从中任选若干件放在容量为W的背包里，每种物品的体积为W1，W2……Wn（Wi为整数），与之相对应的价值为P1,P2……Pn（Pi为整数）。求背包能够容纳的最大价值。</p>
<a id="more"></a>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行，2个整数，N和W中间用空格隔开。N为物品的种类，W为背包的容量。(1 &lt;= N &lt;= 100，1 &lt;= W &lt;= 50000)<br>第2 - N + 1行，每行3个整数，Wi，Pi和Ci分别是物品体积、价值和数量。(1 &lt;= Wi, Pi &lt;= 10000， 1 &lt;= Ci &lt;= 200)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出可以容纳的最大价值。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 6</span><br><span class="line">2 2 5</span><br><span class="line">3 3 8</span><br><span class="line">1 4 1</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>先是水水的01背包<a href="https://leflacon.github.io/cb821a33/" target="_blank" rel="noopener">1085 背包问题（01背包）</a></p>
<p>这题与01背包不同在于每件物品有多个，思路还是一样，多一步把相同价值和重量的物品看成不同的物品，再按01背包的算法解决，但是01背包那个复杂度是<code>o（n*W）</code>，多重背包的n相当于c1+c2+……+cn，所以用二进制进一步优化</p>
<p>不把n件相同物品看成不同的n件，而是看成<code>(w,v),(2*w,2*v),(2^2*w,2^2*v)...</code>这样的形式，比如有15个价值1重量1的物品，就看成（1，1）（2，2）（4，4）（8，8）这样四件物品，14个就看成（1，1）（2，2）（4，4）（7，7），不是直接看二进制为1的位，而是要保证分出来的这些数能凑出[1,c]的所有数，这样就能用少少的物品数涵盖所有情况了</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;1005;</span><br><span class="line">int dp[50005],w[N],p[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,W,ww,pp,c;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;W);</span><br><span class="line">    int ji&#x3D;0;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;ww,&amp;pp,&amp;c);</span><br><span class="line">        int tmp&#x3D;1;</span><br><span class="line">        while(c)&#123;</span><br><span class="line">            if(c&gt;&#x3D;tmp)&#123;</span><br><span class="line">                w[++ji]&#x3D;tmp*ww;</span><br><span class="line">                p[ji]&#x3D;tmp*pp;</span><br><span class="line">                c-&#x3D;tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                w[++ji]&#x3D;c*ww;</span><br><span class="line">                p[ji]&#x3D;c*pp;</span><br><span class="line">                c&#x3D;0;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp*&#x3D;2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;ji;i++)&#123;</span><br><span class="line">        for(int j&#x3D;W;j&gt;&#x3D;w[i];j--)</span><br><span class="line">            dp[j]&#x3D;max(dp[j],dp[j-w[i]]+p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,dp[W]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>1085 背包问题（01背包）</title>
    <url>/cb821a33/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB </p>
<p>在N件物品取出若干件放在容量为W的背包里，每件物品的体积为W1，W2……Wn（Wi为整数），与之相对应的价值为P1,P2……Pn（Pi为整数）。求背包能够容纳的最大价值。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行，2个整数，N和W中间用空格隔开。N为物品的数量，W为背包的容量。(1 &lt;= N &lt;= 100，1 &lt;= W &lt;= 10000)<br>第2 - N + 1行，每行2个整数，Wi和Pi，分别是物品的体积和物品的价值。(1 &lt;= Wi, Pi &lt;= 10000)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出可以容纳的最大价值。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 6</span><br><span class="line">2 5</span><br><span class="line">3 8</span><br><span class="line">4 9</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>01背包水题 </p>
<p>dp[w]表示容量为w能放的最大价值</p>
<p>dp[j]=max(dp[j],dp[j-w]+p);就是第i个物品不取和取</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;10005;</span><br><span class="line">int dp[N],a[105];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,W,w,p;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;W);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;w,&amp;p);</span><br><span class="line">        for(int j&#x3D;W;j&gt;&#x3D;w;j--)</span><br><span class="line">            dp[j]&#x3D;max(dp[j],dp[j-w]+p);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,dp[W]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>1073 约瑟夫环（递推）</title>
    <url>/59d4cd0/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB </p>
<p>N个人坐成一个圆环（编号为1 - N），从第1个人开始报数，数到K的人出列，后面的人重新从1开始报数。问最后剩下的人的编号。</p>
<a id="more"></a>

<p>例如：N = 3，K = 2。2号先出列，然后是1号，最后剩下的是3号。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>2个数N和K，表示N个人，数到K出列。(2 &lt;= N, K &lt;= 10^6)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>最后剩下的人的编号</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>好像是大一c++作业，当时还是直接模拟写的2333333</p>
<p>约瑟夫环结论见代码</p>
<p>证明如下：</p>
<p>n个人，编号1-n，从1开始报数，报到k的退出，剩下人继续从1开始报数</p>
<p>第一个人编号（k%n）出列，剩下的n-1个人组成一个新的约瑟夫环，从编号（k%n+1）开始，k+1,k+2…n-2,n-1,n,1,2…k-2,k-1，编号k+1的人报1，那么重新编号一下k+1-&gt;1,k+2-&gt;2…k-2-&gt;n-2,k-1-&gt;n-1，变成了n-1个人报数的子问题</p>
<p>那么根据这个新编号可以得到变回原编号的方程，即得到n个人情况的解，变回去的公式是，x’=(x+k)%n，所以问题就结束了，递推，要知道n-1人问题的解，只需要知道n-2人问题的解，然后继续往前得知道n-3问题的解</p>
<p>令f[i]表示i个人玩游戏报k退出最后胜利者的编号，f[1]=1; f[i]=(f[i-1]+k)%i; (i&gt;1) 有了这个公式，从2-n顺序算出f[i]的数值，编号从1开始，所以最后答案输出f[n]+1</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,k;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);</span><br><span class="line">    int ans&#x3D;0;</span><br><span class="line">    for(int i&#x3D;2;i&lt;&#x3D;n;i++)ans&#x3D;(ans+k)%i;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans+1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>1106 质数检测（米勒罗宾判素数和直接判）</title>
    <url>/41f5723f/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB </p>
<p>给出N个正整数，检测每个数是否为质数。如果是，输出”Yes”，否则输出”No”。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：一个数N，表示正整数的数量。(1 &lt;= N &lt;= 1000)<br>第2 - N + 1行：每行1个数(2 &lt;= S[i] &lt;= 10^9)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出共N行，每行为 Yes 或 No。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>第一个代码是不知出自何处的米勒罗宾判素数的模版，懒得研究了直接模版吧。。这里设置了50次循环</p>
<p>反正原理是费马小定理，假如a是整数，p是质数，且a,p互质，那么a^(p-1)%p=1恒成立，</p>
<p>即若 a^(p-1)%p !=1 <code>(0&lt;a&lt;p)</code>，p一定是合数，若 a^(p-1)%p ==1 <code>(0&lt;a&lt;p)</code> 则它可能是合数可能是素数，概率算法的概率就在这个 a上体现</p>
<p>第二个代码是榜上学来的方法，这个想法蛮妙蛮清晰的，跑的比第一个快，就是先埃筛，然后先直接干掉偶数，对于奇数n，向上取整根号n得到e，然后如果所有[2,e]的质数都不能整除n的话，那么n肯定是个质数</p>
<p>更新：第三个代码，米勒罗宾模版二号</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">bool Miller_Rabin(LL n)&#123;</span><br><span class="line">    if(n&#x3D;&#x3D;2)return true;</span><br><span class="line">    if(n&lt;2||!(n&amp;1))return false;</span><br><span class="line">    int cishu&#x3D;20,ji&#x3D;0;</span><br><span class="line">    LL m&#x3D;n-1;</span><br><span class="line">    while(!(m&amp;1))&#123;</span><br><span class="line">        ji++;</span><br><span class="line">        m&gt;&gt;&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    srand(100);</span><br><span class="line">    while(cishu--)&#123;</span><br><span class="line">        LL a&#x3D;rand()%(n-1)+1;</span><br><span class="line">        LL x&#x3D;qpow(a,m,n),tmp&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;ji;i++)&#123;</span><br><span class="line">            tmp&#x3D;mul(x,x,n);</span><br><span class="line">            if(tmp&#x3D;&#x3D;1&amp;&amp;x!&#x3D;1&amp;&amp;x!&#x3D;n-1)return false;</span><br><span class="line">            x&#x3D;tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        if(tmp!&#x3D;1)return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        if(Miller_Rabin(n))puts(&quot;YES&quot;);</span><br><span class="line">        else puts(&quot;NO&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;100005;</span><br><span class="line">int vis[N],prime[N],ji&#x3D;0;</span><br><span class="line">void init()&#123;</span><br><span class="line">    for(int i&#x3D;2;i&lt;N;i++)&#123;&#x2F;&#x2F;埃筛素数</span><br><span class="line">        if(vis[i])continue;</span><br><span class="line">        prime[ji++]&#x3D;i;</span><br><span class="line">        for(int j&#x3D;2*i;j&lt;N;j+&#x3D;i)vis[j]&#x3D;true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,n;</span><br><span class="line">    init();</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        if((n&amp;1)&#x3D;&#x3D;0)&#123;</span><br><span class="line">            puts(n&#x3D;&#x3D;2?&quot;YES&quot;:&quot;NO&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        int e&#x3D;(int)sqrt(n)+1,i;</span><br><span class="line">        for(i&#x3D;1;prime[i]&lt;&#x3D;e;i++)if(n%prime[i]&#x3D;&#x3D;0)break;</span><br><span class="line">        puts(prime[i]&lt;&#x3D;e?&quot;NO&quot;:&quot;YES&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">LL mul(LL a,LL b,LL p)&#123;</span><br><span class="line">    a%&#x3D;p;</span><br><span class="line">    LL res&#x3D;0;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)res&#x3D;(res+a)%p;</span><br><span class="line">        b&gt;&gt;&#x3D;1;</span><br><span class="line">        a&#x3D;(a&lt;&lt;1)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">LL qpow(LL a,LL b,LL p)&#123;</span><br><span class="line">    a%&#x3D;p;b%&#x3D;p;</span><br><span class="line">    LL ans&#x3D;1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            ans&#x3D;mul(ans,a,p);</span><br><span class="line">        &#125;</span><br><span class="line">        b&gt;&gt;&#x3D;1;</span><br><span class="line">        a&#x3D;mul(a,a,p);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">bool Miller_Rabin(LL n)&#123;</span><br><span class="line">    if(n&#x3D;&#x3D;2)return true;</span><br><span class="line">    if(n&lt;2||!(n&amp;1))return false;</span><br><span class="line">    int cishu&#x3D;2,ji&#x3D;0;</span><br><span class="line">    LL m&#x3D;n-1;</span><br><span class="line">    while(!(m&amp;1))&#123;</span><br><span class="line">        ji++;</span><br><span class="line">        m&gt;&gt;&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    srand(100);</span><br><span class="line">    while(cishu--)&#123;</span><br><span class="line">        LL a&#x3D;rand()%(n-1)+1;</span><br><span class="line">        LL x&#x3D;qpow(a,m,n),tmp&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;ji;i++)&#123;</span><br><span class="line">            tmp&#x3D;mul(x,x,n);</span><br><span class="line">            if(tmp&#x3D;&#x3D;1&amp;&amp;x!&#x3D;1&amp;&amp;x!&#x3D;n-1)return false;</span><br><span class="line">            x&#x3D;tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        if(tmp!&#x3D;1)return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        if(Miller_Rabin(n))puts(&quot;YES&quot;);</span><br><span class="line">        else puts(&quot;NO&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>1118 机器人走方格（组合数）</title>
    <url>/3697a1c/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB</p>
<p><code>M * N</code>的方格，一个机器人从左上走到右下，只能向右或向下走。有多少种不同的走法？由于方法数量可能很大，只需要输出Mod 10^9 + 7的结果。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行，2个数M,N，中间用空格隔开。（2 &lt;= m,n &lt;= 1000)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出走法的数量。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 3</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>C(m+n-2,m-1)，直接上组合数模版</p>
<p>组合数模版原理：<code>a/x mod p=a*x^(p-2) mod p</code></p>
<p>证明：</p>
<p>由费马小定理有<code>x^(p-1) mod p=1</code>，即<code>x*x^(p-2) mod p=1</code>，x和x^(p-2)互为逆元，所以<code>a/x mod p=a*x^(p-2) mod p</code>成立</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int p&#x3D;1000000007;</span><br><span class="line">LL qpow(LL a,LL b)&#123;</span><br><span class="line">    LL ans&#x3D;1;</span><br><span class="line">    a%&#x3D;p;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            ans&#x3D;ans*a%p;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        b&gt;&gt;&#x3D;1;</span><br><span class="line">        a&#x3D;a*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">LL C(LL n,LL m)&#123;</span><br><span class="line">    if(m&gt;n)return 0;</span><br><span class="line">    LL ans&#x3D;1;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">        LL a&#x3D;(n+i-m)%p;</span><br><span class="line">        LL b&#x3D;i%p;</span><br><span class="line">        ans&#x3D;ans*(a*qpow(b,p-2)%p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    LL m,n;</span><br><span class="line">    scanf(&quot;%lld%lld&quot;,&amp;m,&amp;n);</span><br><span class="line">    printf(&quot;%lld\n&quot;,C(m+n-2,m-1));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>1130 N的阶乘的长度 V2（斯特林公式取n阶乘位数）</title>
    <url>/41d56d9c/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB </p>
<p>输入N求N的阶乘的10进制表示的长度。例如6! = 720，长度为3。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 1000)</p>
<p>第2 - T + 1行：每行1个数N。（1 &lt;= N &lt;= 10^9)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>共T行，输出对应的阶乘的长度。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>stirling公式</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkkt301pj204h01ojr7.jpg" alt=""></p>
<p>因为这题是十进制，所以两边对10取对数得</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkkt3igfj207a01oglh.jpg" alt=""></p>
<p>[ ]表示取整，即<code>LL ans=0.5*log10(2.0*PI*n)+n*log10(1.0*n/e)+1</code></p>
<p>同理，如果是a进制下的位数，数学公式懒得打了0.0直接放代码吧。。</p>
<p><code>LL ans=(0.5*log(2.0*PI*n)+n*log(1.0*n/e))/log(a)+1</code></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const double PI&#x3D;asin(1.0)*2,e&#x3D;2.718281828459;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        LL ans&#x3D;0.5*log10(2.0*PI*n)+n*log10(1.0*n&#x2F;e)+1;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>1134 最长递增子序列（dp）</title>
    <url>/c746a48a/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB </p>
<p>给出长度为N的数组，找出这个数组的最长递增子序列。(递增子序列是指，子序列的元素是递增的）</p>
<a id="more"></a>

<p>例如：5 1 6 8 2 4 5 10，最长递增子序列是1 2 4 5 10。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：1个数N，N为序列的长度(2 &lt;= N &lt;= 50000)<br>第2 - N + 1行：每行1个数，对应序列的元素(-10^9 &lt;= S[i] &lt;= 10^9)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出最长递增子序列的长度。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">5</span><br><span class="line">1</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>一开始暴力dp然后又T又wa的。。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">    for(int j&#x3D;i-1;j&gt;&#x3D;0;j--)&#123;</span><br><span class="line">        if(a[i]&gt;a[j])dp[i]&#x3D;max(dp[i],dp[j]+1);</span><br><span class="line">    &#125;</span><br><span class="line">    ans&#x3D;max(ans,dp[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化的方法见代码：</p>
<p>对样例来说5，1，6，8，2，4，5，10，dp[1]=5，dp[1]=1，dp[2]=6，dp[3]=8，dp[2]=2，dp[3]=4，dp[4]=5，dp[5]=10，答案为5</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;50005;</span><br><span class="line">int dp[N],a[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,len&#x3D;0;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">        dp[i]&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        if(i&#x3D;&#x3D;1)dp[++len]&#x3D;a[i];</span><br><span class="line">        else&#123;</span><br><span class="line">            if(a[i]&gt;dp[len])dp[++len]&#x3D;a[i];</span><br><span class="line">            else&#123;</span><br><span class="line">                int cur&#x3D;lower_bound(dp+1,dp+len+1,a[i])-dp;</span><br><span class="line">                dp[cur]&#x3D;a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,len);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>1135 原根（原根性质）</title>
    <url>/8c5ac577/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB </p>
<p>设m是正整数，a是整数，若a模m的阶等于φ(m)，则称a为模m的一个原根。（其中φ(m)表示m的欧拉函数）</p>
<a id="more"></a>

<p>给出1个质数P，找出P最小的原根。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入1个质数P(3 &lt;= P &lt;= 10^9)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出P最小的原根。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>百度百科关于阶的解释：</p>
<blockquote>
<p>其在数论中的定义为：</p>
<p>设a，p是整数，a和p互素，那么：</p>
<p>使 a^n≡1(mod p) 成立的最小正整数n叫做a模p的阶。</p>
</blockquote>
<p>百度百科关于原根的性质：</p>
<blockquote>
<p>原根具有以下性质：</p>
<p>（1）可以证明，如果正整数(a,m) = 1和正整数 d 满足a^d≡1(mod m)，则 d 整除 φ(m)。因此Ordm(a)整除φ(m)。在例子中，当a= 3时，我们仅需要验证 3 的 1 、2、3 和 6 次方模 7 的余数即可。</p>
<p>（2）记δ = Ordm(a)，则a^1，……a^(δ-1)模 m 两两不同余。因此当a是模m的原根时，a^0,a^1，……a^(δ-1)构成模 m 的简化剩余系。</p>
<p>（3）模m有原根的充要条件是m= 1,2,4,p,2p,p^n，其中p是奇质数，n是任意正整数。</p>
<p>（4）对正整数(a,m) = 1，如果 a 是模 m 的原根，那么 a 是整数模n乘法群（即加法群 Z/mZ的可逆元，也就是所有与 m 互素的正整数构成的等价类构成的乘法群）Zn的一个生成元。由于Zn有 φ(m)个元素，而它的生成元的个数就是它的可逆元个数，即 φ(φ(m))个，因此当模m有原根时，它有φ(φ(m))个原根。</p>
</blockquote>
<p>性质一大堆0.0，但是怎么求原根呢</p>
<p>首先p为质数，φ(p)=p-1，即a^n≡1(mod p)当且仅当n=p-1时成立，如果直接从1～n-2都暴力判断过去会妥妥的t</p>
<p>这时候性质的第一条就派上用场了：<code>可以证明，如果正整数(a,m) = 1和正整数 d 满足a^d≡1(mod m)，则 d 整除 φ(m)</code></p>
<p>举个例子：</p>
<p>假如输入的p=7，那么φ(p)=6</p>
<p>因为要找最小的那个，所以a从2开始找，2^3=8≡1(mod 7)，2^6=64≡1(mod7)，2^3≡2^6(mod7)，所以2不是模7的原根，那么a=3，3^1≡3(mod 7)，3^2≡2(mod 7)，3^3≡6(mod 7)，3^4≡4(mod 7)，3^5≡5(mod 7)，3^6≡1(mod 7)，按照定义3是模7的一个原根，而根据性质1，整除的才有可能得到1，所以只需要验证3^1，3^2，3^3，3^6即可，这样可以跑的飞快</p>
<p>最后代码就是先埃筛，再处理p-1的质因子b[i]，因为只要判断a^((p-1)/b[i])≡1(mod p)是否成立即可，只要有一个成立，那当前的a就不是原根</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;1000005;</span><br><span class="line">bool vis[N];</span><br><span class="line">vector&lt;int&gt;p,b;</span><br><span class="line">void init()&#123;&#x2F;&#x2F;埃筛素数</span><br><span class="line">    memset(vis,false,sizeof(vis));</span><br><span class="line">    for(int i&#x3D;2;i&lt;&#x3D;N;i++)&#123;</span><br><span class="line">        if(!vis[i])&#123;</span><br><span class="line">            p.push_back(i);</span><br><span class="line">            for(int j&#x3D;i+i;j&lt;&#x3D;N;j+&#x3D;i)vis[j]&#x3D;true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void getnum(LL n)&#123;&#x2F;&#x2F;分解质因子</span><br><span class="line">    int tmp&#x3D;sqrt(n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;p.size();i++)&#123;</span><br><span class="line">        if(n%p[i]&#x3D;&#x3D;0)&#123;</span><br><span class="line">            b.push_back(p[i]);</span><br><span class="line">            while(n%p[i]&#x3D;&#x3D;0)n&#x2F;&#x3D;p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(n&gt;1)b.push_back(n);</span><br><span class="line">&#125;</span><br><span class="line">LL qpow(LL a,LL b,LL p)&#123;</span><br><span class="line">    LL ans&#x3D;1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            ans&#x3D;(ans*a)%p;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        b&gt;&gt;&#x3D;1;</span><br><span class="line">        a&#x3D;a*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    LL x;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;x);</span><br><span class="line">    init();</span><br><span class="line">    getnum(x-1);</span><br><span class="line">    for(int i&#x3D;2;i&lt;x;i++)&#123;</span><br><span class="line">        int flag&#x3D;0;</span><br><span class="line">        for(int j&#x3D;0;j&lt;b.size();j++)&#123;</span><br><span class="line">            LL tmp&#x3D;(x-1)&#x2F;b[j];</span><br><span class="line">            if(qpow(i,tmp,x)&#x3D;&#x3D;1)&#123;</span><br><span class="line">                flag&#x3D;1;break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!flag)&#123;</span><br><span class="line">            printf(&quot;%d\n&quot;,i);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>codevs 1425 最长公共子串（STL）</title>
    <url>/86eadb67/</url>
    <content><![CDATA[<h3 id="题目描述-Description"><a href="#题目描述-Description" class="headerlink" title="题目描述 Description"></a>题目描述 Description</h3><p>输入N（2&lt;=N&lt;=20）个字符串，输出最长公共子串。</p>
<a id="more"></a>

<h3 id="输入描述-Input-Description"><a href="#输入描述-Input-Description" class="headerlink" title="输入描述 Input Description"></a>输入描述 Input Description</h3><p>输入N</p>
<p>再输入N个字符串</p>
<h3 id="输出描述-Output-Description"><a href="#输出描述-Output-Description" class="headerlink" title="输出描述 Output Description"></a>输出描述 Output Description</h3><p>输出最大公共子串。</p>
<h3 id="样例输入-Sample-Input"><a href="#样例输入-Sample-Input" class="headerlink" title="样例输入 Sample Input"></a>样例输入 Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line"></span><br><span class="line">abce</span><br><span class="line"></span><br><span class="line">cabk</span><br><span class="line"></span><br><span class="line">jaab</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-Sample-Output"><a href="#样例输出-Sample-Output" class="headerlink" title="样例输出 Sample Output"></a>样例输出 Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ab</span><br></pre></td></tr></table></figure>

<hr>
<p>substr(i,j)取出这段字符串</p>
<p>str.find(x）返回字符串x在str中的位置，如果没有找到，则返回-1</p>
<p>string::npos表示字符串的末尾</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	string str[25];</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	int minlen&#x3D;INT_MAX;</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;str[i];</span><br><span class="line">		if(str[i].length()&lt;minlen)minlen&#x3D;str[i].length();</span><br><span class="line">	&#125;</span><br><span class="line">	if(n&#x3D;&#x3D;1)&#123;</span><br><span class="line">		cout&lt;&lt;str[0];</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;从最长的可能性开始找</span><br><span class="line">	for(int i&#x3D;minlen;i&gt;&#x3D;0;i--)&#123;</span><br><span class="line">		for(int j&#x3D;0;j&lt;str[0].length()-i;j++)&#123;</span><br><span class="line">			int flag&#x3D;1;</span><br><span class="line">			for(int k&#x3D;1;k&lt;n;k++)&#123;</span><br><span class="line">				if(str[k].find(str[0].substr(j,i))&#x3D;&#x3D;string::npos)flag&#x3D;0;&#x2F;&#x2F;如果不匹配flag&#x3D;0</span><br><span class="line">			&#125;</span><br><span class="line">			if(flag)&#123;</span><br><span class="line">					cout&lt;&lt;str[0].substr(j,i);</span><br><span class="line">					return 0;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 5448 Marisa’s Cake（凸多边形面积，推公式，前缀和）</title>
    <url>/a5bf9421/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkhfkx6cj20r70dwahj.jpg" alt=""></p>
<a id="more"></a>

<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">0 0</span><br><span class="line">1 0</span><br><span class="line">1 1</span><br><span class="line">0 2</span><br><span class="line">5</span><br><span class="line">1 1</span><br><span class="line">3 1</span><br><span class="line">3 2</span><br><span class="line">2 3</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">50</span><br></pre></td></tr></table></figure>


<h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>2015 ACM/ICPC Asia Regional Changchun Online</p>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给一个凸n边形，n个点任选大于等于三个点，求所有情况的面积之和，答案为<code>2*S%(1e9+7)</code>，n&lt;1e6</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>面积用叉积算（计算几何里计算多边形面积）</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkisoouxj208x01w746.jpg" alt=""></p>
<p>随便展开n=5时的情况可以发现，每一项<code>Ci*Cj</code>其实有重复计算，因此试图求出<code>Ci*Cj</code>前的系数，任取两个点i，j，假设有<code>j&lt;i</code>然后考虑在j到i的逆时针方向区域内取点和在二者外部取点，易得方法数是个组合数的和，即2^?-1</p>
<p>最终会得到如下公式</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkispn96j20bx01w0sp.jpg" alt=""></p>
<p>化简将公式改为如下，使循环次数相同</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkisoyw9j20br01wmx6.jpg" alt=""></p>
<p>按顺序记为一二三四部分</p>
<p>本来算上面这个式子要i和j都算过去，这样的复杂度是O(n^2),所以考虑优化，这里利用前缀和的思想，把上面这个式子分成四部分来看，第二和四部分利用前缀和每次累加上新的一个<code>Cj*2^(-j)</code>，具体见代码，所以最后这个问题只要O(n)扫一遍就好啦</p>
<p>开头要预处理 2^i 和 2^(-i) </p>
<p>然后由于我又愚蠢的初始化反了nx，ny，mx，my的值。。。就一直deeeeeeeebug</p>
<p>被注释掉的那段代码是费马小定理求2的逆元用的，后来发现其实没啥用。。直接inv2=(1e9+7+1)/2 多省事。。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">    </span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;100005;</span><br><span class="line">const LL inv2&#x3D;500000004;</span><br><span class="line">const LL p&#x3D;1000000007;</span><br><span class="line">LL pow2[N],inv[N];</span><br><span class="line">struct node&#123;</span><br><span class="line">	LL x,y;</span><br><span class="line">&#125;tmp[N];</span><br><span class="line">void init()&#123;</span><br><span class="line">	pow2[0]&#x3D;inv[0]&#x3D;1;</span><br><span class="line">	for(int i&#x3D;1;i&lt;N;i++)&#123;</span><br><span class="line">		pow2[i]&#x3D;(pow2[i-1]*2)%p;</span><br><span class="line">		inv[i]&#x3D;(inv[i-1]*inv2)%p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">LL mul(LL x1,LL y1,LL x2,LL y2)&#123;</span><br><span class="line">	return (x1*y2%p-x2*y1%p+p)%p;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">LL pow_mod(LL a,LL b,LL p)&#123;</span><br><span class="line">    LL ret&#x3D;1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)ret&#x3D;(ret*a)%p;</span><br><span class="line">        a&#x3D;(a*a)%p;</span><br><span class="line">        b&gt;&gt;&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">LL Fermat(LL a,LL p)&#123;</span><br><span class="line">        return pow_mod(a,p-2,p);</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int t,n;</span><br><span class="line">	LL ans;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">	init();</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		&#x2F;&#x2F; printf(&quot;%lld&quot;,Fermat(2,1000000007));</span><br><span class="line">		ans&#x3D;0;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;n;i++)scanf(&quot;%lld%lld&quot;,&amp;tmp[i].x,&amp;tmp[i].y);</span><br><span class="line">		LL nx&#x3D;inv2*tmp[1].x%p,ny&#x3D;inv2*tmp[1].y%p;</span><br><span class="line">		LL mx&#x3D;tmp[1].x%p,my&#x3D;tmp[1].y%p;</span><br><span class="line">		&#x2F;&#x2F; cout&lt;&lt;nx&lt;&lt;&quot; &quot;&lt;&lt;ny&lt;&lt;&quot; &quot;&lt;&lt;mx&lt;&lt;&quot; &quot;&lt;&lt;my&lt;&lt;endl; </span><br><span class="line">		for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">			ans&#x3D;(ans+mul(pow2[i-1]*tmp[i].x%p,pow2[i-1]*tmp[i].y%p,nx,ny)+p)%p;</span><br><span class="line">			nx&#x3D;(nx+inv[i]*tmp[i].x%p)%p;</span><br><span class="line">			ny&#x3D;(ny+inv[i]*tmp[i].y%p)%p;</span><br><span class="line">			ans&#x3D;(ans-mul(pow2[n-i]*tmp[i].x%p,pow2[n-i]*tmp[i].y%p,mx,my)+p)%p;</span><br><span class="line">			mx&#x3D;(mx+pow2[i-1]*tmp[i].x%p)%p;</span><br><span class="line">			my&#x3D;(my+pow2[i-1]*tmp[i].y%p)%p;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%lld\n&quot;,ans%p);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>Entertainment Box -- Nordic Collegiate Programming Contest 2015​（贪心，读题。。）</title>
    <url>/e86890fb/</url>
    <content><![CDATA[<p><a href="https://nanti.jisuanke.com/t/28880" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/28880</a></p>
<p><img src="https://res.jisuanke.com/img/upload/20180715/4048c5a89f84ffebae8ded319176bb59c82b28ad.png" alt=""></p>
<a id="more"></a>

<p>Ada, Bertrand and Charles often argue over which TV shows to watch, and to avoid some of their fights they have finally decided to buy a video tape recorder. This fabulous, new device can record k different TV shows simultaneously, and whenever a show recorded in one the machine’s k slots ends, the machine is immediately ready to record another show in the same slot.</p>
<p>The three friends wonder how many TV shows they can record during one day. They provide you with the TV guide for today’s shows, and tell you the number of shows the machine can record simultaneously. How many shows can they record, using their recording machine? Count only shows that are recorded in their entirety.</p>
<h3 id="Input-Format"><a href="#Input-Format" class="headerlink" title="Input Format"></a>Input Format</h3><p>The first line of input contains two integers n,k<code>(1≤k&lt;n≤100000)</code>. Then follow n lines, each containing two integers xi​,yi, meaning that show i starts at time xi and finishes by time yi. This means that two shows i and j, where yi=xj, can be recorded, without conflict, in the same recording slot. You may assume that <code>0≤xi&lt;yi≤1000000000</code>.</p>
<h3 id="Output-Format"><a href="#Output-Format" class="headerlink" title="Output Format"></a>Output Format</h3><p>The output should contain exactly one line with a single integer: the maximum number of full shows from the TV guide that can be recorded with the tape recorder.</p>
<h3 id="样例输入1"><a href="#样例输入1" class="headerlink" title="样例输入1"></a>样例输入1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 1</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>
<h3 id="样例输出1"><a href="#样例输出1" class="headerlink" title="样例输出1"></a>样例输出1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="样例输入2"><a href="#样例输入2" class="headerlink" title="样例输入2"></a>样例输入2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 1</span><br><span class="line">1 3</span><br><span class="line">4 6</span><br><span class="line">7 8</span><br><span class="line">2 5</span><br></pre></td></tr></table></figure>
<h3 id="样例输出2"><a href="#样例输出2" class="headerlink" title="样例输出2"></a>样例输出2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="样例输入3"><a href="#样例输入3" class="headerlink" title="样例输入3"></a>样例输入3</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 2</span><br><span class="line">1 4</span><br><span class="line">5 9</span><br><span class="line">2 7</span><br><span class="line">3 8</span><br><span class="line">6 10</span><br></pre></td></tr></table></figure>
<h3 id="样例输出3"><a href="#样例输出3" class="headerlink" title="样例输出3"></a>样例输出3</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>怎么会有这么难读懂的题(╯°□°）╯︵ ┻━┻</p>
<p>给你k个段，n个区间[l,r]，要求每个段内区间不重合，问你最多能填上几个区间</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>初始化每个段的当前末尾为0，存入vector中</p>
<p>把区间按r从小到大排序，r最小的最优，用upper_bound贪心的选段填，填好后更新那个段的末位位子，然后操作下一个区间</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;100005;</span><br><span class="line">struct p&#123;</span><br><span class="line">	int x,y;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line">bool cmp(p a,p b)&#123;</span><br><span class="line">	if(a.y!&#x3D;b.y)return a.y&lt;b.y;</span><br><span class="line">	else return a.x&lt;b.x;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,k,ans&#x3D;0;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;n,&amp;k);</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;,&amp;q[i].x,&amp;q[i].y);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(q,q+n,cmp);</span><br><span class="line">	vector&lt;int&gt;c;</span><br><span class="line">	for(int i&#x3D;0;i&lt;k;i++)c.push_back(0);</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">		int tmp&#x3D;upper_bound(c.begin(),c.end(),q[i].x)-c.begin();</span><br><span class="line">		if(tmp!&#x3D;0)&#123;</span><br><span class="line">			c.erase(c.begin()+tmp-1);</span><br><span class="line">			c.push_back(q[i].y);</span><br><span class="line">			ans++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>poj 1328 Radar Installation（贪心，线段交集）</title>
    <url>/8e5f1388/</url>
    <content><![CDATA[<p><a href="http://poj.org/problem?id=1328" target="_blank" rel="noopener">http://poj.org/problem?id=1328</a></p>
<p>Time Limit: 1000MS        Memory Limit: 10000K</p>
<p>Assume the coasting is an infinite straight line. Land is in one side of coasting, sea in the other. Each small island is a point locating in the sea side. And any radar installation, locating on the coasting, can only cover d distance, so an island in the sea can be covered by a radius installation, if the distance between them is at most d. </p>
<p>We use Cartesian coordinate system, defining the coasting is the x-axis. The sea side is above x-axis, and the land side below. Given the position of each island in the sea, and given the distance of the coverage of the radar installation, your task is to write a program to find the minimal number of radar installations to cover all the islands. Note that the position of an island is represented by its x-y coordinates. </p>
<p><img src="http://poj.org/images/1328_1.jpg" alt=""><br><strong>Figure A Sample Input of Radar Installations</strong></p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input consists of several test cases. The first line of each case contains two integers n (1&lt;=n&lt;=1000) and d, where n is the number of islands in the sea and d is the distance of coverage of the radar installation. This is followed by n lines each containing two integers representing the coordinate of the position of each island. Then a blank line follows to separate the cases. </p>
<p>The input is terminated by a line containing pair of zeros </p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case output one line consisting of the test case number followed by the minimal number of radar installations needed. “-1” installation means no solution for that case.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 2</span><br><span class="line">-3 1</span><br><span class="line">2 1</span><br><span class="line"></span><br><span class="line">1 2</span><br><span class="line">0 2</span><br><span class="line"></span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case 1: 2</span><br><span class="line">Case 2: 1</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给一条直线，直线一侧有一些小岛，要在直线上放最少个数的半径为r的雷达，覆盖所有小岛</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>思路肯定是贪心，但是怎么贪心才能保证是最优的</p>
<p>如果直接画圆来贪心的满足各个岛屿的话，圆的位置其实是不好确定的，直接先满足最高的点然后平移圆不一定是最优策略，所以不妨反过来想：</p>
<p>以岛屿为圆心画圆，然后记录圆与直线相交的区间，只要雷达放在这个区间内，那么这个岛屿就一定可以被包含</p>
<p>这样问题就变的简单了，用所得的区间按照左端点从小到大排序，从第一个开始，如果和第二个区间有交集，那么这两个岛屿可以共用一个雷达，更新交集，然后同理看第三个区间，直到没有交集，就要增加一个雷达，记录新的区间</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;1005;</span><br><span class="line">struct q&#123;</span><br><span class="line">    double l,r;</span><br><span class="line">&#125;q[N];</span><br><span class="line">bool cmp(struct q q1,struct q q2)&#123;</span><br><span class="line">    return q1.l&lt;q2.l;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,r;</span><br><span class="line">    int cas&#x3D;0;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;r)&amp;&amp;(n||r))&#123;</span><br><span class="line">        double a,b;</span><br><span class="line">        int flag&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            scanf(&quot;%lf%lf&quot;,&amp;a,&amp;b);</span><br><span class="line">            if(b&gt;r)flag&#x3D;1;</span><br><span class="line">            else&#123;</span><br><span class="line">                q[i].l&#x3D;a*1.0-sqrt(r*r-b*b);</span><br><span class="line">                q[i].r&#x3D;a*1.0+sqrt(r*r-b*b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            printf(&quot;Case %d: -1\n&quot;,++cas);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(q,q+n,cmp);</span><br><span class="line">        double ll&#x3D;q[0].l,rr&#x3D;q[0].r;</span><br><span class="line">        int ans&#x3D;1;</span><br><span class="line">        for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">            if(q[i].l&gt;rr)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                ll&#x3D;q[i].l;rr&#x3D;q[i].r;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                ll&#x3D;q[i].l;</span><br><span class="line">                rr&#x3D;min(rr,q[i].r);</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case %d: %d\n&quot;,++cas,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>D.xor序列 -- 牛客练习赛26（线性基）</title>
    <url>/10f322b7/</url>
    <content><![CDATA[<p><a href="https://www.nowcoder.com/acm/contest/180/D" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/180/D</a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小a有n个数，他提出了一个很有意思的问题：他想知道对于任意的x, y，能否将x与这n个数中的任意多个数异或任意多次后变为y</p>
<a id="more"></a>

<h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><p>第一行为一个整数n，表示元素个数<br>第二行一行包含n个整数，分别代表序列中的元素<br>第三行为一个整数Q，表示询问次数<br>接下来Q行，每行两个数x,y，含义如题所示   </p>
<h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><p>输出Q行，若x可以变换为y，输出“YES”，否则输出“NO”</p>
<h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br><span class="line">3</span><br><span class="line">6 7 </span><br><span class="line">2 1</span><br><span class="line">3 8</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>对于(6,7)来说，6可以先和3异或，再和2异或<br>对于(2,1)来说，2可以和3异或<br>对于(3,8)来说，3不论如何都不能变换为8   </p>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h3><p>对于100%的数据，n,Q&lt;=10^5<br>保证所有运算均在int范围内</p>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>刚开始写线性基，随便写点啥吧</p>
<p>线性基就是把一组数转化成一个集合，新集合里所有数能相互异或得到原集合的所有相互异或得到的值，且线性基是满足这一条件的最小集合</p>
<p>随便举个例子，一个线性基大概长这个样子：（p[i]表示第i位为1）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1??????   p[6]</span><br><span class="line">01?????   p[5]</span><br><span class="line">001????   p[4]</span><br><span class="line">0001???   p[3]</span><br><span class="line">00001??   p[2]</span><br><span class="line">000001?   p[1]</span><br><span class="line">0000001   p[0]</span><br><span class="line"></span><br><span class="line">0表示这位没有，？表示这位是0或1</span><br></pre></td></tr></table></figure>

<p>构造方法如下：</p>
<p>对每一个数c从高位到低位扫，扫到第i位为1时，若pi不存在，则pi=c并结束此数的扫描，否则令c=c^pi</p>
<p>把这个题目转化一下，假设集合里的n个数任取几个异或可以得到a，那么要判断x^a=y能否成立，移项一下就是判断a=x^y能否成立，所以题目就是求x^y任意异或这n个数能不能得到0</p>
<p>线性基的本质是贪心的思想</p>
<p>假设已经用n个数构造好了一组线性基，a=x^y最高位是第k位，那么找p[k]，因为p[k-i]的第k位都是0，所以如果要转化成0，必须异或上p[k]这个数，所以就更新a，a=a^p[k]，继续往下匹配</p>
<p>如果p[k]不存在，那么更新p[k]，p[k]=a;</p>
<p>那么要把第k位变成0，为什么不能异或p[k+i]呢，因为这样p[k+i]位是1，异或之后虽然p[k]位顺心如意的变成了0，但是p[k+i]却变成了1，而且继续往低位找这个1就绝对不可能被消掉了</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;100005;</span><br><span class="line">LL p[61];</span><br><span class="line">void f(LL x)&#123;</span><br><span class="line">    for(int i&#x3D;60;i&gt;&#x3D;0;i--)&#123;</span><br><span class="line">        if((x&gt;&gt;i)&amp;1)&#123;</span><br><span class="line">            if(!p[i])&#123;</span><br><span class="line">                p[i]&#x3D;x;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else x^&#x3D;p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    LL c;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%lld&quot;,&amp;c);</span><br><span class="line">        f(c);</span><br><span class="line">    &#125;</span><br><span class="line">    int m;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        LL x,y;</span><br><span class="line">        scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y);</span><br><span class="line">        x&#x3D;x^y;</span><br><span class="line">        for(int i&#x3D;60;i&gt;&#x3D;0;i--)&#123;</span><br><span class="line">            if((x&gt;&gt;i)&amp;1)&#123;</span><br><span class="line">                if(!p[i])break;</span><br><span class="line">                x&#x3D;x^p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(x&#x3D;&#x3D;0)puts(&quot;YES&quot;);</span><br><span class="line">        else puts(&quot;NO&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>B.烟花 -- 牛客练习赛26（概率dp）</title>
    <url>/f9c3ad7f/</url>
    <content><![CDATA[<p><a href="https://www.nowcoder.com/acm/contest/180/B" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/180/B</a></p>
<a id="more"></a>

<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小a有个烟花，每个烟花代表着互不相同的颜色，对于第i个烟花，它有pi的概率点燃，现在小a要去点燃它们，他想知道产生颜色的期望个数 及 产生恰好产生k种颜色的概率</p>
<h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><p>第一行两个整数n,k<br>接下来一行n个数，第i个数pi表示第i个烟花被点燃的概率</p>
<h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><p>输出有两行<br>第一行表示产生不同颜色的期望个数<br>第二行表示产生恰好k种颜色的概率<br>以换行符分割  </p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">0.5 0.25 0.75</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.5000</span><br><span class="line">0.4062</span><br></pre></td></tr></table></figure>

<h3 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h3><p>对于30%的数据：n&lt;=6,k&lt;=n<br>对于100%的数据：<code>n&lt;=10^5,k&lt;=2*10^2</code><br>输出均保留4位小数,若你的答案误差与std不超过即为正确</p>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>第一问产生不同颜色的期望个数为：∑pi</p>
<p>第二问产生恰好k种颜色的概率：</p>
<p>用概率dp做，dp[i][j]表示前i个烟花恰好有j个点燃，根据第i个烟花点燃和没点燃的可能获得状态转移方程如下：<br><code>dp[i][j]=dp[i-1][j-1]*pi+dp[i-1][j]*(1-pi)</code></p>
<p>初始化dp[0][0]=1，0个烟花点燃0个概率是1，dp[0][i]=0，0个烟花点燃i个概率是0</p>
<p>还要初始化一下dp[i][0]的情况，就是i个烟花点燃0个，读入的时候累乘一下就行</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;100005;</span><br><span class="line">double p[N],dp[N][300];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,k;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);</span><br><span class="line">    double sum&#x3D;0;</span><br><span class="line">    dp[0][0]&#x3D;1;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%lf&quot;,&amp;p[i]);</span><br><span class="line">        sum+&#x3D;p[i];</span><br><span class="line">        dp[0][i]&#x3D;0;</span><br><span class="line">        dp[i][0]&#x3D;(1-p[i])*dp[i-1][0];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">        for(int j&#x3D;1;j&lt;&#x3D;k;j++)</span><br><span class="line">            dp[i][j]&#x3D;dp[i-1][j-1]*p[i]+(1-p[i])*dp[i-1][j];</span><br><span class="line">    printf(&quot;%.4lf\n%.4lf\n&quot;,sum,dp[n][k]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Best Solver -- ACM-ICPC 2015 Shenyang（推公式，广义斐波那契）</title>
    <url>/7ecca125/</url>
    <content><![CDATA[<p><a href="https://nanti.jisuanke.com/t/29121" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/29121</a></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkd3disej20me0c6dhm.jpg" alt=""></p>
<a id="more"></a>

<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">0 46337</span><br><span class="line">1 46337</span><br><span class="line">3 46337</span><br><span class="line">1 46337</span><br><span class="line">21 46337</span><br><span class="line">321 46337</span><br><span class="line">4321 46337</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case #1: 97</span><br><span class="line">Case #2: 969</span><br><span class="line">Case #3: 16537</span><br><span class="line">Case #4: 969</span><br><span class="line">Case #5: 40453</span><br><span class="line">Case #6: 10211</span><br><span class="line">Case #7: 17947</span><br></pre></td></tr></table></figure>
<h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p>ACM-ICPC 2015 Shenyang Preliminary Contest</p>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkd3cxspj204d013a9v.jpg" alt="">，求[y]%m</p>
<p>m&lt;=46337且为质数，x&lt;2^32</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>先凑个新的整数数列an出来，如下图：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkd3fg0oj20qo0f0gp0.jpg" alt=""></p>
<p>由a0=2  a1=10  a2=98  a3=970  a4=9602  a5=95050</p>
<p>递推得<code>an=10*an-1-an-2</code></p>
<p>又因为an%m且m不大 所以找an的循环结（为什么有循环结？？！按题目m不大猜的。。）</p>
<p>然后求(2^x-1)对应的是循环中的哪个，那个值减一即为整数部分</p>
<p>2333333t了 233333a了 不用加欧拉函数的优化还快了一点点(#ﾟДﾟ)。。？？？迷啊迷</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long </span><br><span class="line">const int N&#x3D;233333;</span><br><span class="line"></span><br><span class="line">int p,f[N];</span><br><span class="line">int init()&#123;</span><br><span class="line">	f[1]&#x3D;10;f[2]&#x3D;98;</span><br><span class="line">	for(int i&#x3D;3;;i++)&#123;</span><br><span class="line">		f[i]&#x3D;(10*f[i-1]%p-f[i-2]+p)%p;</span><br><span class="line">		if(f[i-2]%p&#x3D;&#x3D;2&amp;&amp;f[i-1]%p&#x3D;&#x3D;10)return i-2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">int phi(int x)&#123;</span><br><span class="line">	int ans&#x3D;x;</span><br><span class="line">	for(int i&#x3D;2;i*i&lt;&#x3D;x;i++)&#123;</span><br><span class="line">		if(x%i&#x3D;&#x3D;0)&#123;</span><br><span class="line">			ans&#x3D;ans&#x2F;i*(i-1);</span><br><span class="line">			while(x%i&#x3D;&#x3D;0)x&#x2F;&#x3D;i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(x&gt;1)ans&#x3D;ans&#x2F;x*(x-1);</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">int qpow(int a,int b,int m)&#123;</span><br><span class="line">	&#x2F;&#x2F; a&#x3D;a%m;</span><br><span class="line">	&#x2F;&#x2F; b&#x3D;b%phi(m);</span><br><span class="line">    int ans&#x3D;1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            ans&#x3D;ans*a%m;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        a&#x3D;a*a%m;</span><br><span class="line">        b&gt;&gt;&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int t;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;t;i++)&#123;</span><br><span class="line">		int x;</span><br><span class="line">		scanf(&quot;%d%d&quot;,&amp;x,&amp;p);</span><br><span class="line">		memset(f,0,sizeof(f));</span><br><span class="line">		int cur&#x3D;init();</span><br><span class="line">		int ans&#x3D;(qpow(2,x,cur)+1)%cur;</span><br><span class="line">		printf(&quot;Case #%d: %d\n&quot;,i,(f[ans]-1+p)%p);</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>cf 1008D Pave the Parallelepiped --（容斥，gcd，推公式）</title>
    <url>/19356a39/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/problemset/problem/1008/D" target="_blank" rel="noopener">http://codeforces.com/problemset/problem/1008/D</a></p>
<p>time limit per test2 seconds<br>memory limit per test256 megabytes</p>
<p>You are given a rectangular parallelepiped with sides of positive integer lengths<br>A, B and C.Find the number of different groups of three integers (a, b, c) such that 1≤a≤b≤c and parallelepiped A×B×C can be paved with parallelepipeds a×b×c. Note, that all small parallelepipeds have to be rotated in the same direction.</p>
<p>For example, parallelepiped 1×5×6 can be divided into parallelepipeds 1×3×5, but can not be divided into parallelepipeds 1×2×3.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains a single integer t (1≤t≤10^5) — the number of test cases.Each of the next t lines contains three integers A, B and C (1<br>≤A,B,C≤10^5) — the sizes of the parallelepiped.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, print the number of different groups of three points that satisfy all given conditions.</p>
<p>Example</p>
<h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 1 1</span><br><span class="line">1 6 1</span><br><span class="line">2 2 2</span><br><span class="line">100 100 100</span><br></pre></td></tr></table></figure>
<h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">165</span><br></pre></td></tr></table></figure>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>In the first test case, rectangular parallelepiped (1,1,1) can be only divided into rectangular parallelepiped with sizes (1,1,1).</p>
<p>In the second test case, rectangular parallelepiped (1,6,1) can be divided into rectangular parallelepipeds with sizes (1,1,1), (1,1,2), (1,1,3) and (1,1,6).</p>
<p>In the third test case, rectangular parallelepiped (2,2,2) can be divided into rectangular parallelepipeds with sizes (1,1,1), (1,1,2), (1,2,2) and (2,2,2).</p>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给(A,B,C)，求无序三元组(a,b,c)满足<code>a|A,b|B,c|C</code>的种数，一共T组数据，T,A,B,C≤105</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>首先上一个小结论：从n个元素里允许重复地选择r个元素的方案数是C(r,n+r−1)</p>
<p>证明：设xi为n个元素里第i个元素的个数，则有方程x1+x2+……+xn=r，即n元一次方程非负整数解的个数，高中数学问题(｡･ω･｡)，<br>（x1+1）+（x2+1）+…+(xn+1)=n+r，隔板法得C(r,n+r−1)</p>
<p>考虑把所有因数分组，使得每一组的因数都不同，将其分为7组，用二进制状态s表示：第1位为1表示这个因数为A的因数，第2位为1表示这个因数为B的因数，第3位为1表示这个因数为C的因数 ，cnt[s]表示状态为s的因数的个数，用（gcd+容斥）求，然后abc枚举状态，先判断是否合法（是否ABC的因数都存在），合法就算组合数，use[i]表示三个数中状态为i的数有几个</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int MAXN&#x3D;100005;</span><br><span class="line">int n,q[MAXN],m,cnt[10],use[10],fac[MAXN];</span><br><span class="line">LL C(int n,int m)&#123;</span><br><span class="line">    long long res&#x3D;1;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;m;i++)res*&#x3D;(n-i+1);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;m;i++)res&#x2F;&#x3D;i;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">bool check(int a,int b,int c)&#123;</span><br><span class="line">    if((a&amp;1)&amp;&amp;(b&amp;2)&amp;&amp;(c&amp;4))return true;</span><br><span class="line">    if((a&amp;1)&amp;&amp;(c&amp;2)&amp;&amp;(b&amp;4))return true;</span><br><span class="line">    if((b&amp;1)&amp;&amp;(a&amp;2)&amp;&amp;(c&amp;4))return true;</span><br><span class="line">    if((b&amp;1)&amp;&amp;(c&amp;2)&amp;&amp;(a&amp;4))return true;</span><br><span class="line">    if((c&amp;1)&amp;&amp;(a&amp;2)&amp;&amp;(b&amp;4))return true;</span><br><span class="line">    if((c&amp;1)&amp;&amp;(b&amp;2)&amp;&amp;(a&amp;4))return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int gcd(int a,int b)&#123;</span><br><span class="line">    return b&#x3D;&#x3D;0?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    &#x2F;&#x2F;预处理每个数的因数个数</span><br><span class="line">    for(int i&#x3D;1;i&lt;MAXN;i++)</span><br><span class="line">        for(int j&#x3D;i;j&lt;MAXN;j+&#x3D;i)</span><br><span class="line">            fac[j]++;</span><br><span class="line">    int T,X,Y,Z;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    LL ans;</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;X,&amp;Y,&amp;Z);</span><br><span class="line">        m&#x3D;0;</span><br><span class="line">        int xy&#x3D;gcd(X,Y),yz&#x3D;gcd(Y,Z),xz&#x3D;gcd(X,Z);</span><br><span class="line">        int xyz&#x3D;gcd(xy,Z);</span><br><span class="line">        &#x2F;&#x2F;计算每种状态的因数个数</span><br><span class="line">        cnt[7]&#x3D;fac[xyz];&#x2F;&#x2F;111</span><br><span class="line">        cnt[6]&#x3D;fac[yz]-fac[xyz];&#x2F;&#x2F;110</span><br><span class="line">        cnt[5]&#x3D;fac[xz]-fac[xyz];&#x2F;&#x2F;101</span><br><span class="line">        cnt[4]&#x3D;fac[Z]-fac[xz]-fac[yz]+fac[xyz];&#x2F;&#x2F;100</span><br><span class="line">        cnt[3]&#x3D;fac[xy]-fac[xyz];&#x2F;&#x2F;011</span><br><span class="line">        cnt[2]&#x3D;fac[Y]-fac[yz]-fac[xy]+fac[xyz];&#x2F;&#x2F;010</span><br><span class="line">        cnt[1]&#x3D;fac[X]-fac[xy]-fac[xz]+fac[xyz];&#x2F;&#x2F;001</span><br><span class="line">        ans&#x3D;0;</span><br><span class="line">        for(int a&#x3D;1;a&lt;8;a++)</span><br><span class="line">            for(int b&#x3D;a;b&lt;8;b++)</span><br><span class="line">                for(int c&#x3D;b;c&lt;8;c++)</span><br><span class="line">                    if(check(a,b,c))&#123;&#x2F;&#x2F;检查合法</span><br><span class="line">                        memset(use,0,sizeof(use));</span><br><span class="line">                        use[a]++;use[b]++;use[c]++;</span><br><span class="line">                        LL tmp&#x3D;1;</span><br><span class="line">                        for(int i&#x3D;1;i&lt;8;i++)</span><br><span class="line">                            if(use[i])</span><br><span class="line">                            tmp*&#x3D;C(cnt[i]+use[i]-1,use[i]);&#x2F;&#x2F;组合数计算</span><br><span class="line">                        if(tmp&gt;0)ans+&#x3D;tmp;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;%I64d\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>cf</tag>
      </tags>
  </entry>
  <entry>
    <title>Teemo&#39;s formula（推公式）</title>
    <url>/f6227d77/</url>
    <content><![CDATA[<p><a href="https://nanti.jisuanke.com/t/29324" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/29324</a></p>
<p>Teemo has a formula and he want to calculate it quickly.</p>
<p>The formula is <img src="http://latex.codecogs.com/gif.latex?%5Csum_%7Bi%3D1%7D%5E%7Bn%7Dk%5E%7B2%7DC_%7Bn%7D%5E%7Bk%7D" alt="">.</p>
<p>As the result may be very large, please output the result mod 1000000007.</p>
<h3 id="Input-Format"><a href="#Input-Format" class="headerlink" title="Input Format"></a>Input Format</h3><p>The input contains several test cases, and the first line is a positive integer T indicating the number of test cases which is up to 10^5.</p>
<p>For each test case, the first line contains an integer n(1&lt;=n&lt;=10^9).</p>
<h3 id="Output-Format"><a href="#Output-Format" class="headerlink" title="Output Format"></a>Output Format</h3><p>For each test case, output a line containing an integer that indicates the answer.</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">24</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p><img src="http://latex.codecogs.com/gif.latex?%5Csum_%7Bi%3D1%7D%5E%7Bn%7Dk%5E%7B2%7DC_%7Bn%7D%5E%7Bk%7D" alt=""></p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>先上结论，<code>n*(n+1)*2^(n-2)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Σ[(k^2)*C(n,k)]&#x3D;Σ[k*(k-1)*C(n,k)]+Σ[k*C(n,k)])</span><br><span class="line"></span><br><span class="line">Σ[k(k-1)*C(n,k)]&#x3D;Σ(n(n-1)*[C(n-2,k)]&#x3D;n(n-1)*2^(n-2)</span><br><span class="line"></span><br><span class="line">Σ[k*C(n,k)])&#x3D;Σ[n*C(n-1,k)])&#x3D;n*2^(n-1)</span><br><span class="line"></span><br><span class="line">Σ[(k^2)*C(n,k)]&#x3D;n(n-1)*2^(n-2)+n*2^(n-1)&#x3D;n*(n+1)*2^(n-2)</span><br></pre></td></tr></table></figure>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;climits&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;limits&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;100005;</span><br><span class="line">#define LL long long</span><br><span class="line">const LL p&#x3D;1000000007;</span><br><span class="line"></span><br><span class="line">LL qpow(LL a,LL b)&#123;</span><br><span class="line">    LL ans&#x3D;1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            ans&#x3D;ans*a%p;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        a&#x3D;a*a%p;</span><br><span class="line">        b&gt;&gt;&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        LL n;</span><br><span class="line">        scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">        LL res&#x3D;(qpow(2,n-2)*(n*(n+1)%p))%p;</span><br><span class="line">        printf(&quot;%lld\n&quot;,res);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>Fence Building -- ACM-ICPC 2017 Asia Urumqi（欧拉公式，分割平面，大组合数）</title>
    <url>/e85a11e8/</url>
    <content><![CDATA[<p><a href="https://nanti.jisuanke.com/t/19939" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/19939</a><br><img src="https://res.jisuanke.com/img/upload/20171219/40b0664b58afd8a8681063b2e63ffd46d77fb902.png" alt=""></p>
<a id="more"></a>

<p>Farmer John owns a farm. He first builds a circle fence. Then, he will choose n points and build some straight fences connecting them. Next, he will feed a cow in each region so that cows cannot play with each other without breaking the fences. In order to feed more cows, he also wants to have as many regions as possible. However, he is busy building fences now, so he needs your help to determine what is the maximum number of cows he can feed if he chooses these n points properly.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains an integer 1≤T≤100000, the number of test cases. For each test case, there is one line that contains an integer n. It is guaranteed that 1≤T≤10^5 and 1≤n≤10^18.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, you should output a line ”Case #i: ans” where i is the test caseS number, starting from 1 and ans is the remainder of the maximum number of cows farmer John can feed when divided by 10^9 + 7.</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case #1: 1</span><br><span class="line">Case #2: 4</span><br><span class="line">Case #3: 16</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给一个圆，在圆周上找n个点，连线，将圆划分区域的最大值</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>多面体欧拉公式：</p>
<blockquote>
<p>V+F-E=X(P)，V是多面体P的顶点个数，F是多面体P的面数，E是多面体P的棱的条数，X(P)是多面体P的欧拉示性数</p>
</blockquote>
<p>平面欧拉公式：V-E+F=2，（V、E、F表示简单几何体的顶点数、边数、面数），即 点-边+面=2</p>
<p>证明见度娘～<a href="https://baike.baidu.com/item/%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F/92066?fr=aladdin" target="_blank" rel="noopener">欧拉公式</a></p>
<p>对于这题来说，圆周上每四个点可以在圆内产生一个新的交叉点，所以点数为<code>c(n,4)+n</code></p>
<p>每两个点可以产生一条边，形成交点处额外贡献两个边，所以加上<code>2*c(n,4)</code>，边数为<code>n+2*c(n,4)+c(n,2)</code></p>
<p>要减去外面的大区域1，所以ans为（边-点+1）即C(n,4)+C(n,2)+1</p>
<p>因为这题n是1e18，所以要用卢卡斯定理大组合数模版一下</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const LL p&#x3D;1000000007;</span><br><span class="line">LL qpow(LL a,LL b)&#123;</span><br><span class="line">    LL ans&#x3D;1;</span><br><span class="line">    a%&#x3D;p;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            ans&#x3D;ans*a%p;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        b&gt;&gt;&#x3D;1;</span><br><span class="line">        a&#x3D;a*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL C(LL n,LL m)&#123;</span><br><span class="line">    if(m&gt;n)return 0;</span><br><span class="line">    LL ans&#x3D;1;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">        LL a&#x3D;(n+i-m)%p;</span><br><span class="line">        LL b&#x3D;i%p;</span><br><span class="line">        ans&#x3D;ans*(a*qpow(b,p-2)%p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">LL lucas(LL n,LL m)&#123;</span><br><span class="line">    if(m&#x3D;&#x3D;0)return 1;</span><br><span class="line">    return C(n%p,m%p)*lucas(n&#x2F;p,m&#x2F;p)%p;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;t;i++)&#123;</span><br><span class="line">        LL n;</span><br><span class="line">        scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">        LL ans&#x3D;(lucas(n,4)+lucas(n,2)+1)%p;</span><br><span class="line">        printf(&quot;Case #%d: %lld\n&quot;,i,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>Sum of the Line -- ACM-ICPC 2017 Asia Urumqi（容斥，平方和，逆元）</title>
    <url>/40f7970d/</url>
    <content><![CDATA[<p><a href="https://nanti.jisuanke.com/t/28970" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/28970</a></p>
<p><img src="https://ws1.sinaimg.cn/large/dda38d2bly1g4kk6a7fvlj20nc0csju2.jpg" alt=""></p>
<a id="more"></a>

<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>求1-n中与n互质的数的平方和</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>把这个题的代码改改就能交了<br><a href="https://leflacon.github.io/8434b274/" target="_blank" rel="noopener">hdu 4059 The Boss on Mars（容斥，四次方和，逆元）</a></p>
<p>思路和上面那个hdu4059一毛一样：转化为求1-n中与n不互质的数的平方的和，所以要先筛出素因子，然后利用容斥原理求解</p>
<p>下面是具体做法：</p>
<p>首先抛一个平方和公式<code>1^2+2^2+...+n^2=n*(n+1)*(2*n+1)/6</code><br>公式里有个除以6，求逆元费马小定理一下，除以6就是乘以pow(6,p-2)%p</p>
<p>getnum(n)那个函数就是用来求平方和，然后就是容斥了</p>
<p>举个例子，比如n=6，素因子是2，3，存入vector中，然后ans=1^2+2^2+3^2+4^2+5^2+6^2，接下来枚举状态 [1,2^2)，即01，10，11，（第i位为1表示取第i个素因子），a记录当前状态素因子个数来确定容斥正负号，now记录当前状态素因子之积，那么答案就是：<code>ans=ans-2^2*(3^2+2^2+1^2)-3^2*(2^2+1^2)+6^2*(1^2)</code>，getnum(n/now)这个很巧妙的把该因子所有的倍数都算上了，2^2*(3^2+2^2+1^2)也就是2和2的所有倍数的平方和（6^2+4^2+2^2）</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int p&#x3D;998244353;</span><br><span class="line">const int N&#x3D;1000005;</span><br><span class="line">const int MAXN&#x3D;100000005;</span><br><span class="line">LL inv6,n;</span><br><span class="line">int prime[N],ji;</span><br><span class="line">bool vis[N];</span><br><span class="line">vector&lt;LL&gt;v;</span><br><span class="line">LL qpow(LL a,LL b)&#123;</span><br><span class="line">    LL ans&#x3D;1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            ans&#x3D;(ans*a)%p;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        b&#x2F;&#x3D;2;</span><br><span class="line">        a&#x3D;a*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">	inv6&#x3D;qpow(6LL,p-2);</span><br><span class="line">	ji&#x3D;0;</span><br><span class="line">	memset(vis,false,sizeof(vis));</span><br><span class="line">	for(int i&#x3D;2;i*i&lt;&#x3D;MAXN;i++)&#123;&#x2F;&#x2F;埃筛素数</span><br><span class="line">		if(vis[i])continue;</span><br><span class="line">		prime[ji++]&#x3D;i;</span><br><span class="line">		for(int j&#x3D;2*i;j&lt;N;j+&#x3D;i)vis[j]&#x3D;true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">LL getnum(LL n)&#123;</span><br><span class="line">	&#x2F;&#x2F;1^2+2^2+...+n^2&#x3D;n*(n+1)*(2*n+1)&#x2F;6</span><br><span class="line">	LL ans;</span><br><span class="line">	ans&#x3D;(n*(n+1)%p*(2*n+1)%p)%p;</span><br><span class="line">	ans&#x3D;(ans*inv6)%p;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">	v.clear();</span><br><span class="line">	LL tmp&#x3D;n;</span><br><span class="line">	for(int i&#x3D;0;i&lt;ji;i++)&#123;</span><br><span class="line">		if(tmp%prime[i]&#x3D;&#x3D;0)&#123;</span><br><span class="line">			v.push_back(prime[i]);</span><br><span class="line">			while(tmp%prime[i]&#x3D;&#x3D;0)tmp&#x2F;&#x3D;prime[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(tmp&gt;1)v.push_back(tmp);</span><br><span class="line">	LL ans&#x3D;getnum(n);</span><br><span class="line">	for(int i&#x3D;1;i&lt;(1&lt;&lt;v.size());i++)&#123;</span><br><span class="line">		int a&#x3D;0;</span><br><span class="line">		LL now&#x3D;1;</span><br><span class="line">		for(int j&#x3D;0;j&lt;v.size();j++)&#123;</span><br><span class="line">			if(i&amp;(1&lt;&lt;j))&#123;</span><br><span class="line">				a++;</span><br><span class="line">				now&#x3D;now*v[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		LL res&#x3D;qpow(now,2LL)*(getnum(n&#x2F;now)%p)%p;</span><br><span class="line">		if(a&amp;1)ans&#x3D;(ans-res+p)%p;</span><br><span class="line">		else ans&#x3D;(ans+res+p)%p;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">    	scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">    	solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 4059 The Boss on Mars（与n互质的数的四次方的和）</title>
    <url>/8434b274/</url>
    <content><![CDATA[<p>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4059" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=4059</a></p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>On Mars, there is a huge company called ACM (A huge Company on Mars), and it’s owned by a younger boss.</p>
<p>Due to no moons around Mars, the employees can only get the salaries per-year. There are n employees in ACM, and it’s time for them to get salaries from their boss. All employees are numbered from 1 to n. With the unknown reasons, if the employee’s work number is k, he can get k^4 Mars dollars this year. So the employees working for the ACM are very rich.</p>
<p>Because the number of employees is so large that the boss of ACM must distribute too much money, he wants to fire the people whose work number is co-prime with n next year. Now the boss wants to know how much he will save after the dismissal.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains an integer T indicating the number of test cases. (1 ≤ T ≤ 1000) Each test case, there is only one integer n, indicating the number of employees in ACM. (1 ≤ n ≤ 10^8)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, output an integer indicating the money the boss can save. Because the answer is so large, please module the answer with 1,000,000,007.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">82</span><br><span class="line">354</span><br></pre></td></tr></table></figure>
<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case1: sum&#x3D;1+3*3*3*3&#x3D;82</span><br><span class="line">Case2: sum&#x3D;1+2*2*2*2+3*3*3*3+4*4*4*4&#x3D;354</span><br></pre></td></tr></table></figure>


<h3 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h3><p>ZHANG, Chao</p>
<h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>2011 Asia Dalian Regional Contest</p>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>求1-n中与n互质的数的四次方的和</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>这题的思路是：转化为求1-n中与n不互质的数的四次方的和，所以要先筛出素因子，然后利用容斥原理求解</p>
<p>下面是具体做法：</p>
<p>首先抛一个<strong>四次方求和公式</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkd3bn50j209401w0sn.jpg" alt=""></p>
<p>推导过程如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(x+1)^5&#x3D;x^5+5*x^4+10*x^3+10*x^2+5*x+1</span><br><span class="line"></span><br><span class="line">然后从x&#x3D;1开始列出n个式子</span><br><span class="line"></span><br><span class="line">2^5&#x3D;(1+1)^5&#x3D;1^5+5*1^4+10*1^3+10*1^2+5*1^1+1;</span><br><span class="line">3^5&#x3D;(2+1)^5&#x3D;2^5+5*2^4+10*2^3+10*2^2+5*2^1+1;</span><br><span class="line">……</span><br><span class="line">(n+1)^5&#x3D;(n+1)^5&#x3D;n^5+5*n^4+10*n^3+10*n^2+5*n^1+1;</span><br><span class="line"></span><br><span class="line">叠加得：</span><br><span class="line">(n+1)^5&#x3D;1+5*(1^4+2^4+……n^4)+10*(1^3+2^3+……+n^3)+10*(1^2+2^2+……+n^2)+5*(1+2+……+n)+n</span><br><span class="line"></span><br><span class="line">再代入</span><br><span class="line">(1^3+2^3+……n^3)&#x3D;(n+1)^2*n^2&#x2F;4，</span><br><span class="line">(1^2+2^2+……n^2)&#x3D;n*(n+1)*(2*n+1)&#x2F;6，</span><br><span class="line">(1+2+……+n)&#x3D;n*(n+1)&#x2F;2</span><br><span class="line"></span><br><span class="line">即得</span><br><span class="line">(1^4+2^4+……+n^4)&#x3D;n*(n+1)*(2n+1)*(3*n*n+3*n-1)&#x2F;30;</span><br></pre></td></tr></table></figure>

<p>公式里有个除以30，那么显然要用到逆元的知识了，费马小定理一下，除以30就是乘以<code>pow(30,p-2)%p</code></p>
<p>getnum(n)那个函数就是用来求四次方和的，写的时候括号来括号去的要小心0.0，反正我偷懒写一行然后wa了几次。。下次还是分开写清楚点。。（补上分开写的了，不过注释掉了）</p>
<p>然后就是容斥了</p>
<p>来举个例子吧，比如n=6，素因子是2，3，存入vector中，然后ans=1^4+2^4+3^4+4^4+5^4+6^4=2275，接下来枚举状态 [1,2^2)，即01，10，11，（第i位为1表示取第i个素因子），a记录当前状态素因子个数来确定容斥正负号，now记录当前状态素因子之积，那么答案就是：<code>ans=ans-2^4*(3^4+2^4+1^4)-3^4*(2^4+1^4)+6^4*(1^4)</code>，getnum(n/now)这个很巧妙的把该因子所有的倍数都算上了，<code>2^4*(3^4+2^4+1^4)</code>也就是2和2的所有倍数的四次方和<code>（6^4+4^4+2^4）</code></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int p&#x3D;1000000007;</span><br><span class="line">const int N&#x3D;100005;</span><br><span class="line">LL inv30,n;</span><br><span class="line">int prime[N],ji;</span><br><span class="line">bool vis[N];</span><br><span class="line">vector&lt;LL&gt;v;</span><br><span class="line">LL qpow(LL a,LL b)&#123;</span><br><span class="line">    LL ans&#x3D;1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            ans&#x3D;(ans*a)%p;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        b&#x2F;&#x3D;2;</span><br><span class="line">        a&#x3D;a*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">	inv30&#x3D;qpow(30LL,p-2);</span><br><span class="line">	ji&#x3D;0;</span><br><span class="line">	memset(vis,false,sizeof(vis));</span><br><span class="line">	for(int i&#x3D;2;i&lt;N;i++)&#123;&#x2F;&#x2F;埃筛素数</span><br><span class="line">		if(vis[i])continue;</span><br><span class="line">		prime[ji++]&#x3D;i;</span><br><span class="line">		for(int j&#x3D;2*i;j&lt;N;j+&#x3D;i)vis[j]&#x3D;true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">LL getnum(LL n)&#123;</span><br><span class="line">	&#x2F;&#x2F;(1^4+2^4+……+n^4)&#x3D;n*(n+1)*(2n+1)*(3*n*n+3*n-1)&#x2F;30</span><br><span class="line"></span><br><span class="line">	LL ans;</span><br><span class="line">	ans&#x3D;(n*(n+1)%p*(2*n+1)%p*((3*n*n)%p+(3*n-1)%p))%p;</span><br><span class="line">	ans&#x3D;(ans*inv30)%p;</span><br><span class="line">	return ans;</span><br><span class="line">	</span><br><span class="line">	&#x2F;*分开写的版本</span><br><span class="line">	LL ans;</span><br><span class="line">	ans&#x3D;(n*((n+1)%p))%p;</span><br><span class="line">	ans&#x3D;(ans*((2*n+1)%p))%p;</span><br><span class="line">	ans&#x3D;(ans*((3*n*n)%p+(3*n-1)%p))%p;</span><br><span class="line">	ans&#x3D;(ans*inv30)%p;</span><br><span class="line">	return ans;</span><br><span class="line">	*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">	v.clear();</span><br><span class="line">	LL tmp&#x3D;n;</span><br><span class="line">	for(int i&#x3D;0;i&lt;ji;i++)&#123;</span><br><span class="line">		if(tmp%prime[i]&#x3D;&#x3D;0)&#123;</span><br><span class="line">			v.push_back(prime[i]);</span><br><span class="line">			while(tmp%prime[i]&#x3D;&#x3D;0)tmp&#x2F;&#x3D;prime[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(tmp&gt;1)v.push_back(tmp);</span><br><span class="line">	LL ans&#x3D;getnum(n);</span><br><span class="line">	for(int i&#x3D;1;i&lt;(1&lt;&lt;v.size());i++)&#123;</span><br><span class="line">		int a&#x3D;0;</span><br><span class="line">		LL now&#x3D;1;</span><br><span class="line">		for(int j&#x3D;0;j&lt;v.size();j++)&#123;</span><br><span class="line">			if(i&amp;(1&lt;&lt;j))&#123;</span><br><span class="line">				a++;</span><br><span class="line">				now&#x3D;now*v[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		LL res&#x3D;qpow(now,4LL)*(getnum(n&#x2F;now)%p)%p;</span><br><span class="line">		if(a&amp;1)ans&#x3D;(ans-res+p)%p;</span><br><span class="line">		else ans&#x3D;(ans+res+p)%p;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">    	scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">    	solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1502 Regular Words（dp，java高精度）</title>
    <url>/18f146f5/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1502" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1502</a></p>
<p>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Consider words of length 3n over alphabet {A, B, C} . Denote the number of occurences of A in a word a as A(a) , analogously let the number of occurences of B be denoted as B(a), and the number of occurenced of C as C(a) . </p>
<p>Let us call the word w regular if the following conditions are satisfied: </p>
<p>A(w)=B(w)=C(w) ;<br>if c is a prefix of w , then A(c)&gt;= B(c) &gt;= C(c) .<br>For example, if n = 2 there are 5 regular words: AABBCC , AABCBC , ABABCC , ABACBC and ABCABC . </p>
<p>Regular words in some sense generalize regular brackets sequences (if we consider two-letter alphabet and put similar conditions on regular words, they represent regular brackets sequences). </p>
<p>Given n , find the number of regular words.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>There are mutiple cases in the input file. </p>
<p>Each case contains n (0 &lt;= n &lt;= 60 ). </p>
<p>There is an empty line after each case.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Output the number of regular words of length 3n . </p>
<p>There should be am empty line after each case.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line"></span><br><span class="line">3</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line"></span><br><span class="line">42</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>ABC三个字母每个字母n个，排列成一个长度为<code>3*n</code>的串，要求任意前缀满足，A的个数大于等于B的个数大于等于C的个数，即<code>A(c)&gt;= B(c) &gt;= C(c)</code> ，求方法数</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>dp[i][j][k]表示当前串由i个A，j个B，k个C组成的方法数   </p>
<p>状态转移方程为 <code>dp[i][j][k] = dp[i-1][j][k] + dp[i][j-1][k] + dp[i][j][k-1]</code></p>
<p>初始化dp[0][0][0]=1，每一项加的时候判断一下是否合法即可</p>
<p>这题需要高精度，就用java写了</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;  </span><br><span class="line">import java.math.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">        BigInteger dp[][][]&#x3D;new BigInteger[65][65][65];</span><br><span class="line">        dp[0][0][0]&#x3D;BigInteger.valueOf(1);</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;60;i++) &#123;</span><br><span class="line">        	for(int j&#x3D;0;j&lt;&#x3D;i;j++) &#123;</span><br><span class="line">        		for(int k&#x3D;0;k&lt;&#x3D;j;k++) &#123;</span><br><span class="line">        			dp[i][j][k]&#x3D;BigInteger.valueOf(0);</span><br><span class="line">        			if(i&gt;j)dp[i][j][k]&#x3D;dp[i][j][k].add(dp[i-1][j][k]);</span><br><span class="line">        			if(j&gt;k)dp[i][j][k]&#x3D;dp[i][j][k].add(dp[i][j-1][k]);</span><br><span class="line">        			if(k&gt;0)dp[i][j][k]&#x3D;dp[i][j][k].add(dp[i][j][k-1]);</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int n;</span><br><span class="line">        while(cin.hasNext()) &#123;</span><br><span class="line">        	n&#x3D;cin.nextInt();</span><br><span class="line">        	System.out.println(dp[n][n][n]);</span><br><span class="line">        	System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        cin.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1013 Digital Roots（数根公式推导）</title>
    <url>/68903b21/</url>
    <content><![CDATA[<p>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)</p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1013" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1013</a></p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The digital root of a positive integer is found by summing the digits of the integer. If the resulting value is a single digit then that digit is the digital root. If the resulting value contains two or more digits, those digits are summed and the process is repeated. This is continued as long as necessary to obtain a single digit.</p>
<p>For example, consider the positive integer 24. Adding the 2 and the 4 yields a value of 6. Since 6 is a single digit, 6 is the digital root of 24. Now consider the positive integer 39. Adding the 3 and the 9 yields 12. Since 12 is not a single digit, the process must be repeated. Adding the 1 and the 2 yeilds 3, a single digit and also the digital root of 39.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input file will contain a list of positive integers, one per line. The end of the input will be indicated by an integer value of zero.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each integer in the input, output its digital root on a separate line of the output.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>24<br>39<br>0</p>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>6<br>3</p>
<h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>Greater New York 2000</p>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>先放个百度百科数根定义：</p>
<blockquote>
<p>数根(又称数字根Digital root)是自然数的一种性质，换句话说，每个自然数都有一个数根</p>
</blockquote>
<p>数根是将一正整数的各个位数相加(即横向相加)，若加完后的值大于等于10的话，则继续将各位数进行横向相加直到其值小于十为止，或是，将一数字重复做数字和，直到其值小于十为止，则所得的值为该数的数根。例如54817的数根为7，因为5+4+8+1+7=25，25大于10则再加一次，2+5=7，7小于十，则7为54817的数根</p>
<p>再放个结论：</p>
<blockquote>
<p>for(int i=0;i&lt;s.length();i++)ans+=(s[i]-‘0’);<br>printf(“%d\n”,1+(ans-1)%9);</p>
<p>即每位数相加的结果记为ans, 1+(ans-1)%9 即为所求</p>
</blockquote>
<p>最后放个证明：</p>
<p>按题意得：  </p>
<p><img src="https://ws1.sinaimg.cn/large/dda38d2bly1g4kk77nirdj203r01wmwz.jpg" alt=""></p>
<p>因为有<img src="https://ws1.sinaimg.cn/large/dda38d2bly1g4kk77objuj204c00tglf.jpg" alt=""></p>
<p>所以原式等于  </p>
<p><img src="https://ws1.sinaimg.cn/large/dda38d2bly1g4kk77o2wwj206o01w3yd.jpg" alt=""></p>
<p>处理一下即推出上面的结论</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string s;</span><br><span class="line">    while(cin&gt;&gt;s)&#123;</span><br><span class="line">        if(s&#x3D;&#x3D;&quot;0&quot;)break;</span><br><span class="line">        int ans&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;s.length();i++)ans+&#x3D;(s[i]-&#39;0&#39;);</span><br><span class="line">        printf(&quot;%d\n&quot;,1+(ans-1)%9);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 5973 Game of Taking Stones（威佐夫博弈，java大数，二分求高精度根号）</title>
    <url>/f0d0bafc/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5973" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=5973</a></p>
<p>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Two people face two piles of stones and make a game. They take turns to take stones. As game rules, there are two different methods of taking stones: One scheme is that you can take any number of stones in any one pile while the alternative is to take the same amount of stones at the same time in two piles. In the end, the first person taking all the stones is winner.Now,giving the initial number of two stones, can you win this game if you are the first to take stones and both sides have taken the best strategy?</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>Input contains multiple sets of test data.Each test data occupies one line,containing two non-negative integers a andb,representing the number of two stones.a and b are not more than 10^100.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test data,output answer on one line.1 means you are the winner,otherwise output 0.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 1</span><br><span class="line">8 4</span><br><span class="line">4 7</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>


<h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>2016ACM/ICPC亚洲区大连站-重现赛（感谢大连海事大学）</p>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>首先这是个威佐夫博弈裸题 判断<code>(b-a)*((√5+1)/2)==a</code>是否成立即可，麻烦在于又加了大数</p>
<p>刚开始直接用之前算过的1000位黄金分割数 <a href="https://leflacon.github.io/2e9cbb0/" target="_blank" rel="noopener">计算黄金分割数小数点后1000位</a> 交了一发，然后wa了？？？黑人问号。。</p>
<p>然后查了网上的写法，是二分求高精度√5，具体见代码</p>
<p>跑500次二分精确度只能到两百多位，那为啥那个精确到一千位的数不行么（我当时跑了10000次循环来着）。。猜测可能是赋值问题吧emmmmmm。。不管了</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;  </span><br><span class="line">import java.math.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">        BigDecimal a,b,tmp,hj;</span><br><span class="line">        BigDecimal l&#x3D;BigDecimal.valueOf(2),r&#x3D;BigDecimal.valueOf(3);</span><br><span class="line">        for(int i&#x3D;0;i&lt;500;i++) &#123;</span><br><span class="line">        	BigDecimal m&#x3D;l.add(r).divide(BigDecimal.valueOf(2));</span><br><span class="line">        	if(m.multiply(m).compareTo(BigDecimal.valueOf(5))&lt;0)l&#x3D;m;</span><br><span class="line">        	else r&#x3D;m;</span><br><span class="line">        &#125;</span><br><span class="line">        hj&#x3D;l.add(BigDecimal.valueOf(1)).divide(BigDecimal.valueOf(2));</span><br><span class="line">        while(cin.hasNext()) &#123;</span><br><span class="line">        	a&#x3D;cin.nextBigDecimal();</span><br><span class="line">        	b&#x3D;cin.nextBigDecimal();</span><br><span class="line">        	if(a.compareTo(b)&gt;0) &#123;</span><br><span class="line">        		tmp&#x3D;a;a&#x3D;b;b&#x3D;tmp;</span><br><span class="line">        	&#125;</span><br><span class="line">        	a&#x3D;a.setScale(0,BigDecimal.ROUND_DOWN);</span><br><span class="line">        	b&#x3D;b.subtract(a).multiply(hj);</span><br><span class="line">        	b&#x3D;b.setScale(0,BigDecimal.ROUND_DOWN);</span><br><span class="line">        	if(a.compareTo(b)&#x3D;&#x3D;0)System.out.println(&quot;0&quot;);</span><br><span class="line">        	else System.out.println(&quot;1&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        cin.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>博弈</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 5047 Sawtooth（java大数，分割平面问题）</title>
    <url>/5c6528a4/</url>
    <content><![CDATA[<p>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Think about a plane:</p>
<a id="more"></a>

<p>● One straight line can divide a plane into two regions.<br>● Two lines can divide a plane into at most four regions.<br>● Three lines can divide a plane into at most seven regions.<br>● And so on…</p>
<p>Now we have some figure constructed with two parallel rays in the same direction, joined by two straight segments. It looks like a character “M”. You are given N such “M”s. What is the maximum number of regions that these “M”s can divide a plane ?</p>
<p><img src="http://acm.hdu.edu.cn/data/images/C537-1006-1.jpg" alt=""></p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input is T (1 ≤ T ≤ 100000), which stands for the number of test cases you need to solve.</p>
<p>Each case contains one single non-negative integer, indicating number of “M”s. (0 ≤ N ≤ 1012)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, print a line “Case #t: ”(without quotes, t means the index of the test case) at the beginning. Then an integer that is the maximum number of regions N the “M” figures can divide.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case #1: 2</span><br><span class="line">Case #2: 19</span><br></pre></td></tr></table></figure>


<h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>2014 ACM/ICPC Asia Regional Shanghai Online</p>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>如图有n个“M”，求能把矩形分成几块</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p><code>ans=8*n*n-7*n+1</code></p>
<p>首先n条直线可以把平面分成<code>n*(n+1)/2+1</code>个区域，那么对于<code>4*n</code>条直线来说，可以分成<code>2*n*(4*n+1)+1</code>个区域，一个“M”延长出去后，最多会多9块，也就是说因为“M”型的特殊性，每次会少<code>9*n</code>个块，所以答案为<code>8*n*n-7*n+1</code></p>
<p>其余各种类型分割平面见这个传送门，学习了学习了∑(ﾟДﾟ) <a href="https://blog.csdn.net/qq_34131212/article/details/78043679" target="_blank" rel="noopener">折线分割平面问题总结</a></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;  </span><br><span class="line">import java.math.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">        int t;</span><br><span class="line">        t&#x3D;cin.nextInt();</span><br><span class="line">        BigInteger n,ans;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;t;i++) &#123;</span><br><span class="line">        	n&#x3D;cin.nextBigInteger();</span><br><span class="line">        	ans&#x3D;n.multiply(BigInteger.valueOf(8)).multiply(n);</span><br><span class="line">        	ans&#x3D;ans.subtract(n.multiply(BigInteger.valueOf(7)));</span><br><span class="line">        	ans&#x3D;ans.add(BigInteger.valueOf(1));</span><br><span class="line">        	System.out.println(&quot;Case #&quot;+i+&quot;: &quot;+ans.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        cin.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 5050 Divided Land（java大数，二进制）</title>
    <url>/276c2267/</url>
    <content><![CDATA[<p>Time Limit: 8000/4000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)</p>
<a id="more"></a>

<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>It’s time to fight the local despots and redistribute the land. There is a rectangular piece of land granted from the government, whose length and width are both in binary form. As the mayor, you must segment the land into multiple squares of equal size for the villagers. What are required is there must be no any waste and each single segmented square land has as large area as possible. The width of the segmented square land is also binary.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input is T (1 ≤ T ≤ 100), which stands for the number of test cases you need to solve.</p>
<p>Each case contains two binary number represents the length L and the width W of given land. (0 &lt; L, W ≤ 21000)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, print a line “Case #t: ”(without quotes, t means the index of the test case) at the beginning. Then one number means the largest width of land that can be divided from input data. And it will be show in binary. Do not have any useless number or space.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">10 100</span><br><span class="line">100 110</span><br><span class="line">10010 1100</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case #1: 10</span><br><span class="line">Case #2: 10</span><br><span class="line">Case #3: 110</span><br></pre></td></tr></table></figure>


<h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>2014 ACM/ICPC Asia Regional Shanghai Online</p>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>a,b两个二进制边长，分成大小相等的小正方形，即求gcd(a,b)</p>
<p>java二进制都封装好了T^T太好用了吧</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;  </span><br><span class="line">import java.math.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">        int t;</span><br><span class="line">        t&#x3D;cin.nextInt();</span><br><span class="line">        BigInteger a,b;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;t;i++) &#123;</span><br><span class="line">        	a&#x3D;cin.nextBigInteger(2);</span><br><span class="line">        	b&#x3D;cin.nextBigInteger(2);</span><br><span class="line">        	System.out.println(&quot;Case #&quot;+i+&quot;: &quot;+a.gcd(b).toString(2));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1212 Big Number（java大数取模）</title>
    <url>/6a4cab08/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1212" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1212</a></p>
<p>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>As we know, Big Number is always troublesome. But it’s really important in our ACM. And today, your task is to write a program to calculate A mod B.</p>
<p>To make the problem easier, I promise that B will be smaller than 100000.</p>
<p>Is it too hard? No, I work it out in 10 minutes, and my program contains less than 25 lines.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input contains several test cases. Each test case consists of two positive integers A and B. The length of A will not exceed 1000, and B will be smaller than 100000. Process to the end of file.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, you have to ouput the result of A mod B.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 3</span><br><span class="line">12 7</span><br><span class="line">152455856554521 3250</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">5</span><br><span class="line">1521</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>求A%B，A的长度不超过1000，B小于100000</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p>【c++】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string s;</span><br><span class="line">    int n;</span><br><span class="line">    while(cin&gt;&gt;s&gt;&gt;n)&#123;</span><br><span class="line">        int ans&#x3D;s[0]-&#39;0&#39;;</span><br><span class="line">        for(int i&#x3D;1;i&lt;s.length();i++)ans&#x3D;(ans*10+s[i]-&#39;0&#39;)%n;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【java】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;  </span><br><span class="line">import java.math.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">        BigInteger a,b;</span><br><span class="line">        while(cin.hasNext()) &#123;</span><br><span class="line">        	a&#x3D;cin.nextBigInteger();</span><br><span class="line">        	b&#x3D;cin.nextBigInteger();</span><br><span class="line">        	System.out.println(a.remainder(b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 6222 Heron and His Triangle（海伦公式，打表找规律，java大数）</title>
    <url>/a1e708e2/</url>
    <content><![CDATA[<p>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 262144/262144 K (Java/Others)</p>
<a id="more"></a>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>A triangle is a Heron’s triangle if it satisfies that the side lengths of it are consecutive integers t-1, t, t+ 1 and thatits area is an integer. Now, for given n you need to find a Heron’s triangle associated with the smallest t bigger<br>than or equal to n.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input contains multiple test cases. The first line of a multiple input is an integer T (1 ≤ T ≤ 30000) followedby T lines. Each line contains an integer N (1 ≤ N ≤ 10^30).</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, output the smallest t in a line. If the Heron’s triangle required does not exist, output -1.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure>


<h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>2017ACM/ICPC亚洲区沈阳站-重现赛（感谢东北大学）</p>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>三角形三边为t-1,t,t+1，且面积为整数</p>
<p>给定一个n，找出大于等于n的最小的t</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>求面积这题用海伦公式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p&#x3D;(a+b+c)&#x2F;2</span><br><span class="line">S&#x3D;√p(p-a)(p-b)(p-c)</span><br></pre></td></tr></table></figure>
<p>然后写个c++打表找满足的t</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    for(int i&#x3D;1;i&lt;10000;i++)&#123;</span><br><span class="line">        long double t&#x3D;i,p&#x3D;t*3&#x2F;2,s&#x3D;p*(p-t)*(p-t-1)*(p-t+1);</span><br><span class="line">        LL tmp&#x3D;sqrt(s);</span><br><span class="line">        if(tmp*tmp&#x3D;&#x3D;s)printf(&quot;%d &quot;,i);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到序列：(2) 4 14 52 194 724 2702……</p>
<p>这里2也满足式子，但是1，2，3不能构成三角形，不过2在推公式时候可以用一下</p>
<p>发现递推式<code>f[n]=4*f[n-1]-f[n-2]</code></p>
<p>然后10^30就是java大数搞一搞了</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;  </span><br><span class="line">import java.math.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">        BigInteger f[]&#x3D;new BigInteger[105];</span><br><span class="line">        f[1]&#x3D;BigInteger.valueOf(4);f[2]&#x3D;BigInteger.valueOf(14);       </span><br><span class="line">        BigInteger tmp&#x3D;BigInteger.valueOf(10);</span><br><span class="line">        int ji&#x3D;2;</span><br><span class="line">        while(f[ji].compareTo(tmp.pow(30))&lt;&#x3D;0) &#123;</span><br><span class="line">        	ji++;</span><br><span class="line">        	f[ji]&#x3D;f[ji-1].multiply(BigInteger.valueOf(4)).subtract(f[ji-2]);</span><br><span class="line">        &#125;</span><br><span class="line">        int t;</span><br><span class="line">        t&#x3D;cin.nextInt();</span><br><span class="line">        while(t--&gt;0) &#123;</span><br><span class="line">        	BigInteger n&#x3D;cin.nextBigInteger();</span><br><span class="line">        	for(int i&#x3D;1;i&lt;&#x3D;ji;i++) &#123;</span><br><span class="line">        		if(n.compareTo(f[i])&lt;&#x3D;0) &#123;</span><br><span class="line">        			System.out.println(f[i]);</span><br><span class="line">        			break;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 2054 A == B ?（java高精度）</title>
    <url>/560387bb/</url>
    <content><![CDATA[<p>Time Limit: 1000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Give you two numbers A and B, if A is equal to B, you should print “YES”, or print “NO”.</p>
<a id="more"></a>

<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>each test case contains two numbers A and B.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>for each case, if A is equal to B, you should print “YES”, or print “NO”.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2</span><br><span class="line">2 2</span><br><span class="line">3 3</span><br><span class="line">4 3</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>

<hr>
<p>虽然样例给的都是整数，但是题目里说给的是两个数，所以有小数。。用BigDecimal就行</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;  </span><br><span class="line">import java.math.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">        BigDecimal a,b;</span><br><span class="line">        while(cin.hasNext()) &#123;</span><br><span class="line">        	a&#x3D;cin.nextBigDecimal();</span><br><span class="line">        	b&#x3D;cin.nextBigDecimal();</span><br><span class="line">        	if(a.compareTo(b)&#x3D;&#x3D;0)System.out.println(&quot;YES&quot;);</span><br><span class="line">        	else System.out.println(&quot;NO&quot;);      </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 4523 威威猫系列故事——过生日（java大数）</title>
    <url>/d5042e55/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4523" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=4523</a></p>
<p>Time Limit: 500/200 MS (Java/Others)    Memory Limit: 65535/32768 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>　　2月29号是威威猫的生日，由于这个日子非常特殊，4年才一次，所以生日这天许多朋友都前往威威猫家祝贺他的生日。<br>　　大家给威威猫买了一个非常大非常大的蛋糕，蛋糕的形状是一个有n条边的凸多边形，可是威威猫的审美观有一点奇怪，他只喜欢有m条边的蛋糕，所以他要伙伴们把这个蛋糕切p次，然后给他一个只有m条边的新蛋糕。这下大家急了，这不是坑爹吗，审美观崎岖作怪。<br>　　假设蛋糕可看成一个平面含n条边的凸多边形，每一刀必须沿直线切下去，p刀之后能给威威猫切出一个m条边的蛋糕吗？</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>多组测试数据，每组占一行，包含3个整数n, m, p（含义如上）。<br>[Technical Specification]<br>3 &lt;= n &lt;= 10^100<br>0 &lt; m &lt;= 10^100<br>0 &lt;= p &lt;= 10^100</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>每组测试数据，如果能够切出威威猫喜欢的蛋糕，请输出”YES”，否则请输出”NO”；<br>每组数据输出一行。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 5 1</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure>

<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>Sample对应的示意图如下：<br><img src="http://acm.hdu.edu.cn/data/images/4523-1.jpg" alt=""></p>
<h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>2013腾讯编程马拉松初赛第四场（3月24日）</p>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>切一刀最多可以少n-3条边或者多1条边，所以就是判断m是否在[3，n+p]范围内</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;  </span><br><span class="line">import java.math.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">        BigInteger n,m,p;</span><br><span class="line">        while(cin.hasNextBigInteger()) &#123;</span><br><span class="line">        	n&#x3D;cin.nextBigInteger();</span><br><span class="line">        	m&#x3D;cin.nextBigInteger();</span><br><span class="line">        	p&#x3D;cin.nextBigInteger();</span><br><span class="line">        	if(m.compareTo(BigInteger.valueOf(3))&gt;&#x3D;0&amp;&amp;m.compareTo(n.add(p))&lt;&#x3D;0)System.out.println(&quot;YES&quot;);</span><br><span class="line">        	else System.out.println(&quot;NO&quot;);      </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 5920 Ugly Problem（贪心，java大数）</title>
    <url>/cfe28c6a/</url>
    <content><![CDATA[<p>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)</p>
<p>Special Judge</p>
<a id="more"></a>

<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Everyone hates ugly problems.</p>
<p>You are given a positive integer. You must represent that number by sum of palindromic numbers.</p>
<p>A palindromic number is a positive integer such that if you write out that integer as a string in decimal without leading zeros, the string is an palindrome. For example, 1 is a palindromic number and 10 is not.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>In the first line of input, there is an integer T denoting the number of test cases.</p>
<p>For each test case, there is only one line describing the given integer s (1≤s≤10^1000).</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, output “Case #x:” on the first line where x is the number of that test case starting from 1. Then output the number of palindromic numbers you used, n, on one line. n must be no more than 50. en output n lines, each containing one of your palindromic numbers. Their sum must be exactly s.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">18</span><br><span class="line">1000000000000</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case #1:</span><br><span class="line">2</span><br><span class="line">9</span><br><span class="line">9</span><br><span class="line">Case #2:</span><br><span class="line">2</span><br><span class="line">999999999999</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9 + 9 &#x3D; 18</span><br><span class="line">999999999999 + 1 &#x3D; 1000000000000</span><br></pre></td></tr></table></figure>



<h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>2016中国大学生程序设计竞赛（长春）-重现赛</p>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给一个数n，把它分成50个以内回文数，这些回文数的和等于n</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>题目竟然叫ugly problem。。果然不beautiful。。wa了好多次。。c++的话大概是要再写一个高精度减法</p>
<p>思路是构造的时候贪心的去构造，对一个数x来说，先取他的前（len+1）/2 位，记为l，然后再复制（len/2）位记为r，（这两个式子对奇偶都适用）</p>
<p>如果生成的这个长度相同的数now比x小，那么直接更新x，用新的x重复上诉操作</p>
<p>如果生成的now比x大，那么就把l-1，用新的l来算出r和now</p>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x&#x3D;654321</span><br><span class="line">则一开始l&#x3D;654，这样r&#x3D;456，now&#x3D;654456，但是654456&gt;654321，</span><br><span class="line">所以l--，l&#x3D;653，r&#x3D;356，now&#x3D;653356，更新x，x&#x3D;654321-653356&#x3D;965，</span><br><span class="line">l&#x3D;96，r&#x3D;9，now&#x3D;969，969&gt;965，l&#x3D;95，r&#x3D;9，now&#x3D;959，</span><br><span class="line">x&#x3D;965-959&#x3D;6，跳出while，存入最后一个6</span><br></pre></td></tr></table></figure>


<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;  </span><br><span class="line">import java.math.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">        int t;</span><br><span class="line">        t&#x3D;cin.nextInt();</span><br><span class="line">        BigInteger x&#x3D;BigInteger.valueOf(0),num,jian;</span><br><span class="line">        String s&#x3D;null,r&#x3D;null,l&#x3D;null,now&#x3D;null;</span><br><span class="line">        String ans[]&#x3D;new String[55];</span><br><span class="line">        for(int cas&#x3D;1;cas&lt;&#x3D;t;cas++) &#123;</span><br><span class="line">            int ji&#x3D;0;</span><br><span class="line">            x&#x3D;cin.nextBigInteger();</span><br><span class="line">            System.out.println(&quot;Case #&quot;+cas+&quot;:&quot;);</span><br><span class="line">            s&#x3D;x.toString();</span><br><span class="line">            int len&#x3D;s.length();</span><br><span class="line">            now&#x3D;s.substring(0,(len+1)&#x2F;2);</span><br><span class="line">            num&#x3D;new BigInteger(now);</span><br><span class="line">            while(x.compareTo(BigInteger.valueOf(11))&gt;&#x3D;0) &#123;</span><br><span class="line">                l&#x3D;num.toString();</span><br><span class="line">                r&#x3D;&quot;&quot;;</span><br><span class="line">                for(int i&#x3D;len&#x2F;2-1;i&gt;&#x3D;0;i--)r&#x3D;r+l.charAt(i);</span><br><span class="line">                now&#x3D;l+r;</span><br><span class="line">                jian&#x3D;new BigInteger(now);</span><br><span class="line">                if(x.compareTo(jian)&gt;&#x3D;0) &#123;</span><br><span class="line">                    x&#x3D;x.subtract(jian);</span><br><span class="line">                    ans[ji++]&#x3D;now;</span><br><span class="line">                    s&#x3D;x.toString();</span><br><span class="line">                    len&#x3D;s.length();</span><br><span class="line">                    now&#x3D;s.substring(0,(len+1)&#x2F;2);</span><br><span class="line">                    num&#x3D;new BigInteger(now);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    num&#x3D;num.subtract(BigInteger.valueOf(1));</span><br><span class="line">                &#125;                           </span><br><span class="line">            &#125;</span><br><span class="line">            int res&#x3D;x.intValue();</span><br><span class="line">            if(res&gt;&#x3D;10) &#123;</span><br><span class="line">                ans[ji++]&#x3D;&quot;9&quot;;</span><br><span class="line">                ans[ji++]&#x3D;String.valueOf(res-9);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(res!&#x3D;0)&#123;</span><br><span class="line">                ans[ji++]&#x3D;String.valueOf(res);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ji);</span><br><span class="line">            for(int i&#x3D;0;i&lt;ji;i++)System.out.println(ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java大数水题集 高精度</title>
    <url>/84b8f7c6/</url>
    <content><![CDATA[<p>自从有一次用java写一个卡特兰数<a href="https://leflacon.github.io/bb984cd4/" target="_blank" rel="noopener"> C. Catalan Square </a>的题之后，觉得再不写写java大整数就老了。。啊c++高精度模拟再见吧╮(￣▽￣””)╭</p>
<p>先水个几题感受一下～</p>
<hr>
<p>hdu 1002 <a href="https://leflacon.github.io/be3871f5" target="_blank" rel="noopener">A + B Problem II</a> 开头肯定是<s>万恶之源</s>a+b </p>
<p>hdu 1753 <a href="https://leflacon.github.io/773303aa/" target="_blank" rel="noopener">大明A+B</a>小数a+b</p>
<p>hdu 2054 <a href="https://leflacon.github.io/560387bb" target="_blank" rel="noopener">A == B ?</a>判断两个大数（可能是小数）是否相等</p>
<p>hdu 1047 <a href="https://leflacon.github.io/63dfb318" target="_blank" rel="noopener">Integer Inquiry</a>很多大数相加</p>
<p>hdu 1212 <a href="https://leflacon.github.io/6a4cab08" target="_blank" rel="noopener">Big Number</a>a%b </p>
<p>hdu 1042 <a href="https://leflacon.github.io/7becbf63" target="_blank" rel="noopener">N！</a>阶乘</p>
<p>hdu 1715 <a href="https://leflacon.github.io/bef6deea" target="_blank" rel="noopener">大菲波数</a>大斐波那契</p>
<p>hdu 1250 <a href="https://leflacon.github.io/5f826ba6" target="_blank" rel="noopener">Hat’s Fibonacci</a>类似斐波那契</p>
<p>hdu 1316 <a href="https://leflacon.github.io/659aa8d8" target="_blank" rel="noopener">How Many Fibs?
</a>区间斐波那契</p>
<p>hdu 1063 <a href="https://leflacon.github.io/c2176cf3" target="_blank" rel="noopener">Exponentiation
</a>小数的n次方高精度</p>
<p>hdu 5050 <a href="https://leflacon.github.io/276c2267" target="_blank" rel="noopener">Divided Land
</a>二进制大数</p>
<p>还有些没那么那么水的题就不收录在这篇了，放在分类java–BigInteger下面了</p>
<hr>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1753 大明A+B（java高精度小数）</title>
    <url>/773303aa/</url>
    <content><![CDATA[<p>Time Limit: 3000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)</p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1753" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1753</a></p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>话说，经过了漫长的一个多月，小明已经成长了许多，所以他改了一个名字叫“大明”。<br>这时他已经不是那个只会做100以内加法的那个“小明”了，现在他甚至会任意长度的正小数的加法。</p>
<p>现在，给你两个正的小数A和B，你的任务是代表大明计算出A+B的值。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>本题目包含多组测试数据，请处理到文件结束。<br>每一组测试数据在一行里面包含两个长度不大于400的正小数A和B。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>请在一行里面输出输出A+B的值，请输出最简形式。详细要求请见Sample Output。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.1 2.9</span><br><span class="line">1.1111111111 2.3444323343</span><br><span class="line">1 1.1</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">3.4555434454</span><br><span class="line">2.1</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;  </span><br><span class="line">import java.math.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">        BigDecimal a,b;</span><br><span class="line">        while(cin.hasNext()) &#123;</span><br><span class="line">        	a&#x3D;cin.nextBigDecimal();</span><br><span class="line">        	b&#x3D;cin.nextBigDecimal();</span><br><span class="line">            String ans&#x3D;a.add(b).stripTrailingZeros().toPlainString();&#x2F;&#x2F;化简</span><br><span class="line">            System.out.println(ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1316 How Many Fibs?（java大数，区间斐波那契）</title>
    <url>/659aa8d8/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1316" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1316</a></p>
<p>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Recall the definition of the Fibonacci numbers:<br>f1 := 1<br>f2 := 2<br>fn := fn-1 + fn-2 (n &gt;= 3) </p>
<p>Given two numbers a and b, calculate how many Fibonacci numbers are in the range [a, b]. </p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input contains several test cases. Each test case consists of two non-negative integer numbers a and b. Input is terminated by a = b = 0. Otherwise, a &lt;= b &lt;= 10^100. The numbers a and b are given with no superfluous leading zeros.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case output on a single line the number of Fibonacci numbers fi with a &lt;= fi &lt;= b. </p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 100</span><br><span class="line">1234567890 9876543210</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">4</span><br></pre></td></tr></table></figure>


<h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>University of Ulm Local Contest 2000</p>
<hr>
<p>[a,b]区间内有多少个斐波那契数，a &lt;= b &lt;= 10^100</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;  </span><br><span class="line">import java.math.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">        int ans;</span><br><span class="line">        BigInteger a,b;</span><br><span class="line">        BigInteger f[]&#x3D;new BigInteger[1005];</span><br><span class="line">        f[1]&#x3D;BigInteger.valueOf(1);</span><br><span class="line">        f[2]&#x3D;BigInteger.valueOf(2);</span><br><span class="line">        for(int i&#x3D;3;i&lt;&#x3D;1000;i++)f[i]&#x3D;f[i-1].add(f[i-2]);</span><br><span class="line">        while(cin.hasNextBigInteger()) &#123;</span><br><span class="line">        	ans&#x3D;0;</span><br><span class="line">        	a&#x3D;cin.nextBigInteger();</span><br><span class="line">        	b&#x3D;cin.nextBigInteger();</span><br><span class="line">        	if(a.compareTo(BigInteger.valueOf(0))&#x3D;&#x3D;0&amp;&amp;b.compareTo(BigInteger.valueOf(0))&#x3D;&#x3D;0)break;</span><br><span class="line">        	for(int i&#x3D;1;i&lt;&#x3D;1000;i++) &#123;</span><br><span class="line">        		if(a.compareTo(f[i])&lt;&#x3D;0&amp;&amp;b.compareTo(f[i])&gt;&#x3D;0)ans++;</span><br><span class="line">        		if(b.compareTo(f[i])&lt;0)break;</span><br><span class="line">        	&#125;</span><br><span class="line">            System.out.println(ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1063 Exponentiation（java高精度）</title>
    <url>/c2176cf3/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1063" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1063</a><br>Time Limit: 2000/500 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Problems involving the computation of exact values of very large magnitude and precision are common. For example, the computation of the national debt is a taxing experience for many computer systems. </p>
<p>This problem requires that you write a program to compute the exact value of Rn where R is a real number ( 0.0 &lt; R &lt; 99.999 ) and n is an integer such that 0 &lt; n &lt;= 25. </p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input will consist of a set of pairs of values for R and n. The R value will occupy columns 1 through 6, and the n value will be in columns 8 and 9.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>The output will consist of one line for each line of input giving the exact value of R^n. Leading zeros should be suppressed in the output. Insignificant trailing zeros must not be printed. Don’t print the decimal point if the result is an integer.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">95.123 12</span><br><span class="line">0.4321 20</span><br><span class="line">5.1234 15</span><br><span class="line">6.7592  9</span><br><span class="line">98.999 10</span><br><span class="line">1.0100 12</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">548815620517731830194541.899025343415715973535967221869852721</span><br><span class="line">.00000005148554641076956121994511276767154838481760200726351203835429763013462401</span><br><span class="line">43992025569.928573701266488041146654993318703707511666295476720493953024</span><br><span class="line">29448126.764121021618164430206909037173276672</span><br><span class="line">90429072743629540498.107596019456651774561044010001</span><br><span class="line">1.126825030131969720661201</span><br></pre></td></tr></table></figure>


<h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>East Central North America 1988</p>
<hr>
<p>求R^n，( 0.0 &lt; R &lt; 99.999，0 &lt; n &lt;= 25 )</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;  </span><br><span class="line">import java.math.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">        while(cin.hasNext()) &#123;</span><br><span class="line">        	BigDecimal ans&#x3D;cin.nextBigDecimal();</span><br><span class="line">            int n&#x3D;cin.nextInt();</span><br><span class="line">            String res&#x3D;ans.pow(n).stripTrailingZeros().toPlainString();&#x2F;&#x2F;整数去掉小数点和后面的0</span><br><span class="line">            if(res.startsWith(&quot;0&quot;))&#123;</span><br><span class="line">         	   res&#x3D;res.substring(1);&#x2F;&#x2F;从第一位开始取，即去前导0</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1250 Hat&#39;s Fibonacci（java大数）</title>
    <url>/5f826ba6/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1250" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1250</a></p>
<p>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>A Fibonacci sequence is calculated by adding the previous two members the sequence, with the first two members being both 1.<br>F(1) = 1, F(2) = 1, F(3) = 1,F(4) = 1, F(n&gt;4) = F(n - 1) + F(n-2) + F(n-3) + F(n-4)<br>Your task is to take a number as input, and print that Fibonacci number.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>Each line will contain an integers. Process to end of file.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each case, output the result in a line.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4203968145672990846840663646</span><br></pre></td></tr></table></figure>


<h3 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h3><p>No generated Fibonacci number in excess of 2005 digits will be in the test data, ie. F(20) = 66526 has 5 digits.</p>
<hr>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;  </span><br><span class="line">import java.math.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">        BigInteger []f&#x3D;new BigInteger[10005];</span><br><span class="line">        f[1]&#x3D;BigInteger.valueOf(1);</span><br><span class="line">        f[2]&#x3D;BigInteger.valueOf(1);</span><br><span class="line">        f[3]&#x3D;BigInteger.valueOf(1);</span><br><span class="line">        f[4]&#x3D;BigInteger.valueOf(1);</span><br><span class="line">        for(int i&#x3D;5;i&lt;&#x3D;10000;i++) &#123;</span><br><span class="line">            f[i]&#x3D;f[i-1].add(f[i-2].add(f[i-3].add(f[i-4])));</span><br><span class="line">        &#125;</span><br><span class="line">        int n;</span><br><span class="line">        while(cin.hasNext()) &#123;</span><br><span class="line">            n&#x3D;cin.nextInt();</span><br><span class="line">            System.out.println(f[n]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1715 大菲波数（java大数）</title>
    <url>/bef6deea/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1715" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1715</a></p>
<p>Time Limit: 1000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Fibonacci数列，定义如下：<br>f(1)=f(2)=1<br>f(n)=f(n-1)+f(n-2) n&gt;=3。<br>计算第n项Fibonacci数值。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入第一行为一个整数N，接下来N行为整数Pi（1&lt;=Pi&lt;=1000）。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出为N行，每行为对应的f(Pi)。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;  </span><br><span class="line">import java.math.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">        BigInteger []f&#x3D;new BigInteger[1005];</span><br><span class="line">        f[1]&#x3D;BigInteger.valueOf(1);</span><br><span class="line">        f[2]&#x3D;BigInteger.valueOf(1);</span><br><span class="line">        for(int i&#x3D;3;i&lt;&#x3D;1000;i++) &#123;</span><br><span class="line">            f[i]&#x3D;f[i-1].add(f[i-2]);</span><br><span class="line">        &#125;</span><br><span class="line">        int t&#x3D;cin.nextInt(),n;</span><br><span class="line">        while(t--&gt;0) &#123;</span><br><span class="line">            n&#x3D;cin.nextInt();</span><br><span class="line">            System.out.println(f[n]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1047 Integer Inquiry（java大数）</title>
    <url>/63dfb318/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1047" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1047</a></p>
<p>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>One of the first users of BIT’s new supercomputer was Chip Diller. He extended his exploration of powers of 3 to go from 0 to 333 and he explored taking various sums of those numbers.<br>“This supercomputer is great,” remarked Chip. “I only wish Timothy were here to see these results.” (Chip moved to a new apartment, once one became available on the third floor of the Lemon Sky apartments on Third Street.) </p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input will consist of at most 100 lines of text, each of which contains a single VeryLongInteger. Each VeryLongInteger will be 100 or fewer characters in length, and will only contain digits (no VeryLongInteger will be negative). </p>
<p>The final input line will contain a single zero on a line by itself.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Your program should output the sum of the VeryLongIntegers given in the input. </p>
<p>This problem contains multiple test cases!</p>
<p>The first line of a multiple input is an integer N, then a blank line followed by N input blocks. Each input block is in the format indicated in the problem description. There is a blank line between input blocks.</p>
<p>The output format consists of N output blocks. There is a blank line between output blocks.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">123456789012345678901234567890</span><br><span class="line">123456789012345678901234567890</span><br><span class="line">123456789012345678901234567890</span><br><span class="line">0</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">370370367037037036703703703670</span><br></pre></td></tr></table></figure>


<h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>East Central North America 1996</p>
<hr>
<p>最多100个100个字符那么长的大数相加</p>
<p>最后一行不多一个换行</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>import java.io.*; 
import java.math.*;
import java.util.*;

public class Main {
    public static void main(String[] args){
        Scanner cin=new Scanner(System.in);
        int t;
        BigInteger ans,a;
        t=cin.nextInt();
        while(t--&gt;0){
            ans=BigInteger.valueOf(0);
            while(cin.hasNextBigInteger()) {
                a=cin.nextBigInteger();
                if(!a.equals(BigInteger.valueOf(0))) {
                    ans=ans.add(a);
                }
                else {
                    System.out.println(ans);
                    if(t&gt;0)System.out.println(&quot;&quot;);
                    break;
                }
            }
        }
    }
}</code></pre>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1042 N!（Java大整数，阶乘）</title>
    <url>/7becbf63/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1042" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1042</a></p>
<p>Time Limit: 10000/5000 MS (Java/Others)    Memory Limit: 262144/262144 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Given an integer N(0 ≤ N ≤ 10000), your task is to calculate N!</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>One N in one line, process to the end of file.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each N, output N! in one line.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<hr>
<p>一路写水题的感觉真的好舒服0.0</p>
<p>不过这个题wa到怀疑人生啊。。直到我发现0的阶乘竟然是0！</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;  </span><br><span class="line">import java.math.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">        BigInteger []a&#x3D;new BigInteger[10005];</span><br><span class="line">        a[0]&#x3D;BigInteger.valueOf(1);</span><br><span class="line">        a[1]&#x3D;BigInteger.valueOf(1);</span><br><span class="line">        int n;</span><br><span class="line">        for(int i&#x3D;2;i&lt;&#x3D;10000;i++) &#123;</span><br><span class="line">            a[i]&#x3D;a[i-1].multiply(BigInteger.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">        while(cin.hasNext()) &#123;</span><br><span class="line">            n&#x3D;cin.nextInt();</span><br><span class="line">            System.out.println(a[n]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1002 A + B Problem II（java大数）</title>
    <url>/be3871f5/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1002" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1002</a></p>
<p>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>I have a very simple problem for you. Given two integers A and B, your job is to calculate the Sum of A + B.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input contains an integer T(1&lt;=T&lt;=20) which means the number of test cases. Then T lines follow, each line consists of two positive integers, A and B. Notice that the integers are very large, that means you should not process them by using 32-bit integer. You may assume the length of each integer will not exceed 1000.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, you should output two lines. The first line is “Case #:”, # means the number of the test case. The second line is the an equation “A + B = Sum”, Sum means the result of A + B. Note there are some spaces int the equation. Output a blank line between two test cases.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">112233445566778899 998877665544332211</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case 1:</span><br><span class="line">1 + 2 &#x3D; 3</span><br><span class="line"></span><br><span class="line">Case 2:</span><br><span class="line">112233445566778899 + 998877665544332211 &#x3D; 1111111111111111110</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>a+b 长度小于1000</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p>pe了无数次。。只好去网上找代码，最后一行没有附加换行。。</p>
<pre><code>import java.io.*;  
import java.math.*;
import java.util.*;

public class Main{
    public static void main(String[] args){
        Scanner cin=new Scanner(System.in);
        int t;
        BigInteger a,b,c;
        t=cin.nextInt();
        for(int i=1;i&lt;=t;i++){
            a=cin.nextBigInteger();
            b=cin.nextBigInteger();
            c=a.add(b);
            System.out.println(&quot;Case &quot;+i+&quot;:&quot;);
            System.out.println(a+&quot; + &quot;+b+&quot; = &quot;+c);
            if(i&lt;t)System.out.println();
        }
    }
}</code></pre>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>C. Catalan Square -- Nordic Collegiate Programming Contest 2014（java大数，卡特兰数）</title>
    <url>/bb984cd4/</url>
    <content><![CDATA[<p>题目里公式太多了0.0，懒得贴题目了直接抛链接吧<br><a href="https://nanti.jisuanke.com/t/30371" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/30371</a></p>
<a id="more"></a>

<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>求卡特兰数的第n+1项，n范围[0,5000]</p>
<p>通项公式：<br><code>f(n)=C(n,2n)/(n+1)=(2n)!/((n!)*(n+1)!)=C(n,2n)-C(n+1,2n)</code></p>
<p>递推公式：<br><code>f(n)=f(n-1)*(4*n-2)/(n+1)</code></p>
<p>1,1,2,5,14,42,132,429,1430……</p>
<hr>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;  </span><br><span class="line">import java.math.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"> </span><br><span class="line">public class Main&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">		BigInteger []a&#x3D;new BigInteger[5005];</span><br><span class="line">		BigInteger start&#x3D;new BigInteger(&quot;1&quot;);</span><br><span class="line">		a[0]&#x3D;start;</span><br><span class="line">		a[1]&#x3D;start;</span><br><span class="line">		for(int i&#x3D;2;i&lt;5005;i++)&#123;</span><br><span class="line">			Integer t1&#x3D;i+1;</span><br><span class="line">			Integer t2&#x3D;4*i-2; </span><br><span class="line">			BigInteger k1&#x3D;new BigInteger(t1.toString());</span><br><span class="line">			BigInteger k2&#x3D;new BigInteger(t2.toString());</span><br><span class="line">			a[i]&#x3D;(a[i-1].multiply(k2)).divide(k1);</span><br><span class="line">		&#125;</span><br><span class="line">		while(cin.hasNext())&#123;</span><br><span class="line">			int n &#x3D; cin.nextInt();</span><br><span class="line">			System.out.println(a[n]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>A. Too Rich -- ACM Changchun 2015（贪心，dfs，回溯）</title>
    <url>/10a23843/</url>
    <content><![CDATA[<p><a href="https://nanti.jisuanke.com/t/30416" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/30416</a></p>
<p>You are a rich person, and you think your wallet is too heavy and full now. So you want to give me some money by buying a lovely pusheen sticker which costs p dollars from me. To make your wallet lighter, you decide to pay exactly p dollars by as many coins and/or banknotes as possible.</p>
<p>For example, if p = 17 and you have two 10 coins, four 5 coins, and eight 1 coins, you will pay it by two 5 coins and seven 1 coins. But this task is incredibly hard since you are too rich and the sticker is too expensive and pusheen is too lovely, please write a program to calculate the best solution.</p>
<h3 id="Input-Format"><a href="#Input-Format" class="headerlink" title="Input Format"></a>Input Format</h3><p>The first line contains an integer T indicating the total number of test cases.</p>
<p>Each test case is a line with 11 integers p, c1, c5, c10, c20, c50, c100, c200, c500, c1000, c2000, specifying the price of the pusheen sticker, and the number of coins and banknotes in each denomination. The number ci means how many coins/banknotes in denominations of ii dollars in your wallet.</p>
<p>• 200001≤T≤20000</p>
<p>• 0≤p≤10^9</p>
<p>• ci≤100000</p>
<h3 id="Output-Format"><a href="#Output-Format" class="headerlink" title="Output Format"></a>Output Format</h3><p>For each test case, please output the maximum number of coins and/or banknotes he can pay for exactly p dollars in a line. If you cannot pay for exactly p dollars, please simply output ‘-1’.</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">17 8 4 2 0 0 0 0 0 0 0</span><br><span class="line">100 99 0 0 0 0 0 0 0 0 0</span><br><span class="line">2015 9 8 7 6 5 4 3 2 1 0</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9 </span><br><span class="line">-1 </span><br><span class="line">36</span><br></pre></td></tr></table></figure>
<h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p>ACM Changchun 2015</p>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>有面值1,5,10,20,50,100,200,500,1000,2000的硬币各若干，问你能不能用最多的硬币凑出p元，能的话输出最多硬币数，不能的话输出-1，</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>如果要保证硬币数最多的话，肯定是要让小面值的硬币尽可能的多，所以肯定是用贪心的思路去求解，有两种贪心的思路，一种是从小面值硬币开始看能不能凑成p元，还有一种是从大面值开始看能不能凑出money-p元（money是硬币能凑成的总钱数）</p>
<p>考虑一下这种情况：<code>60=10+50=20+20+20</code>，假设刚好只有10，20，20，20，50这五个硬币，从小面值开始取，如果10已取，那么只能找50，是无法保证最优的，所以这里考虑到回溯，如果开始取第二种硬币后，第一种硬币个数大于0，那么我就假设第一种硬币少取一个，用新状态继续dfs</p>
<p>但是仔细一想这也有个问题啊，因为是在所有可行解里找最小的，如果要你用2000个1元和1个2000元凑2001元，那么一开始贪心的取2000个1元硬币，然后一个一个减要dfs到什么时候0.0，所以这就是这题的另一个特点，硬币面值差比较大</p>
<p>所以不如用第二种贪心的思路，既然要求用最多的硬币凑成p，那不如求用最少的硬币凑成（money-p），这样就是从最大面值开始贪心，然后回溯</p>
<p>a[i]存的是给定的硬币数，b[i]存的是当前取的第i种硬币的个数，dfs（m，cur，res），m表示当前还需要凑的钱，cur表示当前轮到使用的硬币是哪种，res表示当前需要的硬币个数</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line">const int N&#x3D;1000005;</span><br><span class="line">LL coin[10]&#x3D;&#123;1,5,10,20,50,100,200,500,1000,2000&#125;,a[10],b[10],ans;</span><br><span class="line">void dfs(LL m,int cur,int res)&#123;</span><br><span class="line">    if(m&#x3D;&#x3D;0)&#123;</span><br><span class="line">        ans&#x3D;ans&gt;res?res:ans;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(cur&#x3D;&#x3D;-1)return;</span><br><span class="line">    b[cur]&#x3D;a[cur]&gt;(m&#x2F;coin[cur])?(m&#x2F;coin[cur]):a[cur];</span><br><span class="line">    dfs(m-coin[cur]*b[cur],cur-1,res+b[cur]);</span><br><span class="line">    if(b[cur]&gt;0)&#123;</span><br><span class="line">        b[cur]--;</span><br><span class="line">        dfs(m-coin[cur]*b[cur],cur-1,res+b[cur]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,p;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;p);</span><br><span class="line">        LL money&#x3D;0,geshu&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;10;i++)&#123;</span><br><span class="line">            scanf(&quot;%lld&quot;,&amp;a[i]);</span><br><span class="line">            geshu+&#x3D;a[i];</span><br><span class="line">            money+&#x3D;coin[i]*a[i];      </span><br><span class="line">        &#125;</span><br><span class="line">        money-&#x3D;p;</span><br><span class="line">        if(money&lt;0)&#123;</span><br><span class="line">            puts(&quot;-1&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            ans&#x3D;INF;</span><br><span class="line">            dfs(money,9,0);</span><br><span class="line">            if(ans&#x3D;&#x3D;INF)puts(&quot;-1&quot;);</span><br><span class="line">            else printf(&quot;%lld\n&quot;,geshu-ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>wxpy -- 用 Python 玩微信</title>
    <url>/12fb71da/</url>
    <content><![CDATA[<p>在csdn公众号上看见的，感觉好妙，而且操作简单，这就去玩诶嘿</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkbwzo39j20ku112wir.jpg" alt=""></p>
<a id="more"></a>

<hr>
<h2 id="安装wxpy"><a href="#安装wxpy" class="headerlink" title="安装wxpy"></a>安装wxpy</h2><ul>
<li><p>安装pip（python包管理工具）<br>打开终端，输入<code>sudo easy_install pip</code></p>
</li>
<li><p>安装wxpy<br>装好pip之后继续在终端输入<code>suso pip3 install -U wxpy</code></p>
<blockquote>
<p>（这里如果是python3的话就写pip3，2的话就写pip2，查找python版本的办法是在终端输入<code>python -V</code>（大写））</p>
</blockquote>
</li>
</ul>
<h2 id="用wxpy愉快的玩耍"><a href="#用wxpy愉快的玩耍" class="headerlink" title="用wxpy愉快的玩耍"></a>用wxpy愉快的玩耍</h2><ul>
<li>导入模块，初始化机器人（会扫一个二维码登陆微信）</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkbwz96yj20a204974l.jpg" alt=""></p>
<p>官方文档里说最好用小号试0.0，但是我没有小号啊，直接大号玩0.0，被微信web封也拦不住我(￣Д￣)ﾉ</p>
<ul>
<li>拿基友来做实验 (=´∀｀)人(´∀｀=)</li>
</ul>
<p>新建一个变量就好了，随便记录一下，涂掉的是微信昵称</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kkbwyxg2j20cn01b74d.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@bot.register()   </span><br><span class="line">def print_others(msg):   </span><br><span class="line">	print(msg)</span><br></pre></td></tr></table></figure>
<p>然后有了上面这段就会print实时消息了，这样就能直接在python上实现最基本的收发消息了，奇妙啊，然后继续试了一大堆乱七八糟的功能，官方文档真的说的相当详细了，传送门放下面啦～</p>
<hr>
<h2 id="wxpy传送门"><a href="#wxpy传送门" class="headerlink" title="wxpy传送门"></a>wxpy传送门</h2><p style="background-color:rgba(221,204,222,0.7)">官方文档：[wxpy: 用 Python 玩微信](https://wxpy.readthedocs.io/zh/latest/index.html)

<p>github地址：<a href="https://github.com/youfou/wxpy" target="_blank" rel="noopener">微信机器人 / 可能是最优雅的微信个人号 API ✨✨</a></p></p>
<hr>
]]></content>
      <categories>
        <category>瞎折腾(=ﾟωﾟ)ﾉ</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>文章阅读次数显示：Counter not initialized! See more at consoleerr msg的解决办法</title>
    <url>/52b56662/</url>
    <content><![CDATA[<p>按照网上的leancloud教程配置下来，但是就是显示<code>Counter not initialized! See more at consoleerr msg</code></p>
<a id="more"></a>

<p>然后百度查到了这篇文章：<a href="https://leaferx.online/2018/02/11/lc-security" target="_blank" rel="noopener">Leancloud访客统计插件重大安全漏洞修复指南</a></p>
<p>猜测应该和next升级版啥的或者安全性有关，就按照这篇文章里说的配置了各种，</p>
<p>装了「leancloud-counter-security」这个插件，本以为能解决了的，然而还是显示那句英文(#ﾟДﾟ)</p>
<p>拖了好几天没解决，然后有一次在主题配置文件里乱翻终于发现了问题0.0，然后就是乱搞出奇迹了。。。这里放上我的解决办法</p>
<hr>
<p>首先打开主题配置文件_config.yml，next下的那个，搜索<code>valine:</code>（虽然这个是基于leancloud的评论系统的和阅读量无关，但是在这里发现了很重要的一段话0.0）</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kjj1p9lgj20io07babq.jpg" alt=""></p>
<p>可以看见visitor那一项后面有一段话，我把它截出来了，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">leancloud-counter-security is not supported for now. When visitor is set to be true,</span><br><span class="line"> appid and appkey are recommended to be the same as leancloud_visitors&#39; for counter </span><br><span class="line"> compatibility. Article reading statistic https:&#x2F;&#x2F;valine.js.org&#x2F;visitor.html</span><br><span class="line"></span><br><span class="line">目前不支持leancloud-counter-security。 当访问者设置为true时，建议appid和appkey与</span><br><span class="line">leancloud_visitors相同，以实现计数器兼容性。 文章阅读统计https:&#x2F;&#x2F;valine.js.org&#x2F;visitor.html</span><br></pre></td></tr></table></figure>

<p style="background-color:rgba(219,233,243,0.8)">这里说「leancloud-counter-security」这个插件是不支持的，我原来visitor设置的是false，然后把它改成了ture</p>

<hr>
<p>然后在_config.yml里搜索<code>leancloud_visitors:</code>，如图：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kjj1pgyej20it04ijsb.jpg" alt=""></p>
<p>这里这段话如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If you don&#39;t care about security in lc counter and just want to use it directly</span><br><span class="line">(without hexo-leancloud-counter-security plugin), set the &#96;security&#96; to &#96;false&#96;.</span><br><span class="line"></span><br><span class="line">如果您不关心lc计数器的安全性，只想直接使用它（没有hexo-leancloud-counter-security插件），</span><br><span class="line">将&#96;security&#96;设置为&#96;false&#96;。</span><br></pre></td></tr></table></figure>

<p>security这项，我原来设置的就是true，不知道有没有关系，此处只是放上我的设置而已</p>
<hr>
<p>然后打开leancloud，打开这个项目，存储–Counter–其他–权限设置：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kjj1p676j20ge0bx0ta.jpg" alt=""></p>
<p style="background-color:rgba(219,233,243,0.8)">原来跟着那篇文章把add_fields这一项设了指定用户，然后现在改成了所有用户，虽然这样或许会对安全性有影响0.0，但是管他呢反正能用了先这样再说Σ（ﾟдﾟlll）</p>

<hr>
<p>设置了上面这两个，重新hexo-clean-g-d之后就可以发现阅读量正常显示了，但是这都是在上面那篇别人博客里的文章设置完成且仍出现此问题的情况下设置的，所以不清楚是不是二者相互作用的结果0.0</p>
<hr>
<p style="background-color:rgba(239,221,236,0.7)">「更新」：评论里有小伙伴遇到了不报错但是也不显示数值的问题，这有可能是因为你没有在leancloud里设置安全域名</p>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kjjsmwchj20j40gfgno.jpg" alt=""></p>
<p>如图设置，添加自己的域名即可，比如我没有在安全域名里添加localhost，所以我本地预览的时候就会遇到啥都不显示的情况</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kjjsoo3gj206h015q2q.jpg" alt=""></p>
<p>实际上别的设置都是没有问题哒</p>
<hr>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo下各种博客美化和功能插件汇总（内附本博客css样式）</title>
    <url>/9a99eb64/</url>
    <content><![CDATA[<hr>
<p>自从开始捣鼓hexo也有十几天了，有了点基本功能之后就走上了博客美化的不归路 ◡ ヽ(`Д´)ﾉ ┻━┻ ，这个过程简直是摸爬滚打，各种看不懂各种试效果，而且百度对hexo似乎不是很友好啊，一般的教程都是csdn和简书之类的会放在前面，而且nexT主题还更新了，有些老的教程配置就没法用，还得看官方文档啥的0.0，这篇博客大概记录一下一些问题和几个汇总链接</p>
<a id="more"></a>

<hr>
<p style="background-color:rgba(219,233,243,0.7)">**「目录」** </p>

<p style="background-color:rgba(219,233,243,0.7)">【博客美化和功能插件汇总】    
包括背景和背景动态效果，各种样式设置，递交搜索引擎，评论功能，阅读数，置顶……反正新手上手需要的，大佬的博客里都有</p>

<p style="background-color:rgba(219,233,243,0.7)">【捕捉一只会聊天的看板娘live2d】</p>

<p style="background-color:rgba(219,233,243,0.7)">【访客小地球插件revolvermaps】</p>

<p style="background-color:rgba(219,233,243,0.7)">【给hexo设置不同的背景图片（随机或轮播）】</p>

<p style="background-color:rgba(219,233,243,0.7)">【在菜单栏添加新页面with新图标】</p>

<p style="background-color:rgba(219,233,243,0.7)">【其他杂七杂八的记录】   
1.npm无法装插件，549 throw err的解决办法   
2.hexo g时报错Template render error: unexpected token: >    
3.文章阅读次数显示：Counter not initialized! See more at consoleerr msg    
4.如何给个人博客换上专属免费域名[hexo+github+freenom]
</p>

<hr>
<h2 id="博客美化和功能插件汇总"><a href="#博客美化和功能插件汇总" class="headerlink" title="博客美化和功能插件汇总"></a><p style="background-color:rgba(219,233,243,0.7)">博客美化和功能插件汇总</p></h2><h3 id="hexo大佬的教程"><a href="#hexo大佬的教程" class="headerlink" title="hexo大佬的教程"></a><p style="background-color:rgba(239,221,236,0.7)">hexo大佬的教程</p></h3><p>最前面肯定要放上大佬的这篇：<a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener"><strong>打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化</strong></a></p>
<p>next主题升级可能出现的一些问题和解决：<a href="https://www.suyi123.com/2018/04/26/next%E4%B8%BB%E9%A2%98%E5%8D%87%E7%BA%A76-0/" target="_blank" rel="noopener">next主题升级6.0</a></p>
<p>其他还有很多，因为内容有重复就懒的放了，总之只要获得一个大佬的博客，那么通过他的友链，友链的友链，友链的友链的友链……你就能获得一堆大佬的博客啦～可以去控制台或者通过网页源代码看看那些好看的博客的秘密，虽然大佬们一般是不会留下踪迹的╮(￣▽￣””)╭</p>
<p>总之要先看完第一篇懂个大概才行，不然真的是一头雾水，之前不知道「themes/next/source/css/<em>custom/custom.styl」这个文件是next专门留给用户自定义样式的，以至于跟着别的教程改了一点点不知道哪里的样式设置的源码0.0，要改回来就不方便了，下面也放上我的css样式设置，有些是参考大佬的，没有写很多0.0硬学css，有点乱而且有些地方其实不知道实际是否存在相应对象 _ (:з」∠)</em> 都是保存刷新看效果试出来的</p>
<h3 id="我的custom-styl（现在的可能有改动）"><a href="#我的custom-styl（现在的可能有改动）" class="headerlink" title="我的custom.styl（现在的可能有改动）"></a><p style="background-color:rgba(239,221,236,0.7)">我的custom.styl（现在的可能有改动）</p></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Custom styles.</span><br><span class="line">&#x2F;&#x2F; 主页文章添加阴影效果</span><br><span class="line"> .post &#123;</span><br><span class="line">   margin: 19px 0px 45px 0px;&#x2F;&#x2F;外框离外外框距离</span><br><span class="line">   padding: 10px 30px 5px 30px;&#x2F;&#x2F;文字离外框距离</span><br><span class="line">   -webkit-box-shadow: 0 0 10px rgba(0, 0, 0, .5);</span><br><span class="line">   -moz-box-shadow: 0 0 10px rgba(0, 0, 0, .5);</span><br><span class="line">   background: rgba(255,255,255,0.65) none repeat scroll !important;</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 页面背景图</span><br><span class="line">body &#123;</span><br><span class="line">    background: url(https:&#x2F;&#x2F;hbimg.b0.upaiyun.com&#x2F;fe7343d213869361a4428c581278d427e3d2b0aa9725-Os4lwD_fw658);</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-attachment:fixed;</span><br><span class="line">    background-position:50% 100%;</span><br><span class="line">    background-size: cover;   </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 页面最顶部的横线</span><br><span class="line">.headband &#123;</span><br><span class="line">    height: 1.5px;</span><br><span class="line">    background-image: linear-gradient(90deg, #e3cae4 0%, #ffffff 15%, #d6ceff 30%, #e3cae4 44%, #afc4e0 58%, #d2e4fd 72%, #d1d1ef 86%, #e3cae4 100%);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 页面顶部行高</span><br><span class="line">.header &#123;</span><br><span class="line">    line-height: 1.5;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 页面留白更改</span><br><span class="line">.header-inner &#123;</span><br><span class="line">    padding-top: 20px;</span><br><span class="line">    padding-bottom: 5px;</span><br><span class="line">&#125;</span><br><span class="line">.posts-expand &#123;</span><br><span class="line">    padding-top: 10px;</span><br><span class="line">&#125;</span><br><span class="line">.posts-expand .post-meta &#123;</span><br><span class="line">    margin: 5px 0px 0px 0px;</span><br><span class="line">&#125;</span><br><span class="line">.post-button &#123;</span><br><span class="line">    margin-top: 0px;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 站点名背景</span><br><span class="line">.brand&#123;</span><br><span class="line">    background-color: rgba(255, 255, 255, 0);</span><br><span class="line">    margin-top: 15px;</span><br><span class="line">    padding: 0px;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 站点名字体</span><br><span class="line">.site-title &#123;</span><br><span class="line">    font-family: Times;</span><br><span class="line">    font-size: 38px;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    color: #222222;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 站点子标题</span><br><span class="line">.site-subtitle&#123;</span><br><span class="line">    padding-top: 11px;</span><br><span class="line">    padding-bottom: 5px;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 去除页面底部页码上面的横线</span><br><span class="line">.pagination &#123;</span><br><span class="line">    border: none;</span><br><span class="line">    margin: 0px;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 去掉图片边框</span><br><span class="line">.posts-expand .post-body img &#123;</span><br><span class="line">    border: none;</span><br><span class="line">    padding: 0px;</span><br><span class="line">&#125;</span><br><span class="line">.post-gallery .post-gallery-img img &#123;</span><br><span class="line">    padding: 3px;</span><br><span class="line">&#125;</span><br><span class="line">.posts-expand .post-title &#123;</span><br><span class="line">    font-family: Times;</span><br><span class="line">    font-size: 26px;</span><br><span class="line">    font-weight: 700;</span><br><span class="line">    letter-spacing: 1px;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 文章的描述description</span><br><span class="line">.posts-expand .post-meta &#123;</span><br><span class="line">    font-size: 14px;</span><br><span class="line">    margin-top: 20px;</span><br><span class="line">    margin-bottom: 20px;</span><br><span class="line">    color: #666;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; [Read More]按钮样式</span><br><span class="line">.post-button .btn &#123;</span><br><span class="line">    background-color: #3f3f3f;</span><br><span class="line">    margin-top: 20px;</span><br><span class="line">    margin-bottom: 20px;</span><br><span class="line">    border-color: #7f7f7f;</span><br><span class="line">&#125;</span><br><span class="line">.post-button .btn:hover &#123;</span><br><span class="line">    border-color: #7f7f7f;</span><br><span class="line">    background-color: #ffffff;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 去除在页面文章之间的分割线</span><br><span class="line">.posts-expand .post-eof &#123;</span><br><span class="line">    margin: 0px;</span><br><span class="line">    background-color: rgba(255, 255, 255, 0);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 去除页面底部页码上面的横线</span><br><span class="line">.pagination &#123;</span><br><span class="line">    border: none;</span><br><span class="line">    margin: 0px;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 右下角返回顶部按钮样式</span><br><span class="line">.back-to-top &#123;</span><br><span class="line">    background-color: #373737;</span><br><span class="line">    border-radius: 5px;</span><br><span class="line">&#125;</span><br><span class="line">.back-to-top.back-to-top-on &#123;</span><br><span class="line">    bottom: 10px;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 分类页面</span><br><span class="line">.post-block.page &#123;</span><br><span class="line">    margin-top: 40px;</span><br><span class="line">    margin-right: 30px;</span><br><span class="line">    margin-left: 30px;</span><br><span class="line">&#125;</span><br><span class="line">.category-all-page &#123;</span><br><span class="line">    margin: -80px 0px 40px 0px;</span><br><span class="line">    box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.5);</span><br><span class="line">    background-color: rgba(255, 255, 255, 0.5);</span><br><span class="line">    padding: 80px 20px 100px 40px;&#x2F;&#x2F;上右下左</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 选中文字部分的样式</span><br><span class="line">::selection &#123;</span><br><span class="line">    background-color: #fced6d;</span><br><span class="line">    color: #222222;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 侧栏</span><br><span class="line">.sidebar &#123;</span><br><span class="line">    background-color: rgba(255, 255, 255, 0.5);</span><br><span class="line">    padding-left: 10px;</span><br><span class="line">&#125;</span><br><span class="line">.sidebar-inner &#123;</span><br><span class="line">    margin-top: 0px;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 自定义页脚跳动的心样式</span><br><span class="line">@keyframes heartAnimate &#123;</span><br><span class="line">    0%,100%&#123;transform:scale(1);&#125;</span><br><span class="line">    10%,30%&#123;transform:scale(0.9);&#125;</span><br><span class="line">    20%,40%,60%,80%&#123;transform:scale(1.1);&#125;</span><br><span class="line">    50%,70%&#123;transform:scale(1.1);&#125;</span><br><span class="line">&#125;</span><br><span class="line">#heart &#123;</span><br><span class="line">    animation: heartAnimate 1s ease-in-out infinite;</span><br><span class="line">&#125;</span><br><span class="line">.with-love &#123;</span><br><span class="line">    color: rgba(255,0,0,0.5);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 文章底部评论</span><br><span class="line">.comments &#123;</span><br><span class="line">    box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.75);</span><br><span class="line">    margin: 80px 0px 40px 0px;</span><br><span class="line">    padding: 10px 20px 10px 20px;</span><br><span class="line">&#125;</span><br><span class="line">.post-toc .nav .nav-child &#123;</span><br><span class="line">    display: block;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 侧栏</span><br><span class="line">.sidebar &#123;</span><br><span class="line">    box-shadow: inset 0px 0px 10px 0px rgba(0, 0, 0, 0.3);</span><br><span class="line">    background-color: rgba(255, 255, 255, 0.6);</span><br><span class="line">&#125;</span><br><span class="line">.sidebar-inner &#123;</span><br><span class="line">    margin-top: 30px;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 侧栏顶部文字</span><br><span class="line">.sidebar-nav li &#123;</span><br><span class="line">    font-size: 15px;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    color: #7f7f7f;</span><br><span class="line">&#125;</span><br><span class="line">.sidebar-nav li:hover &#123;</span><br><span class="line">    color: #222222;</span><br><span class="line">&#125;</span><br><span class="line">.sidebar-nav .sidebar-nav-active &#123;</span><br><span class="line">    color: #222222;</span><br><span class="line">    border-bottom-color: #7f7f7f;</span><br><span class="line">    border-bottom-width: 1.5px;</span><br><span class="line">&#125;</span><br><span class="line">.sidebar-nav .sidebar-nav-active:hover &#123;</span><br><span class="line">    color: #626262;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 侧栏站点概况行高</span><br><span class="line">.site-overview &#123;</span><br><span class="line">    line-height: 1;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 侧栏头像（圆形以及旋转效果）</span><br><span class="line">.site-author-image &#123;</span><br><span class="line">    border: 2px inset rgb(255, 255, 255);</span><br><span class="line">    border-radius: 100%;</span><br><span class="line">    transition: transform 1.0s ease-out;</span><br><span class="line">&#125;</span><br><span class="line">img:hover &#123;</span><br><span class="line">    transform: rotateZ(360deg);</span><br><span class="line">&#125;</span><br><span class="line">.posts-expand .post-body img:hover &#123;</span><br><span class="line">    transform: initial;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 侧栏站点作者名</span><br><span class="line">.site-author-name &#123;</span><br><span class="line">    padding: 25px;</span><br><span class="line">    font-size: 20px;</span><br><span class="line">    &#x2F;&#x2F;font-family: Times;</span><br><span class="line">    color: #626262;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 侧栏站点描述</span><br><span class="line">.site-description &#123;</span><br><span class="line">    letter-spacing: 5px;</span><br><span class="line">    font-size: 15px;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    margin-top: 15px;</span><br><span class="line">    margin-left: 13px;</span><br><span class="line">    color: #656565;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 侧栏站点文章、分类、标签</span><br><span class="line">.site-state &#123;</span><br><span class="line">    line-height: 1.3;</span><br><span class="line">    margin-left: 12px;</span><br><span class="line">&#125;</span><br><span class="line">.site-state-item &#123;</span><br><span class="line">    padding: 0px 15px;</span><br><span class="line">    border-left: 1.5px solid #7f7f7f;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 自定义的侧栏时间样式</span><br><span class="line">#days &#123;</span><br><span class="line">    padding: 30px;</span><br><span class="line">    display: block;</span><br><span class="line">    color: #7f7f7f;</span><br><span class="line">    font-size: 13px;</span><br><span class="line">    margin-top: 15px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="获取十六进制的颜色"><a href="#获取十六进制的颜色" class="headerlink" title="获取十六进制的颜色"></a><p style="background-color:rgba(239,221,236,0.7)">获取十六进制的颜色</p></h3><p>rgb（0，0，0）这种常识就不说了</p>
<p>然后还有一种rgba（0，0，0，0）最后一位是设置透明度的，1是不透0是全透</p>
<p>最后一种就是用十六进制表示，可以看到代码里很多都是这种，下面就讲一下 <strong>「利用chrome浏览器的取十六进制色方法」</strong></p>
<p>1.右键——检查  </p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kjmegh7lj20fs0asdhy.jpg" alt=""></p>
<p>2.在下图的位置输入color然后回车，会跳到冒号后，输入red再回车，这时候会出现一个红色小方块，点击左侧任何网页里的地方，就可以获得这个地方的颜色，还有一个上下的箭头，就可以获得rgba了  </p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kjmeh14oj207e04ot8t.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kjmehfmbj20c80ccjsq.jpg" alt=""></p>
<hr>
<h3 id="关于css里的padding和margin"><a href="#关于css里的padding和margin" class="headerlink" title="关于css里的padding和margin"></a><p style="background-color:rgba(239,221,236,0.7)">关于css里的padding和margin</p></h3><p>还是记录一下吧，margin和padding我一开始也分不清，多设置了几次就发现效果了，如下图：  </p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kjnngleej20q208a759.jpg" alt=""></p>
<p>可以看见一个文章框，对于post这部分来说margin设置的是文字矩形到阴影框的距离，padding设置的是两个阴影框之间的距离</p>
<hr>
<h2 id="捕捉一只会聊天的看板娘live2d"><a href="#捕捉一只会聊天的看板娘live2d" class="headerlink" title="捕捉一只会聊天的看板娘live2d"></a><p style="background-color:rgba(219,233,243,0.7)">捕捉一只会聊天的看板娘live2d</p></h2><p>这个花了好久才捕捉成功 ಥ_ಥ 因为一开始啥都不会么。。</p>
<blockquote>
<p>github地址：<a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">hexo-helper-live2d</a><br>这个是没有聊天功能的，效果如下：</p>
</blockquote>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kjnni6ynj21400jh0z7.jpg" alt=""></p>
<blockquote>
<p>github地址：<a href="https://github.com/galnetwen/Live2D" target="_blank" rel="noopener">Live2D</a><br>教程：<a href="https://haremu.com/p/205" target="_blank" rel="noopener">Live2D！把可爱的看板娘捕捉到你的博客去吧</a><br><a href="https://imjad.cn/archives/lab/add-dynamic-poster-girl-with-live2d-to-your-blog-02" target="_blank" rel="noopener">给博客添加能动的看板娘(Live2D)-将其添加到网页上吧</a><br>实现的效果和本站的看板娘差不多，就不贴图了，不过我的live2d出处不是这个0.0</p>
</blockquote>
<p>不懂html一开始没懂啥叫把代码放到合适的位置0.0，然后看了一下别人的网页源代码，在一大片代码中搜索live2d就知道啦～结合教程很好上手</p>
<hr>
<h2 id="访客小地球插件revolvermaps"><a href="#访客小地球插件revolvermaps" class="headerlink" title="访客小地球插件revolvermaps"></a><p style="background-color:rgba(219,233,243,0.7)">访客小地球插件revolvermaps</p></h2><p>写在另一篇博客里了，放上传送门，效果见右侧侧栏站点概览下方</p>
<p><a href="https://leflacon.github.io/783cca3a" target="_blank" rel="noopener">给hexo添加访客小地球插件revolvermaps</a></p>
<hr>
<h2 id="给hexo设置不同的背景图片（随机或轮播）"><a href="#给hexo设置不同的背景图片（随机或轮播）" class="headerlink" title="给hexo设置不同的背景图片（随机或轮播）"></a><p style="background-color:rgba(219,233,243,0.7)">给hexo设置不同的背景图片（随机或轮播）</p></h2><p>理论上随机和轮播是两种：</p>
<p>第一种是轮播：用 <a href="https://github.com/jquery-backstretch/jquery-backstretch" target="_blank" rel="noopener">jquery-backstretch</a>，这种方法的特点是可以选择自己喜欢的图片进行轮播，但是比下面那个方法麻烦，我太菜了还没研究清楚，这里就不讲了</p>
<p>第二种是随机：用了个相当简单投机取巧的方法，偶然一试竟然还真的可以，只要刷新一下就能换张图，具体操作是只要获得一个随机图片的接口，然后在custom.styl里连上就行了，</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kjnngo61j20hs03dmxj.jpg" alt=""></p>
<p>各种随机图片的API写在了这篇博客里：<a href="https://leflacon.github.io/6a2b981f/" target="_blank" rel="noopener">几个随机图片API接口(给hexo设置随机背景图片)</a></p>
<hr>
<h2 id="在菜单栏添加新页面with新图标"><a href="#在菜单栏添加新页面with新图标" class="headerlink" title="在菜单栏添加新页面with新图标"></a><p style="background-color:rgba(219,233,243,0.7)">在菜单栏添加新页面with新图标</p></h2><p>开始的时候是想给自己做一个类似说说的页面，<s>实现很草率</s>(/ω＼)，就直接把leancloud的评论功能拿来当说说用，所以这样就需要在菜单栏新建一个页面了，操作如下：</p>
<h3 id="生成新的自定义页面"><a href="#生成新的自定义页面" class="headerlink" title="生成新的自定义页面"></a>生成新的自定义页面</h3><p>输入<code>sudo hexo new page &quot;nothing&quot;</code></p>
<p>然后在source下就会有一个nothing文件夹生成，打开之后自己编辑那个index.md页面就行了</p>
<h3 id="把新页面添加到菜单栏"><a href="#把新页面添加到菜单栏" class="headerlink" title="把新页面添加到菜单栏"></a>把新页面添加到菜单栏</h3><p>打开主题配置文件，找到menu那一块，如下配置：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kjojri4qj20ao0503z2.jpg" alt=""></p>
<p>说说: /nothing || star</p>
<p>第一项是显示的名字，第二项是对应的页面名，第三项是图标</p>
<p>next主题的图标来自Font Awesome，相当方便，只要在图标库里找到那个图标，然后直接输入图标名字即可，附上图标库链接 <a href="http://www.fontawesome.com.cn/faicons/" target="_blank" rel="noopener">http://www.fontawesome.com.cn/faicons/</a></p>
<hr>
<h2 id="其他杂七杂八的记录："><a href="#其他杂七杂八的记录：" class="headerlink" title="其他杂七杂八的记录："></a><p style="background-color:rgba(219,233,243,0.7)">其他杂七杂八的记录：</p></h2><hr>
<h3 id="npm无法装插件，549-throw-err的解决办法"><a href="#npm无法装插件，549-throw-err的解决办法" class="headerlink" title="npm无法装插件，549 throw err的解决办法"></a><p style="background-color:rgba(239,221,236,0.7)">npm无法装插件，549 throw err的解决办法</p></h3><p>有一次玩着玩着不小心把npm给玩坏了一直报错,没法install也没法uninstall，当时没截图，在历史记录里找到了一个开头：<br><code>module.js:549 throw err; ^ Error: Cannot find module……</code><br>把npm删了重装就好了0.0，下次用npm装插件的时候再也不强退了，这玩意儿似乎不好折腾</p>
<hr>
<h3 id="hexo-g时报错Template-render-error-unexpected-token-gt"><a href="#hexo-g时报错Template-render-error-unexpected-token-gt" class="headerlink" title="hexo g时报错Template render error: unexpected token: &gt;"></a><p style="background-color:rgba(239,221,236,0.7)">hexo g时报错Template render error: unexpected token: &gt;</p></h3><p>Template render error: (unknown path) [Line 28, Column 143]<br>  unexpected token: &gt;</p>
<p>如下图：</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kjojsfauj20fo06rgng.jpg" alt=""></p>
<p>查了一下原因是因为md文件里有一些未转义字符报的奇奇怪怪的错，找了一下还真是，就因为我那篇里用了一个这样的颜文字 </p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kjok185bj203q0170sk.jpg" alt=""></p>
<p>编译的时候是不允许两对包起来的大括号这种形式的出现的，而且后来改成了注释掉的形式还是报错0.0实在是。。解决办法当然是把这个删了就好了</p>
<hr>
<h3 id="文章阅读次数显示：Counter-not-initialized-See-more-at-consoleerr-msg"><a href="#文章阅读次数显示：Counter-not-initialized-See-more-at-consoleerr-msg" class="headerlink" title="文章阅读次数显示：Counter not initialized! See more at consoleerr msg"></a><p style="background-color:rgba(239,221,236,0.7)">文章阅读次数显示：Counter not initialized! See more at consoleerr msg</p></h3><p>放个传送门，一个瞎折腾的方法0.0</p>
<p><a href="https://leflacon.github.io/52b56662" target="_blank" rel="noopener">文章阅读次数显示：Counter not initialized! See more at consoleerr msg的解决办法</a></p>
<hr>
<h3 id="如何给个人博客换上专属免费域名-hexo-github-freenom"><a href="#如何给个人博客换上专属免费域名-hexo-github-freenom" class="headerlink" title="如何给个人博客换上专属免费域名[hexo+github+freenom]"></a><p style="background-color:rgba(239,221,236,0.7)">如何给个人博客换上专属免费域名[hexo+github+freenom]</p></h3><h2 id="丢传送门如何给个人博客换上专属免费域名"><a href="#丢传送门如何给个人博客换上专属免费域名" class="headerlink" title="丢传送门如何给个人博客换上专属免费域名"></a>丢传送门<a href="http://leflacon.github.io/59f6b91c/" target="_blank" rel="noopener">如何给个人博客换上专属免费域名</a></h2><p>其他问题好像还有一些吧，一时没记录也想不起来，以后或许会更新吧(￣Д￣)ﾉ唉天天放着控制台里的错不管，好愧疚0.0，好晚了不写了睡了睡了</p>
<hr>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>几个随机图片API接口(给hexo设置随机背景图片)</title>
    <url>/6a2b981f/</url>
    <content><![CDATA[<p>2020.05 写在前面</p>
<p>文中的API是我18年收集的了 当时做这个API的人还不多 现在有些已经不能用了链接也失效了</p>
<a id="more"></a>

<hr>
<p style="background-color:rgba(221,204,222,0.7)">在custom.styl里设置一下body的background属性就行，在另一篇关于hexo的博客里有写
</p>

<p><a href="https://unsplash.it/1600/900?random" target="_blank" rel="noopener">https://unsplash.it/1600/900?random</a>（据说国内加载略慢，我试了一下还好都差不多）</p>
<p><a href="https://uploadbeta.com/api/pictures/random/?key=BingEverydayWallpaperPicture" target="_blank" rel="noopener">https://uploadbeta.com/api/pictures/random/?key=BingEverydayWallpaperPicture</a>（必应每日图片）<br><a href="https://uploadbeta.com/api/pictures/random" target="_blank" rel="noopener">https://uploadbeta.com/api/pictures/random</a>（必应图库，一些风景图人物图什么的，都是现代风格）</p>
<p><a href="https://source.unsplash.com/random" target="_blank" rel="noopener">https://source.unsplash.com/random</a>（风格同上，但这个的图尺寸不是大图）</p>
<p style="background-color:rgba(221,204,222,0.7)">下面是几个二次元的,都差不多ヽ(´o｀（大部分都在本地测试过，可以放心食用），但是以下这些唯一的问题就是。。有些图片质量参差不齐。。所以要想完全和自己口味的话还是自己做一个吧，有开源代码
</p>


<p>首先最牛逼的大概就是<a href="http://ikmoe.com/8548.html" target="_blank" rel="noopener"><strong>「漫月API」</strong></a>了，一直被模仿从未被超越那种╮(￣▽￣””)╭，但是现在关了，大概过几个月会开</p>
<p><a href="https://www.xwboke.cn/api/api.php" target="_blank" rel="noopener">https://www.xwboke.cn/api/api.php</a> （出处被不小心遗忘在风中了，对不住了0.0）</p>
<p><a href="https://img.xjh.me/random_img.php" target="_blank" rel="noopener">https://img.xjh.me/random_img.php</a> <a href="https://www.xjh.me/3069.html?replytocom=4888" target="_blank" rel="noopener">出处(・ω・)ノ</a></p>
<p><a href="http://www.dmoe.cc/random.php" target="_blank" rel="noopener">http://www.dmoe.cc/random.php</a>（1000+）<a href="http://www.dmoe.cc/" target="_blank" rel="noopener">出处(・ω・)ノ</a></p>
<p><a href="http://acg.bakayun.cn/randbg.php" target="_blank" rel="noopener">http://acg.bakayun.cn/randbg.php</a>（6000+ | 东方project可选 | 多尺寸）<a href="http://acg.bakayun.cn/" target="_blank" rel="noopener">出处(・ω・)ノ</a></p>
<p><a href="https://acg.yanwz.cn/api.php" target="_blank" rel="noopener">https://acg.yanwz.cn/api.php</a> (400+) <a href="https://acg.yanwz.cn/" target="_blank" rel="noopener">出处(・ω・)ノ</a></p>
<p><a href="http://moece.cc/apl/img.php" target="_blank" rel="noopener">http://moece.cc/apl/img.php</a>（433+）<a href="http://moece.cc/" target="_blank" rel="noopener">出处(・ω・)ノ</a></p>
<p><a href="https://random.52ecy.cn/random.php" target="_blank" rel="noopener">https://random.52ecy.cn/random.php</a> (8000+) <a href="https://random.52ecy.cn/" target="_blank" rel="noopener">出处(・ω・)ノ</a>！！这个我用不了，当前接口需要认证啥的emmmmm</p>
<p><a href="https://acg.moedragon.com/api.php" target="_blank" rel="noopener">https://acg.moedragon.com/api.php</a> (1000+) <a href="https://acg.moedragon.com/" target="_blank" rel="noopener">出处(・ω・)ノ</a></p>
<p><a href="http://api.3ewl.cc/acg/img.php" target="_blank" rel="noopener">http://api.3ewl.cc/acg/img.php</a>（1000+ | 尺寸可选） <a href="http://api.3ewl.cc/acg/" target="_blank" rel="noopener">出处(・ω・)ノ</a> 下面这篇是作者的博客<a href="http://www.3ewl.cc/324.html" target="_blank" rel="noopener">随机图片api–开源</a></p>
<p><a href="https://acg.toubiec.cn/random.php" target="_blank" rel="noopener">https://acg.toubiec.cn/random.php</a>（1000+） <a href="https://acg.toubiec.cn/" target="_blank" rel="noopener">出处(・ω・)ノ</a> 作者开源了 这篇博客里有介绍和源码 先蟹蟹大佬了<a href="https://www.toubiec.cn/164.html" target="_blank" rel="noopener">[项目]随机二次元图片API-已经开源</a></p>
<p style="background-color:rgba(221,204,222,0.7)">mark一下慢慢研究➡️ [一个可在php中直接输出随机图片的API](https://www.xhboke.com/14.html)
</p>

<hr>
<p>2020.09</p>
<p>💡更新一个工具：<a href="https://www.websiteplanet.com/zh-hans/webtools/dummy-images-generator/" target="_blank" rel="noopener">Dummy Image Generator – Free Placeholder Image Tool</a></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj25v4cx3vj31iy0u07a0.jpg" alt=""></p>
<p>感谢Elouise提供了此方法，这是一个图像占位符工具，从某种程度上来说也可以提供一种构造随机图片的思路，并且他的大小是可以设置的，对于网页设计者来说是一种图像占位很棒的方法！</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>给hexo添加访客小地球插件revolvermaps</title>
    <url>/783cca3a/</url>
    <content><![CDATA[<p>这个小插件是无意间看到的，感觉好神奇，就搞来用了<br>这是官网地址：  </p>
<p><a href="https://www.revolvermaps.com/?target=setupgl">revolvermaps——3D访客地图</a></p>
<a id="more"></a>

<p>使用方法是先高级选项搞个自己喜欢的样式，然后复制那段html代码  </p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kjkip8zrj20l206gaay.jpg" alt=""></p>
<p>然后找个你想放到的地方，因为放在了侧栏的最下方，所以就写一下放在侧栏的操作</p>
<p>打开<code>themes/next/layout/_custom/sidebar.swig</code>，在最后粘贴上复制的那段代码就可以了，重新编译一下打开侧栏就可以看到转转的访客地球了(・ω・)ノ</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kjkiow64j20ir036q3g.jpg" alt=""></p>
<p>效果如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbzaa2g0a8j306g0i275x.jpg" alt=""></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>1136 欧拉函数</title>
    <url>/98ac8a82/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 </p>
<p>对正整数n，欧拉函数是少于或等于n的数中与n互质的数的数目。此函数以其首名研究者欧拉命名，它又称为Euler’s totient function、φ函数、欧拉商数等。例如：φ(8) = 4（Phi(8) = 4），因为1,3,5,7均和8互质。</p>
<a id="more"></a>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入一个数N。(2 &lt;= N &lt;= 10^9)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出Phi(n)。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>要求一个数欧拉函数，要先知道容斥是什么，这里就不写了</p>
<p>那么先随便举个例子比如 24 好了</p>
<p><code>24=2*2*2*3</code></p>
<p>2的倍数有：2，4，6，8，10，12，14，16，18，20，22，24<br>3的倍数有：3，66，9，12，15，18，21，24</p>
<p>那些既是2的倍数又是3的倍数的数就要靠容斥来处理了</p>
<p><code>phi(24)=24-24/2-24/3+24/(2*3)</code></p>
<p>这样一来就求好了 但是如果要写容斥分母要枚举啊好麻烦的 </p>
<p>所以这里有一个妙妙的等式(●°u°●)​ 」<br><code>phi(24)=24*(1-1/2-1/3+1/2*3)=24*(1-1/2)*(1-1/3)</code></p>
<p>所以只要找出n的质因子a，然后乘以（1-1/a）就好了,当然这里要通分一下方便操作</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int phi(int x)&#123;</span><br><span class="line">	int ans&#x3D;x;</span><br><span class="line">	for(int i&#x3D;2;i*i&lt;&#x3D;x;i++)&#123;&#x2F;&#x2F;i*i&lt;&#x3D;x！！！</span><br><span class="line">		if(x%i&#x3D;&#x3D;0)&#123;</span><br><span class="line">			ans&#x3D;ans&#x2F;i*(i-1);</span><br><span class="line">			while(x%i&#x3D;&#x3D;0)x&#x2F;&#x3D;i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(x&amp;&amp;x!&#x3D;1)ans&#x3D;ans&#x2F;x*(x-1);&#x2F;&#x2F;不要忘了这句！！</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	printf(&quot;%d\n&quot;,phi(n));</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>1137 矩阵乘法</title>
    <url>/b972d127/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 </p>
<p>给出2个N * N的矩阵M1和M2，输出2个矩阵相乘后的结果。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：1个数N，表示矩阵的大小(2 &lt;= N &lt;= 100)<br>第2 - N + 1行，每行N个数，对应M1的1行(0 &lt;= M1[i] &lt;= 1000)<br>第N + 2 - 2N + 1行，每行N个数，对应M2的1行(0 &lt;= M2[i] &lt;= 1000)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出共N行，每行N个数，对应M1 * M2的结果的一行。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 0</span><br><span class="line">0 1</span><br><span class="line">0 1</span><br><span class="line">1 0</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 1</span><br><span class="line">1 0</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>矩阵乘法基本操作</p>
<p>看了榜里别人的代码 如果直接一边乘一边输出的话就不用跑两遍了 会快很多</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">typedef vector&lt;LL&gt;row;</span><br><span class="line">typedef vector&lt;row&gt;mat;</span><br><span class="line">mat mul(mat a,mat b)&#123;</span><br><span class="line">	mat c(a.size(),row(b[0].size()));&#x2F;&#x2F;c的行数列数分别是a的行数，b的列数</span><br><span class="line">	for(int i&#x3D;0;i&lt;a.size();i++)&#123;&#x2F;&#x2F;a的第i行，b的第j列</span><br><span class="line">		for(int j&#x3D;0;j&lt;b.size();j++)&#123;</span><br><span class="line">			for(int k&#x3D;0;k&lt;b[0].size();k++)</span><br><span class="line">				c[i][j]&#x3D;c[i][j]+a[i][k]*b[k][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return c;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	mat m1(n,row(n)),m2(n,row(n));</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">		for(int j&#x3D;0;j&lt;n;j++)scanf(&quot;%lld&quot;,&amp;m1[i][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">		for(int j&#x3D;0;j&lt;n;j++)scanf(&quot;%lld&quot;,&amp;m2[i][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	mat m&#x3D;mul(m1,m2);</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">		for(int j&#x3D;0;j&lt;n;j++)&#123;</span><br><span class="line">			if(j!&#x3D;n-1)printf(&quot;%lld &quot;,m[i][j]);</span><br><span class="line">			else printf(&quot;%lld\n&quot;,m[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>1174 区间中最大的数（RMQ，dp，线段树）</title>
    <url>/99dc77d/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 </p>
<p>给出一个有N个数的序列，编号0 – N-1。进行Q次查询，查询编号i至j的所有数中，最大的数是多少。</p>
<a id="more"></a>

<p>例如: 1 7 6 3 1。i = 1, j = 3，对应的数为7 6 3，最大的数为7。（该问题也被称为RMQ问题）</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：1个数N，表示序列的长度。(2 &lt;= N &lt;= 10000)<br>第2 - N + 1行：每行1个数，对应序列中的元素。(0 &lt;= S[i] &lt;= 10^9)<br>第N + 2行：1个数Q，表示查询的数量。(2 &lt;= Q &lt;= 10000)<br>第N + 3 - N + Q + 2行：每行2个数，对应查询的起始编号i和结束编号j。(0 &lt;= i &lt;= j &lt;= N - 1)  </p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>共Q行，对应每一个查询区间的最大值。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">7</span><br><span class="line">6</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">0 1</span><br><span class="line">1 3</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">7</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>求区间最值，直接线段树水一发125ms</p>
<p>RMQ也跑了125ms</p>
<blockquote>
<p><strong>RMQ:</strong></p>
<p>dp[i][j]表示[i,i+2^j)个数中的最大值<br>初始化F[i,0]即为输入的第i个数<br>把dp[i][j]分成两段：</p>
<blockquote>
<p>[i,i+2^(j-1))<br>[i+2^(j-1),i+2^j)   </p>
</blockquote>
<p>状态转移方程：dp[i][j]=max(dp[i][j-1],dp[i+2^(j-1)][j-1])  </p>
<p>查询：<br>要查询[i,j],需要找到覆盖这个区间的两段<br>区间长度为(j-i+1)，取k=log2(j-i+1)<br>则ans=max(dp[i][k],dp[j-2^k+1][k])，也就是[i,i+2^k),[j-2^k+1,j+1)这两段 </p>
</blockquote>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p>【线段树】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define lson l,m,rt&lt;&lt;1</span><br><span class="line">#define rson m+1,r,rt&lt;&lt;1|1</span><br><span class="line">const int N&#x3D;200005;</span><br><span class="line"></span><br><span class="line">int MAX[N&lt;&lt;2];</span><br><span class="line">void pushup(int rt)&#123;</span><br><span class="line">	MAX[rt]&#x3D;max(MAX[rt&lt;&lt;1],MAX[rt&lt;&lt;1|1]);</span><br><span class="line">&#125;</span><br><span class="line">void build(int l,int r,int rt)&#123;</span><br><span class="line">	if(l&#x3D;&#x3D;r)&#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;MAX[rt]);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	int m&#x3D;(l+r)&gt;&gt;1;</span><br><span class="line">	build(lson);</span><br><span class="line">	build(rson);</span><br><span class="line">	pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line">void update(int p,int sc,int l,int r,int rt)&#123;</span><br><span class="line">	if(l&#x3D;&#x3D;r)&#123;</span><br><span class="line">		MAX[rt]&#x3D;sc;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	int m&#x3D;(l+r)&gt;&gt;1;</span><br><span class="line">	if(m&gt;&#x3D;p)update(p,sc,lson);</span><br><span class="line">	else update(p,sc,rson);</span><br><span class="line">	pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line">int query(int L,int R,int l,int r,int rt)&#123;</span><br><span class="line">	if(L&lt;&#x3D;l&amp;&amp;R&gt;&#x3D;r)&#123;</span><br><span class="line">		return MAX[rt];</span><br><span class="line">	&#125;</span><br><span class="line">	int m&#x3D;(l+r)&gt;&gt;1;</span><br><span class="line">	int ans&#x3D;0;</span><br><span class="line">	if(m&gt;&#x3D;L)ans&#x3D;max(ans,query(L,R,lson));</span><br><span class="line">	if(R&gt;m)ans&#x3D;max(ans,query(L,R,rson));</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,m;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	build(1,n,1);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">	while(m--)&#123;</span><br><span class="line">		int a,b;</span><br><span class="line">		scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">		a++;b++;</span><br><span class="line">		printf(&quot;%d\n&quot;,query(a,b,1,n,1));</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【RMQ】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;10005;</span><br><span class="line">int dp[N][15],n,m;</span><br><span class="line">void rmq()&#123;</span><br><span class="line">	for(int j&#x3D;1;(1&lt;&lt;j)&lt;&#x3D;n;j++)&#123;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">			if(i+(1&lt;&lt;j)-1&lt;&#x3D;n)</span><br><span class="line">				dp[i][j]&#x3D;max(dp[i][j-1],dp[i+(1&lt;&lt;(j-1))][j-1]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)scanf(&quot;%d&quot;,&amp;dp[i][0]);</span><br><span class="line">	rmq();</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">	while(m--)&#123;</span><br><span class="line">		int l,r;</span><br><span class="line">		scanf(&quot;%d%d&quot;,&amp;l,&amp;r);</span><br><span class="line">		l++;r++;</span><br><span class="line">		int k&#x3D;log(r-l+1)&#x2F;log(2);</span><br><span class="line">		printf(&quot;%d\n&quot;,max(dp[l][k],dp[r-(1&lt;&lt;k)+1][k]));</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>1079 中国剩余定理</title>
    <url>/1109bacf/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 </p>
<p>一个正整数K，给出K Mod 一些质数的结果，求符合条件的最小的K。例如，K % 2 = 1, K % 3 = 2, K % 5 = 3。符合条件的最小的K = 23。</p>
<a id="more"></a>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：1个数N表示后面输入的质数及模的数量。（2 &lt;= N &lt;= 10)<br>第2 - N + 1行，每行2个数P和M，中间用空格分隔，P是质数，M是K % P的结果。（2 &lt;= P &lt;= 100, 0 &lt;= K &lt; P)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出符合条件的最小的K。数据中所有K均小于10^9。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 1</span><br><span class="line">3 2</span><br><span class="line">5 3</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">23</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给n对数，pi，mi表示k%pi=mi,问是否存在一个最小的k满足所有pi和mi</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>中国剩余定理 相当水的裸题 直接模版上就好了</p>
<p>先拿样例举例一下(・ω・)ノ</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">k%2&#x3D;1      </span><br><span class="line">k%3&#x3D;2  </span><br><span class="line">k%5&#x3D;3  </span><br><span class="line"></span><br><span class="line">先构造一下下面这个东西，逆元搞一下</span><br><span class="line"></span><br><span class="line">3*5*inv(3*5,2)%2&#x3D;1            1*3*5*inv(3*5,2)%2&#x3D;1</span><br><span class="line">2*5*inv(2*5,3)%3&#x3D;1     &#x3D;&#x3D;&gt;    2*2*5*inv(2*5,3)%3&#x3D;2 </span><br><span class="line">2*3*inv(2*3,5)%5&#x3D;1            3*2*3*inv(2*3,5)%5&#x3D;3</span><br><span class="line">  </span><br><span class="line">然后和上面式子一比 余数就这么出来啦</span><br><span class="line"></span><br><span class="line">令k1&#x3D;1*3*5*inv(3*5,2),k2&#x3D;2*2*5*inv(2*5,3),k3&#x3D;3*2*3*inv(2*3,5)</span><br><span class="line"></span><br><span class="line">也就是</span><br><span class="line">k1%2&#x3D;1,且k1是3和5的倍数</span><br><span class="line">k2%3&#x3D;2,且k2是2和5的倍数</span><br><span class="line">k3%5&#x3D;3,且k3是2和3的倍数</span><br><span class="line"></span><br><span class="line">令k&#x3D;k1+k2+k3</span><br><span class="line"></span><br><span class="line">k%2&#x3D;k1%2+k2%2+k3%2&#x3D;1+0+0</span><br><span class="line">k%3&#x3D;k1%3+k2%3+k3%3&#x3D;0+2+0</span><br><span class="line">k%5&#x3D;k1%5+k2%5+k3%5&#x3D;0+0+3</span><br><span class="line"></span><br><span class="line">所以k就是要求的那个答案啦</span><br></pre></td></tr></table></figure>

<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int p&#x3D;1000000007;</span><br><span class="line">void ex_gcd(LL a,LL b,LL &amp;x,LL &amp;y,LL &amp;d)&#123;</span><br><span class="line">    if(!b)&#123;</span><br><span class="line">    	d&#x3D;a;x&#x3D;1;y&#x3D;0;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        ex_gcd(b,a%b,y,x,d);</span><br><span class="line">        y-&#x3D;x*(a&#x2F;b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">LL inv(LL t,LL p)&#123;</span><br><span class="line">    LL d,x,y;</span><br><span class="line">    ex_gcd(t,p,x,y,d);</span><br><span class="line">    return d&#x3D;&#x3D;1?(x%p+p)%p:-1;</span><br><span class="line">&#125;</span><br><span class="line">LL china(int n,LL *a,LL *m)&#123;</span><br><span class="line">    LL M&#x3D;1,ret&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)M*&#x3D;m[i];</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        LL w&#x3D;M&#x2F;m[i];</span><br><span class="line">        ret&#x3D;(ret+w*inv(w,m[i])*a[i])%M;</span><br><span class="line">    &#125;</span><br><span class="line">    return (ret+M)%M;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	LL a[11],m[11];</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">		scanf(&quot;%lld%lld&quot;,&amp;m[i],&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%lld\n&quot;,china(n,a,m));</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>1181 质数中的质数（质数筛法,埃筛素数）</title>
    <url>/216acbe1/</url>
    <content><![CDATA[<p>题目来源： Sgu<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 </p>
<p>如果一个质数，在质数列表中的编号也是质数，那么就称之为质数中的质数。例如：3 5分别是排第2和第3的质数，所以他们是质数中的质数。现在给出一个数N，求&gt;=N的最小的质数中的质数是多少（可以考虑用质数筛法来做）。</p>
<a id="more"></a>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入一个数N(N &lt;= 10^6)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出&gt;=N的最小的质数中的质数。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">31</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>埃筛素数 </p>
<p>加个计数和break判断就行</p>
<p>j会爆int，要开long long</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;1000233;</span><br><span class="line">bool prime[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,cnt&#x3D;0;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	memset(prime,true,sizeof(prime));</span><br><span class="line">	prime[1]&#x3D;false;</span><br><span class="line">	prime[2]&#x3D;true;</span><br><span class="line">	for(LL i&#x3D;2;i&lt;N;i++)&#123;</span><br><span class="line">		if(prime[i])&#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			if(prime[cnt]&amp;&amp;i&gt;&#x3D;n)&#123;</span><br><span class="line">				printf(&quot;%lld\n&quot;,i);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			for(LL j&#x3D;i*i;j&lt;N;j+&#x3D;i)prime[j]&#x3D;false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>1183 编辑距离（dp，字符串）</title>
    <url>/29b25bed/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 </p>
<p>编辑距离，又称Levenshtein距离（也叫做Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。</p>
<p>例如将kitten一字转成sitting：<br>sitten （k-&gt;s）<br>sittin （e-&gt;i）<br>sitting （-&gt;g）<br>所以kitten和sitting的编辑距离是3。俄罗斯科学家Vladimir Levenshtein在1965年提出这个概念。</p>
<p>给出两个字符串a,b，求a和b的编辑距离。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：字符串a(a的长度 &lt;= 1000)。<br>第2行：字符串b(b的长度 &lt;= 1000)。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出a和b的编辑距离</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kitten</span><br><span class="line">sitting</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>dp[i][j]表示字符串a的[0,i)和字符串b的[0,j)的最小编辑距离</p>
<p>写出状态转移方程dp[i][j]=min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+(a[i-1]==b[j-1]?0:1))</p>
<ul>
<li>dp[i-1][j]+1表示前[0,i-1)[0,j)已经相同，要改第i位</li>
<li>dp[i][j-1]+1表示前[0,i)[0,j-1)已经相同，要改第j位</li>
<li>dp[i-1][j-1]+(a[i-1]==b[j-1]?0:1）表示前[0,i-1)[0,j-1)已经相同，如果ai和bj相同就改其中一个</li>
</ul>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;1005;</span><br><span class="line">char a[N],b[N],ans[N];</span><br><span class="line">int dp[N][N];</span><br><span class="line">int main()&#123;</span><br><span class="line">	scanf(&quot;%s%s&quot;,a,b);</span><br><span class="line">	int lena&#x3D;strlen(a),lenb&#x3D;strlen(b);</span><br><span class="line">	for(int i&#x3D;0;i&lt;&#x3D;lena;i++)dp[i][0]&#x3D;i;</span><br><span class="line">	for(int i&#x3D;0;i&lt;&#x3D;lenb;i++)dp[0][i]&#x3D;i;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;lena;i++)&#123;</span><br><span class="line">		for(int j&#x3D;1;j&lt;&#x3D;lenb;j++)&#123;</span><br><span class="line">			dp[i][j]&#x3D;min(dp[i-1][j]+1,dp[i][j-1]+1);</span><br><span class="line">			dp[i][j]&#x3D;min(dp[i][j],dp[i-1][j-1]+(a[i-1]&#x3D;&#x3D;b[j-1]?0:1));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d\n&quot;,dp[lena][lenb]);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>1185 威佐夫游戏 V2（高精度，乘法模拟）</title>
    <url>/7dfc273b/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 </p>
<p>有2堆石子。A B两个人轮流拿，A先拿。每次可以从一堆中取任意个或从2堆中取相同数量的石子，但不可不取。拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出2堆石子的数量，问最后谁能赢得比赛。</p>
<p>例如：2堆石子分别为3颗和5颗。那么不论A怎样拿，B都有对应的方法拿到最后1颗。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 10000)<br>第2 - T + 1行：每行2个数分别是2堆石子的数量，中间用空格分隔。(1 &lt;= N &lt;= 10^18)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>共T行，如果A获胜输出A，如果B获胜输出B。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">3 5</span><br><span class="line">3 4</span><br><span class="line">1 9</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B</span><br><span class="line">A</span><br><span class="line">A</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>很水的威佐夫博弈 想都没想直接LL一发然后wa了</p>
<p>因为n太大了，和黄金分割数相乘精度不够，所以要手动乘法模拟</p>
<p>把LL分成前9位q，后9位h</p>
<p>(sqrt(5)+1)/2的小数部分分成<code>x[3]={618033988,749894848,204586834}</code></p>
<p>如下模拟：(具体见代码)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      x0   x1   x2</span><br><span class="line">  *         q    h</span><br><span class="line">----------------------</span><br><span class="line">      x0*h x1*h x2*h</span><br><span class="line"> x0*q x1*q x2*q</span><br><span class="line">----------------------</span><br></pre></td></tr></table></figure>
<h3 id="附加："><a href="#附加：" class="headerlink" title="附加："></a>附加：</h3><p>这题还牵扯到另一个问题，这个27位小数从何而来，下面这个直接用根号求出的显然是不行的<code>x[3]={618033988,74989490,2525738871}</code>，那么如何在没有百度情况下获得高精度的黄金分割数呢？</p>
<p>补充在了这一篇中 <a href="https://leflacon.github.io/2e9cbb0/" target="_blank" rel="noopener">计算黄金分割数小数点后1000位</a></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">LL x[3]&#x3D;&#123;618033988,749894848,204586834&#125;;</span><br><span class="line">&#x2F;&#x2F;1.618033988,749894848,204586834</span><br><span class="line">const LL p&#x3D;1e9;</span><br><span class="line">int main()&#123;</span><br><span class="line">	LL a,b,t;</span><br><span class="line">	scanf(&quot;%lld&quot;,&amp;t);</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b);</span><br><span class="line">		if(a&gt;b)&#123;</span><br><span class="line">			LL tmp&#x3D;a;a&#x3D;b;b&#x3D;tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		LL num&#x3D;b-a;</span><br><span class="line">		LL q&#x3D;num&#x2F;p,h&#x3D;num%p;</span><br><span class="line">		LL ans&#x3D;x[2]*h;</span><br><span class="line">		ans&#x3D;ans&#x2F;p+x[1]*h+x[2]*q;</span><br><span class="line">		ans&#x3D;ans&#x2F;p+x[0]*h+x[1]*q;</span><br><span class="line">		ans&#x3D;ans&#x2F;p+x[0]*q+num;</span><br><span class="line">		if(ans&#x3D;&#x3D;a)printf(&quot;B\n&quot;);</span><br><span class="line">		else printf(&quot;A\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>计算黄金分割数小数点后1000位（java大数，斐波那契，二分求根号5高精度）</title>
    <url>/2e9cbb0/</url>
    <content><![CDATA[<p style="background-color:rgba(219,233,243,0.8)">首先本文最初是为了精确计算黄金分割数小数点后27位写的，当时还不会java大数，所以写了个c++没有高精度的版本，java算了1000位，为了数据准确所以用了斐波那契和二分根号5两种写法对拍，1000位比对一致，和网上的结果也一致，可以放心食用</p>

<p>先放结果。。方便我打表</p>
<p><code>0.6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911374847540880753868917521266338622235369317931800607667263544333890865959395829056383226613199282902678806752087668925017116962070322210432162695486262963136144381497587012203408058879544547492461856953648644492410443207713449470495658467885098743394422125448770664780915884607499887124007652170575179788341662562494075890697040002812104276217711177780531531714101170466659914669798731761356006708748071013179523689427521948435305678300228785699782977834784587822891109762500302696156170025046433824377648610283831268330372429267526311653392473167111211588186385133162038400522216579128667529465490681131715993432359734949850904094762132229810172610705961164562990981629055520852479035240602017279974717534277759277862561943208275051312181562855122248093947123414517022373580577278616008688382952304592647878017889921990270776903895321968198615143780314997411069260886742962267575605231727775203536139362</code></p>
<hr>
<h2 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h2><h3 id="c-思路（斐波那契）："><a href="#c-思路（斐波那契）：" class="headerlink" title="c++思路（斐波那契）："></a>c++思路（斐波那契）：</h3><p>黄金分割数可以递归求得</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n&#x3D;1    1&#x2F;(1+1)&#x3D;1&#x2F;2</span><br><span class="line">n&#x3D;2    1&#x2F;(1+1&#x2F;2)&#x3D;2&#x2F;3</span><br><span class="line">n&#x3D;3    1&#x2F;(1+2&#x2F;3)&#x3D;3&#x2F;5</span><br><span class="line">n&#x3D;4    1&#x2F;(1+3&#x2F;5)&#x3D;5&#x2F;8</span><br><span class="line">……</span><br><span class="line">n&#x3D;i    f(i+1)&#x2F;f(i+2)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>n</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>……</th>
</tr>
</thead>
<tbody><tr>
<td>ans</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>8</td>
<td>13</td>
<td>21</td>
<td>……</td>
</tr>
</tbody></table>
<p>可以发现其实就是斐波那契数列的两个数相除，越往后越接近黄金分割数，据说从250项开始前100位就不变了，这样问题就解决了，只要手动模拟除法就可以让小数自己精确到天涯海角了</p>
<p>但是这样斐波那契第250项就很大了，c++的话肯定要开数组高精度来存的，所以c++代码里只计算到80位，这对于算黄金分割数小数点后27位是够用了的</p>
<h3 id="c-代码："><a href="#c-代码：" class="headerlink" title="c++代码："></a>c++代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">LL f[105];</span><br><span class="line">int main()&#123;</span><br><span class="line">	f[0]&#x3D;0;f[1]&#x3D;1;</span><br><span class="line">	for(int i&#x3D;2;i&lt;81;i++)&#123;</span><br><span class="line">		f[i]&#x3D;f[i-1]+f[i-2];</span><br><span class="line">	&#125;</span><br><span class="line">	LL x&#x3D;f[79],y&#x3D;f[80];</span><br><span class="line">	int a[101];</span><br><span class="line">	for(int i&#x3D;0;i&lt;28;i++)&#123;</span><br><span class="line">		a[i]&#x3D;x&#x2F;y;</span><br><span class="line">		x&#x3D;(x%y)*10;</span><br><span class="line">		cout&lt;&lt;a[i];</span><br><span class="line">		if(i%9&#x3D;&#x3D;0)cout&lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运算结果："><a href="#运算结果：" class="headerlink" title="运算结果："></a>运算结果：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 618033988 749894848 204586834</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><h3 id="java思路（斐波那契，二分计算根号5）"><a href="#java思路（斐波那契，二分计算根号5）" class="headerlink" title="java思路（斐波那契，二分计算根号5）"></a>java思路（斐波那契，二分计算根号5）</h3><ul>
<li><p>斐波那契<br>同c++，但是java大数里算到了斐波那契第1e5项，对于计算黄金分割数1000位已经足够</p>
</li>
<li><p>二分计算根号5<br>设l,r初始值，然后二分找最接近√5的数</p>
</li>
</ul>
<h3 id="java代码："><a href="#java代码：" class="headerlink" title="java代码："></a>java代码：</h3><ul>
<li>斐波那契</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;  </span><br><span class="line">import java.math.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">        BigInteger f[]&#x3D;new BigInteger[100005];</span><br><span class="line">        f[1]&#x3D;BigInteger.valueOf(1);</span><br><span class="line">        f[2]&#x3D;BigInteger.valueOf(1);</span><br><span class="line">        for(int i&#x3D;3;i&lt;&#x3D;100000;i++) &#123;</span><br><span class="line">            f[i]&#x3D;f[i-1].add(f[i-2]);</span><br><span class="line">        &#125;</span><br><span class="line">        BigInteger x&#x3D;f[99999],y&#x3D;f[100000];</span><br><span class="line">        String a[]&#x3D;new String[1001];</span><br><span class="line">        for(int i&#x3D;0;i&lt;&#x3D;1000;i++) &#123;</span><br><span class="line">        	a[i]&#x3D;x.divide(y).toString();</span><br><span class="line">        	x&#x3D;x.remainder(y).multiply(BigInteger.valueOf(10));</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;0;i&lt;&#x3D;1000;i++) &#123;</span><br><span class="line">        	System.out.print(a[i]);</span><br><span class="line">        	if(i%10&#x3D;&#x3D;0)System.out.print(&quot; &quot;);</span><br><span class="line">        	if(i%100&#x3D;&#x3D;0)System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        cin.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>二分计算根号5</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;  </span><br><span class="line">import java.math.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner cin&#x3D;new Scanner(System.in);</span><br><span class="line">        BigDecimal hj;</span><br><span class="line">        BigDecimal l&#x3D;BigDecimal.valueOf(2),r&#x3D;BigDecimal.valueOf(3);</span><br><span class="line">        for(int i&#x3D;0;i&lt;10000;i++) &#123;</span><br><span class="line">            BigDecimal m&#x3D;l.add(r).divide(BigDecimal.valueOf(2));</span><br><span class="line">            if(m.multiply(m).compareTo(BigDecimal.valueOf(5))&lt;0)l&#x3D;m;</span><br><span class="line">            else r&#x3D;m;</span><br><span class="line">        &#125;</span><br><span class="line">        hj&#x3D;l.add(BigDecimal.valueOf(1)).divide(BigDecimal.valueOf(2));</span><br><span class="line">        System.out.println(hj.toString());</span><br><span class="line">        cin.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运算结果：-1"><a href="#运算结果：-1" class="headerlink" title="运算结果："></a>运算结果：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 </span><br><span class="line">6180339887 4989484820 4586834365 6381177203 0917980576 2862135448 6227052604 6281890244 9707207204 1893911374 </span><br><span class="line">8475408807 5386891752 1266338622 2353693179 3180060766 7263544333 8908659593 9582905638 3226613199 2829026788 </span><br><span class="line">0675208766 8925017116 9620703222 1043216269 5486262963 1361443814 9758701220 3408058879 5445474924 6185695364 </span><br><span class="line">8644492410 4432077134 4947049565 8467885098 7433944221 2544877066 4780915884 6074998871 2400765217 0575179788 </span><br><span class="line">3416625624 9407589069 7040002812 1042762177 1117778053 1531714101 1704666599 1466979873 1761356006 7087480710 </span><br><span class="line">1317952368 9427521948 4353056783 0022878569 9782977834 7845878228 9110976250 0302696156 1700250464 3382437764 </span><br><span class="line">8610283831 2683303724 2926752631 1653392473 1671112115 8818638513 3162038400 5222165791 2866752946 5490681131 </span><br><span class="line">7159934323 5973494985 0904094762 1322298101 7261070596 1164562990 9816290555 2085247903 5240602017 2799747175 </span><br><span class="line">3427775927 7862561943 2082750513 1218156285 5122248093 9471234145 1702237358 0577278616 0086883829 5230459264 </span><br><span class="line">7878017889 9219902707 7690389532 1968198615 1437803149 9741106926 0886742962 2675756052 3172777520 3536139362</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>CTU 2017 G.Ice cream samples（乱搞一通）</title>
    <url>/fa5f812b/</url>
    <content><![CDATA[<p>To encourage visitors active movement among the attractions, a circular path with ice cream<br>stands was built in the park some time ago. A discount system common for all stands was<br>also introduced. When a customer buys ice cream at some stand, he is automatically granted a<br>discount for one day at the next stand on the path. When visitors start at any stand and follow<br>systematically the discount directions to the next stands, they eventually traverse the whole<br>circular path and return back to the stand they started at.</p>
<p>Ice creams of various brands are sold at the stands. Additionally, each stand sells a nice sample<br>box which contains small samples of popular ice cream brands. The number of samples in the<br>box depends on the stand and various stands may put different brands into their sample boxes.</p>
<p>Each box contains samples of one or more brands. A brand may be represented by one or more<br>samples in the box, or it may be completely missing. </p>
<p>Each stand sells only one type of sample<br>box (the brands of the samples in the box are always the same for that particular stand).</p>
<p>Quido and Hugo are going to exploit the discount system for their own benefit. They decided<br>to start at some stand and then continue in the direction of the discounts buying one ice cream<br>sample box at each stand they visit in a consecutive sequence. Their goal is to collect at least<br>one sample of each ice cream brand sold in the park.</p>
<p>Simultaneously, to respect their stomach<br>capacities, they want to minimize the total number of ice cream samples they buy.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification"></a>Input Specification</h3><p>There are more test cases. Each case starts with a line containing two integers N, K separated<br>by space (1 ≤ N, K ≤ 106<br>). N is the number of ice cream stands, K is the total number of<br>different ice cream brands sold at all stands. The brands are labeled by numbers 1, 2, . . . , K.<br>Next, there are N lines describing stands in their visiting order. Each such line contains the<br>list of brands of all ice cream samples sold in the sample box at that particular stand. Each list<br>starts with one positive integer L, describing its length, followed by L integers. Each list item<br>represents the brand of one ice cream sample in the sample box sold at this stand. You may<br>assume that even if a visitor buys one sample box at each stand, he/she will collect at most 107<br>ice cream samples.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification"></a>Output Specification</h3><p>For each test case, print a single line with one integer denoting the minimum number of ice<br>cream samples Quido and Hugo have to buy in order to obtain a sample of each ice cream brand<br>sold in the park. If it is impossible to obtain samples of all brands output −1.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3</span><br><span class="line">4 1 3 1 3</span><br><span class="line">1 2</span><br><span class="line">2 3 3</span><br><span class="line">1 1</span><br><span class="line">5 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 1 1</span><br><span class="line">2 2 2</span><br><span class="line">1 1</span><br><span class="line">3 2</span><br><span class="line">2 1 1</span><br><span class="line">1 1</span><br><span class="line">3 1 1 1</span><br></pre></td></tr></table></figure>
<h3 id="Output-for-Sample-Input"><a href="#Output-for-Sample-Input" class="headerlink" title="Output for Sample Input"></a>Output for Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">3</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给N个序列，N个序列不一定长度相同，序列由<code>1~K</code>的整数构成，现在选定连续的几个序列（首尾也算连续，想象它们是一个圈），使得1、2、3……K全在这些数列中，求选出数列所有数字个数和的最小值</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>序列只能整个整个的取，而且要连续，所以肯定要加倍，循环2xn，设两个指针cur1=0，cur2=-1，然后开始实行扩圈和缩圈的操作</p>
<p>如果当前k个数都有了，就更新ans，然后缩圈（cur1++），看看是否有更少的解</p>
<p>如果k个数还没有全，就要继续扩圈（cur2++），然后把新的序列里的数遍历一遍</p>
<p>这里要注意的是，cur2达到上限或已经取了n个连续序列时，就没有扩圈的机会了，只能缩圈找最优</p>
<p>复杂度我也不知道。。这种题大概就是瞎搞吧。。</p>
<p>res记录当前冰淇淋个数，vis[i]存第i种冰淇淋目前的个数，num为当前冰淇淋种类数</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF&#x3D;0x3f3f3f3f;</span><br><span class="line">const int N&#x3D;1000005;</span><br><span class="line">vector&lt;int&gt;a[N];</span><br><span class="line">int ans,vis[N],cur1,cur2,n,k,res,num;</span><br><span class="line">int main()&#123;</span><br><span class="line">	while(scanf(&quot;%d%d&quot;,&amp;n,&amp;k)!&#x3D;EOF)&#123;</span><br><span class="line">		for(int i&#x3D;0;i&lt;n;i++)a[i].clear();</span><br><span class="line">		memset(vis,0,sizeof(vis));</span><br><span class="line">		int l,c;</span><br><span class="line">		for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;l);</span><br><span class="line">			for(int j&#x3D;0;j&lt;l;j++)&#123;</span><br><span class="line">				scanf(&quot;%d&quot;,&amp;c);</span><br><span class="line">				a[i].push_back(c);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans&#x3D;INF;</span><br><span class="line">		res&#x3D;0;num&#x3D;0;</span><br><span class="line">		cur1&#x3D;0;cur2&#x3D;-1;</span><br><span class="line">		while(cur1&lt;2*n)&#123;</span><br><span class="line">			if(num&#x3D;&#x3D;k)&#123;</span><br><span class="line">				&#x2F;&#x2F;如果有k个数了就缩圈找最优</span><br><span class="line">				ans&#x3D;min(ans,res);</span><br><span class="line">				for(int i&#x3D;0;i&lt;a[cur1%n].size();i++)&#123;</span><br><span class="line">					if(vis[a[cur1%n][i]]&gt;1)vis[a[cur1%n][i]]--;</span><br><span class="line">					else&#123;</span><br><span class="line">						num--;</span><br><span class="line">						vis[a[cur1%n][i]]--;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				res-&#x3D;a[cur1%n].size();</span><br><span class="line">				cur1++;</span><br><span class="line">			&#125;</span><br><span class="line">			else if(cur2-cur1+1&#x3D;&#x3D;n||cur2&#x3D;&#x3D;2*n-1)&#123;</span><br><span class="line">				&#x2F;&#x2F;因为是2n为了保证循环到所有情况</span><br><span class="line">				&#x2F;&#x2F;所以如果当前取得已经有n个了或者cur2到了上限就只能缩圈</span><br><span class="line">				for(int i&#x3D;0;i&lt;a[cur1%n].size();i++)&#123;</span><br><span class="line">					if(vis[a[cur1%n][i]]&gt;1)vis[a[cur1%n][i]]--;</span><br><span class="line">					else&#123;</span><br><span class="line">						num--;</span><br><span class="line">						vis[a[cur1%n][i]]--;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				res-&#x3D;a[cur1%n].size();</span><br><span class="line">				cur1++;</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;</span><br><span class="line">				&#x2F;&#x2F;扩圈</span><br><span class="line">				cur2++;</span><br><span class="line">				for(int i&#x3D;0;i&lt;a[cur2%n].size();i++)&#123;</span><br><span class="line">					if(vis[a[cur2%n][i]]&#x3D;&#x3D;0)&#123;</span><br><span class="line">						num++;</span><br><span class="line">						vis[a[cur2%n][i]]++;</span><br><span class="line">					&#125;</span><br><span class="line">					else vis[a[cur2%n][i]]++;&#x2F;&#x2F;漏了这个至关重要的更新可让我好找。。</span><br><span class="line">				&#125;</span><br><span class="line">				res+&#x3D;a[cur2%n].size();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;,ans&#x3D;&#x3D;INF?-1:ans);</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>1212 无向图最小生成树</title>
    <url>/f8eca34c/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 </p>
<p>N个点M条边的无向连通图，每条边有一个权值，求该图的最小生成树。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：2个数N,M中间用空格分隔，N为点的数量，M为边的数量。（2 &lt;= N &lt;= 1000, 1 &lt;= M &lt;= 50000)<br>第2 - M + 1行：每行3个数S E W，分别表示M条边的2个顶点及权值。(1 &lt;= S, E &lt;= N，1 &lt;= W &lt;= 10000)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出最小生成树的所有边的权值之和。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9 14</span><br><span class="line">1 2 4</span><br><span class="line">2 3 8</span><br><span class="line">3 4 7</span><br><span class="line">4 5 9</span><br><span class="line">5 6 10</span><br><span class="line">6 7 2</span><br><span class="line">7 8 1</span><br><span class="line">8 9 7</span><br><span class="line">2 8 11</span><br><span class="line">3 9 2</span><br><span class="line">7 9 6</span><br><span class="line">3 6 4</span><br><span class="line">4 6 14</span><br><span class="line">1 8 8</span><br></pre></td></tr></table></figure>
<p>Output示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">37</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>水一发最小生成树模版</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">const int N&#x3D;1005;</span><br><span class="line">struct Edge&#123;</span><br><span class="line">	int u,v;</span><br><span class="line">	int cap;</span><br><span class="line">&#125;Edge[N*N];</span><br><span class="line">int n,ans,cnt;</span><br><span class="line">int fa[N];</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">	if(x!&#x3D;fa[x])fa[x]&#x3D;find(fa[x]);</span><br><span class="line">	return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">	int a&#x3D;find(x),b&#x3D;find(y);</span><br><span class="line">	if(a&#x3D;&#x3D;b)return;</span><br><span class="line">	else&#123;</span><br><span class="line">		fa[a]&#x3D;b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">bool cmp(struct Edge a,struct Edge b)&#123;</span><br><span class="line">	return a.cap&lt;b.cap;</span><br><span class="line">&#125;</span><br><span class="line">void kruskal()&#123;</span><br><span class="line">	sort(Edge,Edge+cnt,cmp);</span><br><span class="line">	for(int i&#x3D;0;i&lt;cnt;i++)&#123;</span><br><span class="line">		int fx&#x3D;find(Edge[i].u),fy&#x3D;find(Edge[i].v);</span><br><span class="line">		if(fx&#x3D;&#x3D;fy)continue;</span><br><span class="line">		ans+&#x3D;Edge[i].cap;</span><br><span class="line">		join(fx,fy);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int s,e,w;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;n,&amp;cnt);</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)fa[i]&#x3D;i;</span><br><span class="line">	for(int i&#x3D;0;i&lt;cnt;i++)&#123;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;,&amp;s,&amp;e,&amp;w);</span><br><span class="line">		Edge[i].u&#x3D;s;</span><br><span class="line">		Edge[i].v&#x3D;e;</span><br><span class="line">		Edge[i].cap&#x3D;w;</span><br><span class="line">	&#125;</span><br><span class="line">	ans&#x3D;0;</span><br><span class="line">	kruskal();</span><br><span class="line">	printf(&quot;%d\n&quot;,ans);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>1242 斐波那契数列的第N项（矩阵快速幂）</title>
    <url>/52580325/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 </p>
<p>斐波那契数列的定义如下：</p>
<p>F(0) = 0<br>F(1) = 1<br>F(n) = F(n - 1) + F(n - 2) (n &gt;= 2)  </p>
<p>(1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, …)  </p>
<p>给出n，求F(n)，由于结果很大，输出F(n) % 1000000009的结果即可。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入1个数n(1 &lt;= n &lt;= 10^18)。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出F(n) % 1000000009的结果。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><p><code>11</code></p>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><p><code>89</code></p>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>矩阵快速幂</p>
<p>F(n) = F(n - 1) + F(n - 2)</p>
<p>递推式如下。。macdown打不出数学公式。。就这样吧。。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">( F(n)  ) &#x3D; ( 1 1 )*( F(n-1) )</span><br><span class="line">  F(n-1)      1 0     F(n-2)</span><br></pre></td></tr></table></figure>

<p>下面这种存矩阵的方法是在大牛博客看到的 先学为敬(=ﾟωﾟ)ﾉ</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">#define LL long long</span><br><span class="line">typedef vector&lt;LL&gt;row;</span><br><span class="line">typedef vector&lt;row&gt;mat;</span><br><span class="line">const LL p&#x3D;1000000009;</span><br><span class="line">mat mul(mat a,mat b)&#123;</span><br><span class="line">	mat c(a.size(),row(b[0].size()));&#x2F;&#x2F;c的行数列数分别是a的行数，b的列数</span><br><span class="line">	for(int i&#x3D;0;i&lt;a.size();i++)&#123;</span><br><span class="line">		for(int j&#x3D;0;j&lt;b[0].size();j++)&#123;</span><br><span class="line">			for(int k&#x3D;0;k&lt;b.size();k++)</span><br><span class="line">				c[i][j]&#x3D;(c[i][j]+a[i][k]*b[k][j])%p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return c;</span><br><span class="line">&#125;</span><br><span class="line">mat qpow(mat a,LL x)&#123;</span><br><span class="line">	mat b(a.size(),row(a.size()));</span><br><span class="line">	for(int i&#x3D;0;i&lt;a.size();i++)b[i][i]&#x3D;1;</span><br><span class="line">	while(x&gt;0)&#123;</span><br><span class="line">		if(x&amp;1)b&#x3D;mul(b,a);</span><br><span class="line">		a&#x3D;mul(a,a);</span><br><span class="line">		x&gt;&gt;&#x3D;1;</span><br><span class="line">	&#125;</span><br><span class="line">	return b;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">    mat a(2,row(2));</span><br><span class="line">    a[0][0]&#x3D;1;a[0][1]&#x3D;1;a[1][0]&#x3D;1;a[1][1]&#x3D;0;</span><br><span class="line">    a&#x3D;qpow(a,n);</span><br><span class="line">    printf(&quot;%lld\n&quot;,a[1][0]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>cf 487 C. A Mist of Florescence（构造）</title>
    <url>/8b8f3dfd/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/contest/989/problem/C" target="_blank" rel="noopener">http://codeforces.com/contest/989/problem/C</a></p>
<p>As the boat drifts down the river, a wood full of blossoms shows up on the riverfront.<br>“I’ve been here once,” Mino exclaims with delight, “it’s breathtakingly amazing.”</p>
<p>“What is it like?”</p>
<p>“Look, Kanno, you’ve got your paintbrush, and I’ve got my words. Have a try, shall we?”</p>
<p>There are four kinds of flowers in the wood, Amaranths, Begonias, Centaureas and Dianthuses.</p>
<p>The wood can be represented by a rectangular grid of<br>n rows and m columns. In each cell of the grid, there is exactly one type of flowers.</p>
<p>According to Mino, the numbers of connected components formed by each kind of flowers are a, b, c and d respectively. Two cells are considered in the same connected component if and only if a path exists between them that moves between cells sharing common edges and passes only through cells containing the same flowers.</p>
<p>You are to help Kanno depict such a grid of flowers, with<br>n and m arbitrarily chosen under the constraints given below. It can be shown that at least one solution exists under the constraints of this problem.</p>
<p>Note that you can choose arbitrary<br>n and m under the constraints below, they are not given in the input.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first and only line of input contains four space-separated integers a, b, c and d (1≤a,b,c,d≤100) — the required number of connected components of Amaranths, Begonias, Centaureas and Dianthuses, respectively.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>In the first line, output two space-separated integers n and m (1≤n,m≤50) — the number of rows and the number of columns in the grid respectively.</p>
<p>Then output<br>n lines each consisting of m consecutive English letters, representing one row of the grid. Each letter should be among ‘A’, ‘B’, ‘C’ and ‘D’, representing Amaranths, Begonias, Centaureas and Dianthuses, respectively.</p>
<p>In case there are multiple solutions, print any. You can output each letter in either case (upper or lower).</p>
<h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><p>input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 3 2 1</span><br></pre></td></tr></table></figure>
<p>output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 7</span><br><span class="line">DDDDDDD</span><br><span class="line">DABACAD</span><br><span class="line">DBABACD</span><br><span class="line">DDDDDDD</span><br></pre></td></tr></table></figure>
<p>input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">50 50 1 1</span><br></pre></td></tr></table></figure>
<p>output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 50</span><br><span class="line">CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC</span><br><span class="line">ABABABABABABABABABABABABABABABABABABABABABABABABAB</span><br><span class="line">BABABABABABABABABABABABABABABABABABABABABABABABABA</span><br><span class="line">DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD</span><br></pre></td></tr></table></figure>
<p>input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 6 4 5</span><br></pre></td></tr></table></figure>
<p>outputCopy</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 7</span><br><span class="line">DDDDDDD</span><br><span class="line">DDDBDBD</span><br><span class="line">DDCDCDD</span><br><span class="line">DBDADBD</span><br><span class="line">DDCDCDD</span><br><span class="line">DBDBDDD</span><br><span class="line">DDDDDDD</span><br></pre></td></tr></table></figure>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>In the first example, each cell of Amaranths, Begonias and Centaureas forms a connected component, while all the Dianthuses form one.<br><img src="http://codeforces.com/predownloaded/ba/48/ba48b131922fa242edffd37b1eb411f72779e8e3.png" alt=""></p>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>四个类，abcd为每个类的连通块数</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p><code>50*50</code>，分成4块，每块分别先填满abcd，然后每个都减一，然后在a里跳着放b单格，b里放a，c里放d，d里放c，注意一下边界判断就行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	char s[55][55];</span><br><span class="line">	int a,b,c,d,h,l;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;25;i++)&#123;</span><br><span class="line">		for(int j&#x3D;1;j&lt;&#x3D;25;j++)&#123;</span><br><span class="line">			s[i][j]&#x3D;&#39;A&#39;;</span><br><span class="line">			s[i][j+25]&#x3D;&#39;B&#39;;</span><br><span class="line">			s[i+25][j]&#x3D;&#39;C&#39;;</span><br><span class="line">			s[i+25][j+25]&#x3D;&#39;D&#39;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	a--;b--;c--;d--;</span><br><span class="line">	h&#x3D;2;l&#x3D;27;</span><br><span class="line">	while(a--)&#123;</span><br><span class="line">		if(l&gt;50)h+&#x3D;2,l&#x3D;27;</span><br><span class="line">		s[h][l]&#x3D;&#39;A&#39;;</span><br><span class="line">		l+&#x3D;2;</span><br><span class="line">	&#125; </span><br><span class="line">	h&#x3D;2;l&#x3D;2;</span><br><span class="line">	while(b--)&#123;</span><br><span class="line">		if(l&gt;25)h+&#x3D;2,l&#x3D;2;</span><br><span class="line">		s[h][l]&#x3D;&#39;B&#39;;</span><br><span class="line">		l+&#x3D;2;</span><br><span class="line">	&#125;</span><br><span class="line">	h&#x3D;27;l&#x3D;27;</span><br><span class="line">	while(c--)&#123;</span><br><span class="line">		if(l&gt;50)h+&#x3D;2,l&#x3D;27;</span><br><span class="line">		s[h][l]&#x3D;&#39;C&#39;;</span><br><span class="line">		l+&#x3D;2;</span><br><span class="line">	&#125;</span><br><span class="line">	h&#x3D;27;l&#x3D;2;</span><br><span class="line">	while(d--)&#123;</span><br><span class="line">		if(l&gt;25)h+&#x3D;2,l&#x3D;2;</span><br><span class="line">		s[h][l]&#x3D;&#39;D&#39;;</span><br><span class="line">		l+&#x3D;2;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;&quot;50 50&quot;&lt;&lt;endl;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;50;i++)&#123;</span><br><span class="line">		for(int j&#x3D;1;j&lt;&#x3D;50;j++)cout&lt;&lt;s[i][j]; </span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>麻婆豆腐（思维）</title>
    <url>/37630519/</url>
    <content><![CDATA[<p><a href="https://www.nowcoder.com/acm/contest/128/B" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/128/B</a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一次课间休息的时候,音无结弦看到立华奏一个人坐在座位上写作业,于是动了请她吃麻婆豆腐的念头。他迅速移动到她后面的座位,寻思着该怎么开口邀请,他摸了摸口袋,拍了拍脑袋,有了!  </p>
<a id="more"></a>

<p>“奏<del>听说食堂里有种传闻中因为辣过头所以谁都不会点的麻婆豆腐,但是却惊人地好吃啊,这样,我们来做个题吧!如果你做出来了我就天天请你吃麻婆豆腐╰(￣▽￣)╮”<br>奏的笔停下了,她转过头来,还带了一张草稿纸,做好了做题的准备。音无懵了一下,心中暗暗窃喜,“麻婆豆腐果然是她的最爱啊!”<br>“咳咳…请听题!我手上有n枚硬币,第i枚正面朝上的概率是Pi。我现在每个硬币各抛一次,正面朝上看做1,背面朝上看做0,把所有硬币得到的数异或起来决定最后得到的数。问:有多少个子集合使得0和1的概率相等?”<br>不管音无给了怎样的数,奏都是一分钟不到就算出来了!不愧是前学生会长啊</del><br>于是他们就去食堂吃麻婆豆腐了,现在,你也来算一下吧。  </p>
<h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><p>输入的第一行包含一个整数T，表示测试组数。<br>每个测试用例前面都有一个空白行。<br>每个测试用例由两行组成。<br>第一行包含硬币数量n。<br>第二行包含n个数表示：概率p1,…,pn。每个pi都给出6个小数位。</p>
<h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><p>对于每个测试用例输出一个数：使得0和1的概率相等的子集合数量。</p>
<h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 </span><br><span class="line"></span><br><span class="line">3 </span><br><span class="line">0.500000  0.500000  0.500000 </span><br><span class="line"></span><br><span class="line">4 </span><br><span class="line">0.000001  0.000002  0.000003  0.000004</span><br></pre></td></tr></table></figure>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>说明<br>在第一个测试样例中，每个子集显然都能使得0和1的概率相等。<br>在第二个测试样例中，所有子集都不能使得0和1的概率相等<br>备注:<br>n ≤ 60,T=500</p>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>n枚硬币,第i枚正面朝上的概率是Pi。每个硬币各抛一次,正面朝上看做1,背面朝上看做0,把所有硬币得到的数异或起来决定最后得到的数。  求有多少个子集合使得0和1的概率相等?</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>答案为<code>2^n-2^(n-cnt)</code><br>其中cnt是pi中0.5的个数</p>
<p>因为只有pi=0.5，异或后的概率才可能相等，别的数都不行，证明如下：</p>
<p>设当前集合有m个元素，第一个元素为1的概率x，剩下m-1个元素异或和为1的概率为p，那么这个集合最后异或和为1的概率为<code>p*(1-x)+x*(1-p)=0.5</code>,解得x=0.5</p>
<p>注意1要写1LL，不然会WA</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">	double c;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">    	int n;</span><br><span class="line">    	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    	int cnt&#x3D;0;</span><br><span class="line">    	for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">    		scanf(&quot;%lf&quot;,&amp;c);</span><br><span class="line">    		if(c&#x3D;&#x3D;0.5)cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		LL ans&#x3D;(1LL&lt;&lt;n)-(1LL&lt;&lt;(n-cnt));</span><br><span class="line">		printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>Alice和Bob的Nim游戏（博弈，数列，矩阵快速幂）</title>
    <url>/e7a0c86b/</url>
    <content><![CDATA[<p><a href="https://nanti.jisuanke.com/t/28447" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/28447</a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>众所周知，Alice和Bob非常喜欢博弈，而且Alice永远是先手，Bob永远是后手。</p>
<p>Alice和Bob面前有3堆石子，Alice和Bob每次轮流拿某堆石子中的若干个石子（不可以是0个），拿到所有石子中最后一个石子的人获胜。这是一个只有3堆石子的Nim游戏。</p>
<p>Bob错误的认为，三堆石子的Nim游戏只需要少的两堆的石子数量加起来等于多的那一堆，后手就一定会胜利。所以，Bob把三堆石子的数量分别设为 {k，4k，5k}（k&gt;0）。</p>
<p>现在Alice想要知道，在k 小于 2^n 的时候，有多少种情况先手一定会获得胜利。</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>一个整数n(1≤n≤2×10^9)。</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出先手胜利的可能情形数。答案对10^9+7取模。</p>
<p>输出时每行末尾的多余空格，不影响答案正确性</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p><a href="https://nanti.jisuanke.com/?kw=ACM%E8%AE%AD%E7%BB%83%E8%81%94%E7%9B%9F%E5%91%A8%E8%B5%9B" target="_blank" rel="noopener">ACM训练联盟周赛</a></p>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>就是普通尼姆博弈，只要把k，4k，5k异或一下，为0先手就必胜，这题难在k可以是个巨无敌大的数，只好找规律了</p>
<p>先打个表</p>
<p>2，4，6，9，15，25，40，64，104，169…</p>
<p>本来发现的规律是后一个数是前两个数相加，然后前两个数相加减一，前两个数相加，前两个数相加加一，前两个数相加…以此类推，但是没搞出什么名堂来</p>
<p>然后当时看了这篇知道了这个数列和斐波那契有点关系<br><a href="https://zhidao.baidu.com/question/489289663.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/489289663.html</a></p>
<p>四个一组，推出了四个公式，其中用到的斐波那契数列用矩阵快速幂（网上找的模版。。）处理一下，公式具体见代码</p>
<p>最后那个四个乘以qpow(5,p-2,p)，本来公式是除以5的，但是因为除法对求余不分配就WA了，所以费马小定理一下，乘以5的逆元</p>
<p>最后官方题解里是这么写的：f(n) = f(n-1) + f(n-3) + f(n-4) + 2，也是矩阵快速幂处理一下</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;20000000;</span><br><span class="line">const LL p&#x3D;1000000000+7;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct matrix &#123;</span><br><span class="line">	LL m[2][2];</span><br><span class="line">&#125;ans;</span><br><span class="line">matrix base &#x3D; &#123;1, 1, 1, 0&#125;; </span><br><span class="line">matrix multi(matrix a, matrix b) &#123;</span><br><span class="line">	matrix tmp;</span><br><span class="line">	for(int i &#x3D; 0; i &lt; 2; i++) &#123;</span><br><span class="line">		for(int j &#x3D; 0; j &lt; 2; j++) &#123;</span><br><span class="line">			tmp.m[i][j] &#x3D; 0;</span><br><span class="line">			for(int k &#x3D; 0;  k &lt; 2; k++)</span><br><span class="line">				tmp.m[i][j] &#x3D; (tmp.m[i][j] + a.m[i][k] * b.m[k][j]) % p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return tmp;</span><br><span class="line">&#125;</span><br><span class="line">LL matrix_pow(matrix a, int n) &#123;</span><br><span class="line">	ans.m[0][0] &#x3D; ans.m[1][1] &#x3D; 1;</span><br><span class="line">	ans.m[0][1] &#x3D; ans.m[1][0] &#x3D; 0;</span><br><span class="line">	while(n) &#123;</span><br><span class="line">		if(n &amp; 1) ans &#x3D; multi(ans, a);</span><br><span class="line">		a &#x3D; multi(a, a);</span><br><span class="line">		n &gt;&gt;&#x3D; 1;</span><br><span class="line">	&#125;</span><br><span class="line">	return ans.m[0][1];</span><br><span class="line">&#125;</span><br><span class="line">LL fi(LL x) &#123;</span><br><span class="line">	return matrix_pow(base, x);</span><br><span class="line">&#125; </span><br><span class="line">LL qpow(LL a,LL b,LL p)&#123;</span><br><span class="line">    LL anss&#x3D;1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            anss&#x3D;(anss*a)%p;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        b&#x2F;&#x3D;2;</span><br><span class="line">        a&#x3D;a*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return anss;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    LL n,res&#x3D;0;</span><br><span class="line">    LL z;</span><br><span class="line">    while(cin&gt;&gt;n)&#123;</span><br><span class="line">    if(n&#x3D;&#x3D;1||n&#x3D;&#x3D;2)&#123;</span><br><span class="line">    	cout&lt;&lt;0&lt;&lt;endl;</span><br><span class="line">    	return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	else if(n&#x3D;&#x3D;3)&#123;</span><br><span class="line">		cout&lt;&lt;2&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else if(n&#x3D;&#x3D;4)&#123;</span><br><span class="line">		cout&lt;&lt;7&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		LL nn&#x3D;n;</span><br><span class="line">		n+&#x3D;2;</span><br><span class="line">		if(n%4&#x3D;&#x3D;0)&#123;</span><br><span class="line">			z&#x3D;((4*fi(n)+3*fi(n-1)+2)*qpow(5,p-2,p))%p;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(n%4&#x3D;&#x3D;1)&#123;</span><br><span class="line">			z&#x3D;((3*fi(n+1)+fi(n)+1)*qpow(5,p-2,p))%p;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(n%4&#x3D;&#x3D;2)&#123;</span><br><span class="line">			z&#x3D;((4*fi(n)+3*fi(n-1)-2)*qpow(5,p-2,p))%p;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			z&#x3D;((3*fi(n+1)+fi(n)-1)*qpow(5,p-2,p))%p;</span><br><span class="line">		&#125;</span><br><span class="line">		res&#x3D;(qpow(2,nn,p)-z%p+p)%p;</span><br><span class="line">		cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">	&#125;&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>Pawns（博弈，思维）</title>
    <url>/61e3cbc/</url>
    <content><![CDATA[<p><a href="https://nanti.jisuanke.com/t/28205" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/28205</a></p>
<p>Carl and Nathan are completely bored with the game of chess; it’s too easy! They have come up with their own game, which is surely a greater test of one’s intelligence.This game is played on a board with n by m squares. At the start, white and black pawns are placed quasi-randomly over the board, with the following constraint: in every column there is one white pawn and one black pawn, with the white pawn on some square below the black one.</p>
<p>Each player in turn makes a move with one of his pawns. A pawn is only allowed to move one square forward, provided that this square is empty. “Forward” means in the direction of the opponent, so white pawns move up and black pawns move down. In addition, a pawn on the first rank – that is, a white pawn on the bottom row, or a black pawn on the top row – may also move two squares forward, provided that both squares are empty. Unlike normal chess, the pawns are never taken from the board and never change column.</p>
<p><img src="https://res.jisuanke.com/img/upload/20180703/f32e80b481a421fcf94d5ed040138bbc778728d7.png" alt=""></p>
<p>For example, in the position above, White (the player using the white pieces) has eight moves: one with each of the pawns on b1, d2, f5 and h2, and two with both the pawn on c1 and the pawn on g1. The pawns on a6 and e1 cannot move.</p>
<p>Eventually and inevitably, the pawns will meet up in every column, leaving neither player able to move. The game is then finished, and the winner is the player who made the last move.</p>
<p>As usual, White gets the first move. With optimal play, who would win for a given startingposition?</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>On the first line one positive number: the number of test cases, at most 100. After that per test case:</p>
<p>one line with two space-separated integers n and m (3≤n≤20 and 1≤m≤20):the number of rows and columns of the board, respectively.<br>n lines with m characters, describing the position on the board at the start of the game:<br>‘W’ is a white pawn.<br>‘B’ is a black pawn.<br>‘.’ is an empty square.Each column contains exactly one ‘W’ and one ‘B’, with the ‘W’ being below the ‘B’.<br>In every test case, the starting position will be such that White has at least one move.  </p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>Per test case:</p>
<p>one line with the string “White wins” if White can win with optimal play, or “Black wins” if Black has a winning strategy.</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">8 8</span><br><span class="line">.....BB.</span><br><span class="line">B.......</span><br><span class="line">W......B</span><br><span class="line">...B.W..</span><br><span class="line">..B.....</span><br><span class="line">.B......</span><br><span class="line">...WB..W</span><br><span class="line">.WW.W.W.</span><br><span class="line">6 4</span><br><span class="line">....</span><br><span class="line">B..B</span><br><span class="line">....</span><br><span class="line">.B.W</span><br><span class="line">W.B.</span><br><span class="line">.WW.</span><br><span class="line">5 3</span><br><span class="line">...</span><br><span class="line">BBB</span><br><span class="line">...</span><br><span class="line">WW.</span><br><span class="line">..W</span><br><span class="line">4 6</span><br><span class="line">.BBB.B</span><br><span class="line">B...B.</span><br><span class="line">...W..</span><br><span class="line">WWW.WW</span><br><span class="line">7 7</span><br><span class="line">.B.B..B</span><br><span class="line">.......</span><br><span class="line">..B.B..</span><br><span class="line">B....B.</span><br><span class="line">.......</span><br><span class="line">...WW.W</span><br><span class="line">WWW..W.</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Black wins</span><br><span class="line">Black wins</span><br><span class="line">White wins</span><br><span class="line">White wins</span><br><span class="line">Black wins</span><br></pre></td></tr></table></figure>
<h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p>BAPC 2014 Preliminary</p>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>两个人轮流下棋，给定一个棋局，B在W上，白色的棋子W向上移动，黑色的棋子B向下移动，每次可移动一格。底行上的W棋子或顶行上的B棋子可以向前移动两个方格，前提是两个方格都是空的。W先手，无法移动的一方输。</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>首先想到胜负和W，B之间可走步数的奇偶性有关，然后顶行和底行且可以走两步的棋子有改变奇偶性的能力。</p>
<p>先考虑一种特殊情况，某一列中B在顶行且W在底行，这对两个棋子来说是一样的，这种出现次数记为cd。</p>
<blockquote>
<p>1.n&gt;5时，只要一方走两步改变了奇偶性，另一方可以学对方的走法，把奇偶性变回来，所以后续不用考虑这几列的步数。</p>
<p>2.n=3时不会出现这种情况，不考虑。</p>
<p>3.特殊情况n=4和n=5，因为他们一方走两步之后，另一方就没有走两步的能力了，是要考虑的，在后面讨论。</p>
</blockquote>
<p>然后只有一方的棋子在顶行或者底行且该棋子可以走两步时：只要一方有改变奇偶性能力的棋子，另一方就会想要去优先破坏这种能力，比如：</p>
<p>B<br>。<br>。<code>W优先向上走三步，则B就没有破坏奇偶性的能力了，则cw+=3</code><br>。<br>。<br>W  </p>
<blockquote>
<p>cw为W破坏B的能力棋子所需要走的步数<br>cb为B破坏W的能力棋子所需要走的步数</p>
</blockquote>
<p>最后，对于那些没有棋子有机会走两步的列来说，双方都只能一步一步走，只要把可走步数累加即可。</p>
<p>综上所述，W的必胜情况：</p>
<blockquote>
<p>1.n=4，且cd为奇数</p>
<p>这种情况下，cd为奇数，W作为先手无论如何都掌握最后一个改变奇偶的决定权，所以w只要在最后一个机会时判断当前局势决定是否改变奇偶性即可。</p>
<p>2.cw &lt; cb</p>
<p>即B破坏W能力要走的步数多，那么W就有改变奇偶能力，W必胜。</p>
<p>3.cb = cw - 1或cb = cw且步数为奇<br>（这里的bushu指B在顶行且W在底行的情况不算的总步数）</p>
<p>cb = cw - 1时，因为W先走，下完（cb+cw）步之后，此时两人都刚好没有破坏奇偶性的能力，（cb+cw）为奇数，下一步轮到B下，剩余步数为（部分步数-cb-cw）为偶数，所以W必胜。<br>cb = cw时，同上，（cb+cw）为偶，下一步轮到W，剩余步数为奇，W必胜。</p>
</blockquote>
<p>最后考虑n=5的时候的特殊情况<br>比赛的时候这个情况我一直没想想清楚。。随便举个例子：</p>
<p>B 。。。B<br>。B 。。。<br>。。B 。。<br>。。。B 。<br>WWWWW</p>
<p>对于第一，五列那种双方都有能力的棋子来说，不管先手走一步还是两步，后手都可以走（3-i）步使这一列一人走一次然后作废，所以n=5时这种列也不考虑。<br>对于第二列，B要优先破坏W的能力。<br>对于第三，四列，只要数可走步数即可。  </p>
<p>因为剩下的策略都满足上面的n&gt;5时，所以n=5虽然有特殊，但是并不用考虑特殊策略。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int N&#x3D;40;</span><br><span class="line">char p[N][N];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t,num&#x3D;0;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        int n,m;</span><br><span class="line">        int cw&#x3D;0,cb&#x3D;0,cd&#x3D;0,bushu&#x3D;0;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">        memset(p,0,sizeof(p));</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">            for(int j&#x3D;1;j&lt;&#x3D;m;j++)&#123;</span><br><span class="line">                cin&gt;&gt;p[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">            int b,w;</span><br><span class="line">            for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;</span><br><span class="line">                if(p[j][i]&#x3D;&#x3D;&#39;B&#39;)b&#x3D;j;</span><br><span class="line">                else if(p[j][i]&#x3D;&#x3D;&#39;W&#39;)w&#x3D;j;</span><br><span class="line">            &#125;</span><br><span class="line">            if(b&#x3D;&#x3D;1&amp;&amp;w&#x3D;&#x3D;n&amp;&amp;n&gt;3)cd++;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(b&#x3D;&#x3D;1&amp;&amp;w&gt;3)cw+&#x3D;w-3;</span><br><span class="line">                else if(w&#x3D;&#x3D;n&amp;&amp;b&lt;n-2)cb+&#x3D;n-2-b;</span><br><span class="line">                bushu+&#x3D;(w-b-1);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        if((n&#x3D;&#x3D;4&amp;&amp;cd%2&#x3D;&#x3D;1)||(cw&lt;cb)||(((cb&#x3D;&#x3D;cw-1)||(cb&#x3D;&#x3D;cw))&amp;&amp;bushu%2&#x3D;&#x3D;1))printf(&quot;White wins\n&quot;);</span><br><span class="line">        else printf(&quot;Black wins\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1847 Good Luck in CET-4 Everybody!（巴什博弈）</title>
    <url>/3d8d44b2/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1847" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1847</a></p>
<a id="more"></a>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>大学英语四级考试就要来临了，你是不是在紧张的复习？也许紧张得连短学期的ACM都没工夫练习了，反正我知道的Kiki和Cici都是如此。当然，作为在考场浸润了十几载的当代大学生，Kiki和Cici更懂得考前的放松，所谓“张弛有道”就是这个意思。这不，Kiki和Cici在每天晚上休息之前都要玩一会儿扑克牌以放松神经。</p>
<p>“升级”？“双扣”？“红五”？还是“斗地主”？</p>
<p>当然都不是！那多俗啊~</p>
<p>作为计算机学院的学生，Kiki和Cici打牌的时候可没忘记专业，她们打牌的规则是这样的：</p>
<p>1、  总共n张牌;<br>2、  双方轮流抓牌；<br>3、  每人每次抓牌的个数只能是2的幂次（即：1，2，4，8，16…）<br>4、  抓完牌，胜负结果也出来了：最后抓完牌的人为胜者；  </p>
<p>假设Kiki和Cici都是足够聪明（其实不用假设，哪有不聪明的学生），并且每次都是Kiki先抓牌，请问谁能赢呢？</p>
<p>当然，打牌无论谁赢都问题不大，重要的是马上到来的CET-4能有好的状态。</p>
<p>Good luck in CET-4 everybody!</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入数据包含多个测试用例，每个测试用例占一行，包含一个整数n（1&lt;=n&lt;=1000）。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>如果Kiki能赢的话，请输出“Kiki”，否则请输出“Cici”，每个实例的输出占一行。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Kiki</span><br><span class="line">Cici</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>n张牌，每次可以取<code>2^i</code>张,最后取完的人胜</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>因为可以取到1，2，所以剩下取几都不重要了，因为所有数要么是三的倍数，要么是三的倍数多一，要么是三的倍数多二，又因为除了1，2剩下的数都是大于3的偶数，所以不管对手怎么取都无力回天了，不可能再把三的倍数抛给你 _ (: з 」∠) _</p>
<p>所以对手取完，只要你能一直留给他三的倍数，你就赢</p>
<p>综上所述，一开始是三的倍数的人必败</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    while(cin&gt;&gt;n)&#123;</span><br><span class="line">    	if(n%3&#x3D;&#x3D;0)cout&lt;&lt;&quot;Cici&quot;&lt;&lt;endl;</span><br><span class="line">		else cout&lt;&lt;&quot;Kiki&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1404 Digital Deletions（sg函数暴力打表）</title>
    <url>/2d3ae01/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1404" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1404</a></p>
<a id="more"></a>

<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Digital deletions is a two-player game. The rule of the game is as following. </p>
<p>Begin by writing down a string of digits (numbers) that’s as long or as short as you like. The digits can be 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 and appear in any combinations that you like. You don’t have to use them all. Here is an example:</p>
<p><img src="http://acm.hdu.edu.cn/data/images/1404-1.gif" alt=""></p>
<p>On a turn a player may either:<br>Change any one of the digits to a value less than the number that it is. (No negative numbers are allowed.) For example, you could change a 5 into a 4, 3, 2, 1, or 0.<br>Erase a zero and all the digits to the right of it.</p>
<p>The player who removes the last digit wins.</p>
<p>The game that begins with the string of numbers above could proceed like this: </p>
<p><img src="http://acm.hdu.edu.cn/data/images/1404-2.gif" alt=""></p>
<p>Now, given a initial string, try to determine can the first player win if the two players play optimally both. </p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input consists of several test cases. For each case, there is a string in one line.</p>
<p>The length of string will be in the range of [1,6]. The string contains only digit characters.</p>
<p>Proceed to the end of file.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Output Yes in a line if the first player can win the game, otherwise output No.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">00</span><br><span class="line">1</span><br><span class="line">20</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给一个长度在[1,6]的数字字符串</p>
<p>有两种操作：</p>
<p>1.把任何一个数字更改为小于其数字的值</p>
<p>2.删除0及其右侧的数字</p>
<p>删除最后一位的赢，问先手有无必胜策略</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>首先这个最多只有6位，有很多很多状态，所以是个sg函数的题，从最小的已知态往上推，根据sg函数的性质，能一步到达必败状态的都是必胜点，由此求得所有六位数状态的值</p>
<p>分析一下可以sg[1]是必败点，sg[1]=0,那么就从1开始向上拓展必胜态，具体操作见代码</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;1000000;</span><br><span class="line">int sg[N];</span><br><span class="line">int wei(int n)&#123;</span><br><span class="line">	if(n&#x2F;100000)return 6;</span><br><span class="line">	if(n&#x2F;10000)return 5;</span><br><span class="line">	if(n&#x2F;1000)return 4;</span><br><span class="line">	if(n&#x2F;100)return 3;</span><br><span class="line">	if(n&#x2F;10)return 2;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line">void extend(int n)&#123;</span><br><span class="line">&#x2F;&#x2F;sg[n]&#x3D;0先手必败，可以一步变为n的都是先手必胜</span><br><span class="line">	int len&#x3D;wei(n);</span><br><span class="line">	for(int i&#x3D;len;i&gt;0;i--)&#123;&#x2F;&#x2F;每一位上加一个数</span><br><span class="line">		int m&#x3D;n;</span><br><span class="line">		int base&#x3D;1;</span><br><span class="line">		for(int j&#x3D;1;j&lt;i;j++)base*&#x3D;10;</span><br><span class="line">		int tmp&#x3D;(m%(base*10))&#x2F;base;</span><br><span class="line">		for(int j&#x3D;tmp;j&lt;9;j++)&#123;</span><br><span class="line">			m+&#x3D;base;</span><br><span class="line">			sg[m]&#x3D;1;</span><br><span class="line">		&#125;</span><br><span class="line">		if(len&lt;6)&#123;&#x2F;&#x2F;长度小于6，可以在后面补0</span><br><span class="line">			int m&#x3D;n;</span><br><span class="line">			int base&#x3D;1;</span><br><span class="line">			for(int i&#x3D;len;i&lt;6;i++)&#123;</span><br><span class="line">				m*&#x3D;10;</span><br><span class="line">				for(int b&#x3D;0;b&lt;base;b++)sg[m+b]&#x3D;1;</span><br><span class="line">				base*&#x3D;10;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line">void work()&#123;</span><br><span class="line">	memset(sg,0,sizeof(sg));</span><br><span class="line">	sg[0]&#x3D;1;</span><br><span class="line">	for(int i&#x3D;1;i&lt;N;i++)&#123;</span><br><span class="line">		if(!sg[i])extend(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	char str[8];</span><br><span class="line">	int n;</span><br><span class="line">	work();</span><br><span class="line">	while(scanf(&quot;%s&quot;,str)!&#x3D;EOF)&#123;</span><br><span class="line">		if(str[0]&#x3D;&#x3D;&#39;0&#39;)&#123;</span><br><span class="line">			printf(&quot;Yes\n&quot;);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		int len&#x3D;strlen(str);</span><br><span class="line">		n&#x3D;0;</span><br><span class="line">		for(int i&#x3D;0;i&lt;len;i++)&#123;</span><br><span class="line">			n*&#x3D;10;</span><br><span class="line">			n+&#x3D;str[i]-&#39;0&#39;;</span><br><span class="line">		&#125;</span><br><span class="line">		if(sg[n])printf(&quot;Yes\n&quot;);</span><br><span class="line">		else printf(&quot;No\n&quot;); </span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1527 取石子游戏（威佐夫博弈）</title>
    <url>/40d6aa63/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1527" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1527</a></p>
<a id="more"></a>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入包含若干行，表示若干种石子的初始情况，其中每一行包含两个非负整数a和b，表示两堆石子的数目，a和b都不大于1,000,000,000。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出对应也有若干行，每行包含一个数字1或0，如果最后你是胜者，则为1，反之，则为0。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 1</span><br><span class="line">8 4</span><br><span class="line">4 7</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>威佐夫博弈裸题，在<a href="http://leflacon.github.io/eb18b91b" target="_blank" rel="noopener">hdu 2177</a>那篇有介绍威佐夫博弈</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int a,b;</span><br><span class="line">	while(scanf(&quot;%d%d&quot;,&amp;a,&amp;b)!&#x3D;EOF)&#123;</span><br><span class="line">		if(a&gt;b)&#123;</span><br><span class="line">			int temp&#x3D;a;a&#x3D;b;b&#x3D;temp;</span><br><span class="line">		&#125;</span><br><span class="line">		if((int)((sqrt(5)+1)*(b-a)&#x2F;2)&#x3D;&#x3D;a)printf(&quot;0\n&quot;);</span><br><span class="line">		else printf(&quot;1\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1564 Play a game</title>
    <url>/94b377b3/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1564" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1564</a></p>
<a id="more"></a>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>New Year is Coming!<br>ailyanlu is very happy today! and he is playing a chessboard game with 8600.<br>The size of the chessboard is <code>n*n</code>. A stone is placed in a corner square. They play alternatively with 8600 having the first move. Each time, player is allowed to move the stone to an unvisited neighbor square horizontally or vertically. The one who can’t make a move will lose the game. If both play perfectly, who will win the game?</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input is a sequence of positive integers each in a separate line.<br>The integers are between 1 and 10000, inclusive,(means 1 &lt;= n &lt;= 10000) indicating the size of the chessboard. The end of the input is indicated by a zero.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Output the winner (“8600” or “ailyanlu”) for each input line except the last zero.<br>No other characters should be inserted in the output.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">0</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8600</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给一个<code>n*n</code>的网格，一个石头从角落出发，每次水平或垂直移动到相邻的没有访问过的格子上，谁不能走谁输</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>蛮水的题。。</p>
<p>n=1先手必败，n=2先手必胜，n=3先手必败，n=4先手必胜…</p>
<p>这些自己模拟一下大概就能发现规律了：n为奇数时后手胜，n为偶数先手胜</p>
<p>当然这也是可以解释的，就是把棋盘分成一个个<code>1*2</code>的部分，无论先手后手只要跟着对方走把对方那个补上完成一个个<code>1*2</code>，最后就赢了，所以就是看剩下的<code>n*n-1</code>个格子能否恰好凑成一些<code>1*2</code>的小块，<code>n*n-1</code>为偶数就可以，那么后手必胜，如果<code>n*n-1</code>为奇数，多了一个，那么先手必胜</p>
<p>判断 <code>n*n-1</code> 的奇偶性，其实也是 <code>n</code>的奇偶性</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)&#123;</span><br><span class="line">		if(n&amp;1)printf(&quot;ailyanlu\n&quot;);</span><br><span class="line">		else printf(&quot;8600\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1729 Stone Game（尼姆博弈，sg函数）</title>
    <url>/9ac96b1d/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1729" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1729</a></p>
<a id="more"></a>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>This game is a two-player game and is played as follows:</p>
<ol>
<li>There are n boxes; each box has its size. The box can hold up to s stones if the size is s.</li>
<li>At the beginning of the game, there are some stones in these boxes.</li>
<li>The players take turns choosing a box and put a number of stones into the box. The number mustn’t be great than the square of the number of stones before the player adds the stones. For example, the player can add 1 to 9 stones if there are 3 stones in the box. Of course, the total number of stones mustn’t be great than the size of the box.</li>
<li>Who can’t add stones any more will loss the game.</li>
</ol>
<p>Give an Initial state of the game. You are supposed to find whether the first player will win the game if both of the players make the best strategy.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input file contains several test cases.<br>Each test case begins with an integer N, 0 &lt; N ≤ 50, the number of the boxes.<br>In the next N line there are two integer si, ci (0 ≤ ci ≤ si ≤ 1,000,000) on each line, as the size of the box is si and there are ci stones in the box.<br>N = 0 indicates the end of input and should not be processed.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, output the number of the case on the first line, then output “Yes” (without quotes) on the next line if the first player can win the game, otherwise output “No”.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 0</span><br><span class="line">3 3</span><br><span class="line">6 2</span><br><span class="line">2</span><br><span class="line">6 3</span><br><span class="line">6 3</span><br><span class="line">0</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case 1:</span><br><span class="line">Yes</span><br><span class="line">Case 2:</span><br><span class="line">No</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>n个盒子，每个盒子容量si，里面有ci个石头，每次操作向盒子里面放石头，放的数量不能大于盒子中已有石头数量的平方，不能再放石头的人输</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>按题意是个组合游戏和，博弈好题</p>
<p><strong>平等组合游戏</strong></p>
<ul>
<li>两人游戏</li>
<li>有一个状态集，而且通常是有限的</li>
<li>规定哪些状态转移是允许的</li>
<li>所有规定对于两人来说是一样的</li>
<li>两人轮流走步</li>
<li>有一个终止状态，到达终止状态后游戏即告终止</li>
<li>游戏可以在有限步内终止</li>
</ul>
<p>严格的来定义P状态和N状态</p>
<ul>
<li>所有的终止状态都是P状态；</li>
<li>对于任何的N状态，肯定存在一种方式可以一步转到一个P状态；</li>
<li>对于任何的P状态，不管怎么走步，都只能转到N状态。</li>
</ul>
<p><strong>Sprague-Grundy函数</strong><br>解题模型：</p>
<ul>
<li>把原游戏分解成多个独立的子游戏，则原游戏的SG函数值是它的所有子游戏的SG函数值的异或<br>即<code>sg(G)=sg(G1)^sg(G2)^...^sg(Gn)</code></li>
<li>分别考虑每一个子游戏，计算其SG值</li>
</ul>
<p>求每个盒子的sg函数值，<code>get_sg(s,c)</code>，假设每次的取的范围是<code>1～q</code>，那么有<code>q*q+q&lt;s</code> ，同时又要使q尽量大，则有<code>(q+1)*(q+1)+(q+1)&gt;=s</code></p>
<p>所以先根据上限s找到这个q，然后和当前容量c比较判断是否合法，如果当前盒子里的c&gt;q，那么就可以一次性放满，这个盒子就没用了，反之如果不能一次性放满，就需要假设盒子容量是q，继续递归求上一步操作，<code>get_sg(q,c)</code>;</p>
<p>要是倒着想感觉绕的话，那就把需要求两次的正过来想╮(￣▽￣””)╭，当前宝石个数是c，但是 <code>c+c*c&lt;s</code>，放不满怎么办，那就先放x个，x是多少现在我还不知道（因为越往后面平方越大，所以实际上我倒着想才会得到最优的结果），那么现在的宝石个数变成了（c+x）个，我可以放<code>1～(c+x)*(c+x)</code>个，如果按最大值放的话，此时就是<code>(c+x)*(c+x)+(c+x)</code>个，如果这个值恰好大于等于s，那么问题就最优的解决了</p>
<p>然后求这几个sg值的Nim和即可</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int get_sg(int s,int c)&#123;</span><br><span class="line">	int q&#x3D;sqrt((double)s);</span><br><span class="line">	while(q+q*q&gt;&#x3D;s)&#123;</span><br><span class="line">		q--;</span><br><span class="line">	&#125;</span><br><span class="line">	if(c&gt;q)return s-c;</span><br><span class="line">	else return get_sg(q,c);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,cas&#x3D;0;</span><br><span class="line">	while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)&#123;</span><br><span class="line">		int s,c;</span><br><span class="line">		printf(&quot;Case %d:\n&quot;,++cas);</span><br><span class="line">		int ans&#x3D;0;</span><br><span class="line">		while(n--)&#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;,&amp;s,&amp;c);</span><br><span class="line">			ans^&#x3D;get_sg(s,c);</span><br><span class="line">		&#125;</span><br><span class="line">		if(ans)puts(&quot;Yes&quot;);</span><br><span class="line">		else puts(&quot;No&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1846 Brave Game（巴什博弈）</title>
    <url>/a4b21e43/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1846" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1846</a></p>
<a id="more"></a>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>十年前读大学的时候，中国每年都要从国外引进一些电影大片，其中有一部电影就叫《勇敢者的游戏》（英文名称：Zathura），一直到现在，我依然对于电影中的部分电脑特技印象深刻。<br>今天，大家选择上机考试，就是一种勇敢（brave）的选择；这个短学期，我们讲的是博弈（game）专题；所以，大家现在玩的也是“勇敢者的游戏”，这也是我命名这个题目的原因。<br>当然，除了“勇敢”，我还希望看到“诚信”，无论考试成绩如何，希望看到的都是一个真实的结果，我也相信大家一定能做到的~</p>
<p>各位勇敢者要玩的第一个游戏是什么呢？很简单，它是这样定义的：<br>1、  本游戏是一个二人游戏;<br>2、  有一堆石子一共有n个；<br>3、  两人轮流进行;<br>4、  每走一步可以取走1…m个石子；<br>5、  最先取光石子的一方为胜；   </p>
<p>如果游戏的双方使用的都是最优策略，请输出哪个人能赢。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入数据首先包含一个正整数C(C&lt;=100)，表示有C组测试数据。<br>每组测试数据占一行，包含两个整数n和m（1&lt;=n,m&lt;=1000），n和m的含义见题目描述。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>如果先走的人能赢，请输出“first”，否则请输出“second”，每个实例的输出占一行。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">23 2</span><br><span class="line">4 3</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">first</span><br><span class="line">second</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><h4 id="巴什博弈："><a href="#巴什博弈：" class="headerlink" title="巴什博弈："></a>巴什博弈：</h4><p>只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。</p>
<p>若n=m+1，由于一次最多只能取m个，所以无论先手拿几个，后手都能够一次拿走剩下的，先手必败</p>
<p>所以必胜情况就是：n=（m+1）r+s，（r为任意自然数，s≤m),那么先手先拿走s个物品，然后如果后手拿走k（≤m)个，那么先手再拿走m+1-k个，凑成一组（m+1）就行，保证留给后手的永远是（m+1）的倍数，那么先手必胜</p>
<p>所以结论是n%(m+1)!=0,先手必胜，反之后手胜</p>
<p>感觉博弈里很多都是根据对方的动作凑成一组一组，蛮妙的</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        int m,n;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        if(n%(m+1)&#x3D;&#x3D;0)cout&lt;&lt;&quot;second&quot;&lt;&lt;endl;</span><br><span class="line">        else cout&lt;&lt;&quot;first&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1849 Rabbit and Grass（尼姆博弈）</title>
    <url>/6f6ab2c9/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1849" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1849</a></p>
<a id="more"></a>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>大学时光是浪漫的，女生是浪漫的，圣诞更是浪漫的，但是Rabbit和Grass这两个大学女生在今年的圣诞节却表现得一点都不浪漫：不去逛商场，不去逛公园，不去和AC男约会，两个人竟然猫在寝食下棋……<br>说是下棋，其实只是一个简单的小游戏而已，游戏的规则是这样的：</p>
<p>1、棋盘包含1xn个方格，方格从左到右分别编号为0，1，2，…，n-1；</p>
<p>2、m个棋子放在棋盘的方格上，方格可以为空，也可以放多于一个的棋子；</p>
<p>3、双方轮流走棋；</p>
<p>4、每一步可以选择任意一个棋子向左移动到任意的位置（可以多个棋子位于同一个方格），当然，任何棋子不能超出棋盘边界；</p>
<p>5、如果所有的棋子都位于最左边（即编号为0的位置），则游戏结束，并且规定最后走棋的一方为胜者。</p>
<p>对于本题，你不需要考虑n的大小（我们可以假设在初始状态，棋子总是位于棋盘的适当位置）。下面的示意图即为一个1x15的棋盘，共有6个棋子，其中，编号8的位置有两个棋子。</p>
<p><img src="http://acm.hdu.edu.cn/data/images/C101-1004-1.JPG" alt=""></p>
<p>大家知道，虽然偶尔不够浪漫，但是Rabbit和Grass都是冰雪聪明的女生，如果每次都是Rabbit先走棋，请输出最后的结果。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入数据包含多组测试用例，每个测试用例占二行，首先一行包含一个整数m（0&lt;=m&lt;=1000），表示本测试用例的棋子数目，紧跟着的一行包含m个整数Ki(i=1…m; 0&lt;=Ki&lt;=1000)，分别表示m个棋子初始的位置，m=0则结束输入。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>如果Rabbit能赢的话，请输出“Rabbit Win!”，否则请输出“Grass Win!”，每个实例的输出占一行。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 </span><br><span class="line">3 5</span><br><span class="line">3</span><br><span class="line">3 5 6</span><br><span class="line">0</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Rabbit Win!</span><br><span class="line">Grass Win!</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>尼姆博弈水题 </p>
<p>因为棋子最后都移动到最左，可以重合，所以一个棋子的可移动次数就是它的位置号也相当于尼姆博弈n堆石子中某一堆的石子数</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;200005;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)&#123;</span><br><span class="line">		int sum&#x3D;0,c[N];</span><br><span class="line">		for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;c[i]);</span><br><span class="line">			sum^&#x3D;c[i];</span><br><span class="line">		&#125;</span><br><span class="line">		if(sum&#x3D;&#x3D;0)printf(&quot;Grass Win!\n&quot;);</span><br><span class="line">		else&#123;</span><br><span class="line">			printf(&quot;Rabbit Win!\n&quot;);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 2176 取(m堆)石子游戏（尼姆博弈）</title>
    <url>/42b4455d/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2176" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=2176</a></p>
<a id="more"></a>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>m堆石子,两人轮流取.只能在1堆中取.取完者胜.先取者负输出No.先取者胜输出Yes,然后输出怎样取子.例如5堆 5,7,8,9,10先取者胜,先取者第1次取时可以从有8个的那一堆取走7个剩下1个,也可以从有9个的中那一堆取走9个剩下0个,也可以从有10个的中那一堆取走7个剩下3个.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入有多组.每组第1行是m,m&lt;=200000. 后面m个非零正整数.m=0退出.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>先取者负输出No.先取者胜输出Yes,然后输出先取者第1次取子的所有方法.如果从有a个石子的堆中取若干个后剩下b个后会胜就输出a b.参看Sample Output.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">45 45</span><br><span class="line">3</span><br><span class="line">3 6 9</span><br><span class="line">5</span><br><span class="line">5 7 8 9 10</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">No</span><br><span class="line">Yes</span><br><span class="line">9 5</span><br><span class="line">Yes</span><br><span class="line">8 1</span><br><span class="line">9 0</span><br><span class="line">10 3</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><h4 id="尼姆博弈"><a href="#尼姆博弈" class="headerlink" title="尼姆博弈"></a>尼姆博弈</h4><p>这题判断胜负直接异或就行，若异或结果sum=0则先手败，其余先手必胜</p>
<p>胜要求输出第一步操作后剩余的石子数，若<code>c[i]^sum&lt;c[i]</code>则可行，取得个数为<code>c[i]-c[i]^sum</code>，输出剩余个数即为<code>c[i]^sum</code></p>
<p>以下我也忘了摘自哪里。。</p>
<blockquote>
<p>三堆的时候</p>
<p>用(a,b,c)表示某种局势，首先(0,0,0)显然是必败态，无论谁面对(0,0,0) ，都必然失败；第二种必败态是(0,n,n)，自己在某一堆拿走k（k ≤ n）个物品，不论k为多少，对方只要在另一堆拿走k个物品，最后自己都将面临(0,0,0)的局势，必败。仔细分析一下，(1,2,3)也是必败态，无论自己如何拿，接下来对手都可以把局势变为(0,n,n)的情形</p>
<p>任何奇异局势(a,b,c)都有a XOR b XOR c = 0</p>
<p>如果我们面对的是一个非必败态(a,b,c)，要如何变为必败态呢？<br>假设 a &lt; b &lt; c，我们只要将 c 变为a XOR b，即可。因为有如下的运算结果：</p>
<p>a XOR b XOR (a XOR b)=(a XOR a) XOR (b XOR b) = 0 XOR 0 = 0</p>
<p>要将c 变为a XOR b，只要对 c进行 c-(a XOR b)这样的运算即可</p>
<hr>
<p>定义两个状态，分别为N和P，N代表Next-position，可以理解为先手必胜状态，P代表Previous-position，可以理解为后手必胜状态（或为先手必败）<br>N/P两个状态的关系：<br>（1）无法进行局面转移的状态为P；<br>（2）只要有一种转移方式能将局面变为P，则当前状态为N；<br>（3）任何转移方式都只能使局面变为N，则当前状态为P。<br>（1）最后所有石堆中的石子都为0，此时无法再做任何操作，所以此时是P；<br>（2）在还剩一堆的情况下（无论个数，因为可以随意取），把这一堆都取完，留给对方 的肯定是0个石子，也就是P，所以当前肯定是N；<br>（3）还剩下两堆，且每堆个数为1，因为当前必须要取，而当取完后，通过（2）可知， 留给对方的局 面一定是N，所以当前肯定为P。</p>
<hr>
<p>对于Nim游戏的各个石堆（a1,a2,a3……an），当且仅当a1^a2^a3^……^an=0时它为P。</p>
<p>论证还是要根据N/P的三个状态关系来：</p>
<p>（1）无法移动的局面为所有石堆的石子数都为0，0^0^……^0=0，这个很简单；</p>
<p>（2）若当前的局面不为0，即a1^a2^a3^……^an=k，则必定有一个数ai改变ai的值为ai’（或者理解为改变当前某个石堆的状态），能使的a1^a2^a3^……^ai’^……^an=0,证明很简单，通过异或的性质，因为k的二进制最高位（从右往左）为1，可以得出一 定存在某个ai的最高位为1，此时<code>ai&#39;*k&lt;ai</code>，这个也很好理解，当前的最高位由1变为0 ，十进制时ai一定小于ai’。所以，我们可以将<code>ai=ai&#39;*k</code>，此时<code>a1^a2^a3^......^ai&#39;*k ^.......an=0</code>。</p>
<p>（3）若当前某个局面为P，即a1^a2^a3^……^an=0,一定不存在改变某 个ai，使之变为ai’，a1^a2^a3^…….^ai’^……^an=0,因为异或满足消去律，消去后得ai=ai’，由题目可得不能不取，即当前的ai值必须改变，所以此时ai一定不等于ai’。</p>
</blockquote>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;200005;</span><br><span class="line">&#x2F;&#x2F;c1^c2^...^cn&#x3D;k,然后c1^c2^...^cn^k&#x3D;0,那么对那个数执行操作减去（cn-cn^k）,那个数变为cn^k </span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)&#123;</span><br><span class="line">		int sum&#x3D;0,c[N];</span><br><span class="line">		for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;c[i]);</span><br><span class="line">			sum^&#x3D;c[i];</span><br><span class="line">		&#125;</span><br><span class="line">		if(sum&#x3D;&#x3D;0)printf(&quot;No\n&quot;);</span><br><span class="line">		else&#123;</span><br><span class="line">			printf(&quot;Yes\n&quot;);</span><br><span class="line">			for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">				if((c[i]^sum)&lt;c[i])printf(&quot;%d %d\n&quot;,c[i],(c[i]^sum));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 2177 取(2堆)石子游戏（威佐夫博弈）</title>
    <url>/eb18b91b/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2177" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=2177</a></p>
<a id="more"></a>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。如果你胜，你第1次怎样取子? </p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入包含若干行，表示若干种石子的初始情况，其中每一行包含两个非负整数a和b，表示两堆石子的数目，a和b都不大于1,000,000，且a&lt;=b。a=b=0退出。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出也有若干行，如果最后你是败者，则为0，反之，输出1，并输出使你胜的你第1次取石子后剩下的两堆石子的数量x,y,x&lt;=y。如果在任意的一堆中取走石子能胜同时在两堆中同时取走相同数量的石子也能胜，先输出取走相同数量的石子的情况.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 </span><br><span class="line">5 8</span><br><span class="line">4 7</span><br><span class="line">2 2</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">4 7</span><br><span class="line">3 5</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0 0</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><h4 id="威佐夫博弈"><a href="#威佐夫博弈" class="headerlink" title="威佐夫博弈"></a>威佐夫博弈</h4><p>给出一些明显的必败状态(也就是当你面对这些状态时，只要你的对手够聪明，不犯错，无论你怎么拿，你都是必输的)（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）、…… 、（ak，bk） (k = 0, 1, 2, 3,……)。并称这些必败状态为 <strong>“奇异局势”</strong></p>
<p>得到a0=b0=0,ak是未在前面出现过的最小自然数,而 bk= ak + k。然后公式化就得到了奇异局势的状态公式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ak &#x3D; [ k * (1 + √5) &#x2F; 2 ]   ( [x]表示对x取整 )</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bk &#x3D; ak + k</span><br></pre></td></tr></table></figure>

<p>奇异局势有三个性质——</p>
<blockquote>
<p>性质1：每个自然数都包含在且只包含在一个奇异局势中。</p>
</blockquote>
<blockquote>
<p>性质2：对任意的奇异局势，任何合法的操作都会使其成为非奇异局势，也就是奇异局势的所有后继状态均为非奇异局势。</p>
</blockquote>
<blockquote>
<p>性质3：任何非奇异局势都可以通过某种合法操作得到奇异局势，即奇异局势的所有后继状态中存在奇异局势。</p>
</blockquote>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int a,b;</span><br><span class="line">	double x&#x3D;(1+sqrt(5.0))&#x2F;2.0;&#x2F;&#x2F;矩阵黄金分割数 </span><br><span class="line">	while(scanf(&quot;%d%d&quot;,&amp;a,&amp;b)!&#x3D;EOF&amp;&amp;(a+b))&#123;</span><br><span class="line">		if(a&gt;b)&#123;</span><br><span class="line">			int temp&#x3D;a;a&#x3D;b;b&#x3D;temp;</span><br><span class="line">		&#125;</span><br><span class="line">		if((int)((b-a)*x)&#x3D;&#x3D;a)printf(&quot;0\n&quot;);</span><br><span class="line">		else&#123;</span><br><span class="line">			int n,m;</span><br><span class="line">			printf(&quot;1\n&quot;);</span><br><span class="line">			for(int i&#x3D;1;i&lt;&#x3D;a;i++)&#123;&#x2F;&#x2F;一起拿 </span><br><span class="line">				n&#x3D;a-i;</span><br><span class="line">				m&#x3D;b-i;</span><br><span class="line">				if((int)((m-n)*x)&#x3D;&#x3D;n)printf(&quot;%d %d\n&quot;,n,m);</span><br><span class="line">				&#x2F;&#x2F;不用退出循环也可，因为由奇异状态性质，只会有一个i满足 </span><br><span class="line">			&#125;</span><br><span class="line">			for(int i&#x3D;b-1;i&gt;&#x3D;0;i--)&#123;&#x2F;&#x2F;从一个中拿，要从多的那堆中拿！ </span><br><span class="line">				n&#x3D;a;</span><br><span class="line">				m&#x3D;i;</span><br><span class="line">				if(n&gt;m)&#123;</span><br><span class="line">					int temp&#x3D;n;n&#x3D;m;m&#x3D;temp;</span><br><span class="line">				&#125;</span><br><span class="line">				if((int)((m-n)*x)&#x3D;&#x3D;n)printf(&quot;%d %d\n&quot;,n,m);</span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>poj 1704 Georgia and Bob（尼姆博弈，阶梯博弈）</title>
    <url>/e9da39f8/</url>
    <content><![CDATA[<p><a href="http://poj.org/problem?id=1704" target="_blank" rel="noopener">http://poj.org/problem?id=1704</a></p>
<p>Georgia and Bob decide to play a self-invented game. They draw a row of grids on paper, number the grids from left to right by 1, 2, 3, …, and place N chessmen on different grids, as shown in the following figure for example:<br><img src="http://poj.org/images/1704_1.jpg" alt=""></p>
<p>Georgia and Bob move the chessmen in turn. Every time a player will choose a chessman, and move it to the left without going over any other chessmen or across the left edge. The player can freely choose number of steps the chessman moves, with the constraint that the chessman must be moved at least ONE step and one grid can at most contains ONE single chessman. The player who cannot make a move loses the game. </p>
<p>Georgia always plays first since “Lady first”. Suppose that Georgia and Bob both do their best in the game, i.e., if one of them knows a way to win the game, he or she will be able to carry it out. </p>
<p>Given the initial positions of the n chessmen, can you predict who will finally win the game? </p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input contains a single integer T (1 &lt;= T &lt;= 20), the number of test cases. Then T cases follow. Each test case contains two lines. The first line consists of one integer N (1 &lt;= N &lt;= 1000), indicating the number of chessmen. The second line contains N different integers P1, P2 … Pn (1 &lt;= Pi &lt;= 10000), which are the initial positions of the n chessmen.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, prints a single line, “Georgia will win”, if Georgia will win the game; “Bob will win”, if Bob will win the game; otherwise ‘Not sure’.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">8</span><br><span class="line">1 5 6 7 9 12 14 17</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bob will win</span><br><span class="line">Georgia will win</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>从左到右有一排棋子，给出棋子初始位置，每次操作选择一个棋子向左移动，且不能跨过前面的棋子和最左边边缘，一个格子只能放一个棋子，无法移动的输</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>题面一看很玄乎，但是分析分析这其实就是个单单纯纯的尼姆博弈的模型啊</p>
<p>因为每个棋子不能越过前面的棋子，所以其实开始和结束棋子的顺序已经固定了都是一样的，他们最后移动多少步到哪个地方也都是安排好了的，所以最后肯定会变成<code>1...10...0（1表示有棋子，0表示空格）</code>的状态，所以其实就是相当于n堆取石子游戏，没堆的石子数相当于本题里两个棋子之间的距离，也就是后面棋子能直接移动的步数</p>
<p>这时可能会想到一个问题，如果移动后是<code>11100011</code>这样的情况呢？如果是这样的话，后手只要拿着那个跟先手移动的棋同一对棋，学着先手向左移动就好了，次数都一样，所以实际上转化成的石子数只和两个棋子的间隔有关，和具体的位置无关，最后都会在不影响胜负的情况下达到目标态</p>
<p>所以最后的具体写法是，先把棋子位置排序，从大到小两个两个一对，他们之间的间隔（r-l-1）就是每堆的石子数，这里如果最左边多了一个棋子，把它和位置1（即左边缘）凑成一对就可以</p>
<p>然后就是尼姆博弈异或一下没啥好说的啦～</p>
<p>查了一下原来这题有学名叫 <strong>阶梯博弈</strong></p>
<p>先mark一下 <a href="https://blog.csdn.net/a1799342217/article/details/78265265?locationNum=9&fps=1" target="_blank" rel="noopener">阶梯博弈详解</a></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int t,s[1005];</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		int n;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">		for(int i&#x3D;0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;s[i]);</span><br><span class="line">		sort(s,s+n);</span><br><span class="line">		int ans;</span><br><span class="line">		if(n&amp;1)&#123;</span><br><span class="line">			ans&#x3D;s[0]-1;</span><br><span class="line">			for(int i&#x3D;2;i&lt;n;i+&#x3D;2)ans^&#x3D;(s[i]-s[i-1]-1);</span><br><span class="line">			if(ans&#x3D;&#x3D;0)cout&lt;&lt;&quot;Bob will win&quot;&lt;&lt;endl;</span><br><span class="line">			else cout&lt;&lt;&quot;Georgia will win&quot;&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			ans&#x3D;s[1]-s[0]-1;</span><br><span class="line">			for(int i&#x3D;3;i&lt;n;i+&#x3D;2)ans^&#x3D;(s[i]-s[i-1]-1);</span><br><span class="line">			if(ans&#x3D;&#x3D;0)cout&lt;&lt;&quot;Bob will win&quot;&lt;&lt;endl;</span><br><span class="line">			else cout&lt;&lt;&quot;Georgia will win&quot;&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>poj 1740 A New Stone Game（博弈论）</title>
    <url>/16236ee/</url>
    <content><![CDATA[<p><a href="http://poj.org/problem?id=1740" target="_blank" rel="noopener">http://poj.org/problem?id=1740</a></p>
<p>Alice and Bob decide to play a new stone game.At the beginning of the game they pick n(1&lt;=n&lt;=10) piles of stones in a line. Alice and Bob move the stones in turn.<br>At each step of the game,the player choose a pile,remove at least one stones,then freely move stones from this pile to any other pile that still has stones.<br>For example:n=4 and the piles have (3,1,4,2) stones.If the player chose the first pile and remove one.Then it can reach the follow states.<br>2 1 4 2<br>1 2 4 2（move one stone to Pile 2）<br>1 1 5 2（move one stone to Pile 3）<br>1 1 4 3（move one stone to Pile 4）<br>0 2 5 2（move one stone to Pile 2 and another one to Pile 3）<br>0 2 4 3（move one stone to Pile 2 and another one to Pile 4）<br>0 1 5 3（move one stone to Pile 3 and another one to Pile 4）<br>0 3 4 2（move two stones to Pile 2）<br>0 1 6 2（move two stones to Pile 3）<br>0 1 4 4（move two stones to Pile 4）<br>Alice always moves first. Suppose that both Alice and Bob do their best in the game.<br>You are to write a program to determine who will finally win the game. </p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input contains several test cases. The first line of each test case contains an integer number n, denoting the number of piles. The following n integers describe the number of stones in each pile at the beginning of the game, you may assume the number of stones in each pile will not exceed 100.<br>The last test case is followed by one zero. </p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, if Alice win the game,output 1,otherwise output 0. </p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 1 3</span><br><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>有n堆石头，每次操作选择一堆，移除其中至少一块，然后可以取剩下的石子里的任意个移动到别的任意堆，无法操作的输</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>首先当n=1时先手必胜，全部移除就好了</p>
<p>n=2时，若a1=a2，则后手只要模仿先手的操作就可以，先手必败；同理若a1！=a2，则先手把两堆变成相等，然后后手必败</p>
<p>n=3时，先手一次操作把第三堆分给一二堆或丢掉，那么就又变成了之前两堆相等的状态，先手必胜</p>
<p>继续推下去，n=4，由于谁面临三堆就必胜，所以双方都想让对方取了那个第四堆然后自己面对三堆状态，而只有在四堆都是1的时候，才会不得不去取第四堆</p>
<p>经过上面分析，先手有极大优势，先手必败的情况只有这种： <strong>后手一直学先手的操作，而一开始注定了总操作数为偶，刚好让先手无路可走</strong> </p>
<p>这种情况对应的状态为：石头堆数为偶数，且有n/2对一样的数</p>
<p>判断n/2对是否相等只要排序再比较就可以</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)&#123;</span><br><span class="line">		int c[15];</span><br><span class="line">		for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;c[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		if(n&amp;1)&#123;</span><br><span class="line">			printf(&quot;1\n&quot;);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			sort(c,c+n);</span><br><span class="line">			int flag&#x3D;0;</span><br><span class="line">			for(int i&#x3D;0;i&lt;n-1;i+&#x3D;2)&#123;</span><br><span class="line">				if(c[i]!&#x3D;c[i+1])&#123;</span><br><span class="line">					flag&#x3D;1;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if(flag&#x3D;&#x3D;0)printf(&quot;0\n&quot;);</span><br><span class="line">			else printf(&quot;1\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>ACM-ICPC 2015 Changchun Preliminary Contest -- Ponds（拓扑排序）</title>
    <url>/944a2722/</url>
    <content><![CDATA[<p><a href="https://nanti.jisuanke.com/t/29329" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/29329</a></p>
<p>Betty owns a lot of ponds, some of them are connected with other ponds by pipes, and there will not be more than one pipe between two ponds. Each pond has a value v.</p>
<p>Now Betty wants to remove some ponds because she does not have enough money. But each time when she removes a pond, she can only remove the ponds which are connected with less than two ponds, or the pond will explode.</p>
<p>Note that Betty should keep removing ponds until no more ponds can be removed. After that, please help her calculate the sum of the value for each connected component consisting of a odd number of ponds</p>
<h3 id="Input-Format"><a href="#Input-Format" class="headerlink" title="Input Format"></a>Input Format</h3><p>The first line of input will contain a number T(1≤T≤30) which is the number of test cases.</p>
<p>For each test case, the first line contains two number separated by a blank. One is the number p(1≤p≤10^4) which represents the number of ponds she owns, and the other is the number m(1≤m≤10^5) which represents the number of pipes.</p>
<p>The next line contains p numbers v1，···，vp, where vi(1≤vi≤10^8) indicating the value of pond i.</p>
<p>Each of the last m lines contain two numbers a and b, which indicates that pond a and pond b are connected by a pipe.</p>
<h3 id="Output-Format"><a href="#Output-Format" class="headerlink" title="Output Format"></a>Output Format</h3><p>For each test case, output the sum of the value of all connected components consisting of odd number of ponds after removing all the ponds connected with less than two pipes.</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">7 7</span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line">1 4</span><br><span class="line">1 5</span><br><span class="line">4 5</span><br><span class="line">2 3</span><br><span class="line">2 6</span><br><span class="line">3 6</span><br><span class="line">2 7</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure>
<h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p>ACM-ICPC 2015 Changchun Preliminary Contest</p>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给一个无向图，池塘之间有管道相连，每个池塘有一个权值，现在要拆掉所有度数小于2的池塘，直至不能拆为止，最后求连通个数为奇数的池塘的权值和</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>删除一个度数为1的结点之后，这个点的边所通向的点的度数也要减一，就可能产生新的度数小于2的点，有点拓扑排序的意思，出现度数小于2的点就存入q，直到q为空，按照题意写就行</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">const int N&#x3D;1000005;</span><br><span class="line">int d[N],w[N],u[N],v[N],sum[N];</span><br><span class="line">LL ans;</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt;tu;</span><br><span class="line">bool vis[N];</span><br><span class="line">int fa[N];</span><br><span class="line">void init(int x)&#123;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;x;i++)fa[i]&#x3D;i;</span><br><span class="line">	memset(d,0,sizeof(d));</span><br><span class="line">	memset(vis,false,sizeof(vis));</span><br><span class="line">	memset(sum,0,sizeof(sum));</span><br><span class="line">	tu.resize(x+1);</span><br><span class="line">	tu.clear();</span><br><span class="line">&#125;</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">    int tmp&#x3D;x;</span><br><span class="line">    while(fa[tmp]!&#x3D;tmp)tmp&#x3D;fa[tmp]; </span><br><span class="line">    fa[x]&#x3D;tmp;</span><br><span class="line">    return tmp;</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">    if(find(x)!&#x3D;find(y))fa[find(x)]&#x3D;fa[find(y)];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int t,n,m;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		ans&#x3D;0;</span><br><span class="line">		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">		init(n);</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;n;i++)scanf(&quot;%d&quot;,&amp;w[i]);</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;,&amp;u[i],&amp;v[i]);</span><br><span class="line">			d[u[i]]++;d[v[i]]++;</span><br><span class="line">			tu[u[i]].push_back(v[i]);</span><br><span class="line">			tu[v[i]].push_back(u[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		queue&lt;int&gt;q;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">			if(d[i]&lt;&#x3D;1)&#123;</span><br><span class="line">				vis[i]&#x3D;true;</span><br><span class="line">				q.push(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		while(!q.empty())&#123;</span><br><span class="line">			int tmp&#x3D;q.front();</span><br><span class="line">			q.pop();</span><br><span class="line">			for(int i&#x3D;0;i&lt;tu[tmp].size();i++)&#123;</span><br><span class="line">				int nod&#x3D;tu[tmp][i];</span><br><span class="line">				d[nod]--;</span><br><span class="line">				if(d[nod]&lt;&#x3D;1&amp;&amp;vis[nod]&#x3D;&#x3D;false)&#123;</span><br><span class="line">					vis[nod]&#x3D;true;</span><br><span class="line">					q.push(nod);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">			if(vis[u[i]]&#x3D;&#x3D;false&amp;&amp;vis[v[i]]&#x3D;&#x3D;false)join(u[i],v[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">			if(vis[i]&#x3D;&#x3D;false)sum[find(i)]++;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">			if(vis[i]&#x3D;&#x3D;false&amp;&amp;sum[find(i)]&amp;1)ans+&#x3D;w[i];</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%lld\n&quot;,ans);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>Minimum Cut（读题。。）</title>
    <url>/15c1232b/</url>
    <content><![CDATA[<p><a href="https://nanti.jisuanke.com/t/29122" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/29122</a></p>
<p>Given a simple unweighted graph GG (an undirected graph containing no loops nor multiple edges) with nn nodes and mm edges. Let T be a spanning tree of G. We say that a cut in G respects T if it cuts just one edges of T.</p>
<p>Since love needs good faith and hypocrisy return for only grief, you should find the minimum cut of graph G respecting the given spanning tree T.</p>
<h3 id="Input-Format"><a href="#Input-Format" class="headerlink" title="Input Format"></a>Input Format</h3><p>The input contains several test cases.</p>
<p>The first line of the input is a single integer t(1≤t≤5) which is the number of test cases. Then tt test cases follow.</p>
<p>Each test case contains several lines. The first line contains two integers n(2≤n≤20000) and m(n−1≤m≤200000). The following n-1n−1 lines describe the spanning tree T and each of them contains two integers uu and v corresponding to an edge. Next m−n+1 lines describe the undirected graph G and each of them contains two integers u and v corresponding to an edge which is not in the spanning tree T.</p>
<p>Output Format<br>For each test case, you should output the minimum cut of graph G respecting the given spanning tree T.</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case #1: 2</span><br></pre></td></tr></table></figure>
<h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p>ACM-ICPC 2015 Shenyang Preliminary Contest</p>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>先给一棵生成树，再在此基础上给图，删去树的一个边和图一些边使图不连通，求删去的最少边数</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>题目不难 读懂了就很水 但是真的是读了好久。。</p>
<p>要使图不连通且只能删树的一个边，就要找树上度数为1的点，然后加上图中和这个点相连的边，求最小的即可</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long </span><br><span class="line">const int N&#x3D;20005;</span><br><span class="line">const int INF&#x3D;0x3f3f3f3f;</span><br><span class="line">int d1[N],d2[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">	int t;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;t;i++)&#123;</span><br><span class="line">		int n,m,ans&#x3D;INF;</span><br><span class="line">		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">		memset(d1,0,sizeof(d1));</span><br><span class="line">		memset(d2,0,sizeof(d2));</span><br><span class="line">		int u,v;</span><br><span class="line">		for(int i&#x3D;0;i&lt;n-1;i++)&#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">			d1[u]++;d1[v]++;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i&#x3D;n-1;i&lt;m;i++)&#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">			d2[u]++;d2[v]++;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">			if(d1[i]&#x3D;&#x3D;1)ans&#x3D;min(ans,1+d2[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;Case #%d: %d\n&quot;,i,ans);</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 3371 Connect the Cities（最小生成树）</title>
    <url>/70032e53/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3371" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=3371</a></p>
<a id="more"></a>

<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>In 2100, since the sea level rise, most of the cities disappear. Though some survived cities are still connected with others, but most of them become disconnected. The government wants to build some roads to connect all of these cities again, but they don’t want to take too much money.  </p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains the number of test cases.<br>Each test case starts with three integers: n, m and k. n (3 &lt;= n &lt;=500) stands for the number of survived cities, m (0 &lt;= m &lt;= 25000) stands for the number of roads you can choose to connect the cities and k (0 &lt;= k &lt;= 100) stands for the number of still connected cities.</p>
<p>To make it easy, the cities are signed from 1 to n.<br>Then follow m lines, each contains three integers p, q and c (0 &lt;= c &lt;= 1000), means it takes c to connect p and q.</p>
<p>Then follow k lines, each line starts with an integer t (2 &lt;= t &lt;= n) stands for the number of this connected cities. Then t integers follow stands for the id of these cities.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each case, output the least money you need to take, if it’s impossible, just output -1.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">6 4 3</span><br><span class="line">1 4 2</span><br><span class="line">2 6 1</span><br><span class="line">2 3 5</span><br><span class="line">3 4 33</span><br><span class="line">2 1 2</span><br><span class="line">2 1 3</span><br><span class="line">3 4 5 6</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>最小生成树</p>
<p>当时tle无数次 最后同一段代码看人品卡过去。。？什么操作？？</p>
<p>现在测了两次都是748ms</p>
<p>最后求gen的时候不要find(i)==i，直接fa[i]==i<br>k个那段读入的时候用while(num–)，或许真的while比for快一点？？</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;505;</span><br><span class="line">struct Edge&#123;</span><br><span class="line">	int u,v;</span><br><span class="line">	double cap;</span><br><span class="line">&#125;Edge[N*N];&#x2F;&#x2F;边集 </span><br><span class="line">int m,ans; </span><br><span class="line">int fa[N];</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">	if(x!&#x3D;fa[x])fa[x]&#x3D;find(fa[x]);</span><br><span class="line">	return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">	int a&#x3D;find(x),b&#x3D;find(y);</span><br><span class="line">	if(a&#x3D;&#x3D;b)return;</span><br><span class="line">	else&#123;</span><br><span class="line">		fa[a]&#x3D;b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">bool cmp(struct Edge a,struct Edge b)&#123;</span><br><span class="line">	return a.cap&lt;b.cap;</span><br><span class="line">&#125;</span><br><span class="line">void kruskal()&#123;</span><br><span class="line">	sort(Edge+1,Edge+m+1,cmp);&#x2F;&#x2F;按边的最小代价排序 </span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">		int fx&#x3D;find(Edge[i].u),fy&#x3D;find(Edge[i].v);</span><br><span class="line">		if(fx&#x3D;&#x3D;fy)continue;</span><br><span class="line">		ans+&#x3D;Edge[i].cap;&#x2F;&#x2F;u，v不在一棵树上，就加上这条边 </span><br><span class="line">		join(fx,fy);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int t;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		int n,k;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;n;i++)fa[i]&#x3D;i;;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">			int p,q,c;</span><br><span class="line">			scanf(&quot;%d%d%d&quot;,&amp;p,&amp;q,&amp;c);</span><br><span class="line">			Edge[i].u&#x3D;p;</span><br><span class="line">			Edge[i].v&#x3D;q;</span><br><span class="line">			Edge[i].cap&#x3D;c;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;k;i++)&#123;</span><br><span class="line">			int num,a,tmp;</span><br><span class="line">			scanf(&quot;%d%d&quot;,&amp;num,&amp;a);</span><br><span class="line">			num--;tmp&#x3D;a;</span><br><span class="line">			while(num--)&#123;</span><br><span class="line">				scanf(&quot;%d&quot;,&amp;a);</span><br><span class="line">				if(fa[tmp]!&#x3D;fa[a])join(tmp,a);</span><br><span class="line">				tmp&#x3D;a;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans&#x3D;0;</span><br><span class="line">		kruskal();</span><br><span class="line">		int gen&#x3D;0;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">			if(fa[i]&#x3D;&#x3D;i)&#123;</span><br><span class="line">				gen++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(gen&#x3D;&#x3D;1)printf(&quot;%d\n&quot;,ans);</span><br><span class="line">		else printf(&quot;-1\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1879 继续畅通工程（最小生成树）</title>
    <url>/340b38ab/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1879" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1879</a></p>
<a id="more"></a>

<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可）。现得到城镇道路统计表，表中列出了任意两城镇间修建道路的费用，以及该道路是否已经修通的状态。现请你编写程序，计算出全省畅通需要的最低成本。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>测试输入包含若干测试用例。每个测试用例的第1行给出村庄数目N ( 1&lt; N &lt; 100 )；随后的 N(N-1)/2 行对应村庄间道路的成本及修建状态，每行给4个正整数，分别是两个村庄的编号（从1编号到N），此两村庄间道路的成本，以及修建状态：1表示已建，0表示未建。</p>
<p>当N为0时输入结束。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>每个测试用例的输出占一行，输出全省畅通需要的最低成本。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 1 0</span><br><span class="line">1 3 2 0</span><br><span class="line">2 3 4 0</span><br><span class="line">3</span><br><span class="line">1 2 1 0</span><br><span class="line">1 3 2 0</span><br><span class="line">2 3 4 1</span><br><span class="line">3</span><br><span class="line">1 2 1 0</span><br><span class="line">1 3 2 1</span><br><span class="line">2 3 4 1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>给出一些有的和没有的边</p>
<p>有的边直接join 没有的加入边集 跑一遍kruskal</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;105;</span><br><span class="line">struct Edge&#123;</span><br><span class="line">	int u,v;</span><br><span class="line">	double cap;</span><br><span class="line">&#125;Edge[N*N];&#x2F;&#x2F;边集 </span><br><span class="line">int n,num,cnt,ans; </span><br><span class="line">int fa[N];</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">	if(x!&#x3D;fa[x])fa[x]&#x3D;find(fa[x]);</span><br><span class="line">	return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">	int a&#x3D;find(x),b&#x3D;find(y);</span><br><span class="line">	if(a&#x3D;&#x3D;b)return;</span><br><span class="line">	else&#123;</span><br><span class="line">		fa[a]&#x3D;b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">bool cmp(struct Edge a,struct Edge b)&#123;</span><br><span class="line">	return a.cap&lt;b.cap;</span><br><span class="line">&#125;</span><br><span class="line">void kruskal()&#123;</span><br><span class="line">	sort(Edge+1,Edge+cnt,cmp);&#x2F;&#x2F;按边的最小代价排序 </span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;cnt-1;i++)&#123;</span><br><span class="line">		int fx&#x3D;find(Edge[i].u),fy&#x3D;find(Edge[i].v);</span><br><span class="line">		if(fx&#x3D;&#x3D;fy)continue;</span><br><span class="line">		ans+&#x3D;Edge[i].cap;&#x2F;&#x2F;u，v不在一棵树上，就加上这条边 </span><br><span class="line">		join(fx,fy);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	while(scanf(&quot;%d&quot;,&amp;n))&#123;</span><br><span class="line">		if(n&#x3D;&#x3D;0)break;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;n;i++)fa[i]&#x3D;i;</span><br><span class="line">		num&#x3D;n*(n-1)&#x2F;2;</span><br><span class="line">		cnt&#x3D;1;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;num;i++)&#123;</span><br><span class="line">			int a,b,c,d;</span><br><span class="line">			scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line">			if(d&#x3D;&#x3D;0)&#123;</span><br><span class="line">				Edge[cnt].u&#x3D;a;</span><br><span class="line">				Edge[cnt].v&#x3D;b;</span><br><span class="line">				Edge[cnt].cap&#x3D;c;</span><br><span class="line">				cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">			else if(d&#x3D;&#x3D;1)&#123;</span><br><span class="line">				join(a,b);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans&#x3D;0;</span><br><span class="line">		kruskal();</span><br><span class="line">		printf(&quot;%d\n&quot;,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1875 畅通工程再续（最小生成树）</title>
    <url>/5c944241/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1875" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1875</a></p>
<a id="more"></a>


<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>相信大家都听说一个“百岛湖”的地方吧，百岛湖的居民生活在不同的小岛中，当他们想去其他的小岛时都要通过划小船来实现。现在政府决定大力发展百岛湖，发展首先要解决的问题当然是交通问题，政府决定实现百岛湖的全畅通！经过考察小组RPRush对百岛湖的情况充分了解后，决定在符合条件的小岛间建上桥，所谓符合条件，就是2个小岛之间的距离不能小于10米，也不能大于1000米。当然，为了节省资金，只要求实现任意2个小岛之间有路通即可。其中桥的价格为 100元/米。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入包括多组数据。输入首先包括一个整数T(T &lt;= 200)，代表有T组数据。<br>每组数据首先是一个整数C(C &lt;= 100),代表小岛的个数，接下来是C组坐标，代表每个小岛的坐标，这些坐标都是 0 &lt;= x, y &lt;= 1000的整数。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>每组输入数据输出一行，代表建桥的最小花费，结果保留一位小数。如果无法实现工程以达到全部畅通，输出”oh!”.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">10 10</span><br><span class="line">20 20</span><br><span class="line">3</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">1000 1000</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1414.2</span><br><span class="line">oh!</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>最小生成树 加了边的限制 只要在加边前判断一下边长是否合法就行</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;105;</span><br><span class="line">struct Edge&#123;</span><br><span class="line">	int u,v;</span><br><span class="line">	double cap;</span><br><span class="line">&#125;Edge[N*N];&#x2F;&#x2F;边集 </span><br><span class="line">struct Node&#123;</span><br><span class="line">	int x,y;</span><br><span class="line">&#125;Node[N];&#x2F;&#x2F;点集 </span><br><span class="line">int n,num,ed,cnt;</span><br><span class="line">double ans; </span><br><span class="line">int fa[N];</span><br><span class="line">double distance_(int a,int b)&#123;</span><br><span class="line">	return sqrt((Node[a].x-Node[b].x)*(Node[a].x-Node[b].x)+(Node[a].y-Node[b].y)*(Node[a].y-Node[b].y));</span><br><span class="line">&#125;</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">	if(x!&#x3D;fa[x])fa[x]&#x3D;find(fa[x]);</span><br><span class="line">	return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">	int a&#x3D;find(x),b&#x3D;find(y);</span><br><span class="line">	if(a&#x3D;&#x3D;b)return;</span><br><span class="line">	else&#123;</span><br><span class="line">		fa[a]&#x3D;b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">bool cmp(struct Edge a,struct Edge b)&#123;</span><br><span class="line">	return a.cap&lt;b.cap;</span><br><span class="line">&#125;</span><br><span class="line">void kruskal()&#123;</span><br><span class="line">	sort(Edge,Edge+cnt,cmp);&#x2F;&#x2F;按边的最小代价排序 </span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;cnt-1;i++)&#123;</span><br><span class="line">		int fx&#x3D;find(Edge[i].u),fy&#x3D;find(Edge[i].v);</span><br><span class="line">		if(fx&#x3D;&#x3D;fy)continue;</span><br><span class="line">		ans+&#x3D;Edge[i].cap;&#x2F;&#x2F;u，v不在一棵树上，就加上这条边 </span><br><span class="line">		join(fx,fy);</span><br><span class="line">		ed++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int t;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">	while(t--)&#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;,&amp;Node[i].x,&amp;Node[i].y);</span><br><span class="line">			fa[i]&#x3D;i;</span><br><span class="line">		&#125;</span><br><span class="line">		cnt&#x3D;1;</span><br><span class="line">		ed&#x3D;0;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;n-1;i++)&#123;</span><br><span class="line">			for(int j&#x3D;i+1;j&lt;&#x3D;n;j++)&#123;</span><br><span class="line">				if(distance_(i,j)&gt;&#x3D;10.0&amp;&amp;distance_(i,j)&lt;&#x3D;1000.0)&#123;&#x2F;&#x2F;生成边集的时候就把不要的排除了</span><br><span class="line">					Edge[cnt].u&#x3D;i;</span><br><span class="line">					Edge[cnt].v&#x3D;j;</span><br><span class="line">					Edge[cnt].cap&#x3D;distance_(i,j); </span><br><span class="line">					cnt++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans&#x3D;0;</span><br><span class="line">		kruskal();</span><br><span class="line">		if(ed&#x3D;&#x3D;n-1)printf(&quot;%.1f\n&quot;,ans*100);</span><br><span class="line">		else printf(&quot;oh!\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1863 畅通工程（最小生成树）</title>
    <url>/f9161795/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1863" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1863</a></p>
<a id="more"></a>

<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可）。经过调查评估，得到的统计表中列出了有可能建设公路的若干条道路的成本。现请你编写程序，计算出全省畅通需要的最低成本。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>测试输入包含若干测试用例。每个测试用例的第1行给出评估的道路条数 N、村庄数目M ( &lt; 100 )；随后的 N<br>行对应村庄间道路的成本，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间道路的成本（也是正整数）。为简单起见，村庄从1到M编号。当N为0时，全部输入结束，相应的结果不要输出。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对每个测试用例，在1行里输出全省畅通需要的最低成本。若统计数据不足以保证畅通，则输出“?”。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 1</span><br><span class="line">1 3 2</span><br><span class="line">2 3 4</span><br><span class="line">1 3</span><br><span class="line">2 3 2</span><br><span class="line">0 100</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">?</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>给出边 求最小生成树 </p>
<p>如果无法连通 输出“?”</p>
<p>因为要判断最后是否连通 所以用kruskal 最后只要先记录一个点的父亲 然后判断剩余点是否全部和它相同即可</p>
<p>不满足连通条件的情况：</p>
<ul>
<li>（点&lt;=边+1）的不行</li>
<li>最后所有结点不在一个根的不行</li>
</ul>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;105;</span><br><span class="line">struct Edge&#123;</span><br><span class="line">	int u,v;</span><br><span class="line">	int cap;</span><br><span class="line">&#125;Edge[N*N];&#x2F;&#x2F;边集 </span><br><span class="line">int n,ans,num; </span><br><span class="line">int fa[N];</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">	if(x!&#x3D;fa[x])fa[x]&#x3D;find(fa[x]);</span><br><span class="line">	return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">	int a&#x3D;find(x),b&#x3D;find(y);</span><br><span class="line">	if(a&#x3D;&#x3D;b)return;</span><br><span class="line">	else&#123;</span><br><span class="line">		fa[a]&#x3D;b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">bool cmp(struct Edge a,struct Edge b)&#123;</span><br><span class="line">	return a.cap&lt;b.cap;</span><br><span class="line">&#125;</span><br><span class="line">void kruskal()&#123;</span><br><span class="line">	sort(Edge,Edge+num,cmp);&#x2F;&#x2F;按边的最小代价排序 </span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;num;i++)&#123;</span><br><span class="line">		int fx&#x3D;find(Edge[i].u),fy&#x3D;find(Edge[i].v);</span><br><span class="line">		if(fx&#x3D;&#x3D;fy)continue;</span><br><span class="line">		ans+&#x3D;Edge[i].cap;&#x2F;&#x2F;u，v不在一棵树上，就加上这条边 </span><br><span class="line">		join(fx,fy);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	while(scanf(&quot;%d%d&quot;,&amp;num,&amp;n)!&#x3D;EOF)&#123;</span><br><span class="line">		if(num&#x3D;&#x3D;0)&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">			fa[i]&#x3D;i;</span><br><span class="line">		&#125;</span><br><span class="line">		int p,q,w;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;num;i++)&#123;</span><br><span class="line">			scanf(&quot;%d%d%d&quot;,&amp;p,&amp;q,&amp;w);</span><br><span class="line">			Edge[i].u&#x3D;p;</span><br><span class="line">			Edge[i].v&#x3D;q;</span><br><span class="line">			Edge[i].cap&#x3D;w;</span><br><span class="line">		&#125;</span><br><span class="line">		ans&#x3D;0;</span><br><span class="line">		kruskal();</span><br><span class="line">		int flag&#x3D;1;</span><br><span class="line">		for(int i&#x3D;2;i&lt;&#x3D;num;i++)&#123;</span><br><span class="line">			if(find(i)!&#x3D;find(1))&#123;</span><br><span class="line">				flag&#x3D;0;break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		if(num&lt;n-1)printf(&quot;?\n&quot;);</span><br><span class="line">		else if(flag&#x3D;&#x3D;1)printf(&quot;%d\n&quot;,ans);</span><br><span class="line">		else printf(&quot;?\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1301 Jungle Roads（最小生成树）</title>
    <url>/b01398e8/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1301" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1301</a></p>
<a id="more"></a>

<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kjfd8hfvj20eq09qjsb.jpg" alt=""></p>
<p>The Head Elder of the tropical island of Lagrishan has a problem. A burst of foreign aid money was spent on extra roads between villages some years ago. But the jungle overtakes roads relentlessly, so the large road network is too expensive to maintain. The Council of Elders must choose to stop maintaining some roads. The map above on the left shows all the roads in use now and the cost in aacms per month to maintain them. Of course there needs to be some way to get between all the villages on maintained roads, even if the route is not as short as before. The Chief Elder would like to tell the Council of Elders what would be the smallest amount they could spend in aacms per month to maintain roads that would connect all the villages. The villages are labeled A through I in the maps above. The map on the right shows the roads that could be maintained most cheaply, for 216 aacms per month. Your task is to write a program that will solve such problems. </p>
<p>The input consists of one to 100 data sets, followed by a final line containing only 0. Each data set starts with a line containing only a number n, which is the number of villages, 1 &lt; n &lt; 27, and the villages are labeled with the first n letters of the alphabet, capitalized. Each data set is completed with n-1 lines that start with village labels in alphabetical order. There is no line for the last village. Each line for a village starts with the village label followed by a number, k, of roads from this village to villages with labels later in the alphabet. If k is greater than 0, the line continues with data for each of the k roads. The data for each road is the village label for the other end of the road followed by the monthly maintenance cost in aacms for the road. Maintenance costs will be positive integers less than 100. All data fields in the row are separated by single blanks. The road network will always allow travel between all the villages. The network will never have more than 75 roads. No village will have more than 15 roads going to other villages (before or after in the alphabet). In the sample input below, the first data set goes with the map above. </p>
<p>The output is one integer per line for each data set: the minimum cost in aacms per month to maintain a road system that connect all the villages. Caution: A brute force solution that examines every possible set of roads will not finish within the one minute time limit. </p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">A 2 B 12 I 25</span><br><span class="line">B 3 C 10 H 40 I 8</span><br><span class="line">C 2 D 18 G 55</span><br><span class="line">D 1 E 44</span><br><span class="line">E 2 F 60 G 38</span><br><span class="line">F 0</span><br><span class="line">G 1 H 35</span><br><span class="line">H 1 I 35</span><br><span class="line">3</span><br><span class="line">A 2 B 10 C 40</span><br><span class="line">B 1 C 20</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">216</span><br><span class="line">30</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>一看图就是个最小生成树。。</p>
<p>注意回车要用getchar()搞掉</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;30;</span><br><span class="line">struct Edge&#123;</span><br><span class="line">	int u,v;</span><br><span class="line">	double cap;</span><br><span class="line">&#125;Edge[N*N];</span><br><span class="line">int n,ans,cnt; </span><br><span class="line">int fa[N];</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">	if(x!&#x3D;fa[x])fa[x]&#x3D;find(fa[x]);</span><br><span class="line">	return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">	int a&#x3D;find(x),b&#x3D;find(y);</span><br><span class="line">	if(a&#x3D;&#x3D;b)return;</span><br><span class="line">	else&#123;</span><br><span class="line">		fa[a]&#x3D;b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">bool cmp(struct Edge a,struct Edge b)&#123;</span><br><span class="line">	return a.cap&lt;b.cap;</span><br><span class="line">&#125;</span><br><span class="line">void kruskal()&#123;</span><br><span class="line">	sort(Edge,Edge+cnt,cmp);</span><br><span class="line">	for(int i&#x3D;0;i&lt;cnt;i++)&#123;</span><br><span class="line">		int fx&#x3D;find(Edge[i].u),fy&#x3D;find(Edge[i].v);</span><br><span class="line">		if(fx&#x3D;&#x3D;fy)continue;</span><br><span class="line">		ans+&#x3D;Edge[i].cap;</span><br><span class="line">		join(fx,fy);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	while(scanf(&quot;%d&quot;,&amp;n)!&#x3D;EOF)&#123;</span><br><span class="line">		if(n&#x3D;&#x3D;0)break;</span><br><span class="line">		for(int i&#x3D;1;i&lt;N;i++)fa[i]&#x3D;i;</span><br><span class="line">		cnt&#x3D;0;</span><br><span class="line">		for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">			char x,y;</span><br><span class="line">			int xnum,c;</span><br><span class="line">			getchar();</span><br><span class="line">			scanf(&quot;%c %d&quot;,&amp;x,&amp;xnum);</span><br><span class="line">			while(xnum--)&#123;</span><br><span class="line">				getchar();</span><br><span class="line">				scanf(&quot;%c %d&quot;,&amp;y,&amp;c);</span><br><span class="line">				Edge[cnt].u&#x3D;(int)(x-&#39;A&#39;+1);</span><br><span class="line">				Edge[cnt].v&#x3D;(int)(y-&#39;A&#39;+1);</span><br><span class="line">				Edge[cnt].cap&#x3D;c;</span><br><span class="line">				cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans&#x3D;0;</span><br><span class="line">		kruskal();</span><br><span class="line">		printf(&quot;%d\n&quot;,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1233 还是畅通工程（最小生成树）</title>
    <url>/d655b5fc/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1233" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1233</a></p>
<a id="more"></a>

<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>某省调查乡村交通状况，得到的统计表中列出了任意两村庄间的距离。省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可），并要求铺设的公路总长度为最小。请计算最小的公路总长度。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>测试输入包含若干测试用例。每个测试用例的第1行给出村庄数目N ( &lt; 100 )；随后的N(N-1)/2行对应村庄间的距离，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间的距离。为简单起见，村庄从1到N编号。<br>当N为0时，输入结束，该用例不被处理。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对每个测试用例，在1行里输出最小的公路总长度。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 1</span><br><span class="line">1 3 2</span><br><span class="line">2 3 4</span><br><span class="line">4</span><br><span class="line">1 2 1</span><br><span class="line">1 3 4</span><br><span class="line">1 4 1</span><br><span class="line">2 3 3</span><br><span class="line">2 4 2</span><br><span class="line">3 4 5</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>最小生成树 写的Kruskal</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;105;</span><br><span class="line">struct Edge&#123;</span><br><span class="line">	int u,v;</span><br><span class="line">	int cap;</span><br><span class="line">&#125;Edge[N*N];&#x2F;&#x2F;边集 </span><br><span class="line">int n,ans,num; </span><br><span class="line">int fa[N];</span><br><span class="line">void init()&#123;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		fa[i]&#x3D;i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">	if(x!&#x3D;fa[x])fa[x]&#x3D;find(fa[x]);</span><br><span class="line">	return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">	int a&#x3D;find(x),b&#x3D;find(y);</span><br><span class="line">	if(a&#x3D;&#x3D;b)return;</span><br><span class="line">	else&#123;</span><br><span class="line">		fa[a]&#x3D;b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">bool cmp(struct Edge a,struct Edge b)&#123;</span><br><span class="line">	return a.cap&lt;b.cap;</span><br><span class="line">&#125;</span><br><span class="line">void kruskal()&#123;</span><br><span class="line">	sort(Edge,Edge+num,cmp);&#x2F;&#x2F;按边的最小代价排序 </span><br><span class="line">	for(int i&#x3D;0;i&lt;num;i++)&#123;</span><br><span class="line">		int fx&#x3D;find(Edge[i].u),fy&#x3D;find(Edge[i].v);</span><br><span class="line">		if(fx&#x3D;&#x3D;fy)continue;</span><br><span class="line">		ans+&#x3D;Edge[i].cap;&#x2F;&#x2F;u，v不在一棵树上，就加上这条边 </span><br><span class="line">		join(fx,fy);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	while(scanf(&quot;%d&quot;,&amp;n)!&#x3D;EOF&amp;&amp;n)&#123;</span><br><span class="line">		num&#x3D;n*(n-1)&#x2F;2;</span><br><span class="line">		init();</span><br><span class="line">		int p,q,w;</span><br><span class="line">		for(int i&#x3D;0;i&lt;num;i++)&#123;</span><br><span class="line">			scanf(&quot;%d%d%d&quot;,&amp;p,&amp;q,&amp;w);</span><br><span class="line">			Edge[i].u&#x3D;p;</span><br><span class="line">			Edge[i].v&#x3D;q;</span><br><span class="line">			Edge[i].cap&#x3D;w;</span><br><span class="line">		&#125;</span><br><span class="line">		ans&#x3D;0;</span><br><span class="line">		kruskal();</span><br><span class="line">		printf(&quot;%d\n&quot;,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1162 Eddy&#39;s picture（最小生成树）</title>
    <url>/438d787/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1162" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1162</a></p>
<a id="more"></a>


<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Eddy begins to like painting pictures recently ,he is sure of himself to become a painter.Every day Eddy draws pictures in his small room, and he usually puts out his newest pictures to let his friends appreciate. but the result it can be imagined, the friends are not interested in his picture.Eddy feels very puzzled,in order to change all friends ‘s view to his technical of painting pictures ,so Eddy creates a problem for the his friends of you.<br>Problem descriptions as follows: Given you some coordinates pionts on a drawing paper, every point links with the ink with the straight line, causes all points finally to link in the same place. How many distants does your duty discover the shortest length which the ink draws?</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains 0 &lt; n &lt;= 100, the number of point. For each point, a line follows; each following line contains two real numbers indicating the (x,y) coordinates of the point. </p>
<p>Input contains multiple test cases. Process to the end of file.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Your program prints a single real number to two decimal places: the minimum total length of ink lines that can connect all the points. </p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1.0 1.0</span><br><span class="line">2.0 2.0</span><br><span class="line">2.0 4.0</span><br></pre></td></tr></table></figure>


<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.41</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给n个点的坐标 求最小生成树</p>
<p>只要预处理一下边长就没别的了</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;105;</span><br><span class="line">struct Edge&#123;</span><br><span class="line">	int u,v;</span><br><span class="line">	double cap;</span><br><span class="line">&#125;Edge[N*N];</span><br><span class="line">struct Node&#123;</span><br><span class="line">	float x,y;</span><br><span class="line">&#125;Node[N];</span><br><span class="line">int n,num,cnt;</span><br><span class="line">double ans; </span><br><span class="line">int fa[N];</span><br><span class="line">double distance_(int a,int b)&#123;</span><br><span class="line">	return sqrt((Node[a].x-Node[b].x)*(Node[a].x-Node[b].x)+(Node[a].y-Node[b].y)*(Node[a].y-Node[b].y));</span><br><span class="line">&#125;</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">	if(x!&#x3D;fa[x])fa[x]&#x3D;find(fa[x]);</span><br><span class="line">	return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">	int a&#x3D;find(x),b&#x3D;find(y);</span><br><span class="line">	if(a&#x3D;&#x3D;b)return;</span><br><span class="line">	else&#123;</span><br><span class="line">		fa[a]&#x3D;b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">bool cmp(struct Edge a,struct Edge b)&#123;</span><br><span class="line">	return a.cap&lt;b.cap;</span><br><span class="line">&#125;</span><br><span class="line">void kruskal()&#123;</span><br><span class="line">	sort(Edge,Edge+num+1,cmp);</span><br><span class="line">	for(int i&#x3D;0;i&lt;&#x3D;num;i++)&#123;</span><br><span class="line">		int fx&#x3D;find(Edge[i].u),fy&#x3D;find(Edge[i].v);</span><br><span class="line">		if(fx&#x3D;&#x3D;fy)continue;</span><br><span class="line">		ans+&#x3D;Edge[i].cap;</span><br><span class="line">		join(fx,fy);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	while(scanf(&quot;%d&quot;,&amp;n)!&#x3D;EOF)&#123;</span><br><span class="line">		if(n&#x3D;&#x3D;0)&#123;</span><br><span class="line">			printf(&quot;0\n&quot;);</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">			scanf(&quot;%f%f&quot;,&amp;Node[i].x,&amp;Node[i].y);</span><br><span class="line">			fa[i]&#x3D;i;</span><br><span class="line">		&#125;</span><br><span class="line">		cnt&#x3D;0;</span><br><span class="line">		num&#x3D;n*(n-1)&#x2F;2;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;n-1;i++)&#123;</span><br><span class="line">			for(int j&#x3D;i+1;j&lt;&#x3D;n;j++)&#123;</span><br><span class="line">				Edge[cnt].u&#x3D;i;</span><br><span class="line">				Edge[cnt].v&#x3D;j;</span><br><span class="line">				Edge[cnt].cap&#x3D;distance_(i,j); </span><br><span class="line">				cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans&#x3D;0;</span><br><span class="line">		kruskal();</span><br><span class="line">		printf(&quot;%.2f\n&quot;,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1102 Constructing Roads(kruskal/prim/最小生成树)</title>
    <url>/e1d4a8b4/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1102" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1102</a><br>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>There are N villages, which are numbered from 1 to N, and you should build some roads such that every two villages can connect to each other. We say two village A and B are connected, if and only if there is a road between A and B, or there exists a village C such that there is a road between A and C, and C and B are connected. </p>
<p>We know that there are already some roads between some villages and your job is the build some roads such that all the villages are connect and the length of all the roads built is minimum.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line is an integer N (3 &lt;= N &lt;= 100), which is the number of villages. Then come N lines, the i-th of which contains N integers, and the j-th of these N integers is the distance (the distance should be an integer within [1, 1000]) between village i and village j.</p>
<p>Then there is an integer Q (0 &lt;= Q &lt;= N * (N + 1) / 2). Then come Q lines, each line contains two integers a and b (1 &lt;= a &lt; b &lt;= N), which means the road between village a and village b has been built.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>You should output a line contains an integer, which is the length of all the roads to be built such that all the villages are connected, and this value is minimum. </p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">0 990 692</span><br><span class="line">990 0 179</span><br><span class="line">692 179 0</span><br><span class="line">1</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">179</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>裸的最小生成树的题 两种算法都放上 </p>
<p>prim加点 kruskal加边</p>
<p>现在整理以前的代码感觉以前写的好详细。。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p><code>Prim</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;105;</span><br><span class="line">const int INF&#x3D;0x3f3f3f3f;</span><br><span class="line">int n,ans;</span><br><span class="line">int map_[N][N],dis[N],vis[N];</span><br><span class="line">void prim()&#123;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		dis[i]&#x3D;map_[1][i];</span><br><span class="line">		vis[i]&#x3D;0;</span><br><span class="line">	&#125;</span><br><span class="line">	dis[1]&#x3D;0;</span><br><span class="line">	vis[1]&#x3D;1;</span><br><span class="line">	int k,tmp;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		tmp&#x3D;INF;</span><br><span class="line">		for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;&#x2F;&#x2F;在从i到j还没访问过的j中找出代价最小的 </span><br><span class="line">			if(!vis[j]&amp;&amp;tmp&gt;dis[j])&#123;</span><br><span class="line">				k&#x3D;j;</span><br><span class="line">				tmp&#x3D;dis[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(tmp&#x3D;&#x3D;INF)break;&#x2F;&#x2F;没找到即全部访问过了，prim结束 </span><br><span class="line">		vis[k]&#x3D;1;&#x2F;&#x2F;给k标记已访问 </span><br><span class="line">		ans+&#x3D;dis[k];</span><br><span class="line">		for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;&#x2F;&#x2F;加入从k出发的最短路 </span><br><span class="line">			if(!vis[j]&amp;&amp;dis[j]&gt;map_[k][j])&#123;</span><br><span class="line">				dis[j]&#x3D;map_[k][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	while(scanf(&quot;%d&quot;,&amp;n)!&#x3D;EOF)&#123;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">			for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;</span><br><span class="line">				scanf(&quot;%d&quot;,&amp;map_[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		int q,a,b;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;q);</span><br><span class="line">		while(q--)&#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">			map_[a][b]&#x3D;map_[b][a]&#x3D;0;</span><br><span class="line">		&#125;</span><br><span class="line">		ans&#x3D;0;</span><br><span class="line">		prim();</span><br><span class="line">		printf(&quot;%d\n&quot;,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Kruskal</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;105;</span><br><span class="line">struct Edge&#123;</span><br><span class="line">	int u,v;</span><br><span class="line">	int cap;</span><br><span class="line">&#125;Edge[N*N];</span><br><span class="line">int n,ans,cnt;&#x2F;&#x2F;cnt为边数 </span><br><span class="line">int fa[N];</span><br><span class="line">void init()&#123;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		fa[i]&#x3D;i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">	if(x!&#x3D;fa[x])fa[x]&#x3D;find(fa[x]);</span><br><span class="line">	return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">	int a&#x3D;find(x),b&#x3D;find(y);</span><br><span class="line">	if(a&#x3D;&#x3D;b)return;</span><br><span class="line">	else&#123;</span><br><span class="line">		fa[a]&#x3D;b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">bool cmp(struct Edge a,struct Edge b)&#123;</span><br><span class="line">	return a.cap&lt;b.cap;</span><br><span class="line">&#125;</span><br><span class="line">void kruskal()&#123;</span><br><span class="line">	sort(Edge,Edge+cnt,cmp);&#x2F;&#x2F;按边的最小代价排序 </span><br><span class="line">	for(int i&#x3D;0;i&lt;cnt;i++)&#123;</span><br><span class="line">		int fx&#x3D;find(Edge[i].u),fy&#x3D;find(Edge[i].v);</span><br><span class="line">		if(fx&#x3D;&#x3D;fy)continue;</span><br><span class="line">		ans+&#x3D;Edge[i].cap;&#x2F;&#x2F;u，v不在一棵树上，就加上这条边 </span><br><span class="line">		join(fx,fy);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	while(scanf(&quot;%d&quot;,&amp;n)!&#x3D;EOF)&#123;</span><br><span class="line">		init();</span><br><span class="line">		cnt&#x3D;0;</span><br><span class="line">		int w;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">			for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;</span><br><span class="line">				scanf(&quot;%d&quot;,&amp;w);</span><br><span class="line">				Edge[cnt].u&#x3D;i;</span><br><span class="line">				Edge[cnt].v&#x3D;j;</span><br><span class="line">				Edge[cnt].cap&#x3D;w;</span><br><span class="line">				cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		int q,u,v;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;q);</span><br><span class="line">		while(q--)&#123;&#x2F;&#x2F;建树 </span><br><span class="line">			scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">			join(u,v);</span><br><span class="line">		&#125;</span><br><span class="line">		ans&#x3D;0;</span><br><span class="line">		kruskal();</span><br><span class="line">		printf(&quot;%d\n&quot;,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1198 Farm Irrigation（并查集）</title>
    <url>/276c371d/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1198" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1198</a></p>
<p>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Benny has a spacious farm land to irrigate. The farm land is a rectangle, and is divided into a lot of samll squares. Water pipes are placed in these squares. Different square has a different type of pipe. There are 11 types of pipes, which is marked from A to K, as Figure 1 shows.</p>
<p><img src="http://acm.hdu.edu.cn/data/images/1121-1.gif" alt=""></p>
<p>Benny has a map of his farm, which is an array of marks denoting the distribution of water pipes over the whole farm. For example, if he has a map </p>
<p>ADC<br>FJK<br>IHE   </p>
<p>then the water pipes are distributed like </p>
<p><img src="http://acm.hdu.edu.cn/data/images/1121-2.gif" alt=""></p>
<p>Several wellsprings are found in the center of some squares, so water can flow along the pipes from one square to another. If water flow crosses one square, the whole farm land in this square is irrigated and will have a good harvest in autumn. </p>
<p>Now Benny wants to know at least how many wellsprings should be found to have the whole farm land irrigated. Can you help him? </p>
<p>Note: In the above example, at least 3 wellsprings are needed, as those red points in Figure 2 show.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>There are several test cases! In each test case, the first line contains 2 integers M and N, then M lines follow. In each of these lines, there are N characters, in the range of ‘A’ to ‘K’, denoting the type of water pipe over the corresponding square. A negative M or N denotes the end of input, else you can assume 1 &lt;= M, N &lt;= 50.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, output in one line the least number of wellsprings needed.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 2</span><br><span class="line">DK</span><br><span class="line">HF</span><br><span class="line">3 3</span><br><span class="line">ADC</span><br><span class="line">FJK</span><br><span class="line">IHE</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure>

<p><strong>Sample Output</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>一个并查集好题</p>
<p>水管连通本质上就是集合的合并，最后求有几个集合的问题，很容易想到并查集</p>
<p>只需要对每个地块与右方和下方的地块进行合并即可，合并之前先判断是否能连通，若能连通则合并，不能连通，则不能合并</p>
<p>每个地块的四个方向用数组的01来表示，用位运算来判断可连性</p>
<p>具体见代码注释</p>
<p>还有一种二进制的位运算写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int type[11] &#x3D; &#123;3,6,9,12,10,5,7,11,13,14,15&#125;; </span><br><span class="line"></span><br><span class="line">if(dir&#x3D;&#x3D;1)&#123;</span><br><span class="line">    if(((type[ta]&gt;&gt;3) &amp; 1) &amp;&amp; ((type[tb]&gt;&gt;1) &amp; 1))mark &#x3D; true;  </span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    if(((type[ta]&gt;&gt;2) &amp; 1) &amp;&amp; (type[tb] &amp; 1))mark &#x3D; true;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;505;</span><br><span class="line">const int type[11][4]&#x3D;&#123; &#123;1,1,0,0&#125;,&#123;0,1,1,0&#125;,&#123;1,0,0,1&#125;,&#123;0,0,1,1&#125;,&#123;0,1,0,1&#125;,&#123;1,0,1,0&#125;,&#123;1,1,1,0&#125;,&#123;1,1,0,1&#125;,&#123;1,0,1,1&#125;,&#123;0,1,1,1&#125;,&#123;1,1,1,1&#125; &#125;;</span><br><span class="line">int n,m,num,cnt; </span><br><span class="line">int fa[N*N+1];</span><br><span class="line">char f[N][N]; </span><br><span class="line">int find(int x)&#123;</span><br><span class="line">	if(x!&#x3D;fa[x])fa[x]&#x3D;find(fa[x]);</span><br><span class="line">	return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">void join(int x1,int y1,int x2,int y2,int dir)&#123;</span><br><span class="line">	if(x2&gt;n||y2&gt;m)return;&#x2F;&#x2F;超出地图不合并</span><br><span class="line">	bool flag&#x3D;false;&#x2F;&#x2F;标记是否可连通 </span><br><span class="line">	int t1,t2;</span><br><span class="line">	t1&#x3D;f[x1][y1]-&#39;A&#39;;</span><br><span class="line">	t2&#x3D;f[x2][y2]-&#39;A&#39;; </span><br><span class="line">	if(dir&#x3D;&#x3D;1)&#123;</span><br><span class="line">		if(type[t1][3]&amp;&amp;type[t2][1])flag&#x3D;true;&#x2F;&#x2F;竖直方向 </span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		if(type[t1][2]&amp;&amp;type[t2][0])flag&#x3D;true;&#x2F;&#x2F;水平方向 </span><br><span class="line">	&#125;</span><br><span class="line">	if(flag)&#123;&#x2F;&#x2F;合并 </span><br><span class="line">		int a&#x3D;find((x1-1)*m+y1),b&#x3D;find((x2-1)*m+y2);</span><br><span class="line">		if(a!&#x3D;b)&#123;</span><br><span class="line">			fa[b]&#x3D;a;</span><br><span class="line">			--cnt;&#x2F;&#x2F;消去一个水井 </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">	while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!&#x3D;EOF)&#123;</span><br><span class="line">		if(n&#x3D;&#x3D;-1&amp;&amp;m&#x3D;&#x3D;-1)break;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;n*m;i++)&#123;</span><br><span class="line">			fa[i]&#x3D;i;</span><br><span class="line">		&#125;</span><br><span class="line">		cnt&#x3D;n*m;&#x2F;&#x2F;初始化，假设所有田里都有水井 </span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">			scanf(&quot;%s&quot;,f[i]+1);</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;&#x2F;&#x2F;统一向右or下合并 </span><br><span class="line">			for(int j&#x3D;1;j&lt;&#x3D;m;j++)&#123;</span><br><span class="line">				join(i,j,i+1,j,1);&#x2F;&#x2F;竖直 </span><br><span class="line">				join(i,j,i,j+1,0);&#x2F;&#x2F;水平 </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;,cnt);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1856 More is better（并查集）</title>
    <url>/fc584b3/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1856" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1856</a></p>
<a id="more"></a>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Mr Wang wants some boys to help him with a project. Because the project is rather complex, the more boys come, the better it will be. Of course there are certain requirements.</p>
<p>Mr Wang selected a room big enough to hold the boys. The boy who are not been chosen has to leave the room immediately. There are 10000000 boys in the room numbered from 1 to 10000000 at the very beginning. After Mr Wang’s selection any two of them who are still in this room should be friends (direct or indirect), or there is only one boy left. Given all the direct friend-pairs, you should decide the best way.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input contains an integer n (0 &lt;= n &lt;= 100000) - the number of direct friend-pairs. The following n lines each contains a pair of numbers A and B separated by a single space that suggests A and B are direct friends. (A != B, 1 &lt;= A, B &lt;= 10000000) </p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>The output in one line contains exactly one integer equals to the maximum number of boys Mr Wang may keep. </p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br><span class="line">5 6</span><br><span class="line">1 6</span><br><span class="line">4</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br><span class="line">5 6</span><br><span class="line">7 8</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>一开始1e7个人，有n对朋友，a和b是朋友</p>
<p>最后剩下的人必须直接或间接是朋友 求剩下人数的最大值</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>求每个集合中元素的个数，然后求个数的最大值</p>
<p>求集合个数的方法:只需要在合并两个集合时处理一下，让这两个集合的元素个数也合并一下就行了</p>
<p>要注意的一个地方就是：当n=0时特判，没人是朋友，最多选一个人要输出1</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;100005;</span><br><span class="line">int fa[N],sum[N];</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">	int tmp&#x3D;x;</span><br><span class="line">	while(tmp!&#x3D;fa[tmp])tmp&#x3D;fa[tmp];</span><br><span class="line">	fa[x]&#x3D;tmp;</span><br><span class="line">	return tmp;</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">	int a,b;</span><br><span class="line">	a&#x3D;find(x);b&#x3D;find(y);</span><br><span class="line">	if(a!&#x3D;b)&#123;</span><br><span class="line">		fa[a]&#x3D;b;</span><br><span class="line">		sum[b]+&#x3D;sum[a];&#x2F;&#x2F;合并集合中元素个数 </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	while(scanf(&quot;%d&quot;,&amp;n)!&#x3D;EOF)&#123;</span><br><span class="line">		if(n&#x3D;&#x3D;0)&#123;</span><br><span class="line">			printf(&quot;1\n&quot;);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;N;i++)&#123;</span><br><span class="line">			fa[i]&#x3D;i;</span><br><span class="line">			sum[i]&#x3D;1;&#x2F;&#x2F;开始时数量的都为1 </span><br><span class="line">		&#125;</span><br><span class="line">		int num&#x3D;0;</span><br><span class="line">		while(n--)&#123;</span><br><span class="line">			int a,b;</span><br><span class="line">			scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">			num&#x3D;a&gt;num?a:num;</span><br><span class="line">			num&#x3D;b&gt;num?b:num;</span><br><span class="line">			join(a,b);</span><br><span class="line">		&#125;</span><br><span class="line">		int ans&#x3D;0;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;num;i++)&#123;</span><br><span class="line">			ans&#x3D;sum[i]&gt;ans?sum[i]:ans;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1232 畅通工程（并查集）</title>
    <url>/34822d81/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1232" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1232</a></p>
<p>Time Limit: 4000/2000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ </p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。 </p>
<p>注意:两个城市之间可以有多条道路相通,也就是说</p>
<p>3 3<br>1 2<br>1 2<br>2 1<br>这种输入也是合法的</p>
<p>当N为0时，输入结束，该用例不被处理。 </p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对每个测试用例，在1行里输出最少还需要建设的道路数目。 </p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 2</span><br><span class="line">1 3</span><br><span class="line">4 3</span><br><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">5 2</span><br><span class="line">1 2</span><br><span class="line">3 5</span><br><span class="line">999 0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p><strong>Sample Output</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">998</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>初始化时每个城镇都没有路，所以总共要连接的路的数量为n-1个，在增加路的过程中，先用并查集判断，如果两个城镇确实不在一个集合，这条路就有用，两个城镇归为一个集合中，要连接的路减一。如果两个城镇之前就已经在一个集合里，增加的这条路就无用，要连接的路不变</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N&#x3D;100005;</span><br><span class="line">int fa[N];</span><br><span class="line">int ed;</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">	int tmp&#x3D;x;</span><br><span class="line">	while(tmp!&#x3D;fa[tmp])tmp&#x3D;fa[tmp];</span><br><span class="line">	fa[x]&#x3D;tmp;</span><br><span class="line">	return tmp;</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">	int a,b;</span><br><span class="line">	a&#x3D;find(x);b&#x3D;find(y);</span><br><span class="line">	if(a!&#x3D;b)&#123;</span><br><span class="line">		fa[a]&#x3D;b;</span><br><span class="line">		ed++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int m,n,a,b;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">		if(n&#x3D;&#x3D;0)break;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">		ed&#x3D;0;</span><br><span class="line">		for(int i&#x3D;1;i&lt;&#x3D;n;i++)fa[i]&#x3D;i;</span><br><span class="line">		while(m--)&#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">			join(a,b);</span><br><span class="line">		&#125;</span><br><span class="line">		int k&#x3D;0,flag&#x3D;1;</span><br><span class="line">		int ans&#x3D;n-1-ed;</span><br><span class="line">		printf(&quot;%d\n&quot;,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1272 小希的迷宫（并查集）</title>
    <url>/d67f02ad/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1272" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1272</a><br>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)</p>
<h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>上次Gardon的迷宫城堡小希玩了很久（见Problem B），现在她也想设计一个迷宫让Gardon来走。但是她设计迷宫的思路不一样，首先她认为所有的通道都应该是双向连通的，就是说如果有一个通道连通了房间A和B，那么既可以通过它从房间A走到房间B，也可以通过它从房间B走到房间A，为了提高难度，小希希望任意两个房间有且仅有一条路径可以相通（除非走了回头路）。小希现在把她的设计图给你，让你帮忙判断她的设计图是否符合她的设计思路。比如下面的例子，前两个是符合条件的，但是最后一个却有两种方法从5到达8。<br><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kjej9iz7j20ac03k74f.jpg" alt=""></p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入包含多组数据，每组数据是一个以0 0结尾的整数对列表，表示了一条通道连接的两个房间的编号。房间的编号至少为1，且不超过100000。每两组数据之间有一个空行。<br>整个文件以两个-1结尾。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于输入的每一组数据，输出仅包括一行。如果该迷宫符合小希的思路，那么输出”Yes”，否则输出”No”。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 8  5 3  5 2  6 4</span><br><span class="line">5 6  0 0</span><br><span class="line"></span><br><span class="line">8 1  7 3  6 2  8 9  7 5</span><br><span class="line">7 4  7 8  7 6  0 0</span><br><span class="line"></span><br><span class="line">3 8  6 8  6 4</span><br><span class="line">5 3  5 6  5 2  0 0</span><br><span class="line"></span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><ul>
<li>保证图是连通的，且连通分量为1</li>
<li>不存在环（包括自环）</li>
</ul>
<p>因为这是一个无向图，只要保证 顶点数 = 边数+1 ， 就可以说明是连通的</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line">const int N&#x3D;100005;</span><br><span class="line">int fa[N];</span><br><span class="line">bool vis[N];</span><br><span class="line">bool circle;&#x2F;&#x2F;判断是否成环</span><br><span class="line">int ed,v;&#x2F;&#x2F;边数和顶点数 </span><br><span class="line">int find(int x)&#123;</span><br><span class="line">	int tmp&#x3D;x;</span><br><span class="line">	while(tmp!&#x3D;fa[tmp])tmp&#x3D;fa[tmp];</span><br><span class="line">	fa[x]&#x3D;tmp;</span><br><span class="line">	return tmp;</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">	if(x&#x3D;&#x3D;y)circle&#x3D;true;</span><br><span class="line">	int a,b;</span><br><span class="line">	a&#x3D;find(x);b&#x3D;find(y);</span><br><span class="line">	if(a!&#x3D;b)&#123;</span><br><span class="line">		fa[a]&#x3D;b;</span><br><span class="line">		ed++;&#x2F;&#x2F;多一条边 </span><br><span class="line">	&#125;</span><br><span class="line">	else circle&#x3D;true;&#x2F;&#x2F;要join(x,y)，而a&#x3D;b说明 x,y是同一祖先，再连起来就成环了 </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int a,b;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		memset(vis,0,sizeof(vis));</span><br><span class="line">		circle&#x3D;false;</span><br><span class="line">		ed&#x3D;0;v&#x3D;0; </span><br><span class="line">		for(int i&#x3D;1;i&lt;N;i++)fa[i]&#x3D;i;</span><br><span class="line">		scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">		if(a&#x3D;&#x3D;0&amp;&amp;b&#x3D;&#x3D;0)&#123;&#x2F;&#x2F;空树特判 </span><br><span class="line">			puts(&quot;Yes&quot;);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		if(a&#x3D;&#x3D;-1&amp;&amp;b&#x3D;&#x3D;-1)return 0;</span><br><span class="line">		vis[a]&#x3D;true;vis[b]&#x3D;true;</span><br><span class="line">		join(a,b);</span><br><span class="line">		while(1)&#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">			if(a&#x3D;&#x3D;0&amp;&amp;b&#x3D;&#x3D;0)break;</span><br><span class="line">			join(a,b);</span><br><span class="line">			vis[a]&#x3D;true;vis[b]&#x3D;true;</span><br><span class="line">		&#125;</span><br><span class="line">		int k&#x3D;0,flag&#x3D;1;</span><br><span class="line">		for(int i&#x3D;1;i&lt;N;i++)&#123;</span><br><span class="line">			if(vis[i])v++;</span><br><span class="line">		&#125;</span><br><span class="line">		if(!circle&amp;&amp;ed+1&#x3D;&#x3D;v)puts(&quot;Yes&quot;);</span><br><span class="line">		else puts(&quot;No&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1325 Is it a tree？（并查集）</title>
    <url>/d2d140b5/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1325" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1325</a></p>
<a id="more"></a>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kje039baj20qv0gotbx.jpg" alt=""></p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input will consist of a sequence of descriptions (test cases) followed by a pair of negative integers. Each test case will consist of a sequence of edge descriptions followed by a pair of zeroes Each edge description will consist of a pair of integers; the first integer identifies the node from which the edge begins, and the second integer identifies the node to which the edge is directed. Node numbers will always be greater than zero. </p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case display the line <code>Case k is a tree.&quot; or the line</code>Case k is not a tree.”, where k corresponds to the test case number (they are sequentially numbered starting with 1). </p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 8 5 3 5 2 6 4</span><br><span class="line">5 6 0 0</span><br><span class="line">8 1 7 3 6 2 8 9 7 5</span><br><span class="line">7 4 7 8 7 6 0 0</span><br><span class="line">3 8 6 8 6 4</span><br><span class="line">5 3 5 6 5 2 0 0</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case 1 is a tree.</span><br><span class="line">Case 2 is a tree.</span><br><span class="line">Case 3 is not a tree.</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>按题意判断是不是一棵树</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>类似hdu1272</p>
<ul>
<li>无环；   </li>
<li>除了根，所有的入度为1，根入度为0；   </li>
<li>这个结构只有一个根，空树也是树。  </li>
</ul>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line">const int N&#x3D;100005;</span><br><span class="line">int fa[N];</span><br><span class="line">bool vis[N];</span><br><span class="line">bool circle;&#x2F;&#x2F;判断是否成环</span><br><span class="line">int du[N];</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">	int tmp&#x3D;x;</span><br><span class="line">	while(tmp!&#x3D;fa[tmp])tmp&#x3D;fa[tmp];</span><br><span class="line">	fa[x]&#x3D;tmp;</span><br><span class="line">	return tmp;</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">	du[y]++;</span><br><span class="line">	if(x&#x3D;&#x3D;y)circle&#x3D;true;</span><br><span class="line">	int a,b;</span><br><span class="line">	a&#x3D;find(x);b&#x3D;find(y);</span><br><span class="line">	if(a!&#x3D;b)&#123;</span><br><span class="line">		fa[a]&#x3D;b;</span><br><span class="line">	&#125;</span><br><span class="line">	else circle&#x3D;true;&#x2F;&#x2F;要join(x,y)，而a&#x3D;b说明 x,y是同一祖先，再连起来就成环了 </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int a,b;</span><br><span class="line">	int cas&#x3D;1; </span><br><span class="line">	while(1)&#123;</span><br><span class="line">		memset(vis,0,sizeof(vis));</span><br><span class="line">		memset(du,0,sizeof(du));</span><br><span class="line">		circle&#x3D;false;</span><br><span class="line">		for(int i&#x3D;1;i&lt;N;i++)fa[i]&#x3D;i;</span><br><span class="line">		scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">		if(a&#x3D;&#x3D;0&amp;&amp;b&#x3D;&#x3D;0)&#123;&#x2F;&#x2F;空树特判 </span><br><span class="line">			printf(&quot;Case %d is a tree.\n&quot;,cas);</span><br><span class="line">			cas++;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		if(a&lt;0&amp;&amp;b&lt;0)return 0;</span><br><span class="line">		vis[a]&#x3D;true;vis[b]&#x3D;true;</span><br><span class="line">		join(a,b);</span><br><span class="line">		while(1)&#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">			if(a&#x3D;&#x3D;0&amp;&amp;b&#x3D;&#x3D;0)break;</span><br><span class="line">			join(a,b);</span><br><span class="line">			vis[a]&#x3D;true;vis[b]&#x3D;true;</span><br><span class="line">		&#125;</span><br><span class="line">		int gen&#x3D;0,flag&#x3D;0;</span><br><span class="line">		for(int i&#x3D;1;i&lt;N;i++)&#123;</span><br><span class="line">			if(vis[i])&#123;</span><br><span class="line">				if(du[i]&gt;1)&#123;</span><br><span class="line">					flag&#x3D;1;break;</span><br><span class="line">				&#125;</span><br><span class="line">				else if(du[i]&#x3D;&#x3D;0)gen++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(!circle&amp;&amp;flag&#x3D;&#x3D;0&amp;&amp;gen&#x3D;&#x3D;1)printf(&quot;Case %d is a tree.\n&quot;,cas);</span><br><span class="line">		else printf(&quot;Case %d is not a tree.\n&quot;,cas);</span><br><span class="line">		cas++;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>poj 1182 食物链（并查集）</title>
    <url>/e612ace7/</url>
    <content><![CDATA[<p><a href="http://poj.org/problem?id=1182" target="_blank" rel="noopener">http://poj.org/problem?id=1182</a></p>
<a id="more"></a>

<p>Time Limit: 1000MS        Memory Limit: 10000K</p>
<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。<br>现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。<br>有人用两种说法对这N个动物所构成的食物链关系进行描述：<br>第一种说法是”1 X Y”，表示X和Y是同类。<br>第二种说法是”2 X Y”，表示X吃Y。<br>此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。<br>1）    当前的话与前面的某些真的话冲突，就是假话；<br>2）    当前的话中X或Y比N大，就是假话；<br>3）    当前的话表示X吃X，就是假话。<br>你的任务是根据给定的N（1 &lt;= N &lt;= 50,000）和K句话（0 &lt;= K &lt;= 100,000），输出假话的总数。 </p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行是两个整数N和K，以一个空格分隔。<br>以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。<br>若D=1，则表示X和Y是同类。<br>若D=2，则表示X吃Y。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>只有一个整数，表示假话的数目。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100 7</span><br><span class="line">1 101 1 </span><br><span class="line">2 1 2</span><br><span class="line">2 2 3 </span><br><span class="line">2 3 3 </span><br><span class="line">1 1 3 </span><br><span class="line">2 3 1 </span><br><span class="line">1 5 5</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>分成三类 所以用 <strong>并查集+数组加倍</strong></p>
<p>不知道当时在哪看到的这种数组加倍的写法 反正巨好用</p>
<p><code>i (i+n) (i+2*n)</code>分别代表abc三个种类</p>
<p>如果a吃b 就分别把三种的a和b的下一个join起来</p>
<p>注意这题不合法的输入也要处理成假话</p>
<p>下面是网上找的带权并查集的写法 但是我还是喜欢数组加倍。。<br><a href="https://blog.csdn.net/sunmaoxiang/article/details/80959300" target="_blank" rel="noopener">https://blog.csdn.net/sunmaoxiang/article/details/80959300</a></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;50005;</span><br><span class="line">int fa[N*3];</span><br><span class="line"></span><br><span class="line">int find(int x)&#123;</span><br><span class="line">	return fa[x]&#x3D;&#x3D;x?x:fa[x]&#x3D;find(fa[x]);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">	fa[find(x)]&#x3D;find(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,k,ans&#x3D;0;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;n,&amp;k);</span><br><span class="line">	for(int i&#x3D;0;i&lt;&#x3D;3*n;i++)fa[i]&#x3D;i;</span><br><span class="line">	for(int i&#x3D;0;i&lt;k;i++)&#123;</span><br><span class="line">		int a,b,d;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;,&amp;d,&amp;a,&amp;b);</span><br><span class="line">		if(a&gt;n||b&gt;n||a&lt;1||b&lt;1)&#123;</span><br><span class="line">			ans++;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(d&#x3D;&#x3D;1)&#123;</span><br><span class="line">			if(find(a)&#x3D;&#x3D;find(b+n)||find(a)&#x3D;&#x3D;find(b+2*n))&#123;</span><br><span class="line">				ans++;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			join(a,b);</span><br><span class="line">			join(a+n,b+n);</span><br><span class="line">			join(a+2*n,b+2*n);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			if(find(a)&#x3D;&#x3D;find(b)||find(a)&#x3D;&#x3D;find(b+2*n))&#123;</span><br><span class="line">				ans++;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;</span><br><span class="line">				join(a,b+n);</span><br><span class="line">				join(a+n,b+2*n);</span><br><span class="line">				join(a+2*n,b);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	printf(&quot;%d\n&quot;,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>poj 1988 Cube Stacking（并查集）</title>
    <url>/223d29ea/</url>
    <content><![CDATA[<p><a href="http://poj.org/problem?id=1988" target="_blank" rel="noopener">http://poj.org/problem?id=1988</a><br>Time Limit: 2000MS        Memory Limit: 30000K</p>
<a id="more"></a>

<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Farmer John and Betsy are playing a game with N (1 &lt;= N &lt;= 30,000)identical cubes labeled 1 through N. They start with N stacks, each containing a single cube. Farmer John asks Betsy to perform P (1&lt;= P &lt;= 100,000) operation. There are two types of operations:<br>moves and counts.   </p>
<ul>
<li>In a move operation, Farmer John asks Bessie to move the stack containing cube X on top of the stack containing cube Y. </li>
<li>In a count operation, Farmer John asks Bessie to count the number of cubes on the stack with cube X that are under the cube X and report that value. </li>
</ul>
<p>Write a program that can verify the results of the game. </p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><ul>
<li><p>Line 1: A single integer, P </p>
</li>
<li><p>Lines 2..P+1: Each of these lines describes a legal operation. Line 2 describes the first operation, etc. Each line begins with a ‘M’ for a move operation or a ‘C’ for a count operation. For move operations, the line also contains two integers: X and Y.For count operations, the line also contains a single integer: X. </p>
</li>
</ul>
<p>Note that the value for N does not appear in the input file. No move operation will request a move a stack onto itself. </p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Print the output from each of the count operations in the same order as the input file. </p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">M 1 6</span><br><span class="line">C 1</span><br><span class="line">M 2 4</span><br><span class="line">M 2 6</span><br><span class="line">C 3</span><br><span class="line">C 4</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给n个箱子 1-n排成n列<br>有两种操作：</p>
<ul>
<li>M：将x所在列上的箱子移到y所在列箱子上面</li>
<li>C：求x箱子下有几个箱子</li>
</ul>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>因为有合并两堆箱子的操作 所以想到用并查集 </p>
<p>这题巧妙的地方在于如何求解这个箱子下面的箱子数 开两个数组</p>
<p>num[i]记录当前第i列有几个箱子<br>place[i]记录箱子i下面的箱子个数</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;30010;</span><br><span class="line">int fa[N],num[N],place[N];</span><br><span class="line"></span><br><span class="line">int find(int x)&#123;</span><br><span class="line">    if(fa[x]&#x3D;&#x3D;x)return x;</span><br><span class="line">    int temp&#x3D;fa[x];</span><br><span class="line">    fa[x]&#x3D;find(fa[x]);</span><br><span class="line">    place[x]+&#x3D;place[temp];</span><br><span class="line">    return fa[x];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">    fa[x]&#x3D;y;</span><br><span class="line">    place[x]+&#x3D;num[y];</span><br><span class="line">    num[y]+&#x3D;num[x];</span><br><span class="line">    num[x]&#x3D;0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;30000;i++)&#123;</span><br><span class="line">        place[i]&#x3D;0;</span><br><span class="line">        num[i]&#x3D;1;</span><br><span class="line">        fa[i]&#x3D;i;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        char s[5];</span><br><span class="line">        scanf(&quot;%S&quot;,&amp;s);</span><br><span class="line">        if(s[0]&#x3D;&#x3D;&#39;M&#39;)&#123;</span><br><span class="line">            int x,y;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);</span><br><span class="line">            int x1&#x3D;find(x),y1&#x3D;find(y);</span><br><span class="line">            if(x1!&#x3D;y1)join(x1,y1);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(s[0]&#x3D;&#x3D;&#39;C&#39;)&#123;</span><br><span class="line">            int x;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">            find(x);</span><br><span class="line">            printf(&quot;%d\n&quot;,place[x]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>Teemo&#39;s bad day（并查集）</title>
    <url>/561c553e/</url>
    <content><![CDATA[<p><a href="https://nanti.jisuanke.com/t/29203" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/29203</a></p>
<p>Today is a bad day. Teemo is scolded badly by his teacher because he didn’t do his homework.But Teemo is very self-confident, he tells the teacher that the problems in the homework are too simple to solve. So the teacher gets much angrier and says”I will choose a problem in the homework, if you can’t solve it, I will call you mother! “</p>
<p>The problem is that:</p>
<p>There is an array A which contains n integers, and an array B which also contains n integers. You can pay one dollar to buy a card which contains two integers a1 and a2, The card can arbitrary number of times transform a single integer a1 to a2 and vise-versa on both array A and Array B. Please calculate the minimum dollars you should pay to make the two array same(For every 1&lt;=i&lt;=n,A[i]=B[i]);</p>
<h3 id="Input-Format"><a href="#Input-Format" class="headerlink" title="Input Format"></a>Input Format</h3><p>The first line of the input contains an integer T(1&lt;=T&lt;=10), giving the number of test cases.<br>For every test case, the first line contains an integer n(1&lt;=n&lt;=500000). The second line contains n integers. The i th integer represents A<a href="1<=A[i]<=100000">i</a>. And the third line contains n integers. The i th integer represents B<a href="1<=B[i]<=100000">i</a>.</p>
<h3 id="Output-Format"><a href="#Output-Format" class="headerlink" title="Output Format"></a>Output Format</h3><p>For each test case, output an integer which means the minimum dollars you should pay in a line.</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">5</span><br><span class="line">1 1 2 3 2</span><br><span class="line">1 2 3 1 1</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给两个序列，某一张卡片可以把数a换成数b，次数不限，求把两个序列变成相同需要的最少卡片数</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>两个数父亲不同就join（a,b），然后ans++</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;climits&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;limits&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;100005;</span><br><span class="line">int fa[N];</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">    int tmp&#x3D;x;</span><br><span class="line">    while(fa[tmp]!&#x3D;tmp)tmp&#x3D;fa[tmp]; </span><br><span class="line">    fa[x]&#x3D;tmp;</span><br><span class="line">    return tmp;</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#123;</span><br><span class="line">    if(find(x)!&#x3D;find(y))fa[find(x)]&#x3D;fa[find(y)];</span><br><span class="line">&#125;</span><br><span class="line">int a[N*5],b[N*5];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        int n;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;N;i++)fa[i]&#x3D;i;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;n;i++)scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;n;i++)scanf(&quot;%d&quot;,&amp;b[i]);</span><br><span class="line">        int ans&#x3D;0;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">            int aa&#x3D;find(a[i]),bb&#x3D;find(b[i]);</span><br><span class="line">            if(aa&#x3D;&#x3D;bb)continue;</span><br><span class="line">            else&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                join(aa,bb);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>1365 浴火银河星际跳跃（并查集）</title>
    <url>/7a72e0ec/</url>
    <content><![CDATA[<p><a href="http://codevs.cn/problem/1365/" target="_blank" rel="noopener">http://codevs.cn/problem/1365/</a></p>
<p> 时间限制: 1 s<br> 空间限制: 128000 KB<br> <a id="more"></a></p>
<p> 题目等级 : 黄金 Gold</p>
<h3 id="题目描述-Description"><a href="#题目描述-Description" class="headerlink" title="题目描述 Description"></a>题目描述 Description</h3><p>小 K 又在玩浴火银河了。。。不过这次他的目的不是跑运输赚钱，而<br>是做任务赚钱。<br>他想知道关于一个任务的两个星系是否可以连通。</p>
<h3 id="输入描述-Input-Description"><a href="#输入描述-Input-Description" class="headerlink" title="输入描述 Input Description"></a>输入描述 Input Description</h3><p>第一行，三个数，X,N,M<br>X 表示出现的星系代号的最大值；<br>N 表示有 N 个星际跳跃门;<br>M 表示有 M 个任务。<br>接下来的 N 行描述每个星际跳跃门：每行为两个数字（星系代号），<br>星际跳跃门连通这两个星系（星际跳跃门是可以双向通行的）<br>；<br>接下来的 M 行表示每个任务需要到达的星系，每个任务需要到达两<br>个星系。</p>
<h3 id="输出描述-Output-Description"><a href="#输出描述-Output-Description" class="headerlink" title="输出描述 Output Description"></a>输出描述 Output Description</h3><p>共 M 行。<br>第 i 行表示第 i 个任务是否能完成：即两个星系是否能连通。（能→<br>Yes；不能→No）</p>
<h3 id="样例输入-Sample-Input"><a href="#样例输入-Sample-Input" class="headerlink" title="样例输入 Sample Input"></a>样例输入 Sample Input</h3><p>5 2 1<br>3 5<br>4 5<br>3 4</p>
<h3 id="样例输出-Sample-Output"><a href="#样例输出-Sample-Output" class="headerlink" title="样例输出 Sample Output"></a>样例输出 Sample Output</h3><p>Yes</p>
<h3 id="数据范围及提示-Data-Size-amp-Hint"><a href="#数据范围及提示-Data-Size-amp-Hint" class="headerlink" title="数据范围及提示 Data Size &amp; Hint"></a>数据范围及提示 Data Size &amp; Hint</h3><p>最大数据第一行：19999 17542 1664</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;20005;</span><br><span class="line">int fa[N];</span><br><span class="line">int find(int t)&#123;</span><br><span class="line">    int tmp&#x3D;t;</span><br><span class="line">    while(tmp!&#x3D;fa[tmp])tmp&#x3D;fa[tmp];</span><br><span class="line">    fa[t]&#x3D;tmp;</span><br><span class="line">    return tmp;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int x,n,m,a,b;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;x;i++)fa[i]&#x3D;i;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        int tmpa&#x3D;find(a),tmpb&#x3D;find(b);</span><br><span class="line">        if(tmpa!&#x3D;tmpb)fa[tmpb]&#x3D;tmpa;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        int tmpa&#x3D;find(a),tmpb&#x3D;find(b);</span><br><span class="line">        if(tmpa&#x3D;&#x3D;tmpb)cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;</span><br><span class="line">        else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>1240 莫比乌斯函数（数论）</title>
    <url>/9c66e3e3/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 </p>
<p>莫比乌斯函数，由德国数学家和天文学家莫比乌斯提出。梅滕斯(Mertens)首先使用μ(n)（miu(n)）作为莫比乌斯函数的记号。（据说，高斯(Gauss)比莫比乌斯早三十年就曾考虑过这个函数）。</p>
<p>具体定义如下：</p>
<p>如果一个数包含平方因子，那么miu(n) = 0。例如：miu(4), miu(12), miu(18) = 0。</p>
<p>如果一个数不包含平方因子，并且有k个不同的质因子，那么miu(n) = (-1)^k。例如：miu(2), miu(3), miu(30) = -1,miu(1), miu(6), miu(10) = 1。</p>
<p>给出一个数n, 计算miu(n)。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入包括一个数n，(2 &lt;= n &lt;= 10^9)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出miu(n)。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><p><code>5</code></p>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><p><code>-1</code></p>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>只有一个输入 直接求因子数就好 不用线筛</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line"></span><br><span class="line">int mu(int x)&#123;</span><br><span class="line">    int flag&#x3D;0,num&#x3D;0;</span><br><span class="line">    for(int i&#x3D;2;i*i&lt;&#x3D;x;i++)&#123;</span><br><span class="line">        if(x%i&#x3D;&#x3D;0)&#123;</span><br><span class="line">            x&#x2F;&#x3D;i;</span><br><span class="line">            num++;</span><br><span class="line">            if(x%i&#x3D;&#x3D;0)&#123;</span><br><span class="line">                flag&#x3D;1;&#x2F;&#x2F;包含平方因子</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(num&amp;1)return 1;</span><br><span class="line">    else return -1;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*o(n)线筛</span><br><span class="line">int mu[N],prime[N];</span><br><span class="line">bool vis[N];</span><br><span class="line">int ji;</span><br><span class="line">void init()&#123;</span><br><span class="line">    mu[1]&#x3D;1;</span><br><span class="line">    memset(vis,false,sizeof(vis));</span><br><span class="line">    for(int i&#x3D;2;i&lt;N;i++)&#123;</span><br><span class="line">        if(!vis[i])&#123;</span><br><span class="line">            prime[ji++]&#x3D;i;</span><br><span class="line">            mu[i]&#x3D;-1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j&#x3D;0;j&lt;ji&amp;&amp;i*prime[j]&lt;N;j++)&#123;</span><br><span class="line">            vis[i*prime[j]]&#x3D;true;</span><br><span class="line">            if(i%prime[j])mu[i*prime[j]]&#x3D;-mu[i];</span><br><span class="line">            else&#123;</span><br><span class="line">                mu[i*prime[j]]&#x3D;0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">int main()&#123; </span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    printf(&quot;%d\n&quot;,mu(n));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>1256 乘法逆元（数论）</title>
    <url>/c3fd1e79/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题</p>
<p>给出2个数M和N(M &lt; N)，且M与N互质，找出一个数K满足0 &lt; K &lt; N且K * M % N = 1，如果有多个满足条件的，输出最小的。</p>
<a id="more"></a>

<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入2个数M, N中间用空格分隔（1 &lt;= M &lt; N &lt;= 10^9)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一个数K，满足0 &lt; K &lt; N且K * M % N = 1，如果有多个满足条件的，输出最小的。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 3</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>数论 —— 扩展欧几里得</p>
<p>ax+by=gcd(a,b)   </p>
<p>a,b互质 有ax+by=1  </p>
<p>ax%b=1%b </p>
<p>记x为inv(a) 则 <code>a*inv(a)%b=1%b</code> </p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">void ex_gcd(LL a,LL b,LL &amp;x,LL &amp;y,LL &amp;d)&#123;</span><br><span class="line">    if(!b)&#123;</span><br><span class="line">        d&#x3D;a;x&#x3D;1;y&#x3D;0;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        ex_gcd(b,a%b,y,x,d);</span><br><span class="line">        y-&#x3D;x*(a&#x2F;b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">LL inv(LL t,LL p)&#123;</span><br><span class="line">    LL d,x,y;</span><br><span class="line">    ex_gcd(t,p,x,y,d);</span><br><span class="line">    return d&#x3D;&#x3D;1?(x%p+p)%p:-1;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123; </span><br><span class="line">    LL m,n;</span><br><span class="line">    scanf(&quot;%lld%lld&quot;,&amp;m,&amp;n);</span><br><span class="line">    printf(&quot;%lld\n&quot;,inv(m,n));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>1264 线段相交（计算几何）</title>
    <url>/33eb241b/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 </p>
<p>给出平面上两条线段的两个端点，判断这两条线段是否相交（有一个公共点或有部分重合认为相交）。 如果相交，输出”Yes”，否则输出”No”。</p>
<a id="more"></a>

<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：一个数T，表示输入的测试数量(1 &lt;= T &lt;= 1000)<br>第2 - T + 1行：每行8个数，x1,y1,x2,y2,x3,y3,x4,y4。(-10^8 &lt;= xi, yi &lt;= 10^8)<br>(直线1的两个端点为x1,y1 | x2, y2,直线2的两个端点为x3,y3 | x4, y4)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出共T行，如果相交输出”Yes”，否则输出”No”。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 2 2 1 0 0 2 2</span><br><span class="line">-1 1 1 1 0 0 1 -1</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>计算几何判断线段相交模版</p>
<p>注释掉的部分是不包括端点和线段重合的模版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define eps 1e-8</span><br><span class="line">#define zero(x) (((x)&gt;0?(x):-(x))&lt;eps)</span><br><span class="line">struct point&#123;</span><br><span class="line">	double x,y,z;</span><br><span class="line">&#125;q[4];</span><br><span class="line">&#x2F;&#x2F;叉积</span><br><span class="line">double xmult(point p1,point p2,point p0)&#123;</span><br><span class="line">    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;判三点共线</span><br><span class="line">int dots_inline(point p1,point p2,point p3)&#123;</span><br><span class="line">    return zero(xmult(p1,p2,p3));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;判点是否在线段上，包括端点</span><br><span class="line">int dot_online_in(point p,point l1,point l2)&#123;</span><br><span class="line">    return zero(xmult(p,l1,l2)&amp;&amp;(l1.x-p.x)*(l2.x-p.x)&lt;eps&amp;&amp;(l1.y-p.y)*(l2.y-p.y)&lt;eps);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;判两点在线段同侧,点在线段上返回0</span><br><span class="line">int same_side(point p1,point p2,point l1,point l2)&#123;</span><br><span class="line">    return xmult(l1,p1,l2)*xmult(l1,p2,l2)&gt;eps;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;判两线段相交，包括端点和重合(p14)</span><br><span class="line">int intersect_in(point u1,point u2,point v1,point v2)&#123;</span><br><span class="line">    if(!dots_inline(u1,u2,v1)||!dots_inline(u1,u2,v2))</span><br><span class="line">        return !same_side(u1,u2,v1,v2)&amp;&amp;!same_side(v1,v2,u1,u2);</span><br><span class="line">    return (dot_online_in(u1,v1,v2)||dot_online_in(u2,v1,v2)||</span><br><span class="line">            dot_online_in(v1,u1,u2)||dot_online_in(v2,u1,u2));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">&#x2F;&#x2F;判两点在线段异侧</span><br><span class="line">int opposite_side(point p1,point p2,point l1,point l2)&#123;</span><br><span class="line">    return xmult(l1,p1,l2)*xmult(l1,p2,l2)&lt;-eps;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;判两线段相交，不包括端点和重合</span><br><span class="line">int intersect_ex(point u1,point u2,point v1,point v2)&#123;</span><br><span class="line">    return opposite_side(u1,u2,v1,v2)&amp;&amp;opposite_side(v1,v2,u1,u2);</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">int main()&#123; </span><br><span class="line">    int t; </span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;4;i++)scanf(&quot;%lf%lf&quot;,&amp;q[i].x,&amp;q[i].y);</span><br><span class="line">        if(intersect_in(q[0],q[1],q[2],q[3]))puts(&quot;Yes&quot;);</span><br><span class="line">        else puts(&quot;No&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>1265 四点共面（计算几何）</title>
    <url>/23c9f6c3/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题</p>
<p>给出三维空间上的四个点（点与点的位置均不相同），判断这4个点是否在同一个平面内（4点共线也算共面）。如果共面，输出”Yes”，否则输出”No”。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：一个数T，表示输入的测试数量(1 &lt;= T &lt;= 1000)<br>第2 - 4T + 1行：每行4行表示一组数据，每行3个数，x, y, z, 表示该点的位置坐标(-1000 &lt;= x, y, z &lt;= 1000)。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出共T行，如果共面输出”Yes”，否则输出”No”。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1 2 0</span><br><span class="line">2 3 0</span><br><span class="line">4 0 0</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>计算几何四点共面模版 已经包含四点共线的情况了  </p>
<p>如果四点不能共线 那就用两次三点共线判断一下就行</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define eps 1e-8</span><br><span class="line">#define zero(x) (((x)&gt;0?(x):-(x))&lt;eps)</span><br><span class="line">struct point&#123;</span><br><span class="line">	double x,y,z;</span><br><span class="line">&#125;q[4];</span><br><span class="line">&#x2F;&#x2F;叉积</span><br><span class="line">point xmult(point u,point v)&#123;</span><br><span class="line">    point ret;</span><br><span class="line">    ret.x&#x3D;u.y*v.z-v.y*u.z;</span><br><span class="line">    ret.y&#x3D;u.z*v.x-u.x*v.z;</span><br><span class="line">    ret.z&#x3D;u.x*v.y-u.y*v.x;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;点积</span><br><span class="line">double dmult(point u,point v)&#123;</span><br><span class="line">    return u.x*v.x+u.y*v.y+u.z*v.z;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;矢量差</span><br><span class="line">point subt(point u,point v)&#123;</span><br><span class="line">    point ret;</span><br><span class="line">    ret.x&#x3D;u.x-v.x;</span><br><span class="line">    ret.y&#x3D;u.y-v.y;</span><br><span class="line">    ret.z&#x3D;u.z-v.z;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;取平面法向量</span><br><span class="line">point pvec(point s1,point s2,point s3)&#123;</span><br><span class="line">    return xmult(subt(s1,s2),subt(s2,s3));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;向量大小</span><br><span class="line">double vlen(point p)&#123;</span><br><span class="line">    return sqrt(p.x*p.x+p.y*p.y+p.z*p.z);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;判三点共线</span><br><span class="line">int dots_inline(point a,point b,point c)&#123;</span><br><span class="line">    return vlen(xmult(subt(a,b),subt(b,c)))&lt;eps;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;判四点共面</span><br><span class="line">int dots_onplane(point a,point b,point c,point d)&#123;</span><br><span class="line">    return zero(dmult(pvec(a,b,c),subt(d,a)));</span><br><span class="line">&#125;</span><br><span class="line">bool check()&#123;</span><br><span class="line">    if(dots_onplane(q[0],q[1],q[2],q[3]))return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123; </span><br><span class="line">    int t; </span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;4;i++)&#123;</span><br><span class="line">            scanf(&quot;%lf%lf%lf&quot;,&amp;q[i].x,&amp;q[i].y,&amp;q[i].z);</span><br><span class="line">        &#125;</span><br><span class="line">        if(check())puts(&quot;Yes&quot;);</span><br><span class="line">        else puts(&quot;No&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>1298 圆与三角形（计算几何）</title>
    <url>/c02d18a7/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kjbjpmjzj20of0hlabo.jpg" alt=""></p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行：一个数T，表示输入的测试数量(1 &lt;= T &lt;= 10000)，之后每4行用来描述一组测试数据。<br>4-1：三个数，前两个数为圆心的坐标xc, yc，第3个数为圆的半径R。(-3000 &lt;= xc, yc &lt;= 3000, 1 &lt;= R &lt;= 3000）<br>4-2：2个数，三角形第1个点的坐标。<br>4-3：2个数，三角形第2个点的坐标。<br>4-4：2个数，三角形第3个点的坐标。(-3000 &lt;= xi, yi &lt;= 3000）</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>共T行，对于每组输入数据，相交输出”Yes”，否则输出”No”。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">0 0 10</span><br><span class="line">10 0</span><br><span class="line">15 0</span><br><span class="line">15 5</span><br><span class="line">0 0 10</span><br><span class="line">0 0</span><br><span class="line">5 0</span><br><span class="line">5 5</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>判断圆和三角形是否相交 直接判断三角形三条线段和圆是否有交点 上个计算几何模版</p>
<p>最初的思路是分成三种情况考虑 一种是内包含 只要判断三个点是否都在圆内即可 第二种是外包含 要判断三个点都在圆外且圆心到三边距离都大于半径 第三种是下图情况 就不好操作了 所以还是直接用模版啦</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kjc6dbl4j20e7086glu.jpg" alt=""></p>
<p>然后系统说我编译错误 明明sublime编译通过了的 麻烦诶。。然后用devc++试了下 报了下图的错  </p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kjc6dm50j20jx02p0tx.jpg" alt=""></p>
<p>查了是因为distance和内置的函数重名了 改改就好了下次注意</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define eps 1e-8</span><br><span class="line">double a0,b0,r,a1,a2,a3,b1,b2,b3;</span><br><span class="line">struct point&#123;</span><br><span class="line">	double x,y;</span><br><span class="line">&#125;q0,q1,q2,q3;</span><br><span class="line">double xmult(point p1,point p2,point p0)&#123;</span><br><span class="line">    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);</span><br><span class="line">&#125;</span><br><span class="line">double Distance(point p1,point p2)&#123;</span><br><span class="line">    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 点到直线距离</span><br><span class="line">double disptoline(point p,point l1,point l2)&#123;</span><br><span class="line">    return fabs(xmult(p,l1,l2)&#x2F;Distance(l1,l2));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 判断线段和圆相交，包括端点和相切(p33)</span><br><span class="line">int intersect_seg_circle(point c,double r0,point l1,point l2)&#123;</span><br><span class="line">    double t1&#x3D;Distance(c,l1)-r,t2&#x3D;Distance(c,l2)-r;</span><br><span class="line">    point t&#x3D;c;</span><br><span class="line">    if(t1&lt;eps||t2&lt;eps)return t1&gt;-eps||t2&gt;-eps;</span><br><span class="line">    t.x+&#x3D;l1.y-l2.y;</span><br><span class="line">    t.y+&#x3D;l2.x-l1.x;</span><br><span class="line">    return xmult(l1,c,t)*xmult(l2,c,t)&lt;eps&amp;&amp;disptoline(c,l1,l2)-r&lt;eps;</span><br><span class="line">&#125;</span><br><span class="line">bool check()&#123;</span><br><span class="line">    if(intersect_seg_circle(q0,r,q1,q2))return true;</span><br><span class="line">    if(intersect_seg_circle(q0,r,q1,q3))return true;</span><br><span class="line">    if(intersect_seg_circle(q0,r,q2,q3))return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;   </span><br><span class="line">int main()&#123; </span><br><span class="line">    int t; </span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%lf%lf%lf&quot;,&amp;a0,&amp;b0,&amp;r);q0.x&#x3D;a0;q0.y&#x3D;b0;</span><br><span class="line">        scanf(&quot;%lf%lf&quot;,&amp;a1,&amp;b1);q1.x&#x3D;a1;q1.y&#x3D;b1;</span><br><span class="line">        scanf(&quot;%lf%lf&quot;,&amp;a2,&amp;b2);q2.x&#x3D;a2;q2.y&#x3D;b2;</span><br><span class="line">        scanf(&quot;%lf%lf&quot;,&amp;a3,&amp;b3);q3.x&#x3D;a3;q3.y&#x3D;b3;</span><br><span class="line">        if(check())puts(&quot;Yes&quot;);</span><br><span class="line">        else puts(&quot;No&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>1384 全排列（STL/dfs）</title>
    <url>/4b67d3c8/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题</p>
<p>给出一个字符串S（可能有重复的字符），按照字典序从小到大，输出S包括的字符组成的所有排列。例如：S = “1312”，<br>输出为：</p>
<p>1123<br>1132<br>1213<br>1231<br>1312<br>1321<br>2113<br>2131<br>2311<br>3112<br>3121<br>3211   </p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入一个字符串S（S的长度 &lt;= 9，且只包括0 - 9的阿拉伯数字）</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出S所包含的字符组成的所有排列</p>
<h2 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1312</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1123</span><br><span class="line">1132</span><br><span class="line">1213</span><br><span class="line">1231</span><br><span class="line">1312</span><br><span class="line">1321</span><br><span class="line">2113</span><br><span class="line">2131</span><br><span class="line">2311</span><br><span class="line">3112</span><br><span class="line">3121</span><br><span class="line">3211</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>题意很简单 就水水的全排列</p>
<p>直接next_permutation就好啦 诶好用</p>
<p>printf竟然tle了 改成 <strong>puts()</strong> 之后跑了46ms </p>
<p>不过这样太依赖stl了 还是乖乖再写个dfs吧。。</p>
<p>然后又t了。。1900ms+。。把printf改成cout就过了 跑了484ms 不是很懂 printf不是比cout快的嘛？？？</p>
<p>而且加上输入输出优化之后<code>ios::sync_with_stdio(false);cin.tie(0);</code> 没有跑得更快反而慢了一丢丢</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    char s[10];</span><br><span class="line">    scanf(&quot;%s&quot;,s);</span><br><span class="line">    int len&#x3D;strlen(s);</span><br><span class="line">    sort(s,s+len);</span><br><span class="line">    do&#123;</span><br><span class="line">        &#x2F;&#x2F; printf(&quot;%s\n&quot;,s);</span><br><span class="line">        puts(s);</span><br><span class="line">    &#125;while(next_permutation(s,s+len));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char s[10];</span><br><span class="line">int ans[10],len;</span><br><span class="line">bool vis[10];</span><br><span class="line">void dfs(int x)&#123;</span><br><span class="line">    if(x&#x3D;&#x3D;len)&#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;len;i++)cout&lt;&lt;ans[i];</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;0;i&lt;len;i++)&#123;</span><br><span class="line">        if(!vis[i])&#123;</span><br><span class="line">            vis[i]&#x3D;true;</span><br><span class="line">            ans[x]&#x3D;s[i]-&#39;0&#39;;</span><br><span class="line">            dfs(x+1);</span><br><span class="line">            vis[i]&#x3D;false;</span><br><span class="line">            while(i&lt;&#x3D;len&amp;&amp;s[i]&#x3D;&#x3D;s[i+1])i++;&#x2F;&#x2F;去重</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;  </span><br><span class="line">    scanf(&quot;%s&quot;,s);</span><br><span class="line">    len&#x3D;strlen(s);</span><br><span class="line">    sort(s,s+len);</span><br><span class="line">    memset(vis,false,sizeof(vis));</span><br><span class="line">    dfs(0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>1459 迷宫游戏（Dijkstra）</title>
    <url>/a8a8763e/</url>
    <content><![CDATA[<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题</p>
<p>你来到一个迷宫前。该迷宫由若干个房间组成，每个房间都有一个得分，第一次进入这个房间，你就可以得到这个分数。还有若干双向道路连结这些房间，你沿着这些道路从一个房间走到另外一个房间需要一些时间。游戏规定了你的起点和终点房间，你首要目标是从起点尽快到达终点，在满足首要目标的前提下，使得你的得分总和尽可能大。现在问题来了，给定房间、道路、分数、起点和终点等全部信息，你能计算在尽快离开迷宫的前提下，你的最大得分是多少么？</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行4个整数n (&lt;=500), m, start, end。n表示房间的个数，房间编号从0到(n - 1)，m表示道路数,任意两个房间之间最多只有一条道路，start和end表示起点和终点房间的编号。<br>第二行包含n个空格分隔的正整数(不超过600)，表示进入每个房间你的得分。<br>再接下来m行，每行3个空格分隔的整数x, y, z  <code>(0&lt;z&lt;=200)</code>表示道路,表示从房间x到房间y(双向)的道路,注意，最多只有一条道路连结两个房间, 你需要的时间为z。<br>输入保证从start到end至少有一条路径。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一行，两个空格分隔的整数，第一个表示你最少需要的时间，第二个表示你在最少时间前提下可以获得的最大得分。</p>
<h3 id="Input示例"><a href="#Input示例" class="headerlink" title="Input示例"></a>Input示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2 0 2</span><br><span class="line">1 2 3</span><br><span class="line">0 1 10</span><br><span class="line">1 2 11</span><br></pre></td></tr></table></figure>
<h3 id="Output示例"><a href="#Output示例" class="headerlink" title="Output示例"></a>Output示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">21 6</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>dijkstra</p>
<p><a href="https://blog.csdn.net/qq_35644234/article/details/60870719/" target="_blank" rel="noopener">最短路径问题—Dijkstra算法详解</a></p>
<p>这题还要在最短路的基础上求权值最大 开个数组记录一下然后和路径一起更新就行</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;505;</span><br><span class="line">const int INF&#x3D;0x3f3f3f3f;</span><br><span class="line">int a[N],cost[N],ans[N];</span><br><span class="line">bool vis[N];</span><br><span class="line">int n,m,start,endd;</span><br><span class="line">vector&lt;int&gt;mp[N];</span><br><span class="line">vector&lt;int&gt;t[N];</span><br><span class="line">void dij()&#123; </span><br><span class="line">    int x&#x3D;start;</span><br><span class="line">    vis[x]&#x3D;true;</span><br><span class="line">    while(x!&#x3D;endd)&#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;mp[x].size();i++)&#123;</span><br><span class="line">            int y&#x3D;mp[x][i];</span><br><span class="line">            int tmpcost&#x3D;cost[x]+t[x][i];</span><br><span class="line">            int tmpans&#x3D;ans[x]+a[y];</span><br><span class="line">            if(cost[y]&#x3D;&#x3D;0||tmpcost&lt;cost[y]||(tmpcost&#x3D;&#x3D;cost[y]&amp;&amp;tmpans&gt;ans[y]))&#123;</span><br><span class="line">                &#x2F;&#x2F;如果x-&gt;y的路在之前还未连通</span><br><span class="line">                &#x2F;&#x2F;或者新路径从x-&gt;y的时间小于原来的，或等于但是权值更大，就更新答案</span><br><span class="line">                ans[y]&#x3D;tmpans;</span><br><span class="line">                cost[y]&#x3D;tmpcost;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int minn&#x3D;INF,maxx&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            &#x2F;&#x2F;如果i没有标记过且x-&gt;i目前最优，从i出发继续找</span><br><span class="line">            if(!vis[i]&amp;&amp;cost[i]!&#x3D;0&amp;&amp;(cost[i]&lt;minn||(cost[i]&#x3D;&#x3D;minn&amp;&amp;ans[i]&gt;maxx)))&#123;</span><br><span class="line">                minn&#x3D;cost[i];</span><br><span class="line">                maxx&#x3D;ans[i];</span><br><span class="line">                x&#x3D;i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[x]&#x3D;true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;start,&amp;endd);</span><br><span class="line">    memset(vis,false,sizeof(vis));</span><br><span class="line">    memset(cost,0,sizeof(cost));</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">        ans[i]&#x3D;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int u,v,w;</span><br><span class="line">    for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        mp[u].push_back(v);</span><br><span class="line">        mp[v].push_back(u);</span><br><span class="line">        t[u].push_back(w);</span><br><span class="line">        t[v].push_back(w);</span><br><span class="line">    &#125;</span><br><span class="line">    dij();</span><br><span class="line">    printf(&quot;%d %d\n&quot;,cost[endd],ans[endd]);  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>F.The Best Path--ACM-ICPC 2016 Qingdao Preliminary Contest</title>
    <url>/56954db8/</url>
    <content><![CDATA[<p><a href="https://nanti.jisuanke.com/t/29370" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/29370</a></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kj01zjgwj20qv0gotcg.jpg" alt=""></p>
<a id="more"></a>

<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3 2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">4 3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">Impossible</span><br></pre></td></tr></table></figure>
<p>题目来源<br>ACM-ICPC 2016 Qingdao Preliminary Contest</p>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>给一个图，每个点有一个权值，找欧拉通路或者欧拉回路，然后求路径上每个点异或结果的最大值；</p>
<p>首先判断有没有欧拉回路或者通路，用一下定理就好了，有且仅有两个度数为奇数的点则有欧拉通路，没有度数为奇数的点则有欧拉回路；</p>
<p>然后把对异或值有贡献的算上，有贡献的点就是d为奇数的点和（d/2）为奇数的点，因为经过偶数次的点相当于没有贡献；</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;100005;</span><br><span class="line">int n,m,a[N],d[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,u,v;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        int ans&#x3D;0;</span><br><span class="line">        memset(d,0,sizeof(d));</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;n;i++)scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">        for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">            d[u]++;d[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">        int num&#x3D;0;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">            if(d[i]&amp;1)num++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(num&#x3D;&#x3D;0)&#123;</span><br><span class="line">            for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">                if((d[i]&#x2F;2)&amp;1||d[i]&amp;1)ans^&#x3D;a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            int tmp&#x3D;ans;</span><br><span class="line">            for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">                ans&#x3D;max(ans,tmp^a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;%d\n&quot;,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(num&#x3D;&#x3D;2)&#123;</span><br><span class="line">            for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">                if((d[i]&#x2F;2)&amp;1||d[i]&amp;1)ans^&#x3D;a[i];</span><br><span class="line">            &#125;      </span><br><span class="line">            printf(&quot;%d\n&quot;,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        else printf(&quot;Impossible\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>D.Tea--ACM-ICPC 2016 Qingdao Preliminary Contest</title>
    <url>/68e48a7a/</url>
    <content><![CDATA[<p><a href="https://nanti.jisuanke.com/t/29368" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/29368</a><br>Tea is good.</p>
<p>Tea is life.</p>
<p>Tea is everything.</p>
<p>The balance of tea is a journey of pursuing balance of the universe.</p>
<p>Alice knows that.</p>
<p>Alice wants to teach you the art of pouring tea.</p>
<p>Alice has a pot of tea.</p>
<p>The exact volume of tea is not important.</p>
<p>The exact volume of tea is at least LL.</p>
<p>The exact volume of tea is at most RR.</p>
<p>Alice put two empty cups between you and her.</p>
<p>Alice wants the two cups filled by almost equal volume of tea.</p>
<p>Yours cannot be 11 unit more than hers.</p>
<p>Hers cannot be 11 unit more than yours.</p>
<p>Alice wants you to pour the tea.</p>
<p>Alice wants you to pour until the pot is almost empty.</p>
<p>Alice wants no more than 11 unit volume of tea remaining in the pot.</p>
<p>You cannot read the residue volume of tea remaining in the pot.</p>
<p>You can only know the tea status in the pot, empty or not.</p>
<p>Alice does not want you to pour the tea too many times.</p>
<p>You better pour as few times as possible.</p>
<h3 id="Input-Format"><a href="#Input-Format" class="headerlink" title="Input Format"></a>Input Format</h3><p>There are multiple cases.</p>
<p>For each case, there is one line of two integers LL and RR, separated by single space.</p>
<p>Here are some analyses about sample cases.</p>
<p>For the first case, pouring 11 unit into one cup will satisfy Alice.</p>
<p>For the second case, it is clearly that you cannot only pour once to reach the desired balance, but she can achieve it by pouring twice.</p>
<p>First you pour 1.51.5 units into one cup, then you attempt to pour another 1.51.5 units into the other cup.</p>
<p>Since the lower bound is 22, at least 0.50.5 unit remains in the pot after the first pouring.</p>
<p>If the initial volume is in range [2,\ 3][2, 3], the second cup will have volume in range [0.5,\ 1.5][0.5, 1.5] which is balanced with 1.51.5 unit in the first cup, and at most 11 unit remain after these two attempts.</p>
<p>About 10001000 test cases, and 0\le L\le R \le 10^{16}0≤L≤R≤10<br>16<br> .</p>
<h3 id="Output-Format"><a href="#Output-Format" class="headerlink" title="Output Format"></a>Output Format</h3><p>For each case, there should be a single integer in a single line, the least number of pouring attempts.</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 2</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>题目来源<br>ACM-ICPC 2016 Qingdao Preliminary Contest</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>一开始的策略有点问题，第一杯倒 l/2 第二杯倒 l/2+1 这样不一定是最优的； </p>
<p>举个例子（4 9）这组数据，第一杯2，第二杯3，第一杯2+2，第二杯还需要再加一次；  </p>
<p>而第一杯倒（l+1）/2 ，第二杯倒（l+1）/2+1的话，（4 9），第一杯2.5 第二杯3.5 第一杯 2.5 +2，达成要求；  </p>
<p>所以最优策略是第一杯倒（l+1）/2 ，第二杯倒（l+1）/2+1 ，然后剩下的轮流加2，直至壶中水小于等于1；</p>
<p>特判几个特殊情况，具体见代码，需要注意的是，如果l=0，那么一开始（0+1）/2=0，显然不倒水是不划算的，所以如果特判结束后l=0则l=1；</p>
<hr>
<p>###代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define LL long long</span><br><span class="line">int main()&#123;</span><br><span class="line">    LL l,r;</span><br><span class="line">    while(~scanf(&quot;%lld%lld&quot;,&amp;l,&amp;r))&#123;</span><br><span class="line">        if(r&#x3D;&#x3D;0||r&#x3D;&#x3D;1)puts(&quot;0&quot;);</span><br><span class="line">        else if(r&#x3D;&#x3D;2)puts(&quot;1&quot;);</span><br><span class="line">        else if(l&#x3D;&#x3D;r||l&#x3D;&#x3D;r-1)puts(&quot;2&quot;);</span><br><span class="line">        else&#123;</span><br><span class="line">            if(l&#x3D;&#x3D;0)l&#x3D;1;</span><br><span class="line">            printf(&quot;%lld\n&quot;,(r-l+2)&#x2F;2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>2006 飞行员配对(二分图最大匹配,匈牙利算法)</title>
    <url>/42c39770/</url>
    <content><![CDATA[<p>题目来源： 网络流24题<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题  </p>
<p>第二次世界大战时期，英国皇家空军从沦陷国征募了大量外籍飞行员。由皇家空军派出的每一架飞机都需要配备在航行技能和语言上能互相配合的2名飞行员，其中1名是英国飞行员，另1名是外籍飞行员。在众多的飞行员中，每一名外籍飞行员都可以与其他若干名英国飞行员很好地配合。如何选择配对飞行的飞行员才能使一次派出最多的飞机。对于给定的外籍飞行员与英国飞行员的配合情况，试设计一个算法找出最佳飞行员配对方案，使皇家空 军一次能派出最多的飞机 。对于给定的外籍飞行员与英国飞行员的配合情况，编程找出一个最佳飞行员配对方案， 使皇家空军一次能派出最多的飞机。 </p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第1行有2个正整数 m 和 n。n 是皇家空军的飞行 员总数(n&lt;100);m 是外籍飞行员数。外籍飞行员编号为 1<del>m;英国飞行员编号为 m+1</del>n。接下来每行有 2 个正整数 i 和 j，表示外籍飞行员 i 可以和英国飞行员 j 配合。输入最后以 2 个-1 结束。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>第 1 行是最佳飞行 员配对方案一次能派出的最多的飞机数 M。如果所求的最佳飞行员配对方案不存在，则输出‘No Solution!’。</p>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>裸的匈牙利算法求二分图最大匹配</p>
<p>这篇讲的超级生动形象了<a href="https://blog.csdn.net/cillyb/article/details/55511666" target="_blank" rel="noopener">https://blog.csdn.net/cillyb/article/details/55511666</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;105;</span><br><span class="line">vector&lt;int&gt;g[N];</span><br><span class="line">int n,m,ans&#x3D;0,match[N];</span><br><span class="line">bool vis[N];</span><br><span class="line">bool dfs(int x)&#123;</span><br><span class="line">    for(int i&#x3D;0;i&lt;g[x].size();i++)&#123;</span><br><span class="line">        int v&#x3D;g[x][i];</span><br><span class="line">        if(!vis[v])&#123;</span><br><span class="line">            vis[v]&#x3D;true;&#x2F;&#x2F;标记已试图匹配</span><br><span class="line">            if(match[v]&#x3D;&#x3D;-1||dfs(match[v]))&#123;</span><br><span class="line">            &#x2F;&#x2F;这个点没匹配过或者这个点匹配的可拆</span><br><span class="line">                match[v]&#x3D;x;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);</span><br><span class="line">    int x,y;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;,&amp;x,&amp;y),x!&#x3D;-1&amp;&amp;y!&#x3D;-1)&#123;</span><br><span class="line">        g[x].push_back(y);</span><br><span class="line">        g[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    memset(match,-1,sizeof(match));</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">        memset(vis,false,sizeof(vis));</span><br><span class="line">        if(dfs(i))ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac OS下用「hexo+github」搭建个人博客！</title>
    <url>/3ca6f02/</url>
    <content><![CDATA[<p style="background-color:rgba(219,233,243,0.8)">这个不是教程 只是搭建过程记录向 记录一下我报错查教程改错报错查教程改错报错查教程改错。。的过程 前面有些步骤在后面有报错然后修正 所以千万不要相信我的步骤</p>

<a id="more"></a>

<hr>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>** 安装nodejs和git（这个自己在官网安装就可以）**<br>** 接着要用npm安装hexo **<br>在终端输入<code>npm install -g hexo-cli</code></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kj11uy19j20fv07t0ul.jpg" alt=""></p>
<p>很多报错 可以看见好几个都是permission denied（因为权限不足无法访问）<br>可以看见提示的建议是：<code>Please try running this command again as root/Administrator.</code><br>所以重新输入<code>sudo npm install -g hexo-cli</code>（sudo：申请root权限）<br>下图表明安装成功  </p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kj1halzqj20fx04pdgx.jpg" alt=""></p>
<h2 id="用hexo在本地新建一个博客"><a href="#用hexo在本地新建一个博客" class="headerlink" title="用hexo在本地新建一个博客"></a>用hexo在本地新建一个博客</h2><p>** 新建文件夹然后右键「新建位于文件夹位置的终端窗口」**<br>（第一次使用的话可以在【finder-服务-服务偏好设置】中勾选上那一项）<br>** 文件夹位置下终端输入 ** </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo i blog&#x2F;&#x2F;blog是项目名，叫别的也随便</span><br><span class="line">cd blog&#x2F;&#x2F;进入blog文件夹</span><br><span class="line">hexo g&#x2F;&#x2F;编译</span><br><span class="line">hexo s&#x2F;&#x2F;本地预览</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kj2doypej20fs01vwes.jpg" alt=""></p>
<p>（后两句不加sudo的话同样会出现permission denied的问题 所以在开头加上sudo给他权限就可以啦 下面有些地方还会遇到sudo的问题 就不赘述了 报权限不够的错误的话自己加上）</p>
<p>成功后会给出一个链接 一个在本地的博客就这样建好了 点开就可以发现已经有一个博客的大概了</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kj2dov3aj20e8016jri.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kj2dpjlkj21400l278y.jpg" alt=""></p>
<p style="background-color:rgba(219,233,243,0.8)">这里用到了4000端口 如果该端口被占用的话可以查一下是什么东西占用了这个端口`sudo lsof -i:端口号` 如果没有输出表面该端口没有被占用 被占用的话会给出一个进程 里面有一个PID号 如果是没设么用的进程 输入`sudo kill -9 pid号 `结束掉他即可</p>

<p>默认给的是个叫「landscape」的主题 不同主题有不同的功能布局外观 当然也可以自己写个主题出来<br>不过这种是大佬们的操作 我这个小白还是先找个主题用吧。。<br>这里放上一些主题：<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="noopener">https://github.com/hexojs/hexo/wiki/Themes</a> 此外知乎上也有关于hexo主题的讨论</p>
<h2 id="设置博客主题"><a href="#设置博客主题" class="headerlink" title="设置博客主题"></a>设置博客主题</h2><p>** 在文件夹打开终端输入git clone加上所选主题的地址 **</p>
<p>(此处以及后面所说的终端一般都是blog文件夹终端了)</p>
<p><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kj5wotbdj20fq03umyc.jpg" alt=""></p>
<p>** 打开文件夹下的这个文件 官方名叫站点配置文件 **</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kj5wo821j202k02kjr9.jpg" alt=""></p>
<p>** 然后找到里面的theme并更改 **  </p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kj5wocitj20aq022q30.jpg" alt=""></p>
<p>** 回到终端输入 **</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hero s</span><br></pre></td></tr></table></figure>
<p>点进生成的blog可以看见主题已经换好啦</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kj5wovoaj21400l2myy.jpg" alt=""></p>
<p>** 在[themes/next/config.yml]里配置next **</p>
<p>冒号后面是有空格的 后面有些地方也是一样！！！一定要有空格 不然会报很长很长的错！！！</p>
<p>可以看见备注写了三个方案给你选</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kj5wobalj206w03174b.jpg" alt=""></p>
<p>然后重新输入以下代码查看效果   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hero s</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kj5woyqxj213l0k1dhe.jpg" alt=""></p>
<p>这时候这里出现了一个警告 </p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kj5wpzupj20e603xwfp.jpg" alt=""></p>
<p><a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">https://github.com/theme-next/hexo-theme-next</a></p>
<p>我用的这个next主题已经移动到别的地方了 所以问题不大复制一下然后找到这个主题的新的地址 按照上面步骤改一下就行<br>注意要把之前的主题所在文件夹删了 或者生成的时候自己换个不同的文件夹名字</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kj5wqzjsj21400k2go6.jpg" alt=""></p>
<p>上面是Gemini 还蛮好看蛮直男审美的 就这个吧诶嘿</p>
<p>以上就是在本地建立了一个看得过去的blog了<br>下面要把这个本地blog上传到github</p>
<h2 id="把博客部署到GitHub上"><a href="#把博客部署到GitHub上" class="headerlink" title="把博客部署到GitHub上"></a>把博客部署到GitHub上</h2><p>** 先在GitHub上创建一个新项目 **</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kj5wqra4j208004vwen.jpg" alt=""></p>
<p>项目名必须按如下格式输入 最后一项选上</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kj5ws6atj20lg0ebq4m.jpg" alt=""></p>
<p>创建后点项目的setting 下拉找到github pages</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kj5wr9j2j20h70b9gmr.jpg" alt=""></p>
<p>看不懂就翻译了一下 那么发现啦那个网址就是我们要用的<br>现在还是宇宙洪荒混沌初始的状态</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kj5wr2s9j21400k3js2.jpg" alt=""></p>
<p>接下来要把hexo上的内容部署到github上</p>
<p>** 打开之前提到过的站点配置文件 把最后几行改成如下格式 **</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kj5wsml6j20io02574f.jpg" alt=""></p>
<p>** 在终端输入如下 装个插件 **<br><code>npm install hexo-deployer-git --save</code></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kj5wsy7yj20fq08q763.jpg" alt=""></p>
<p>emmmmmm???报了一堆错 没事 照他的提示在mac终端输入<code>npm i -g npm</code>更新一下就好了<br>更新成功的界面如下</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kj5wszuxj20ds02dwew.jpg" alt=""></p>
<p>查一下也可以发现变成 6.3.0 版本了。。这不重要</p>
<p>然后就是最后激动人心的一步了！！！！！<br>** 输入hexo d把它部署到github的网站上去 **</p>
<p>然后就走上了漫长的报错之路。。</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kj5wu54cj20g808n0um.jpg" alt=""></p>
<p>然后又经历了一系列艰苦卓绝我也不知道发生了啥的几个小时的查来查去试来试去！<br>最后 终于突然一下的改好了？？！</p>
<p>emmmmm不废话了先记录下来 大概讲讲我干了些啥</p>
<p>主要问题还是出在站点配置文件上 因为报错的时候一直说这个找不到那个找不到。。你都找不到我哪找得到啊</p>
<p>然后去找了一些有关hexo站点配置的教程 其中这份讲的是比较详细的了 照着这个改了最后那一段</p>
<p><a href="https://blog.csdn.net/xuezhisdc/article/details/53130383" target="_blank" rel="noopener">https://blog.csdn.net/xuezhisdc/article/details/53130383</a></p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kj5wujslj20jw024aa8.jpg" alt=""></p>
<p>然后输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save </span><br><span class="line">sudo hexo clean </span><br><span class="line">sudo hexo g </span><br><span class="line">sudo hexo d</span><br></pre></td></tr></table></figure>

<p>还原一下我的小白操作。。<br>最后终端的结果没报错了也没说啥奇奇怪怪得话了就说明成功了</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kj5wvb1bj20fq04swfi.jpg" alt=""></p>
<p>回到github上可以发现 这些东西已经上传到GitHub了</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kj5wvh43j21400i1aec.jpg" alt=""></p>
<p>然后就点开github之前给的那个链接 如图</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kj5wvq78j21400l3q5s.jpg" alt=""></p>
<p>** 之前的本地网站已经上传了！！撒花！！！！ **</p>
<hr>
<h3 id="补充一点内容："><a href="#补充一点内容：" class="headerlink" title="补充一点内容："></a>补充一点内容：</h3><p>首先是关于博客美化的问题 这个就看到什么好看的功能就往上使就是了 next主题美化教程还是很多哒 还有一些关于目录标签的功能 都很好上手</p>
<p>这篇是一个小小小小小汇总：<a href="https://leflacon.github.io/9a99eb64/" target="_blank" rel="noopener">hexo下各种博客美化和功能插件汇总（内附本博客css样式）</a></p>
<p>2020.02.17更新的一点点：<a href="https://leflacon.github.io/4f06b9da/" target="_blank" rel="noopener">hexo+NexT主题下的一些功能优化</a></p>
<p>2020.03.09更新的双线部署：<a href="https://leflacon.github.io/b61b079a/" target="_blank" rel="noopener">hexo+github+coding双线部署（加快博客访问速度）</a></p>
<hr>
<p>然后就是耍了几天博客会发现一个严重的问题！百度！Google！！竟然查不到我自己的网站 但是吧这个坑已经挖了。。不填怎么行。。网上找一下百度Google递交搜索引擎的教程就好了 </p>
<blockquote>
<p>github站点在百度的http认证到是无法通过的，原因写在下面了</p>
</blockquote>
<p>（不过现在有了自己的域名，这个问题短期内已经得到了解决，具体见这篇文章-&gt;<a href="http://leflacon.github.io/59f6b91c/" target="_blank" rel="noopener">如何给个人博客换上专属免费域名</a>）</p>
<blockquote>
<p>google的效率倒是相当快操作也很简洁 站点地图也交好了 一觉醒来在google上搜索到自己博客的感觉 还蛮妙2333333</p>
</blockquote>
<p>这里在站点地图提交的时候遇到一个问题 <code>此位置的 Sitemap 不允许此网址</code> </p>
<blockquote>
<p>是因为之前在站点配置文件里的 <code>url:</code>  那一项没有设置 要改成自己网站的地址 改完后提交站点地图就不会报错了</p>
</blockquote>
<hr>
<h3 id="更新：关于百度http认证无法通过的问题"><a href="#更新：关于百度http认证无法通过的问题" class="headerlink" title="更新：关于百度http认证无法通过的问题"></a><p style="background-color:rgba(219,233,243,0.8)">更新：关于百度http认证无法通过的问题</p></h3><p>有一次用百度蜘蛛爬了一下，然后发现了抓取失败的原因是被拒绝访问了</p>
<p><img src="http://ww1.sinaimg.cn/large/dda38d2bly1g4kj5wx2g9j20cs09emxp.jpg" alt=""></p>
<p><a href="http://jerryzou.com/posts/feasibility-of-allowing-baiduSpider-for-Github-Pages/?utm_source=tuicool" target="_blank" rel="noopener">解决 Github Pages 禁止百度爬虫的方法与可行性分析</a> 这篇是15年的文章，里面有github support部门的回复的原因</p>
<p><a href="https://www.zhihu.com/question/30898326" target="_blank" rel="noopener">如何解决百度爬虫无法爬取搭建在Github上的个人博客的问题？</a></p>
<p>目前的办法可能是要用cdn加速一下0.0，但是去看了一下站点最近的一些指数，索引量抓取频次啥的都有各种数据了，而且百度已经收录了不少博文了，不像刚开始一条直线。。所以暂时先偷个懒吧(/ω＼)</p>
<hr>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>1995 三子棋</title>
    <url>/a678482f/</url>
    <content><![CDATA[<p>题目来源： syu校赛<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 </p>
<p>小的时候大家一定玩过“井”字棋吧。也就是在九宫格中，只要任意行、列，或者任意连续对角线上面出现三个相同的，就能获胜。现在小明和小花也在玩三子棋，但是他们不是在九宫格里，而是在3×4的格子里面。现在小明先下，但是他知道小花这个人很聪明，他想知道第一步下在哪一个地方最合适，你能帮帮他吗？</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行输入一个整数T，表示数据组数（1&lt;T&lt;10000）；<br>第二行输入两个整数x,y,表示3×4格子里面的一个坐标(x,y)（1&lt;=x&lt;=3,1&lt;=y&lt;=4）；    </p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>每组数据输出最后小明输赢的结果，如果小明一定能赢，第一行输出“Win”,第二行输出小明所需要花的最少步数；如果小明跟小花只能打成平手，第一行输出“Equal”，第二行输出数字0；如果小明不能赢也不能跟小花打成平手，第一行输出“Lose”,第二行输出小花赢小明所需要花的最少步数</p>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>抱着作a+b的心态开始刷基础题，结果基础题怎么这么不水呢么。。<br>没想到啥好方法，就自己跟自己下模拟；<br>策略就和一般五子棋差不多，关于最少步数，由于对手也是绝顶聪明的，所以不会让你下在很快赢的地方，其实应该算最多步数的最少步数那个意思。。大概；   </p>
<p>棋盘是对称的，所以只要看（1，1）（1，2）（2，1）（2，2）四个点就可以；<br>如下表：  </p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>2</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td>4</td>
<td>4</td>
<td>3</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>2</td>
<td>1</td>
</tr>
</tbody></table>
<p>然后结论是对先手来说（1，1）（1，2）（2，2）必胜，（2，1）平局；  </p>
<p>（1，1）的最短路是6：<br>先手:11-&gt;12-&gt;31-&gt;23-&gt;32形成“双二”再下一步就赢了<br>后手:21-&gt;13-&gt;21-&gt;34-&gt;   </p>
<p>（1，2）的最短路是4：<br>先手:12-&gt;23-&gt;32形成“双二”再下一步就赢了<br>后手:13-&gt;34-&gt;   </p>
<p>（2，2）的最短路是4：<br>先手:22-&gt;13-&gt;11形成“双二”再下一步就赢了<br>后手:23-&gt;31-&gt;   </p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int a[3][4]&#x3D;&#123;6,4,4,6,0,4,4,0,6,4,4,6&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,x,y;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);</span><br><span class="line">        x--;</span><br><span class="line">        y--;</span><br><span class="line">        if(a[x][y]&#x3D;&#x3D;0)printf(&quot;Equal\n0\n&quot;);</span><br><span class="line">        else printf(&quot;Win\n%d\n&quot;,a[x][y]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
</search>
