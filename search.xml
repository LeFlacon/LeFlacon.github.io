<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[1256 乘法逆元（数论）]]></title>
    <url>%2F2018%2F08%2F18%2F1256%20%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%2F</url>
    <content type="text"><![CDATA[1256 乘法逆元（数论）基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 给出2个数M和N(M &lt; N)，且M与N互质，找出一个数K满足0 &lt; K &lt; N且K * M % N = 1，如果有多个满足条件的，输出最小的。 Input输入2个数M, N中间用空格分隔（1 &lt;= M &lt; N &lt;= 10^9) Output输出一个数K，满足0 &lt; K &lt; N且K * M % N = 1，如果有多个满足条件的，输出最小的。 Input示例12 3 Output示例12 题解：数论 —— 扩展欧几里得 ax+by=gcd(a,b) a,b互质 有ax+by=1 ax%b=1%b 记x为inv(a) 则a*inv(a)%b=1%b ###代码： 123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;fstream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;list&gt;#include &lt;vector&gt;using namespace std;#define LL long longvoid ex_gcd(LL a,LL b,LL &amp;x,LL &amp;y,LL &amp;d)&#123; if(!b)&#123; d=a;x=1;y=0; &#125; else&#123; ex_gcd(b,a%b,y,x,d); y-=x*(a/b); &#125;&#125;LL inv(LL t,LL p)&#123; LL d,x,y; ex_gcd(t,p,x,y,d); return d==1?(x%p+p)%p:-1;&#125;int main()&#123; LL m,n; scanf(&quot;%lld%lld&quot;,&amp;m,&amp;n); printf(&quot;%lld\n&quot;,inv(m,n)); return 0;&#125;]]></content>
      <categories>
        <category>51nod基础题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1264 线段相交（计算几何）]]></title>
    <url>%2F2018%2F08%2F17%2F1264%20%E7%BA%BF%E6%AE%B5%E7%9B%B8%E4%BA%A4%2F</url>
    <content type="text"><![CDATA[1264 线段相交（计算几何）基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 给出平面上两条线段的两个端点，判断这两条线段是否相交（有一个公共点或有部分重合认为相交）。 如果相交，输出”Yes”，否则输出”No”。 Input第1行：一个数T，表示输入的测试数量(1 &lt;= T &lt;= 1000)第2 - T + 1行：每行8个数，x1,y1,x2,y2,x3,y3,x4,y4。(-10^8 &lt;= xi, yi &lt;= 10^8)(直线1的两个端点为x1,y1 | x2, y2,直线2的两个端点为x3,y3 | x4, y4) Output输出共T行，如果相交输出”Yes”，否则输出”No”。 Input示例12321 2 2 1 0 0 2 2-1 1 1 1 0 0 1 -1 Output示例12YesNo 题解：计算几何判断线段相交模版 注释掉的部分是不包括端点和线段重合的模版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;fstream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;list&gt;#include &lt;vector&gt;using namespace std;#define eps 1e-8#define zero(x) (((x)&gt;0?(x):-(x))&lt;eps)struct point&#123; double x,y,z;&#125;q[4];//叉积double xmult(point p1,point p2,point p0)&#123; return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);&#125;//判三点共线int dots_inline(point p1,point p2,point p3)&#123; return zero(xmult(p1,p2,p3));&#125;//判点是否在线段上，包括端点int dot_online_in(point p,point l1,point l2)&#123; return zero(xmult(p,l1,l2)&amp;&amp;(l1.x-p.x)*(l2.x-p.x)&lt;eps&amp;&amp;(l1.y-p.y)*(l2.y-p.y)&lt;eps);&#125;//判两点在线段同侧,点在线段上返回0int same_side(point p1,point p2,point l1,point l2)&#123; return xmult(l1,p1,l2)*xmult(l1,p2,l2)&gt;eps;&#125;//判两线段相交，包括端点和重合(p14)int intersect_in(point u1,point u2,point v1,point v2)&#123; if(!dots_inline(u1,u2,v1)||!dots_inline(u1,u2,v2)) return !same_side(u1,u2,v1,v2)&amp;&amp;!same_side(v1,v2,u1,u2); return (dot_online_in(u1,v1,v2)||dot_online_in(u2,v1,v2)|| dot_online_in(v1,u1,u2)||dot_online_in(v2,u1,u2));&#125;/*//判两点在线段异侧int opposite_side(point p1,point p2,point l1,point l2)&#123; return xmult(l1,p1,l2)*xmult(l1,p2,l2)&lt;-eps;&#125;//判两线段相交，不包括端点和重合int intersect_ex(point u1,point u2,point v1,point v2)&#123; return opposite_side(u1,u2,v1,v2)&amp;&amp;opposite_side(v1,v2,u1,u2);&#125;*/int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; for(int i=0;i&lt;4;i++)scanf(&quot;%lf%lf&quot;,&amp;q[i].x,&amp;q[i].y); if(intersect_in(q[0],q[1],q[2],q[3]))puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>51nod基础题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1265 四点共面（计算几何）]]></title>
    <url>%2F2018%2F08%2F17%2F1265%20%E5%9B%9B%E7%82%B9%E5%85%B1%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[1265 四点共面（计算几何）基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 给出三维空间上的四个点（点与点的位置均不相同），判断这4个点是否在同一个平面内（4点共线也算共面）。如果共面，输出”Yes”，否则输出”No”。 Input第1行：一个数T，表示输入的测试数量(1 &lt;= T &lt;= 1000)第2 - 4T + 1行：每行4行表示一组数据，每行3个数，x, y, z, 表示该点的位置坐标(-1000 &lt;= x, y, z &lt;= 1000)。 Output输出共T行，如果共面输出”Yes”，否则输出”No”。 Input示例1234511 2 02 3 04 0 00 0 0 Output示例1Yes 题解：计算几何四点共面模版 已经包含四点共线的情况了 如果四点不能共线 那就用两次三点共线判断一下就行 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;fstream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;list&gt;#include &lt;vector&gt;using namespace std;#define eps 1e-8#define zero(x) (((x)&gt;0?(x):-(x))&lt;eps)struct point&#123; double x,y,z;&#125;q[4];//叉积point xmult(point u,point v)&#123; point ret; ret.x=u.y*v.z-v.y*u.z; ret.y=u.z*v.x-u.x*v.z; ret.z=u.x*v.y-u.y*v.x; return ret;&#125;//点积double dmult(point u,point v)&#123; return u.x*v.x+u.y*v.y+u.z*v.z;&#125;//矢量差point subt(point u,point v)&#123; point ret; ret.x=u.x-v.x; ret.y=u.y-v.y; ret.z=u.z-v.z; return ret;&#125;//取平面法向量point pvec(point s1,point s2,point s3)&#123; return xmult(subt(s1,s2),subt(s2,s3));&#125;//向量大小double vlen(point p)&#123; return sqrt(p.x*p.x+p.y*p.y+p.z*p.z);&#125;//判三点共线int dots_inline(point a,point b,point c)&#123; return vlen(xmult(subt(a,b),subt(b,c)))&lt;eps;&#125;//判四点共面int dots_onplane(point a,point b,point c,point d)&#123; return zero(dmult(pvec(a,b,c),subt(d,a)));&#125;bool check()&#123; if(dots_onplane(q[0],q[1],q[2],q[3]))return true; return false;&#125;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; for(int i=0;i&lt;4;i++)&#123; scanf(&quot;%lf%lf%lf&quot;,&amp;q[i].x,&amp;q[i].y,&amp;q[i].z); &#125; if(check())puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>51nod基础题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1298 圆与三角形（计算几何）]]></title>
    <url>%2F2018%2F08%2F17%2F1298-%E5%9C%86%E4%B8%8E%E4%B8%89%E8%A7%92%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[Input第1行：一个数T，表示输入的测试数量(1 &lt;= T &lt;= 10000)，之后每4行用来描述一组测试数据。4-1：三个数，前两个数为圆心的坐标xc, yc，第3个数为圆的半径R。(-3000 &lt;= xc, yc &lt;= 3000, 1 &lt;= R &lt;= 3000）4-2：2个数，三角形第1个点的坐标。4-3：2个数，三角形第2个点的坐标。4-4：2个数，三角形第3个点的坐标。(-3000 &lt;= xi, yi &lt;= 3000） Output共T行，对于每组输入数据，相交输出”Yes”，否则输出”No”。 Input示例12345678920 0 1010 015 015 50 0 100 05 05 5 Output示例12YesNo 题解：判断圆和三角形是否相交 直接判断三角形三条线段和圆是否有交点 上个计算几何模版 最初的思路是分成三种情况考虑 一种是内包含 只要判断三个点是否都在圆内即可 第二种是外包含 要判断三个点都在圆外且圆心到三边距离都大于半径 第三种是下图情况 就不好操作了 所以还是直接用模版啦 然后系统说我编译错误 明明sublime编译通过了的 麻烦诶。。然后用devc++试了下 报了下图的错 查了是因为distance和内置的函数重名了 改改就好了下次注意 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;fstream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;list&gt;#include &lt;vector&gt;using namespace std;#define eps 1e-8double a0,b0,r,a1,a2,a3,b1,b2,b3;struct point&#123; double x,y;&#125;q0,q1,q2,q3;double xmult(point p1,point p2,point p0)&#123; return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);&#125;double Distance(point p1,point p2)&#123; return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));&#125;// 点到直线距离double disptoline(point p,point l1,point l2)&#123; return fabs(xmult(p,l1,l2)/Distance(l1,l2));&#125;// 判断线段和圆相交，包括端点和相切(p33)int intersect_seg_circle(point c,double r0,point l1,point l2)&#123; double t1=Distance(c,l1)-r,t2=Distance(c,l2)-r; point t=c; if(t1&lt;eps||t2&lt;eps)return t1&gt;-eps||t2&gt;-eps; t.x+=l1.y-l2.y; t.y+=l2.x-l1.x; return xmult(l1,c,t)*xmult(l2,c,t)&lt;eps&amp;&amp;disptoline(c,l1,l2)-r&lt;eps;&#125;bool check()&#123; if(intersect_seg_circle(q0,r,q1,q2))return true; if(intersect_seg_circle(q0,r,q1,q3))return true; if(intersect_seg_circle(q0,r,q2,q3))return true; return false;&#125; int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%lf%lf%lf&quot;,&amp;a0,&amp;b0,&amp;r);q0.x=a0;q0.y=b0; scanf(&quot;%lf%lf&quot;,&amp;a1,&amp;b1);q1.x=a1;q1.y=b1; scanf(&quot;%lf%lf&quot;,&amp;a2,&amp;b2);q2.x=a2;q2.y=b2; scanf(&quot;%lf%lf&quot;,&amp;a3,&amp;b3);q3.x=a3;q3.y=b3; if(check())puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>51nod基础题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1384 全排列（STL/dfs）]]></title>
    <url>%2F2018%2F08%2F17%2F1384%20%E5%85%A8%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[1384 全排列（STL/dfs）基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 给出一个字符串S（可能有重复的字符），按照字典序从小到大，输出S包括的字符组成的所有排列。例如：S = “1312”，输出为： 112311321213123113121321211321312311311231213211 Input输入一个字符串S（S的长度 &lt;= 9，且只包括0 - 9的阿拉伯数字） Output输出S所包含的字符组成的所有排列 Input示例11312 Output示例123456789101112112311321213123113121321211321312311311231213211 题解：题意很简单 就水水的全排列 直接next_permutation就好啦 诶好用 printf竟然tle了 改成 puts() 之后跑了46ms 不过这样太依赖stl了 还是乖乖再写个dfs吧。。 然后又t了。。1900ms+。。把printf改成cout就过了 跑了484ms 不是很懂 printf不是比cout快的嘛？？？ 而且加上输入输出优化之后ios::sync_with_stdio(false);cin.tie(0); 没有跑得更快反而慢了一丢丢 代码：1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;fstream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;list&gt;#include &lt;vector&gt;using namespace std;int main()&#123; char s[10]; scanf(&quot;%s&quot;,s); int len=strlen(s); sort(s,s+len); do&#123; // printf(&quot;%s\n&quot;,s); puts(s); &#125;while(next_permutation(s,s+len)); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;fstream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;list&gt;#include &lt;vector&gt;using namespace std;char s[10];int ans[10],len;bool vis[10];void dfs(int x)&#123; if(x==len)&#123; for(int i=0;i&lt;len;i++)cout&lt;&lt;ans[i]; cout&lt;&lt;endl; return; &#125; for(int i=0;i&lt;len;i++)&#123; if(!vis[i])&#123; vis[i]=true; ans[x]=s[i]-&apos;0&apos;; dfs(x+1); vis[i]=false; while(i&lt;=len&amp;&amp;s[i]==s[i+1])i++;//去重 &#125; &#125;&#125;int main()&#123; scanf(&quot;%s&quot;,s); len=strlen(s); sort(s,s+len); memset(vis,false,sizeof(vis)); dfs(0); return 0;&#125;]]></content>
      <categories>
        <category>51nod基础题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1459 迷宫游戏（Dijkstra）]]></title>
    <url>%2F2018%2F08%2F16%2F1459%20%E8%BF%B7%E5%AE%AB%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[1459 迷宫游戏（Dijkstra）基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 你来到一个迷宫前。该迷宫由若干个房间组成，每个房间都有一个得分，第一次进入这个房间，你就可以得到这个分数。还有若干双向道路连结这些房间，你沿着这些道路从一个房间走到另外一个房间需要一些时间。游戏规定了你的起点和终点房间，你首要目标是从起点尽快到达终点，在满足首要目标的前提下，使得你的得分总和尽可能大。现在问题来了，给定房间、道路、分数、起点和终点等全部信息，你能计算在尽快离开迷宫的前提下，你的最大得分是多少么？ Input第一行4个整数n (&lt;=500), m, start, end。n表示房间的个数，房间编号从0到(n - 1)，m表示道路数,任意两个房间之间最多只有一条道路，start和end表示起点和终点房间的编号。第二行包含n个空格分隔的正整数(不超过600)，表示进入每个房间你的得分。再接下来m行，每行3个空格分隔的整数x, y, z (0&lt;z&lt;=200)表示道路,表示从房间x到房间y(双向)的道路,注意，最多只有一条道路连结两个房间, 你需要的时间为z。输入保证从start到end至少有一条路径。 Output一行，两个空格分隔的整数，第一个表示你最少需要的时间，第二个表示你在最少时间前提下可以获得的最大得分。 Input示例12343 2 0 21 2 30 1 101 2 11 Output示例121 6 题解：dijkstra 最短路径问题—Dijkstra算法详解 这题还要在最短路的基础上求权值最大 开个数组记录一下然后和路径一起更新就行 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;fstream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;list&gt;#include &lt;vector&gt;using namespace std;const int N=505;const int INF=0x3f3f3f3f;int a[N],cost[N],ans[N];bool vis[N];int n,m,start,endd;vector&lt;int&gt;mp[N];vector&lt;int&gt;t[N];void dij()&#123; int x=start; vis[x]=true; while(x!=endd)&#123; for(int i=0;i&lt;mp[x].size();i++)&#123; int y=mp[x][i]; int tmpcost=cost[x]+t[x][i]; int tmpans=ans[x]+a[y]; if(cost[y]==0||tmpcost&lt;cost[y]||(tmpcost==cost[y]&amp;&amp;tmpans&gt;ans[y]))&#123; //如果x-&gt;y的路在之前还未连通 //或者新路径从x-&gt;y的时间小于原来的，或等于但是权值更大，就更新答案 ans[y]=tmpans; cost[y]=tmpcost; &#125; &#125; int minn=INF,maxx=0; for(int i=0;i&lt;n;i++)&#123; //如果i没有标记过且x-&gt;i目前最优，从i出发继续找 if(!vis[i]&amp;&amp;cost[i]!=0&amp;&amp;(cost[i]&lt;minn||(cost[i]==minn&amp;&amp;ans[i]&gt;maxx)))&#123; minn=cost[i]; maxx=ans[i]; x=i; &#125; &#125; vis[x]=true; &#125;&#125;int main()&#123; scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;start,&amp;endd); memset(vis,false,sizeof(vis)); memset(cost,0,sizeof(cost)); for(int i=0;i&lt;n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); ans[i]=a[i]; &#125; int u,v,w; for(int i=0;i&lt;m;i++)&#123; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); mp[u].push_back(v); mp[v].push_back(u); t[u].push_back(w); t[v].push_back(w); &#125; dij(); printf(&quot;%d %d\n&quot;,cost[endd],ans[endd]); return 0;&#125;]]></content>
      <categories>
        <category>51nod基础题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[F.The Best Path--ACM-ICPC 2016 Qingdao Preliminary Contest]]></title>
    <url>%2F2018%2F08%2F15%2FF.The%20Best%20Path%2F</url>
    <content type="text"><![CDATA[ACM-ICPC 2016 Qingdao Preliminary ContestF. The Best Pathhttps://nanti.jisuanke.com/t/29370 样例输入12345678910111213141523 23451 22 34 312341 22 32 4 样例输出122Impossible 题目来源ACM-ICPC 2016 Qingdao Preliminary Contest 题解：给一个图，每个点有一个权值，找欧拉通路或者欧拉回路，然后求路径上每个点异或结果的最大值； 首先判断有没有欧拉回路或者通路，用一下定理就好了，有且仅有两个度数为奇数的点则有欧拉通路，没有度数为奇数的点则有欧拉回路； 然后把对异或值有贡献的算上，有贡献的点就是d为奇数的点和（d/2）为奇数的点，因为经过偶数次的点相当于没有贡献； 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;fstream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;list&gt;#include &lt;vector&gt;using namespace std;const int N=100005;int n,m,a[N],d[N];int main()&#123; int t,u,v; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; int ans=0; memset(d,0,sizeof(d)); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]); for(int i=0;i&lt;m;i++)&#123; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); d[u]++;d[v]++; &#125; int num=0; for(int i=1;i&lt;=n;i++)&#123; if(d[i]&amp;1)num++; &#125; if(num==0)&#123; for(int i=1;i&lt;=n;i++)&#123; if((d[i]/2)&amp;1||d[i]&amp;1)ans^=a[i]; &#125; int tmp=ans; for(int i=1;i&lt;=n;i++)&#123; ans=max(ans,tmp^a[i]); &#125; printf(&quot;%d\n&quot;,ans); &#125; else if(num==2)&#123; for(int i=1;i&lt;=n;i++)&#123; if((d[i]/2)&amp;1||d[i]&amp;1)ans^=a[i]; &#125; printf(&quot;%d\n&quot;,ans); &#125; else printf(&quot;Impossible\n&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>暑假训练</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[D.Tea--ACM-ICPC 2016 Qingdao Preliminary Contest]]></title>
    <url>%2F2018%2F08%2F15%2FD.Tea%2F</url>
    <content type="text"><![CDATA[ACM-ICPC 2016 Qingdao Preliminary ContestD.Teahttps://nanti.jisuanke.com/t/29368Tea is good. Tea is life. Tea is everything. The balance of tea is a journey of pursuing balance of the universe. Alice knows that. Alice wants to teach you the art of pouring tea. Alice has a pot of tea. The exact volume of tea is not important. The exact volume of tea is at least LL. The exact volume of tea is at most RR. Alice put two empty cups between you and her. Alice wants the two cups filled by almost equal volume of tea. Yours cannot be 11 unit more than hers. Hers cannot be 11 unit more than yours. Alice wants you to pour the tea. Alice wants you to pour until the pot is almost empty. Alice wants no more than 11 unit volume of tea remaining in the pot. You cannot read the residue volume of tea remaining in the pot. You can only know the tea status in the pot, empty or not. Alice does not want you to pour the tea too many times. You better pour as few times as possible. Input FormatThere are multiple cases. For each case, there is one line of two integers LL and RR, separated by single space. Here are some analyses about sample cases. For the first case, pouring 11 unit into one cup will satisfy Alice. For the second case, it is clearly that you cannot only pour once to reach the desired balance, but she can achieve it by pouring twice. First you pour 1.51.5 units into one cup, then you attempt to pour another 1.51.5 units into the other cup. Since the lower bound is 22, at least 0.50.5 unit remains in the pot after the first pouring. If the initial volume is in range [2,\ 3][2, 3], the second cup will have volume in range [0.5,\ 1.5][0.5, 1.5] which is balanced with 1.51.5 unit in the first cup, and at most 11 unit remain after these two attempts. About 10001000 test cases, and 0\le L\le R \le 10^{16}0≤L≤R≤1016 . Output FormatFor each case, there should be a single integer in a single line, the least number of pouring attempts. 样例输入122 22 4 样例输出1212 题目来源ACM-ICPC 2016 Qingdao Preliminary Contest 题解：一开始的策略有点问题，第一杯倒 l/2 第二杯倒 l/2+1 这样不一定是最优的； 举个例子（4 9）这组数据，第一杯2，第二杯3，第一杯2+2，第二杯还需要再加一次； 而第一杯倒（l+1）/2 ，第二杯倒（l+1）/2+1的话，（4 9），第一杯2.5 第二杯3.5 第一杯 2.5 +2，达成要求； 所以最优策略是第一杯倒（l+1）/2 ，第二杯倒（l+1）/2+1 ，然后剩下的轮流加2，直至壶中水小于等于1； 特判几个特殊情况，具体见代码，需要注意的是，如果l=0，那么一开始（0+1）/2=0，显然不倒水是不划算的，所以如果特判结束后l=0则l=1； ###代码：1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;fstream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;list&gt;#include &lt;vector&gt;using namespace std;#define LL long longint main()&#123; LL l,r; while(~scanf(&quot;%lld%lld&quot;,&amp;l,&amp;r))&#123; if(r==0||r==1)puts(&quot;0&quot;); else if(r==2)puts(&quot;1&quot;); else if(l==r||l==r-1)puts(&quot;2&quot;); else&#123; if(l==0)l=1; printf(&quot;%lld\n&quot;,(r-l+2)/2); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>暑假训练</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2006 飞行员配对(二分图最大匹配,匈牙利算法)]]></title>
    <url>%2F2018%2F08%2F15%2F2006%20%E9%A3%9E%E8%A1%8C%E5%91%98%E9%85%8D%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[2006 飞行员配对(二分图最大匹配)题目来源： 网络流24题基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 第二次世界大战时期，英国皇家空军从沦陷国征募了大量外籍飞行员。由皇家空军派出的每一架飞机都需要配备在航行技能和语言上能互相配合的2名飞行员，其中1名是英国飞行员，另1名是外籍飞行员。在众多的飞行员中，每一名外籍飞行员都可以与其他若干名英国飞行员很好地配合。如何选择配对飞行的飞行员才能使一次派出最多的飞机。对于给定的外籍飞行员与英国飞行员的配合情况，试设计一个算法找出最佳飞行员配对方案，使皇家空 军一次能派出最多的飞机 。对于给定的外籍飞行员与英国飞行员的配合情况，编程找出一个最佳飞行员配对方案， 使皇家空军一次能派出最多的飞机。 Input第1行有2个正整数 m 和 n。n 是皇家空军的飞行 员总数(n&lt;100);m 是外籍飞行员数。外籍飞行员编号为 1~m;英国飞行员编号为 m+1~n。接下来每行有 2 个正整数 i 和 j，表示外籍飞行员 i 可以和英国飞行员 j 配合。输入最后以 2 个-1 结束。 Output第 1 行是最佳飞行 员配对方案一次能派出的最多的飞机数 M。如果所求的最佳飞行员配对方案不存在，则输出‘No Solution!’。 题解：裸的匈牙利算法求二分图最大匹配 这篇讲的超级生动形象了https://blog.csdn.net/cillyb/article/details/55511666 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;fstream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;list&gt;#include &lt;vector&gt;using namespace std;const int N=105;vector&lt;int&gt;g[N];int n,m,ans=0,match[N];bool vis[N];bool dfs(int x)&#123; for(int i=0;i&lt;g[x].size();i++)&#123; int v=g[x][i]; if(!vis[v])&#123; vis[v]=true;//标记已试图匹配 if(match[v]==-1||dfs(match[v]))&#123; //这个点没匹配过或者这个点匹配的可拆 match[v]=x; return true; &#125; &#125; &#125; return false;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;m,&amp;n); int x,y; while(scanf(&quot;%d%d&quot;,&amp;x,&amp;y),x!=-1&amp;&amp;y!=-1)&#123; g[x].push_back(y); g[y].push_back(x); &#125; memset(match,-1,sizeof(match)); for(int i=1;i&lt;=m;i++)&#123; memset(vis,false,sizeof(vis)); if(dfs(i))ans++; &#125; printf(&quot;%d\n&quot;,ans); return 0;&#125;]]></content>
      <categories>
        <category>51nod基础题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mac Os下用「hexo+github」搭建个人博客！]]></title>
    <url>%2F2018%2F08%2F14%2Fblog%2F</url>
    <content type="text"><![CDATA[Mac Os下用「hexo+github」搭建个人博客！ 这个不是教程 只是搭建过程记录向 记录一下我报错查教程改错报错查教程改错报错查教程改错。。的过程 前面有些步骤在后面有报错然后修正 所以千万不要相信我的步骤 准备工作 安装nodejs和git（这个自己在官网安装就可以） 接着要用npm安装hexo 在终端输入npm install -g hexo-cli 很多报错 可以看见好几个都是permission denied（因为权限不足无法访问）可以看见提示的建议是：Please try running this command again as root/Administrator.所以重新输入sudo npm install -g hexo-cli（sudo：申请root权限）下图表明安装成功 用hexo在本地新建一个博客 新建文件夹然后右键「新建位于文件夹位置的终端窗口」（第一次使用的话可以在【finder-服务-服务偏好设置】中勾选上那一项） 文件夹位置下终端输入 1234hexo i blog//blog是项目名，叫别的也随便cd blog//进入blog文件夹hexo g//编译hexo s//本地预览 （后两句不加sudo的话同样会出现permission denied的问题 所以在开头加上sudo给他权限就可以啦 下面有些地方还会遇到sudo的问题 就不赘述了 报权限不够的错误的话自己加上） 成功后会给出一个链接 一个在本地的博客就这样建好了 点开就可以发现已经有一个博客的大概了 这里用到了4000端口 如果该端口被占用的话可以查一下是什么东西占用了这个端口sudo lsof -i:端口号 如果没有输出表面该端口没有被占用 被占用的话会给出一个进程 里面有一个PID号 如果是没设么用的进程 输入sudo kill -9 pid号结束掉他即可 默认给的是个叫「landscape」的主题 不同主题有不同的功能布局外观 当然也可以自己写个主题出来不过这种是大佬们的操作 我这个小白还是先找个主题用吧。。这里放上一些主题：https://github.com/hexojs/hexo/wiki/Themes 此外知乎上也有关于hexo主题的讨论 设置博客主题 在文件夹打开终端输入git clone加上所选主题的地址 (此处以及后面所说的终端一般都是blog文件夹终端了) git clone https://github.com/iissnan/hexo-theme-next themes/next 打开文件夹下的这个文件 官方名叫站点配置文件 然后找到里面的theme并更改 回到终端输入 123hexo cleanhexo ghero s 点进生成的blog可以看见主题已经换好啦 在[themes/next/config.yml]里配置next 冒号后面是有空格的 后面有些地方也是一样！！！一定要有空格 不然会报很长很长的错！！！ 可以看见备注写了三个方案给你选 然后重新输入以下代码查看效果 123hexo cleanhexo ghero s 这时候这里出现了一个警告 https://github.com/theme-next/hexo-theme-next 我用的这个next主题已经移动到别的地方了 所以问题不大复制一下然后找到这个主题的新的地址 按照上面步骤改一下就行注意要把之前的主题所在文件夹删了 或者生成的时候自己换个不同的文件夹名字 上面是Gemini 还蛮好看蛮直男审美的 就这个吧诶嘿 以上就是在本地建立了一个看得过去的blog了下面要把这个本地blog上传到github 把博客部署到GitHub上 先在GitHub上创建一个新项目 项目名必须按如下格式输入 最后一项选上 创建后点项目的setting 下拉找到github pages 看不懂就翻译了一下 那么发现啦那个网址就是我们要用的现在还是宇宙洪荒混沌初始的状态 接下来要把hexo上的内容部署到github上 打开之前提到过的站点配置文件 把最后几行改成如下格式 在终端输入如下 装个插件 npm install hexo-deployer-git --save emmmmmm???报了一堆错 没事 照他的提示在mac终端输入npm i -g npm更新一下就好了更新成功的界面如下 查一下也可以发现变成 6.3.0 版本了。。这不重要 然后就是最后激动人心的一步了！！！！！ 输入hexo d把它部署到github的网站上去 然后就走上了漫长的报错之路。。 然后又经历了一系列艰苦卓绝我也不知道发生了啥的几个小时的查来查去试来试去！最后 终于突然一下的改好了？？！ emmmmm不废话了先记录下来 大概讲讲我干了些啥 主要问题还是出在站点配置文件上 因为报错的时候一直说这个找不到那个找不到。。你都找不到我哪找得到啊 然后去找了一些有关hexo站点配置的教程 其中这份讲的是比较详细的了 照着这个改了最后那一段 https://blog.csdn.net/xuezhisdc/article/details/53130383 然后输入 1234npm install hexo-deployer-git --save sudo hexo clean sudo hexo g sudo hexo d 还原一下我的小白操作。。最后终端的结果没报错了也没说啥奇奇怪怪得话了就说明成功了 回到github上可以发现 这些东西已经上传到GitHub了 然后就点开github之前给的那个链接 如图 之前的本地网站已经上传了！！撒花！！！！ 补充一点内容：首先是关于博客美化的问题 这个就看到什么好看的功能就往上使就是了 next主题美化教程还是很多哒 还有一些关于目录标签的功能 都很好上手 然后就是耍了几天博客会发现一个严重的问题！百度！Google！！竟然查不到我自己的网站 但是吧这个坑已经挖了。。不填怎么行。。网上找一下百度Google递交搜索引擎的教程就好了 但是百度的http认证到现在都没通过 还不知道问题出在哪 这个坑挖着先。。 google的效率倒是相当快操作也很简洁 站点地图也交好了 一觉醒来在google上搜索到自己博客的感觉 还蛮妙2333333 这里在站点地图提交的时候遇到一个问题 此位置的 Sitemap 不允许此网址 是因为之前在站点配置文件里的 url: 那一项没有设置 要改成自己网站的地址 改完后提交站点地图就不会报错了]]></content>
      <categories>
        <category>poi</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1995 三子棋]]></title>
    <url>%2F2018%2F08%2F14%2F1995%20%E4%B8%89%E5%AD%90%E6%A3%8B%20%20%2F</url>
    <content type="text"><![CDATA[1995 三子棋 题目来源： syu校赛基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 小的时候大家一定玩过“井”字棋吧。也就是在九宫格中，只要任意行、列，或者任意连续对角线上面出现三个相同的，就能获胜。现在小明和小花也在玩三子棋，但是他们不是在九宫格里，而是在3×4的格子里面。现在小明先下，但是他知道小花这个人很聪明，他想知道第一步下在哪一个地方最合适，你能帮帮他吗？ Input第一行输入一个整数T，表示数据组数（1&lt;T&lt;10000）；第二行输入两个整数x,y,表示3×4格子里面的一个坐标(x,y)（1&lt;=x&lt;=3,1&lt;=y&lt;=4）； Output每组数据输出最后小明输赢的结果，如果小明一定能赢，第一行输出“Win”,第二行输出小明所需要花的最少步数；如果小明跟小花只能打成平手，第一行输出“Equal”，第二行输出数字0；如果小明不能赢也不能跟小花打成平手，第一行输出“Lose”,第二行输出小花赢小明所需要花的最少步数 题解：抱着作a+b的心态开始刷基础题，结果基础题怎么这么不水呢么。。没想到啥好方法，就自己跟自己下模拟；策略就和一般五子棋差不多，关于最少步数，由于对手也是绝顶聪明的，所以不会让你下在很快赢的地方，其实应该算最多步数的最少步数那个意思。。大概； 棋盘是对称的，所以只要看（1，1）（1，2）（2，1）（2，2）四个点就可以；如下表： 1 2 2 1 3 4 4 3 1 2 2 1 然后结论是对先手来说（1，1）（1，2）（2，2）必胜，（2，1）平局； （1，1）的最短路是6：先手:11-&gt;12-&gt;31-&gt;23-&gt;32形成“双二”再下一步就赢了后手:21-&gt;13-&gt;21-&gt;34-&gt; （1，2）的最短路是4：先手:12-&gt;23-&gt;32形成“双二”再下一步就赢了后手:13-&gt;34-&gt; （2，2）的最短路是4：先手:22-&gt;13-&gt;11形成“双二”再下一步就赢了后手:23-&gt;31-&gt; 代码：123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;fstream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;list&gt;using namespace std;int a[3][4]=&#123;6,4,4,6,0,4,4,0,6,4,4,6&#125;;int main()&#123; int t,x,y; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); x--; y--; if(a[x][y]==0)printf(&quot;Equal\n0\n&quot;); else printf(&quot;Win\n%d\n&quot;,a[x][y]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>51nod基础题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>poi</category>
      </categories>
  </entry>
</search>
